<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一个人的孤落时辰</title>
  
  <subtitle>纵有疾风起，人生不言弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinyuanpei.github.io/"/>
  <updated>2021-10-09T03:32:42.601Z</updated>
  <id>https://qinyuanpei.github.io/</id>
  
  <author>
    <name>飞鸿踏雪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gRPC 搭配 Swagger 实现微服务文档化</title>
    <link href="https://qinyuanpei.github.io/posts/4056800047/"/>
    <id>https://qinyuanpei.github.io/posts/4056800047/</id>
    <published>2021-09-28T14:13:32.000Z</published>
    <updated>2021-10-09T03:32:42.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>有人说，程序员最讨厌两件事情，一件是写文档，一件是别人不写文档，这充分展现了人类双标的本质，所谓的“严于律人”、“宽于律己”就是在说这件事情。虽然这种听来有点自私的想法，是生物自然选择的结果，可一旦人类的大脑皮层在进化过程中产生了“理性”，就会试图去纠正这种来自动物世界的阴暗面。所以，人类双标的本质，大概还是因为这个行为本身就有种超越规则、凌驾于众人之上的感觉，毕竟每个人生来就习惯这种使用特权的感觉。回到写文档这个话题，时下流行的微服务架构，最为显著的一个特点是：仓库多、服务多、接口多，此时，接口文档的重要性就凸显出来，因为接口本质上是一种契约，特别在前后端分离的场景中，只要前、后端约定好接口的参数、返回值，就可以独立进行开发，提供一份清晰的接口文档就显得很有必要。在 RESTful 风格的 API 设计中，<a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 是最为常见的接口文档方案，那么，当我们开始构建以 gRPC 为核心的微服务的时候，我们又该如何考虑接口文档这件事情呢？今天我们就来一起探讨下这个话题。</p><h1 id="protoc-gen-doc-方案"><a href="#protoc-gen-doc-方案" class="headerlink" title="protoc-gen-doc 方案"></a>protoc-gen-doc 方案</h1><p>当视角从 RESTful 转向 gRPC 的时候，本质上是接口的描述语言发生了变化，前者是 JSON 而后者则是 Protobuf，因此，gRPC 服务的文档化自然而然地就落在 Protobuf 上。事实上，官方提供了 <a href="https://github.com/pseudomuto/protoc-gen-doc" target="_blank" rel="noopener">protoc-gen-doc</a> 这个方案，如果大家阅读过我以前的博客，就会意识到这是 Protobuf 编译器，即 <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">protoc</a> 的插件，因为我们曾经通过这个编译器来生成代码、服务描述文件等等。protoc-gen-doc 这个插件的基本用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protoc \</span><br><span class="line">  --plugin=protoc-gen-doc=./protoc-gen-doc \</span><br><span class="line">  --doc_out=./doc \</span><br><span class="line">  --doc_opt=html,index.html \</span><br><span class="line">  proto/*.proto</span><br></pre></td></tr></table></figure><p>其中，官方更推荐使用 Docker 来进行部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">  -v $(pwd)/examples/doc:/out \</span><br><span class="line">  -v $(pwd)/examples/proto:/protos \</span><br><span class="line">  pseudomuto/protoc-gen-doc</span><br></pre></td></tr></table></figure><p>默认情况下，它会生成 HTML 格式的接口文档，看一眼就会发现，就是那种传统的 Word 文档的感觉：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/28/h756tJjApsGgcDW.png" alt="通过 protoc-gen-doc 生成的接口文档" referrerpolicy="no-referrer"></div><div class="image-caption">通过 protoc-gen-doc 生成的接口文档</div></figure><p>除此以外，这个插件还可以生成 Markdown 格式的接口文档，这个就挺符合程序员的审美，因为此时此刻，你眼前看到的这篇文章，就是通过 Markdown 写成的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">  -v $(pwd)/examples/doc:/out \</span><br><span class="line">  -v $(pwd)/examples/proto:/protos \</span><br><span class="line">  pseudomuto/protoc-gen-doc --doc_opt=markdown,docs.md</span><br></pre></td></tr></table></figure><p>这个方案如果整合到 CI/CD 中还是挺不错的，传统的 Word 文档形式的接口文档，最主要的缺点是没有版本控制、无法实时更新，因此，对于团队间的协作是非常不利的，我本身挺讨厌这种 Word 文档发来发去的。有时候，只有接口文档是不完美的，因为懒惰的人类希望你能提供个调用示例，最好是直接<code>Ctrl+C</code>、<code>Ctrl+V</code>这种程度的，对此，博主只有仰天长叹：悠悠苍天，此何人哉……</p><h1 id="Swagger-方案"><a href="#Swagger-方案" class="headerlink" title="Swagger 方案"></a>Swagger 方案</h1><p>考虑到，第一种方案没有办法对接口进行调试，所以，下面我们来尝试第二种方案，即整合 Swagger 的方案，可能有小伙伴会好奇，Swagger 还能和 Protobuf 这样混搭起来玩？目前，Swagger 是事实上的 <a href="https://swagger.io/specification/" target="_blank" rel="noopener">OpenAPI</a> 标准，我们只需要在 Protobuf 和 OpenAPI 规范间做一个适配层即可。还记得博主曾经为 ASP.NET MVC 编写的 Swagger <a href="http://localhost:2333/posts/4116164325/" target="_blank" rel="noopener">扩展</a>吗？没错，我们要再次“整活”了，首先，这里给出的是 OpenAPI 规范的定义：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"openapi"</span>: <span class="string">"3.0.1"</span>,</span><br><span class="line">  <span class="attr">"info"</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">"servers"</span>: [ ],</span><br><span class="line">  <span class="attr">"paths"</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">"components"</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>info</code> 节点里存放的是接口文档的基本信息，例如标题、作者、许可证等。<code>servers</code> 节点里存放的是接口所属服务的主机名、端口号等。<code>paths</code> 节点里存放的是每个 API 端点的信息，例如路由、请求参数、返回值等。<code>components</code> 节点里存放的是类型信息，例如请求参数、返回值中每个属性或者字段的具体类型等。一旦搞清楚了这些内容，我们发现这个里面最关键的两个信息是：<code>paths</code> 和 <code>components</code>，如果我们回过头来看 Protobuf 的声明文件，就会发现这两个东西，分别对应的是 <code>rpc</code> 和 <code>message</code>，如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/28/nPN5QgY2MWrGJBK.png" alt="Swagger 与 Protobuf 的对应关系" referrerpolicy="no-referrer"></div><div class="image-caption">Swagger 与 Protobuf 的对应关系</div></figure><p>通常情况下，我们使用 <code>Swashbuckle.AspNetCore.Swagger</code> 这个库来为 ASP.NET Core 项目提供 Swagger 支持，其中最为关键的是<code>ISwaggerProvider</code>接口，这里我们来尝试为 Protobuf 提供一个具体的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GrpcSwaggerProvider</span> : <span class="title">ISwaggerProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ISchemaGenerator _schemaGenerator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SwaggerGeneratorOptions _options;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IApiDescriptionGroupCollectionProvider _apiDescriptionsProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> GrpcSwaggerSchemaGenerator _swaggerSchemaGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrpcSwaggerProvider</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        SwaggerGeneratorOptions options, </span></span></span><br><span class="line"><span class="function"><span class="params">        ISchemaGenerator schemaGenerator, </span></span></span><br><span class="line"><span class="function"><span class="params">        IApiDescriptionGroupCollectionProvider apiDescriptionsProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">        GrpcSwaggerSchemaGenerator swaggerSchemaGenerator</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _options = options;</span><br><span class="line">        _schemaGenerator = schemaGenerator;</span><br><span class="line">        _apiDescriptionsProvider = apiDescriptionsProvider;</span><br><span class="line">        _swaggerSchemaGenerator = swaggerSchemaGenerator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OpenApiDocument <span class="title">GetSwagger</span>(<span class="params"><span class="keyword">string</span> documentName, <span class="keyword">string</span> host = <span class="literal">null</span>, <span class="keyword">string</span> basePath = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_options.SwaggerDocs.TryGetValue(documentName, <span class="keyword">out</span> OpenApiInfo info))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSwaggerDocument(documentName, _options.SwaggerDocs.Select(d =&gt; d.Key));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> schemaRepository = <span class="keyword">new</span> SchemaRepository(documentName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swagger Document</span></span><br><span class="line">        <span class="keyword">var</span> swaggerDoc = <span class="keyword">new</span> OpenApiDocument</span><br><span class="line">        &#123;</span><br><span class="line">            Info = info,</span><br><span class="line">            Servers = BuildOpenApiServers(host, basePath),</span><br><span class="line">            Paths = <span class="keyword">new</span> OpenApiPaths() &#123; &#125;,</span><br><span class="line">            Components = <span class="keyword">new</span> OpenApiComponents</span><br><span class="line">            &#123;</span><br><span class="line">                Schemas = schemaRepository.Schemas,</span><br><span class="line">                SecuritySchemes = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, OpenApiSecurityScheme&gt;(_options.SecuritySchemes)</span><br><span class="line">            &#125;,</span><br><span class="line">            SecurityRequirements = <span class="keyword">new</span> List&lt;OpenApiSecurityRequirement&gt;(_options.SecurityRequirements)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swagger Filters</span></span><br><span class="line">        <span class="keyword">var</span> apiDescriptions = _apiDescriptionsProvider.GetApiDescriptions().Where(x =&gt; x.Properties[<span class="string">"ServiceAssembly"</span>]?.ToString() == documentName);</span><br><span class="line">        <span class="keyword">var</span> filterContext = <span class="keyword">new</span> DocumentFilterContext(apiDescriptions, _schemaGenerator, schemaRepository);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> filter <span class="keyword">in</span> _options.DocumentFilters)</span><br><span class="line">        &#123;</span><br><span class="line">            filter.Apply(swaggerDoc, filterContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swagger Schemas</span></span><br><span class="line">        swaggerDoc.Components.Schemas = _swaggerSchemaGenerator.GenerateSchemas(apiDescriptions);</span><br><span class="line">        <span class="keyword">var</span> apiDescriptionsGroups = _apiDescriptionsProvider.ApiDescriptionGroups.Items.Where(x =&gt; x.Items.Any(y =&gt; y.Properties[<span class="string">"ServiceAssembly"</span>]?.ToString() == documentName));</span><br><span class="line">        swaggerDoc.Paths = _swaggerSchemaGenerator.BuildOpenApiPaths(apiDescriptionsGroups);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> swaggerDoc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>OpenApiDocument</code>对应着 OpenAPI 规范中的定义的结构，我们需要返回一个<code>OpenApiDocument</code>，并对其<code>Components</code>和<code>Paths</code>属性进行填充，这部分工作由<code>GrpcSwaggerSchemaGenerator</code>类来完成。我们这里不会直接去解析 Protobuf 文件，而是利用<code>Google.Protobuf.Reflection</code>这个包来反射 Protobuf 生成的类，然后将其转化为 OpenAPI 规范中定义的结构，更多的细节，大家可以参考<a href="https://github.com/qinyuanpei/FluentGrpc.Gateway/blob/master/src/FluentGrpc.Gateway/Swagger/GrpcSwaggerSchemaGenerator.cs" target="_blank" rel="noopener">这里</a>。</p><p>接下来，在实现了<code>ISwaggerProvider</code>以后，我们还需要替换掉默认的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGrpcGateway</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">this</span> IServiceCollection services, </span></span></span><br><span class="line"><span class="function"><span class="params">  IConfiguration configuration, </span></span></span><br><span class="line"><span class="function"><span class="params">  Action&lt;Microsoft.OpenApi.Models.OpenApiInfo&gt; setupAction = <span class="literal">null</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">string</span> sectionName = <span class="string">"GrpcGateway"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> configSection = configuration.GetSection(sectionName);</span><br><span class="line">    services.Configure&lt;GrpcGatewayOptions&gt;(configSection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> swaggerGenOptions = <span class="keyword">new</span> GrpcGatewayOptions();</span><br><span class="line">    configSection.Bind(swaggerGenOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> swaggerGenSetupAction = BuildDefaultSwaggerGenSetupAction(swaggerGenOptions, setupAction);</span><br><span class="line">    services.AddSwaggerGen(swaggerGenSetupAction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace ISwaggerProvider</span></span><br><span class="line">    services.Replace(<span class="keyword">new</span> ServiceDescriptor(</span><br><span class="line">        <span class="keyword">typeof</span>(ISwaggerProvider),</span><br><span class="line">        <span class="keyword">typeof</span>(GrpcSwaggerProvider),</span><br><span class="line">        ServiceLifetime.Transient</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace IApiDescriptionGroupCollectionProvider</span></span><br><span class="line">    services.Replace(<span class="keyword">new</span> ServiceDescriptor(</span><br><span class="line">        <span class="keyword">typeof</span>(IApiDescriptionGroupCollectionProvider),</span><br><span class="line">        <span class="keyword">typeof</span>(GrpcApiDescriptionsProvider),</span><br><span class="line">        ServiceLifetime.Transient</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GrpcDataContractResolver</span></span><br><span class="line">    services.AddTransient&lt;GrpcDataContractResolver&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GrpcSwaggerSchemaGenerator</span></span><br><span class="line">    services.AddTransient&lt;GrpcSwaggerSchemaGenerator&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure GrpcClients</span></span><br><span class="line">    services.ConfigureGrpcClients(swaggerGenOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AllowSynchronousIO</span></span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是见证奇迹的时刻，gRPC 和 Swagger 牵手成功。从此，查阅和调试 gRPC 接口，我们有了更时尚的做法：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/28/Uj9Z3EcbQmdhriD.png" alt="gRPC 成功牵手 Swagger" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC 成功牵手 Swagger</div></figure><p>调一下接口看看效果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/28/z9Umj6t5hcSQeTv.png" alt="通过 Swagger 调试 gRPC 接口" referrerpolicy="no-referrer"></div><div class="image-caption">通过 Swagger 调试 gRPC 接口</div></figure><p>可以注意到，此时，Swagger 中返回了我们期望的结果，事实上，只有 Swagger 还不足以令它运作起来，其中的诀窍是，博主利用终结点(<strong>Endpoints</strong>)动态创建了路由。关于这一点，博主曾在 <a href="https://blog.yuanpei.me/posts/2167892202/" target="_blank" rel="noopener">ASP.NET Core gRPC 打通前端世界的尝试</a> 这篇文章中提到过。最终，博主编写了一个更为完整的项目：<a href="https://github.com/qinyuanpei/FluentGrpc.Gateway" target="_blank" rel="noopener">FluentGrpc.Gateway</a>，而关于 Swagger 的这部分内容则成为了这篇博客的内容，如果大家对这个项目感兴趣的话，欢迎大家去做进一步的探索，欢迎大家 Star 和 PR，而到这里，这篇博客差不多就可以结尾啦！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>有时候，博主会不由地感慨，整个微服务架构的落地过程中，服务治理是花费时间和精力最多的环节，除了保证接口的稳定性，更多的时候，其实是不同的服务间相互打交道。那么，除了口头传达外，最好的管理接口的方式是什么呢？显然是接口文档。本文分享了两种针对 gRPC 的服务文档化的方案，第一种是由官方提供的 <a href="https://github.com/pseudomuto/protoc-gen-doc" target="_blank" rel="noopener">protoc-gen-doc</a>，它可以从 Protobuf 生成 HTML 或者 Markdown 格式的接口文档。第二种是由博主实现的 <a href="https://github.com/qinyuanpei/FluentGrpc.Gateway" target="_blank" rel="noopener">FluentGrpc.Gateway</a>，它实现了从 Protobuf 到 Swagger 的转换，只需要在项目中引入这个中间件，就可以把 gRPC 带进 Swagger 的世界，不管是查阅接口还是调试接口，都多了一种玩法，如果你还需要给非开发人员提供接口文档，那么，我觉得你还可以试试 <a href="http://yapi.smart-xwork.cn/" target="_blank" rel="noopener">YAPI</a>，只需要导入 Swagger 格式的服务描述信息即可，而这一步，我们已经实现了。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Swagger" scheme="https://qinyuanpei.github.io/tags/Swagger/"/>
    
      <category term="文档" scheme="https://qinyuanpei.github.io/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>SSL/TLS加密传输与数字证书的前世今生</title>
    <link href="https://qinyuanpei.github.io/posts/3163397596/"/>
    <id>https://qinyuanpei.github.io/posts/3163397596/</id>
    <published>2021-09-05T14:13:32.000Z</published>
    <updated>2021-10-09T03:32:42.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>Hi，大家好，我是飞鸿踏雪，欢迎大家关注我的博客。近来，博主经历了一次服务器迁移，本以为有 Docker-Compose 加持，一切应该会非常顺利，没想到最终还是在证书上栽了跟头，因为它的证书是和IP地址绑定的。对，你没听错，这个世界上还真就有这么别扭的设定，尤其是你折腾了一整天，发现你需要到一个 CA 服务器上去申请证书的时候，那种绝望你晓得吧？数字证书、HTTPS、SSL/TLS、加密……无数的词汇在脑海中席卷而来，这都是些啥啊？为了解答这些困惑，经历了写字、画图、查资料的无数次轮回，终于在周末两天淅淅沥沥的雨声中，有了今天这篇文章，我将借此带大家走进SSL/TLS加密传输与数字证书的前世今生，希望从此刻开始，令人眼花缭乱的证书格式不会再成为你的困扰。</p><h1 id="证书与加密"><a href="#证书与加密" class="headerlink" title="证书与加密"></a>证书与加密</h1><p>对于数字证书的第一印象，通常来自于 HTTPS 协议。因为地球人都知道，HTTP 协议是不需要数字证书的。对于 HTTPS 协议的理解，可以简单粗暴的认为它约等于 HTTP + SSL，所以，从这个协议诞生的那一刻起，加密算法与数字证书就密不可分，因为从本质上来讲，HTTPS 协议就是为了解决如何在不安全的网络上、安全地传输数据的问题。事实上，HTTPS 协议的实现，背后依托SSL/TLS、数字签名、对称/非对称加密等一系列的知识。也许，在读到这篇文章以前，你就像博主一样，对于 HTTPS 的理解，永远止步于 HTTP + SSL。那么，我希望下面的解释可以帮助到你，通常，HTTPS 认证可以分为 单向认证 和 双向认证 两种，这里我们以为以单向认证为例，来说明数字证书与加密算法两者间的联系：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/nkJFiPNdVc4ShAw.png" alt="HTTPS 数字证书与加密传输间的关系" referrerpolicy="no-referrer"></div><div class="image-caption">HTTPS 数字证书与加密传输间的关系</div></figure><p>如图所示，HTTPS 单向认证流程主要经历了下面 7 个步骤，它们分别是：</p><ul><li>客户端发起 HTTPS 请求</li><li>服务器返回证书信息，本质上是公钥</li><li>客户端/浏览器通过 CA 根证书验证公钥，如果验证失败，将会收到警告信息</li><li>客户端随机生成一个对称密钥 Key，并利用公钥对 Key 进行加密</li><li>服务器使用私钥解密获得对称密钥 Key</li><li>通过对称密钥 Key 对确认报文进行加密</li><li>双方开始通信</li></ul><p>由此，我们可以看出，整个 HTTPS 单向认证流程，实际上是结合了 对称加密 和 非对称加密 两种加密方式。其中，非对称加密主要用于客户端、服务器双方的“试探”环节，即证书验证部分；对称加密主要用于客户端、服务器双方的“正式会话”阶段，即数据传输部分。关于 对称加密 和 非对称加密 两者的区别，我们可以从下面的图中找到答案：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/08/lBNLu4t9VxkOewn.png" alt="对称加密 与 非对称加密" referrerpolicy="no-referrer"></div><div class="image-caption">对称加密 与 非对称加密</div></figure><p>因为客户端持有服务器端返回的公钥，所以，两者可以使用 非对称加密 对随机密钥 Key 进行加/解密。同理，因为客户/服务器端使用相同的随机密钥，所以，两者可以使用 对称加密 对数据进行加/解密。有朋友可能会问，那照你这样说，任何一个客户端都可以向服务器端发起请求嘛，你这样感觉一点都不安全呢？我承认，大家的担心是有道理的。所以，在此基础上，我们还可以使用双向认证，就是不单单客户端要验证服务器端返回的证书，同样，服务器端要对客户端的证书进行验证。那么，客户端是如何验证服务器端返回的证书的呢？服务器返回的证书里都含有哪些信息呢？带着这些问题，我们来看看知乎这个网站：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/5vcDPmT14WyCOqE.png" alt="知乎的证书信息" referrerpolicy="no-referrer"></div><div class="image-caption">知乎的证书信息</div></figure><p>事实上，浏览器在对服务器端返回的证书进行校验时，主要关心下面这些信息：</p><ul><li>判断域名、有效期等信息是否正确：这些信息在证书中是公开的，可以非常容易地获得。</li><li>判断证书是否被篡改：需要由 CA 服务器进行校验。</li><li>判断证书来源是否合法：每一份签发的证书都可以按照证书链找到对应的根证书，所以，可以通过操作系统中安装的根证书对证书的来源进行验证。</li><li>判断证书是否被吊销：需要由 CRL（Certificate Revocation List，即 证书注销列表）和 OCSP（Online Certificate Status Protocol, 即 在线证书状态协议） 来实现。</li></ul><p>这里引入了一个新的概念，即 CA（Certification Authority）。那么，什么是 CA 呢？ 通俗来讲，CA 就是一个负责签发、认证和管理证书的机构。可能有朋友会想，客户端和服务器端通过非对称加密相互校验证书就好了啊，为什么还需要这样一个第三方的机构呢？事实上，这相当于一种担保/信用体系，因为服务器端的公钥对任何人来说都是可见的，我们来考虑这样一种情形。假设客户端从服务器端获得了某个公钥，并且它认为这个公钥是可信的，此时，有一个不怀好意的中间人截获了这个公钥，它如法炮制伪造了一个相同的公钥并返回，那么，此时客户端会如何看待这个公钥呢？虽然这个中间人不可能伪造出与服务端相同的私钥，可这无疑会让客户端感到困惑，因为它没有办法判断这个证书的真假。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/renZkROKljmYuoE.png" alt="证书的签发与认证" referrerpolicy="no-referrer"></div><div class="image-caption">证书的签发与认证</div></figure><p>其实，写到这里的时候，博主隐隐约约意识到，当下流行的比特币/数字人民币均与数字签名息息相关，因为 CA 使用私钥对证书进行了签名，这样就杜绝了证书被篡改的可能，从而可以为证书的真实性背书，这种基于信任制、拥有权威性的体系，就像现实生活中银行为货币的真实性、价值背书一样。因此，我们会注意到，在现实生活中，想要获得一份权威机构的数字证书，就需要向 CA 进行申请，例如，知乎的证书是从 DigiCert Inc 这个机构中购买的，不同的机构对于证书申请者的审核要求不同，这样就形成了不同价格甚至免费的数字证书。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/szYK63b2y4XhNr7.png" alt="CA 组织树形结构" referrerpolicy="no-referrer"></div><div class="image-caption">CA 组织树形结构</div></figure><p>当然，这个世界上有超过1亿个网站，如果每个网站都去向 CA 申请数字证书，那么，CA 一定会忙到崩溃。所以，实际的运行过程是，一个根 CA 会分成多个中间 CA，然后中间 CA 可以继续拆分为更小的中间 CA，这样做的好处是效率更高，同时保证了根 CA 中私钥的安全性。此时，我们会发现一个新的问题，就是当整个数字证书体系中突然多出来这么多“中介”以后，我们如何保证证书的权威性和真实性呢？类似地，数字证书世界里里有证书链的概念。所谓证书链，就是指证书可以追本溯源、在整个链路上都是可信任的，听起来是不是有区块链的味道了？事实上区块链正是利用了数字签名的不可伪造、不可抵赖、不可复制等一系列特性。说回到证书链，由根 CA 签发的证书称为根证书、由中间 CA 签发的证书称为中间证书，其关系如下图所示，假设 A 完全信任 B，B 完全信任 C，则 A 可以完全信任 C:</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/WilIrjBSwTft2hL.png" alt="证书链示意图" referrerpolicy="no-referrer"></div><div class="image-caption">证书链示意图</div></figure><h1 id="证书创建"><a href="#证书创建" class="headerlink" title="证书创建"></a>证书创建</h1><p>OK，现在我们已然理清了证书与加密两者间的联系，那么，在实际生活中，我们该如何获得一个证书呢？由上文可知，证书理论上应该由 CA 机构来签发。目前，全球主流的 CA 机构有<a href="https://ssl.idcspy.net/comodo/" target="_blank" rel="noopener">Comodo</a>、<a href="https://ssl.idcspy.net/symantec/" target="_blank" rel="noopener">Symantec</a>、<a href="https://ssl.idcspy.net/geotrust/" target="_blank" rel="noopener">GeoTrust</a>、<a href="https://www.anxinssl.com/digicert/" target="_blank" rel="noopener">DigiCert</a>、<a href="https://ssl.idcspy.net/thawte/" target="_blank" rel="noopener">Thawte</a>、<a href="https://www.anxinssl.com/globalsign/" target="_blank" rel="noopener">GlobalSign</a>、<a href="https://ssl.idcspy.net/rapidssl/" target="_blank" rel="noopener">RapidSSL</a> 等，其中 <a href="https://www.anxinssl.com/symantec/" target="_blank" rel="noopener">Symantec</a>、<a href="https://www.anxinssl.com/geotrust/" target="_blank" rel="noopener">GeoTrust</a> 都是 <a href="https://www.anxinssl.com/digicert/" target="_blank" rel="noopener">DigiCert</a> 机构的子公司，占据数字证书体系中的垄断地位，就连国内的互联网厂商都需要向这些机构来购买证书，所以，推广 HTTPS 并不是完全出于安全的考虑，实际上还有某种利益关系在里面，可以想象得到，假如你的证书信任度不高，不在浏览器的可信任机构列表中，那么，你的网站就会被浏览器认为是不安全的，随之而来的就是用户对网站的信任度的下降。当然，购买数字证书是需要花钱的，所以，实际操作中，通常有自签名证书 和 CA 证书 两种，两者唯一的差别就在于权威性不同，大概相当于一种互联网行业的“保护费”。</p><h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>所谓自签名证书，其实就是自建一个 CA，然后利用这个 CA 对证书进行签名。为什么说它没有权威性呢？大概这就像小时候试卷上要签署大人的名字一样，如果你照着大人的笔迹伪造了签名，那么，此时没有人能保证这份签名的真实性。更深层次的原因在于，由你自建的这个 CA 没有在互联网上备案，它产生的证书无法通过证书链追溯，这是自签名证书没有权威性的原因。我们通常说的创建/生成证书，其实都是指这种自签名证书，创建自签名证书最常见的方式是 <a href="https://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建根证书</span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line">openssl req -new -key ca.key -out ca.csr</span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure><p>在这个过程中，OpenSSL 会要求我们提供下列信息：国家、省份、城市、组织 以及 全域名(FQDN)。在此之前，关于知乎的那个例子，实际上证书上的那些信息就是从这里来的。当我们有了这样一个自建的 CA 以后，我们就可以用这个自建的 CA 去签发证书，这就是自签名 CA 证书，如何生成这个证书呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 环境准备，下列路径在 openssl.conf 文件中定义</span><br><span class="line">mkdir -p ./demoCA/newcerts</span><br><span class="line"><span class="built_in">cd</span> ./demoCA/</span><br><span class="line">touch index.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'01'</span> &gt; serial</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">// 签发证书</span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line">openssl req -new -key ca.key -out server.csr</span><br><span class="line">openssl ca -<span class="keyword">in</span> server.csr -out server.crt -cert ca.crt -keyfile ca.key</span><br></pre></td></tr></table></figure><p>同样的，我们需要再输入一次下列信息：国家、省份、城市、组织 以及 全域名(FQDN)，然后利用自建的 CA 进行签名。在 OpenSSL 中，它定义了证书申请方需要满足的“门槛”，这决定了你能不能向某个 CA 申请证书，其定义位于<code>openssl.conf</code>文件中：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/08/ldIigFrJ8LvYZfP.png" alt="OpenSSL 策略配置" referrerpolicy="no-referrer"></div><div class="image-caption">OpenSSL 策略配置</div></figure><p>例如，这里的策略表示，只有当证书申请方的国家、省份、组织相同的时候，CA 才会接受你的证书申请。所以，至此你明白证书为什么收费了吧？因为主流的 CA 机构都在国外，理论上 CA 机构可以去调整这个策略，可如果对方不愿意调整策略，那么你只能找别人帮你来申请，通过不断的调用<code>openssl ca</code>命令， 产生新的中间 CA，这样就形成了树状的 CA 组织。是不是觉得看人脸色非常地不舒服？除了这种方式以外，我们还可以按下面这种方式生成证书，这种方式像极了我们小时候模仿大人签字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 签发证书</span><br><span class="line">openssl genrsa -out server.key 4096</span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure><p>如果是在 Windows 系统下，我们还可以搭建 CA 服务器，此时，证书申请者需要远程登陆到这台服务器进行操作，请参考：<a href="https://docs.microsoft.com/zh-cn/windows-server/networking/core-network-guide/cncg/server-certs/server-certificate-deployment" target="_blank" rel="noopener">服务器证书部署</a>。</p><h2 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h2><p>一旦理解了自签名证书，理解 CA 证书 就变得特别容易，这就是交了“保护费”的证书，过去总以为互联网世界里没有政治，后来发现互联网并不是“法外之地”，一切的自媒体、流量，最终都会转化为某种商品出售，只要人与人形成了某种圈子或者团体，这种政治就一定会存在。所以，你到腾讯云或者阿里云去购买证书，而腾讯和阿里则是某个 CA 机构的代理商，因为数字证书通常会和域名产生联系，所以，在供应商那里，两者往往是捆绑在一起销售，再加上网站备案、虚拟主机这些东西，在由资本绘制的商业版图里，你的钱包被安排得明明白白。或是为了打破这种垄断，或是为了某种利害关系，慢慢地出现了像 <a href="https://letsencrypt.org/zh-cn/" target="_blank" rel="noopener">Let’s Encrypt</a> 这样的提供免费证书的机构。所以，下面，我们以此为例来展示如何申请一个 CA 证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/acmesh-official/acme.sh.git</span><br><span class="line"><span class="built_in">cd</span> ./acme.sh</span><br><span class="line">./acme.sh --install</span><br><span class="line"></span><br><span class="line">acme.sh --register-account -m &lt;Your E-Mail&gt;</span><br><span class="line">acme.sh --issue -d &lt;Your-Domain&gt; --standalone</span><br></pre></td></tr></table></figure><p>目前，<a href="https://letsencrypt.org/zh-cn/" target="_blank" rel="noopener">Let’s Encrypt</a> 的使用是通过 acme.sh 这个脚本来驱动的，其基本用法如上面脚本所示。不同于自签名证书，Let’s Encrypt 目前不支持使用公网 IP 来申请证书，所以，如果在开发阶段，可以使用自签名的证书；在生产阶段，则最好使用 CA 签发的证书。通过阅读 <a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">文档</a> 可知，它支持 HTTP 和 DNS 两种验证方式，可以使用 Apache 、Nginx 和 Standalone 三种模式，个人推荐使用 Docker 来进行部署，因为前两种模式要求你安装对应的软件，第三种模式要求你的 80 端口是空闲的，这对于一名开发人员来说，简直是痴心妄想。如果你有一个域名，而恰好这个域名提供商在其支持的 <a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi" target="_blank" rel="noopener">列表</a> 内，那么，你就可以使用下面的方式来申请证书。首先，准备一个<code>docker-compose.yml</code>文件，博主的域名是从 <a href="https://www.godaddy.com" target="_blank" rel="noopener">GoDaddy</a> 申请的，大家可以结合实际情况进行调整：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"2.1"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  acme.sh:</span><br><span class="line">    image: neilpang/acme.sh</span><br><span class="line">    container_name: <span class="string">"acme.sh"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /docker/ssl:/acme.sh</span><br><span class="line">    environment:</span><br><span class="line">      - GD_Key=&lt;GoDaddy Key&gt;</span><br><span class="line">      - GD_Secret=&lt;GoDaddy Secret&gt;</span><br><span class="line">    <span class="built_in">command</span>: daemon</span><br></pre></td></tr></table></figure><p>接下来，我们只需要启动容器，然后在容器内部执行命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;ContainerId&gt; sh</span><br><span class="line">acme.sh --register-account -m &lt;Your E-Mail&gt;</span><br><span class="line">acme.sh --issue --dns dns_gd -d &lt;Your-Domain&gt;</span><br></pre></td></tr></table></figure><p>可以注意到，下面即为博主从 Let’s Encrypt 申请到的证书文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/08/FZLKdQ1cBRtjS4y.png" alt="从 Let‘s Encrypt 申请证书" referrerpolicy="no-referrer"></div><div class="image-caption">从 Let‘s Encrypt 申请证书</div></figure><p>如果你的域名提供商在这个 <a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi" target="_blank" rel="noopener">列表</a> 内，此时，你可以手动将其生成的值添加到域名记录中，这些在文档中均有提及，不再赘述。总而言之，你向 CA 机构申请证书需要一个有效的域名，像腾讯云、阿里云这种云服务提供商，早已提供好了完整的一条龙服务，只要你愿意花钱去买对方的产品。</p><h1 id="证书使用"><a href="#证书使用" class="headerlink" title="证书使用"></a>证书使用</h1><p>一旦生成了证书，我们就可以在应用程序中使用这些证书啦，我注意到公司的每个项目都配置了证书文件，其实我一直不明白，为什么不能直接把证书安装到宿主机上？这样只需要折腾一次就好了啊，简直是一劳永逸。如果有小伙伴们知道这个问题的答案，欢迎大家在评论区留言。下面我们来看看，生成的证书如何在不同的环境中配置，这里以 ASP.NET Core 、Envoy 和 Nginx 为例来说明。</p><h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><p>在 ASP.NET Core 中配置 HTTPS 证书，最直接的方案是在通过 Kestrel 中间件来指定证书路径和密码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webBuilder.ConfigureKestrel(options =&gt; &#123;</span><br><span class="line">    <span class="comment">// 方式 1</span></span><br><span class="line">    options.ConfigureHttpsDefaults(kestrel =&gt; &#123;</span><br><span class="line">        kestrel.ServerCertificate = <span class="keyword">new</span> X509Certificate2(<span class="string">"./path/to/your/example.com.pfx"</span>,<span class="string">"&lt;证书密码&gt;"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 2</span></span><br><span class="line">    options.Listen(IPAddress.Loopback, <span class="number">5001</span>, kestrel =&gt; &#123;</span><br><span class="line">      kestrel.UseHttps(<span class="keyword">new</span> X509Certificate2(<span class="string">"./path/to/your/example.com.pfx"</span>,<span class="string">"&lt;证书密码&gt;"</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果整个 ASP.NET Core 应用以容器方式运行，则还可以按下面这样的方式来配置证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -p 8000:80 -p 8001:443 \</span><br><span class="line">  -e ASPNETCORE_URLS=<span class="string">"https://+;http://+"</span> \</span><br><span class="line">  -e ASPNETCORE_HTTPS_PORT=8001 \</span><br><span class="line">  -e ASPNETCORE_ENVIRONMENT=Development \</span><br><span class="line">  -e ASPNETCORE_Kestrel__Certificates__Default__Password=<span class="string">"&lt;证书密码&gt;"</span> \</span><br><span class="line">  -e ASPNETCORE_Kestrel__Certificates__Default__Path=/path/to/your/example.com.pfx</span><br><span class="line">  -v /c/path/to/certs/:/https/ </span><br><span class="line">  &lt;镜像Id&gt;</span><br></pre></td></tr></table></figure><p>不得不说，这里的双下划线，总是让我不由地想起 Python 里的魔法方法：<code>__init__</code>。可能大家会疑惑，为什么博主这里要强调证书的扩展名，因为这实际上是数字证书里最让人迷惑的地方：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/08/tadr5bEHxR1Cs2y.png" alt="数字证书编码格式与扩展名" referrerpolicy="no-referrer"></div><div class="image-caption">数字证书编码格式与扩展名</div></figure><p>在整个数字证书体系中，X.509 是作为数字证书标准而存在的，按照编码格式的不同，可以分为 PEM 证书 和 DER 证书两类，前者是文本格式，而后者是二进制格式。不同的操作系统、开发语言，产生了不同的证书文件格式，但这些扩展名本身并不能说明什么，特别是像 .crt 或者 .cre 这种薛定谔的证书，唯一的判断标准，就是用记事本打开它，如果可读，说明它是 PEM 编码的证书，如果不可读，说明它是 DER 编码的证书。如果大家和 Java 系的技术或者产品做过对接，应该会对这种微妙的差别深有体会，此时，我们就需要通过 OpenSSL 来实现不同证书格式间的转换，ASP.NET Core 需要的 .pfx 证书是如何产生的呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// x.509 -&gt; .pfx</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> server.crt -inkey server.key -out server.pfx</span><br></pre></td></tr></table></figure><p>同理，常见的 OpenSSL 转换命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// .pem -&gt; .pfx</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> cert.pem -out cert.pfx -inkey key.pem </span><br><span class="line">// .pfx -&gt; .cer</span><br><span class="line">openssl pkcs12 -<span class="keyword">in</span> server.pfx -out server.cer -nodes</span><br><span class="line">// .cer -&gt; .pem</span><br><span class="line">openssl x509 -inform der -<span class="keyword">in</span> server.cer -out server.pem</span><br><span class="line">// PEM -&gt; DER</span><br><span class="line">openssl x509 -<span class="keyword">in</span> server.pem -outform der -out server.der</span><br><span class="line">// DER -&gt; PEM</span><br><span class="line">openssl x509 -<span class="keyword">in</span> server.der -inform der -outform pem -out server.pem</span><br></pre></td></tr></table></figure><h2 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h2><p>Envoy 中可以直接使用 .crt 文件 以及 .key 文件，这里出现了一个 TLS 协议，这个协议一直没机会来说，这里可以简单说一下，它可以视为 SSL 3.1，因为早期的 SSL 协议是由网景公司(Netscape)提出的，一共经历了 1.0、2.0 和 3.0 三个版本，后来标准化组织 IETE 在此基础上提出了增强版的 TLS 协议，一直沿用至今，所以，TLS 可以看做是 SSL 3.1，换句话讲，HTTPS = HTTP + SSL/TLS。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">transport_socket:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">envoy.transport_sockets.tls</span></span><br><span class="line">  <span class="attr">typed_config:</span></span><br><span class="line">    <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext</span></span><br><span class="line">    <span class="attr">common_tls_context:</span></span><br><span class="line">      <span class="attr">alpn_protocols:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"h2"</span></span><br><span class="line">      <span class="attr">tls_certificates:</span></span><br><span class="line">        <span class="attr">certificate_chain:</span></span><br><span class="line">          <span class="attr">filename:</span> <span class="string">"/path/to/your/example.com.crt"</span></span><br><span class="line">        <span class="attr">private_key:</span></span><br><span class="line">          <span class="attr">filename:</span> <span class="string">"/path/to/your/example.com.key"</span></span><br></pre></td></tr></table></figure><p>相信到了现在这个地步，大家终于能想明白 通过 HttpClient 调用第三方接口时，为什么要这这样一段堪称魔法的代码了吧？因为在推进 HTTPS 的过程中，大家使用的 SSL/TLS 协议版本都不一样，有时候客户端还提供不了可以通过验证的证书，所以，大家干脆无视协议的版本、证书的验证错误这些问题啦！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.Net.ServicePointManager.SecurityProtocol =</span><br><span class="line">    SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12 | SecurityProtocolType.Tls13;</span><br><span class="line">System.Net.ServicePointManager.ServerCertificateValidationCallback += (a, b, c, d) =&gt; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RestSharp</span></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> RestClient();</span><br><span class="line">client.RemoteCertificateValidationCallback += (a, b, c, d) =&gt; <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx 就更不必说啦，不过我个人现在更喜欢 Envoy 一点，Nginx 可以用 .crt 证书 或者 .pem 证书，我们只需要简单配置一下就可以了：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/example.com.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>因为一次服务器迁移时被证书苦虐的经历，决定花点时间研究了一下数字证书，本文从 HTTPS 协议入手，引出了对称加密、非对称加密等加密相关的内容，然后讨论了什么是证书，什么是 CA，以及 为什么需要 CA 等内容，现实世界中需要一个为证书权威性、真实性提供担保的组织，这种组织可以签发证书、验证证书、管理证书，利用数字签名的不可篡改、不可抵赖、不可复制、不可伪造等特性，根 CA 可以授权中间 CA 去签发证书，因为整个证书链都是可以追溯的。有了这些知识作为背景，我们分享了如何获得一份自签名证书和 CA 证书，两者本质上没有什么不同，唯一的区别在于其信任度不同。故事的最后，博主分享了如何为 ASP.NET Core 、Envoy、Nginx 配置 证书，对于数字证书的理解，从道的层面到术的层面，我们全部都串联起来啦，好了，以上就是这篇博客的全部内容，欢迎大家在评论区积极留言、参与讨论，原创不易，写技术博客更不易，大家点个赞吧！</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://kangzubin.com/certificate-format/" target="_blank" rel="noopener">SSL 数字证书的标准、编码以及文件扩展名</a></li><li><a href="https://www.moeelf.com/archives/281.html" target="_blank" rel="noopener">Docker 使用 acme.sh 申请 SSL 证书</a></li><li><a href="https://ws.wiki.gaogevip.com/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输安全协议</a></li><li><a href="https://zhuanlan.zhihu.com/p/100389013" target="_blank" rel="noopener">RingCentral Tech丨证书，证书链，CA的那些事</a></li><li><a href="https://zhuanlan.zhihu.com/p/96494976" target="_blank" rel="noopener">你知道，HTTPS用的是对称加密还是非对称加密</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="证书" scheme="https://qinyuanpei.github.io/tags/%E8%AF%81%E4%B9%A6/"/>
    
      <category term="加密" scheme="https://qinyuanpei.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="签名" scheme="https://qinyuanpei.github.io/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="HTTPS" scheme="https://qinyuanpei.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>夕雾花园：从建筑中读出的爱情和美学</title>
    <link href="https://qinyuanpei.github.io/posts/3623891261/"/>
    <id>https://qinyuanpei.github.io/posts/3623891261/</id>
    <published>2021-08-26T09:13:32.000Z</published>
    <updated>2021-10-09T03:32:42.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>“古巴比伦王颁布了汉谟拉比法典，刻在黑色的玄武岩，距今已经三千七百多年”。多年以前，周杰伦在 <a href="https://www.bilibili.com/video/BV1Vx411G7Aj/" target="_blank" rel="noopener">《爱在西元前》</a> 里这样喃喃道，古巴比伦、楔形文字、玄武岩石板、底格里斯河、汉谟拉比法典……千年以后，一切已无法考据，这些如图腾符号一般神秘的意象，留给后人的只有无限的遐想。据传，公元前6世纪，新巴比伦国王尼布甲尼撒二世，迎娶了米底的公主安美依迪丝为王后。公主美丽可人，深受国王宠爱，可没过多久，公主就因为思念家乡而满怀愁绪。为此，国王召集工匠依照米底山区的景致修建了空中花园。最终，这座被誉为“古代七大奇迹”之一的神秘建筑，凭借它巧夺天工的园林景色俘获了公主的欢心。当空中花园渐渐淹没在滚滚黄沙里，这段无人知晓的爱，大概会被永远淹没在史书文卷，直到一个叫做方文山的词人发现它，然后写出来。在几乎同时代的周朝，周幽王烽火戏诸侯，只为博褒姒一笑。故事总是相似的，只是我们更愿意相信，那就是爱。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/vL3PmCX9TUfuqN1.jpg" alt="巴比伦“空中花园”" referrerpolicy="no-referrer"></div><div class="image-caption">巴比伦“空中花园”</div></figure><p>在更为久远的公元前4世纪，彼时庞贝城刚刚开始兴建。这个背靠地中海的小渔村，依托着天然的港口优势，在短短几十年里，逐渐成为仅次于意大利古罗马城的第二大城市。它北距罗马300千米，西接著名的西西里岛，南通希腊与北非，有着丝毫不亚于古罗马的斗兽场、太阳神神庙、大剧院、巫师堂、蒸汽浴室、商铺以及娱乐场所，吸引了无数来自周中海周边城邦的贵族和富商。庞贝城以北，有一座维苏威火山，这座活火山千年来一直在不断喷发，甚至庞贝古城本身就是建筑在硬化的火山熔岩上面。公元62年2月8日，一次强烈的地震令庞贝古城中的大量建筑塌毁，人们重建了庞贝古城，比以前更加追求奢侈豪华。历史定格在公元79年8月24日这一天，维苏威火山突然爆发，厚约6米的火山灰完全将这座城市从地球上抹去。<a href="https://music.163.com/#/song?id=1842802205" target="_blank" rel="noopener">许嵩</a> 对此发问，“如果火山喷发，是灾难还是壮美？”。也许，在那一瞬间，真的有人攥着新鲜的玫瑰，准备向喜欢的人求爱。火山喷发的刹那，庞贝是一颗千年的琥珀，时间自此被凝固和封印。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/bte7TPhu15aErHv.jpg" alt="重见天日的庞贝古城" referrerpolicy="no-referrer"></div><div class="image-caption">重见天日的庞贝古城</div></figure><p>不管是神秘莫测的空中花园，还是重见天日的庞贝古城，某种程度上，我们更愿意相信，那些亦真亦假的美丽传说。也许，这是因为它比建筑本身更具有说服力。因此，巴黎圣母院有过卡西莫多与艾丝梅拉达的故事，沧浪亭有过<a href="https://book.douban.com/subject/1088581/" target="_blank" rel="noopener">《浮生六记》</a>里的伉俪情深，泰姬陵有过沙·贾汗的一夜白头，布达拉宫有过松赞干布和文成公主的相敬如宾，埃菲尔铁塔有过古斯塔夫·埃菲尔的望眼欲穿……世上以爱为名的建筑不在少数，或为古堡、或为陵墓、或为高塔、或为教堂……即使随着时间的流逝，建筑会褪去自身的光芒，而透过这些故事所折射出的爱情的光华，则永远不会褪去，还有什么比历经风雨洗礼的建筑更能表达爱的深沉呢？电影 <a href="https://movie.douban.com/subject/30238379/" target="_blank" rel="noopener">《夕雾花园》</a> 同样讲述了一个关于建筑的故事，假如园林艺术可以当做一种建筑的话。于是，爱情、战争、艺术、救赎、悬疑……种种元素交织在一起，像极了这座园林里一草一木、一砖一瓦。透过石头和木头，去打量某段扑朔迷离的历史，这本身就是一种『借景』，谁还能记得起，在兴庆宫的花萼相辉楼，李白曾经写过某一首诗呢？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/D2mPAnxp3Zlo6hv.jpg" alt="从一方天地中借景" referrerpolicy="no-referrer"></div><div class="image-caption">从一方天地中借景</div></figure><p>妹妹云红，年轻时曾和姐姐云林一起前往日本旅行，并在那里见到了日式庭院，自此在心里埋下了一份庭院情结。后来，日本发动对马来西亚的侵略战争，姐妹俩被抓到同一个集中营里。姐姐云林，白天目睹日军对妹妹的暴行，夜晚聆听妹妹对日本园林的畅想。此时此刻，人生的苦难与艺术的理想，像极了一幅太极图，互不相溶而又紧紧相依。再后来，姐姐死里逃生，而妹妹却命丧矿井。带着这份深深的内疚感，云林决心替妹妹建造一座日式园林。就这样，女主结识了日本皇家园艺师中村有朋。中村并没有接受女主的园艺委托，而是让女主参与夕雾花园的修建工作，正是在这个过程中，中村教给了云林『借景』的智慧，所谓『借景』，是指在一个视觉范围内，借由远方的山，眼前的树，天上的云与雾，呼应人工打造的花园，创造出浑然天成的自然框景。所以，对于这个电影而言，云林是从过往的美好回忆、未来的无限期许中借景；中村是从和云林的相处中借景；导演是从时间、氛围、景致、阅历中借景。由此，云林和中村互相实现了自我救赎，云林能放下过去的执念努力生活下去，中村能够放下国家战争的罪恶感潜心钻研园艺，而我们能有幸看到这样一个故事。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/Fv8x1ObSHcuiX2w.jpg" alt="回忆中可爱的妹妹" referrerpolicy="no-referrer"></div><div class="image-caption">回忆中可爱的妹妹</div></figure><p>如果单纯用爱情来定义这部电影，显然是狭隘而片面的，因为我认为它表达了某种关乎艺术、心灵的东西。从无印良品到优衣库，日式的美学，始终让人联想到侘寂或者无用这样的字眼，甚至连同今年的东京奥运会开幕式，都被人们吐槽充满了阴间的味道。对于云林而言，中村是一个侵略者的身份，不管他是不是日军的间谍，不管他是不是知道集中营的位置，因为他们国家的铁蹄踏入自己的家园，亲人因此而走向毁灭，这是不折不扣的事实。可天使和魔鬼谁又真正分得清楚呢？云林曾经这样问妹妹云红，“日本人这样对待我们，为何你还喜欢他们的庭园”，云红说，“我爱的是花园，而不是建造它的人”。所以，对我而言，这部电影的基调是残酷而又不乏温柔的，战争带给人们的伤痛是真实而残酷的，而实现一种心灵层面上的宁静、尊重自然、尊重生命则是平静而温柔的。日式庭院，在战争时期对人们而言是毫无用处的，甚至修建这样一座庭院并不能让妹妹活过来，可正是这样一份来自侵略者国度的艺术理想，支撑着姐妹俩熬过那些人生中至暗的时刻。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/jl9D7bTKYJGMXIH.jpg" alt="我们活在疯狂的世界" referrerpolicy="no-referrer"></div><div class="image-caption">我们活在疯狂的世界</div></figure><p>透过云林被汗水浸透的衣服，中村第一次看见她背上的鞭痕，中村说，从那一刻开始，他就想为眼前的这个女人负责。刺青、折纸、浮世绘，这些非常日系的意象，仿佛故事里纠缠的线索一般，无一不在告诉观众，这是个谜一般的男人。正因为如此，他只能在隐秘的森林深处消失不见，恰如这个故事本身充满冲突和对立，只能选择戛然而止。有时候我会问自己，不能在当下验证和确认的爱，是否就要因此而阻断，甚至遥遥无期直至搁浅。我只知道，电影里是这样处理的，中村以一种私密而残忍的方式，将他对云林的爱，一针一针地钉在她的身上，那片由鞭痕演变而来的刺青。多年以后，经历过时间濯洗的云林，战争带给她的伤痛早已烟消云散，她终于能读懂那个男人的良苦用心。可正如那些被她扯下的折纸一般，当她像从前一样站在门口，凝视着这框架里嵌入的一方天地、一草一木、一花一叶，完成一次『借景』，可那个人此刻又在哪里呢？如果爱上一个来自侵略者国家的人，这样的爱算不算对妹妹、对战争带来的伤痛的背叛？而如果向殖民地的女人吐露国家的秘密，这样的爱又是否是对国家的背叛？年轻时，我们总以为爱情是奋不顾身，可爱与不爱，一个人说了不算啊……</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/Ygl9JcErsHGD3SF.jpg" alt="林深不见“中村”" referrerpolicy="no-referrer"></div><div class="image-caption">林深不见“中村”</div></figure><p>回过头看历史的时候，我们总以为“奋六世之余烈”的大秦帝国，理应是正义的一方，因为历史常常由赢家来书写，一旦你赢了，你怎么说都行，因为后人并不关心真相。一如历史上古罗马帝国横跨亚、欧、非三块大陆，蒙古帝国全盛时期版图甚至辐射到波兰，英国皇家海军一度在海上建立起“日不落”帝国……再后来，人们只记住了联合国五常，我们本以为这个世界不会再有战争，可塔利班还是在阿富汗打了起来。我不认为，战争与伤痛，就只能带来仇恨，就像朝鲜与韩国、印度和巴基斯坦，可能在我们有生之年都不会迎来和解，如果战争不能让人意识到爱与和平的珍贵，相反，它深化了人们内心的仇恨与愤怒，我以为，这才是对那些因为战争而死去的人的辜负和背叛。所以，身处乱世，一座庭院或者建筑，其本身是一种侘寂之美、无用之美，却能在痛苦与艰难中为内心寻得一处安宁，而这正是我看完 <a href="https://movie.douban.com/subject/30238379/" target="_blank" rel="noopener">《夕雾花园》</a> 后想表达的一种观点。无论爱在西元前还是西元后，站在庞贝古城前的你我，是否可以从此刻启程，回到人物饱满、情节充沛的某个瞬间，那一年，汉谟拉比用楔形文字刻下第一部法典，我静静地看着你，完全没想过防卫，拥抱的刹那，庞贝古城仿佛从未消失过一样……</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/IpXbBhykijmU1t2.jpg" alt="彼岸浮灯" referrerpolicy="no-referrer"></div><div class="image-caption">彼岸浮灯</div></figure><p>这世间的有些废墟相当壮观，而我对它们曾经的丰功伟绩知之甚少；这世间的有些故居格外亲切，而它们的主人对于历史进程的影响微乎其微。中国传统文学中的抒情主题，占比最多的怀古之情、兴亡之叹，所以，陈子昂登幽州台，发出前无古人、后无来者的慷慨悲歌；苏东坡赤壁遨游，感慨人生如梦，一樽还酹江月；辛弃疾登京口北固亭，梦回金戈铁马，气吞万里如虎……可能，从废墟中寻找某种感同身受的历史幻想，这才是中国文人群体如同着魔一般的集体症候，而将这一现象延伸到更大的世界，也许，全人类都是这样。谁能说刺客信条系列游戏，不是将人类几千年的历史，放在 Animus 这样一个沉浸式的 VR 设备中重新演绎呢？当艾吉欧·奥迪托雷漫步在古罗马的街道，人们总会不由自主地想到，凯撒在长老院遇刺身死、古罗马斗兽场里的三千斯巴达勇士……罗马不是一天建成的，而条条大路通罗马，这种由废墟而产生的莫名的情结，始终萦绕在人们的心头，帕特农神庙、圆明园、庞贝古城、乞力马扎罗雪山……世间有太多的风景，还未来得及亲眼去看就已经消失不见，无论是天然的景致，还是人造的景观，其实和人类本身一样，都要面临消逝的结局，唯一的不同的是，在时间尺度上它们显得更为永恒一点，相比六十年产权的现代化住宅，我还是更喜欢，这些废墟里慢悠悠地流淌着的故事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="历史" scheme="https://qinyuanpei.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="影评" scheme="https://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="夕雾花园" scheme="https://qinyuanpei.github.io/tags/%E5%A4%95%E9%9B%BE%E8%8A%B1%E5%9B%AD/"/>
    
      <category term="建筑" scheme="https://qinyuanpei.github.io/tags/%E5%BB%BA%E7%AD%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 自动识别防疫健康码</title>
    <link href="https://qinyuanpei.github.io/posts/1509692610/"/>
    <id>https://qinyuanpei.github.io/posts/1509692610/</id>
    <published>2021-08-19T14:13:32.000Z</published>
    <updated>2021-10-09T03:32:42.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>这个月月初的时候，朋友兴奋地和我描述着他的计划——准备带孩子到宁夏自驾游。朋友感慨道，“小孩只在书本上见过黄河、见过沙漠，这样的人生多少有一点遗憾”，可正如新冠病毒会变异为德尔塔一样，生活里唯一不变的变化本身，局部地区疫情卷土重来，朋友为了孩子的健康着想，不得不取消这次计划，因为他原本就想去宁夏看看的。回想过去这一年多，口罩和二维码，是每天打交道最多的东西。也许，这会成为未来几年里的常态。在西安，不管是坐公交还是地铁，都会有人去检查防疫二维码，甚至由此而创造了不少的工作岗位。每次看到那些年轻人，我都有种失落感，因为二十九岁高龄的我，已然不那么年轻了，而这些比我更努力读书、学历更高的年轻人，看起来在做着和学历/知识并不相称的工作。也许，自卑的应该是我，因为国家刚刚给程序员群体定性——<a href="http://www.mohrss.gov.cn/SYrlzyhshbzb/jiuye/gzdt/202108/t20210816_420736.html" target="_blank" rel="noopener">新生代农民工</a>。可是，我这个农民工，今天想做一点和学历/知识相称的事情，利用 Python 来自动识别防疫二维码。</p><h1 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h1><p>对于防疫二维码而言，靠肉眼去看的话，其实主要关注两个颜色，即标识健康状态的颜色和标识疫苗注射状态的颜色。与此同时，为了追踪人的地理位置变化，防疫/安检人员还会关注地理位置信息，因此，如果要自动识别防疫二维码，核心就是读出其中的颜色以及文字信息。对于颜色的识别，我们可以利用 <a href="https://opencv.org" target="_blank" rel="noopener">OpenCV</a> 中的 <a href="https://docs.opencv.org/3.4/da/d97/tutorial_threshold_inRange.html" target="_blank" rel="noopener">inRange()</a> 函数来实现，只要我们定义好对应颜色的 <a href="">HSV</a> 区间即可；对于文字的识别，我们可以利用 <a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a> 库来进行提取。基于以上原理，我们会通过 <a href="https://opencv.org" target="_blank" rel="noopener">OpenCV</a> 来处理摄像头的图像，只要我们将手机二维码对准摄像头，即可以完成防疫二维码的自动识别功能。考虑到检测不到二维码或者颜色识别不到这类问题，程序中增加了蜂鸣报警的功能。写作本文的原因，单纯是我觉得这样好玩，我无意借此来让人们失业。可生而为人，说到底不能像机器一样活着，大家不都追求有趣的灵魂吗？下面是本文中使用到的第三方 Python 库的清单：</p><ul><li>pyzbar == 0.1.8</li><li>opencv-contrib-python == 4.4.0.46</li><li>opencv-python == 4.5.3.56</li><li>paddleocr == 2.2.0.2</li><li>paddlepaddle == 2.0.0</li></ul><h1 id="图块检测"><a href="#图块检测" class="headerlink" title="图块检测"></a>图块检测</h1><p>下面是一张从手机上截取的防疫二维码图片，从这张图片中我们看出，整个防疫二维码，可以分为三个部分，即：上方的定位信息图块，中间的二维码信息图块，以及下方的核酸检验信息图块。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/eqzajLoMHEidy5t.jpg" alt="“西安一码通” 防疫二维码" referrerpolicy="no-referrer"></div><div class="image-caption">“西安一码通” 防疫二维码</div></figure><p>对于二维码的检测，我们可以直接使用 <a href="https://github.com/NaturalHistoryMuseum/pyzbar/" target="_blank" rel="noopener">pyzbar</a> 这个库来解析，可如果直接对整张图进行解析，因为其中的干扰项实在太多，偶尔会出现明明有二维码，结果无法进行解析的情况。所以，我们可以考虑对图片进行切分，而切分的依据就是图中的这三个图块。这里，我们利用二值化函数 <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/threshold/threshold.html" target="_blank" rel="noopener">threshold()</a> 和 轮廓提取函数 <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/shapedescriptors/find_contours/find_contours.html?highlight=findcontours" target="_blank" rel="noopener">findContours()</a> 来实现图块的检测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 灰度化 &amp; 二值化</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, binary = cv2.threshold(gray, <span class="number">135</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 检测轮廓，获得对应的矩形</span></span><br><span class="line">contours = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[<span class="number">-2</span>] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(contours)):</span><br><span class="line">    block_rect = cv2.boundingRect(contours[i])</span><br></pre></td></tr></table></figure><p>这里有一个感触颇深的地方，在检测图块的过程中，博主发现中间和底部这两个图块，其检测要更为简单一点，因为它有明显的边界、属于规则的矩形，而上方的图块，因为带有装饰性的纹理，以及灰色的过渡区，二值化并不能检测到其边缘，如下图所示，地铁上使用的二维码，相比商场里使用的二维码，轮廓线要更为清晰一点。所以，这里选择一个什么样的阈值来做二值化，个人感觉是需要反复去尝试的。考虑到要兼容这种轮廓不规则的图块，实际上我使用了一点小技巧，即：在得到下面两个图块以后，利用高度的换算关系，人为地生成上方图块的矩形范围。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/6gdQlwoDncJAvLV.jpg" alt="“西安一码通” 灰度化 & 二值化" referrerpolicy="no-referrer"></div><div class="image-caption">“西安一码通” 灰度化 & 二值化</div></figure><p>那么，这是否说明，代表美的设计，在代表绝对理性的算法面前，其实更像是一种噪音。也许，它们各自的领域不同、观点不同，可都一样在为这个世界发光发热，生活不止一种真相，世界不止一种回声，有微小的差异，同样有宏大的统一。</p><h1 id="二维码检测"><a href="#二维码检测" class="headerlink" title="二维码检测"></a>二维码检测</h1><p>好了，我们可以注意到，一旦完成图块的切分，此时，二维码位于中间这个图块，检测二维码在这里并不是重点，因为检测这个二维码是第一步，按照这个二维码所在的矩形去检测中心的的色彩，这是这里的重点，因为这个二维码解析以后就是一个 URL 地址，本身并没有包含任何信息，我们想要知道一个人是否健康，唯一的办法就是检测中间的色彩。其实，理论上剩余两个图块同样需要检测色彩，可考虑到三者在含义的表达上是一致的，即三者拥有相同的颜色，我们只需要处理其中一个即可。下面是利用 <a href="https://github.com/NaturalHistoryMuseum/pyzbar/" target="_blank" rel="noopener">pyzbar</a> 库对二维码区块进行解析，获取二维码信息、二维码所在的矩形等信息的代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测二维码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_qrcode</span><span class="params">(image, block)</span>:</span></span><br><span class="line">    block_image, block_rect, _ = block</span><br><span class="line">    block_x, block_y, _, _ = block_rect</span><br><span class="line">    gray = cv2.cvtColor(block_image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    qrcodes = decode(gray, [ZBarSymbol.QRCODE])</span><br><span class="line">    <span class="keyword">if</span> len(qrcodes) &gt; <span class="number">0</span>:</span><br><span class="line">        qrcode = qrcodes[<span class="number">0</span>]</span><br><span class="line">        qrcodeData = qrcode.data.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">        x, y, w, h = qrcode.rect</span><br><span class="line">        abs_x = block_x + x</span><br><span class="line">        abs_y = block_y + y</span><br><span class="line">        cv2.rectangle(image, (abs_x, abs_y), (abs_x + w, abs_y + h), color_marker, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, qrcodeData, (abs_x, abs_y, w, h)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>可以注意到，通过 <a href="https://github.com/NaturalHistoryMuseum/pyzbar/" target="_blank" rel="noopener">pyzbar</a> 这个库，我们不单单可以获取到二维码的信息，同时还可以获得二维码在图块中的矩形范围，由此我们可以推算出，二维码在整张图片中的矩形范围，我们会绘制一个矩形来标识二维码的位置，这样使用者就可以清楚的知道，我们的的确确检测到了二维码。</p><h1 id="色彩检测"><a href="#色彩检测" class="headerlink" title="色彩检测"></a>色彩检测</h1><p>一旦我们确定了二维码的矩形范围，接下来的工作，就是在这个矩形范围里检测颜色啦！譬如一个人如果健康状态，二维码的中间部分会显示为绿色。如果一个人完成了疫苗的注射，二维码边上的区域会显示为金色。所以，基于这样的原理，我们只需要检测对应区域是否有对应的颜色即可，这里主要利用了<code>HSV</code>颜色模型，不同于<code>RGB</code>颜色模型，<code>HSV</code>颜色模型利用色相、饱和度和亮度三个指标来描述颜色，是一种把<code>RGB</code>色彩空间中的点放在倒圆锥体上的表示方法。其中：</p><ul><li>H，即 Hue，表示色相，它通过角度来度量，因此，它的取值范围是0 到 360 度，如下图所示，红色对应 0 度，绿色对应 120 度，蓝色对应 240 度：</li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/jGVkTzscKUabeDf.jpg" alt="HSV 颜色模型：色相" referrerpolicy="no-referrer"></div><div class="image-caption">HSV 颜色模型：色相</div></figure><ul><li>S，即 Saturation，表示饱和度，用 0 到 100% 之间的数值表示，如果用下面的倒圆锥体来表示，则 S 表示的是色彩点到所在圆形切面圆心的距离与该圆半径的比值：</li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/UoSRreKhx2Af39d.jpg" alt="HSV 颜色模型：倒圆锥体" referrerpolicy="no-referrer"></div><div class="image-caption">HSV 颜色模型：倒圆锥体</div></figure><ul><li>V，即 Value，表示亮度，同样用 0 到 100% 之间的数值表示，参考上面的倒圆锥体，可以了解到，V 表示的是色彩点所在圆形切面圆心与该圆圆心在垂直距离上的比值：</li></ul><p>此时此刻，你有没有回想起小时候调电视机画面时的经历呢？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/vHSp6CmZQWnjBVk.jpg" alt="找不到合适的图，简单怀旧一下？" referrerpolicy="no-referrer"></div><div class="image-caption">找不到合适的图，简单怀旧一下？</div></figure><p>对于<code>HSV</code>颜色模型，我们可以参考下面的取值范围：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/FfocQAgdOzrhpjm.png" alt="HSV 颜色模型：参考范围" referrerpolicy="no-referrer"></div><div class="image-caption">HSV 颜色模型：参考范围</div></figure><p>以红色为例，其 H 分量取值范围为：0 到 10；S 分量取值范围为：43 到 255；V 分量取值范围为：46 到 255。<a href="https://opencv.org" target="_blank" rel="noopener">OpenCV</a> 中的 <a href="https://docs.opencv.org/3.4/da/d97/tutorial_threshold_inRange.html" target="_blank" rel="noopener">inRange()</a> 函数，可以判断某个 HSV 数组（此时图片使用一个数组来表示）是否在某个给定的区间范围内。于是，我们的思路就是：定义好目标颜色的 HSV 区间，同时提供一份 HSV 格式的图片数据。此时，其实现逻辑如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 颜色范围定义</span></span><br><span class="line">color_dist = &#123;</span><br><span class="line">    <span class="string">'red'</span>: &#123;<span class="string">'Lower'</span>: np.array([<span class="number">0</span>, <span class="number">60</span>, <span class="number">60</span>]), <span class="string">'Upper'</span>: np.array([<span class="number">6</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">'blue'</span>: &#123;<span class="string">'Lower'</span>: np.array([<span class="number">100</span>, <span class="number">80</span>, <span class="number">46</span>]), <span class="string">'Upper'</span>: np.array([<span class="number">124</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">'green'</span>: &#123;<span class="string">'Lower'</span>: np.array([<span class="number">35</span>, <span class="number">43</span>, <span class="number">35</span>]), <span class="string">'Upper'</span>: np.array([<span class="number">90</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">'golden'</span>: &#123;<span class="string">'Lower'</span>: np.array([<span class="number">26</span>, <span class="number">43</span>, <span class="number">46</span>]), <span class="string">'Upper'</span>: np.array([<span class="number">34</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测颜色</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_color</span><span class="params">(image, color)</span>:</span></span><br><span class="line">    <span class="comment"># gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 灰度</span></span><br><span class="line">    gs = cv2.GaussianBlur(image, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)  <span class="comment"># 高斯模糊</span></span><br><span class="line">    hsv = cv2.cvtColor(gs, cv2.COLOR_BGR2HSV)  <span class="comment"># HSV</span></span><br><span class="line">    erode_hsv = cv2.erode(hsv, <span class="literal">None</span>, iterations=<span class="number">2</span>) <span class="comment"># 腐蚀</span></span><br><span class="line">    inRange_hsv = cv2.inRange(erode_hsv, color_dist[color][<span class="string">'Lower'</span>], color_dist[color][<span class="string">'Upper'</span>])</span><br><span class="line">    contours = cv2.findContours(inRange_hsv.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">if</span> len(contours) &gt; <span class="number">0</span>:</span><br><span class="line">        draw_color_area(image, contours)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        winsound.Beep(<span class="number">440</span>, <span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这里，我们先对图片做了一次高斯模糊、然后将其转换为 HSV 格式，经过侵蚀以后传给 <code>inRange()</code>函数，这样我们就得到了所有符合这个区间范围的点。接下来，单单找到颜色还不行，我们还需要根据这些点得到一个轮廓，此时，<code>findContours()</code>函数再次登场，为了让使用者更直观地找到对应的颜色区域，我们这里使用下面的方法将其“画”出来：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标记颜色区域</span></span><br><span class="line">def draw_color_area(image, contours):</span><br><span class="line">    max, index = 0, -1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(contours)):</span><br><span class="line">       <span class="built_in"> area </span>= cv2.contourArea(contours[i])</span><br><span class="line">        <span class="keyword">if</span><span class="built_in"> area </span>&gt; max:</span><br><span class="line">            max = area</span><br><span class="line">            index = i</span><br><span class="line">    <span class="keyword">if</span> index &gt;= 0:</span><br><span class="line">        rect = cv2.minAreaRect(contours[index])</span><br><span class="line">        cv2.ellipse(image, rect, color_marker, 2, 8)</span><br><span class="line">        cv2.circle(image, (np.int32(rect[0][0]), np.int32(rect[0][1])), 2, color_marker, 2, 8, 0)</span><br></pre></td></tr></table></figure><p>以中间部分的二维码图块为例，此时，我们可以得到下面的结果，这是做了两次颜色检测得到的，第一次检测绿色，第二次检测金色：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/wt6y4gEocnhkM5K.png" alt="“西安一码通” 防疫二维码：颜色检测" referrerpolicy="no-referrer"></div><div class="image-caption">“西安一码通” 防疫二维码：颜色检测</div></figure><h1 id="OCR-识别"><a href="#OCR-识别" class="headerlink" title="OCR 识别"></a>OCR 识别</h1><p><code>OCR</code>识别没有太多悬念，因为我们直接使用 <a href="https://github.com/PaddlePaddle/PaddleOCR" target="_blank" rel="noopener">PaddleOCR</a> 即可，因为我们已经完成对图块的切分，只需要依次对图片进行检验即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install paddlepaddle==2.0.0 -i https://mirror.baidu.com/pypi/simple</span><br><span class="line">python -m pip install paddleocr</span><br></pre></td></tr></table></figure><p>在安装的过程中，可能会得到这样的错误信息：<code>Microsoft Visual C++ 14.0 is required</code>。如果你安装了 Visual Studio 依然提示错误，解决方案就是找到 Visual Studio 安装包，然后勾选那些和 Microsoft Visual C++ 14.0 相关的可选的安装项，再安装了这些必要组件以后，重新使用<code>pip</code>安装即可。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/Iqms8YS6G7l4zrC.png" alt="“Microsoft Visual C++ 14.0 is required” 错误信息" referrerpolicy="no-referrer"></div><div class="image-caption">“Microsoft Visual C++ 14.0 is required” 错误信息</div></figure><p>因为 <a href="https://github.com/PaddlePaddle/PaddleOCR" target="_blank" rel="noopener">PaddleOCR</a> 接受的是<code>PIL</code>库中的<code>Image</code>类型，所以，在拆分图块的时候，实际上是为每个图块生成了一个对应的文件。此时，OCR 识别部分的代码实现如下。首先，我们需要初始化 PaddleOCR ，首次运行会自动下载训练好的模型文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PaddleOCR</span></span><br><span class="line">ocr = PaddleOCR()</span><br></pre></td></tr></table></figure><p>这里，我们通过<code>detect_text</code>来检测每个图块的文字，并在原始图片中标记出文字位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测文字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_text</span><span class="params">(image, block)</span>:</span></span><br><span class="line">    _, block_rect, block_file = block</span><br><span class="line">    block_x, block_y, _, _ = block_rect</span><br><span class="line">    result = ocr.ocr(block_file)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> result:</span><br><span class="line">        boxes = line[<span class="number">0</span>]</span><br><span class="line">        texts = line[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        x = int(boxes[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        y = int(boxes[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        w = int(boxes[<span class="number">2</span>][<span class="number">0</span>]) - x</span><br><span class="line">        h = int(boxes[<span class="number">2</span>][<span class="number">1</span>]) - y</span><br><span class="line">        abs_x = block_x + x</span><br><span class="line">        abs_y = block_y + y</span><br><span class="line">        cv2.rectangle(image, (abs_x, abs_y), (abs_x + w, abs_y + h), color_marker, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">yield</span> texts</span><br></pre></td></tr></table></figure><p>以底部图块的检测结果为例，其文字位置标记及文字识别结果如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/XSTfimvkc2yPOAR.png" alt="通过 OCR 识别出来的文字位置" referrerpolicy="no-referrer"></div><div class="image-caption">通过 OCR 识别出来的文字位置</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/VP2YouclhKLX58j.png" alt="通过 OCR 识别出来的文字信息" referrerpolicy="no-referrer"></div><div class="image-caption">通过 OCR 识别出来的文字信息</div></figure><h1 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h1><p>到现在为止，主要的部分我们已经编写完成，接下来，我们只需要接入摄像头，从摄像头捕捉图像即可。这里，请允许在下推荐一个非常好用的软件：<a href="https://ivcam.en.softonic.com/" target="_blank" rel="noopener">iVCam</a>，它可以让手机摇身一变成为摄像头，从而可以让我们模拟扫描二维码的场景。使用 OpenCV 捕捉来自摄像头的图片非常简单，大家可以参考我曾经的博客：<a href="https://blog.yuanpei.me/posts/2997581895/" target="_blank" rel="noopener">视频是不能P的系列：OpenCV人脸检测</a>，这里我们直接给出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_video</span><span class="params">()</span>:</span></span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, image = cap.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">           <span class="comment"># 检测画面中的图块</span></span><br><span class="line">            blocks = list(detect_blocks(image))</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 处理每个图块</span></span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">                image = handle_block(image, block)</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 展示处理结果</span></span><br><span class="line">            cv2.imshow(<span class="string">'QRCode Detecting'</span>, image)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 按 Q 退出</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    cap.release() </span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>此时，我们就可以看到下面的结果。可以注意到，在实际应用中，通过视频采集的图像会受到环境光照、拍摄角度等因素的影响，受此影响，我们的图块检测在这个环节表现不佳，它甚至把整张图片当成了一个图块，这直接导致最重要的二维码没有检测出来。百度的 <a href="https://github.com/PaddlePaddle/PaddleOCR" target="_blank" rel="noopener">PaddleOCR</a> 表现倒是可圈可点，识别速度和准确性还是非常出色的。对于视频这种级别的输入，特别是在人流量较大的商场、车站等场所，对于识别准确性、可靠性都有着非比寻常的要求，如果要考虑这个思路的落地，应该在图像采集的预处理、图像检测的算法上去下功夫，特别是在拆分图块这个环节，识别的准确性还会受到二维码样式的影响，而这些显然是这篇博客背后的故事啦！正所谓，”路漫漫其修远兮，吾将上下而求索”，如果大家对这个项目感兴趣的话，可以到 <a href="https://github.com/Regularly-Archive/2021/tree/master/src/GreenQRCode" target="_blank" rel="noopener">Github</a> 上做进一步的了解。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/dxtOhKCr8YFLmoW.jpg" alt="通过摄像头检测防疫二维码" referrerpolicy="no-referrer"></div><div class="image-caption">通过摄像头检测防疫二维码</div></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>写完这篇博客的时候，我不由地会想，也许，屏幕前的某个人会在看完这篇博客以后，一脸鄙夷地说道，就这？可这的确就是基础性研究的现状，即：投入了时间和精力，并不一定能得到满意的结果。我们从小到大接受的关于成功的理念，无非都是“只要功夫深，铁杵磨成针”、“吃得苦中苦，方为人上人”……可不知道为什么，这种理念在被一点一点的打破，某种意义上来讲，国家和个人在这个时代面对的选择是相似的，在选择挣快钱还是挣慢钱这个问题上。多年以前，在实验室里捣腾化学试剂的我，曾经一度认为做实验、分析数据、写报告这些事情是枯燥而无用的，因为在当时看来，这些东西距离实际应用都挺遥远的。可是，此刻我大概不得不承认，这些基础工作的重要性。的确，写算法、做模型，这些事情都是科学家去做的事情，我们普通人只要奉行“拿来主义”就好，可当 OpenCV 就放在你手里，而你依然做不好这件事情的时候，大概还是我输了罢，说“认真你就输了”的人，真的真的真的认真过吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="OpenCV" scheme="https://qinyuanpei.github.io/tags/OpenCV/"/>
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="健康码" scheme="https://qinyuanpei.github.io/tags/%E5%81%A5%E5%BA%B7%E7%A0%81/"/>
    
      <category term="防疫" scheme="https://qinyuanpei.github.io/tags/%E9%98%B2%E7%96%AB/"/>
    
  </entry>
  
  <entry>
    <title>你不可不知的容器编排进阶技巧</title>
    <link href="https://qinyuanpei.github.io/posts/172025911/"/>
    <id>https://qinyuanpei.github.io/posts/172025911/</id>
    <published>2021-08-14T22:13:32.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在团队内推广<code>Docker Compose</code>有段时间啦，值得庆幸的是，最终落地效果还不错，因为说到底，大家都不大喜欢，那一长串复杂而枯燥的命令行参数。对我而言，最为重要的一点，团队内使用的技术变得更加透明化、标准化，因为每个微服务的配置信息都写在<code>docker-compose.yml</code>文件中，任何人都可以快速地构建出一套可用的服务，而不是每次都要去找具体的某一个人。我想说，这其实是一个信息流如何在团队内流动的问题。也许，我们有文档或者<code>Wiki</code>，可新人能不能快速融入其中，这才是检验信息流是否流动的唯一标准。就这样，团队从刀耕火种的<code>Docker</code>时代，进入到使用服务编排的<code>Docker Compose</code>时代。接下来，能否进入<code>K8S</code>甚至是云原生的时代，我终究不得而知。今天我想聊聊，在使用<code>Docker Compose</code>的过程中，我们遇到的诸如容器的<strong>启动顺序</strong>、<strong>网络模式</strong>、<strong>健康检查</strong>这类问题，我有一点<code>Docker Compose</code>的进阶使用技巧想和大家分享。</p><h1 id="容器的启动顺序"><a href="#容器的启动顺序" class="headerlink" title="容器的启动顺序"></a>容器的启动顺序</h1><p>使用服务编排以后，大家最关心的问题是，如果服务间存在依赖关系，那么如何保证容器的启动顺序？我承认，这是一个真实存在的问题，譬如，你的应用依赖某个数据库，理论上数据库要先启动，抑或者是像<code>Redis</code>、<code>Kafka</code>、<code>Envoy</code>这样的基础设施，总是要优先于应用服务本身启动。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/LnAh6GSdMJ2NkVx.png" alt="假如章鱼的这些脚互相影响会怎么样？" referrerpolicy="no-referrer"></div><div class="image-caption">假如章鱼的这些脚互相影响会怎么样？</div></figure><p>熟悉<code>Docker Compose</code>的同学，也许会想到<code>depends_on</code>这个选项，可如果大家亲自去尝试过就会知道，这终究只是我们的一厢情愿。为什么呢？因为这个<code>depends_on</code>主要是看目标容器是不是处于<code>running</code>的状态，所以，在大多数情况下，我们会注意到<code>Docker Compose</code>并不是按我们期望的顺序去启动的，因为目标容器在某一瞬间的确已经是<code>running</code>的状态了，那这样简直太尴尬了有木有啊！我们从一个简单的例子开始：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&gt;</span></span><br><span class="line">      <span class="string">/bin/bash</span> <span class="string">-c</span> <span class="string">'</span></span><br><span class="line"><span class="string">      sleep 5;</span></span><br><span class="line"><span class="string">      echo "sleep over";'</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure><p>可以注意到，为了证明<code>city_service</code>服务不会等待<code>redis_server</code>服务，我故意让子弹飞了一会儿，结果如何呢？我们一起来看看：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/BqDRtbJkpVcno3s.png" alt="Docker Compose 启动顺序：一厢情愿" referrerpolicy="no-referrer"></div><div class="image-caption">Docker Compose 启动顺序：一厢情愿</div></figure><p>果然，我没有骗各位，<code>city_service</code>服务不会等待<code>redis_server</code>服务。我们知道，<code>Redis</code>提供的命令行接口中，有一个<code>PING</code>命令，当<code>Redis</code>可以正常连接的时候，它会返回一个<code>PONG</code>，也许，这就是乒乓球的魅力所在。基于这个想法，我们继续修改<code>docker-compose.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&gt;</span></span><br><span class="line">      <span class="string">/bin/bash</span> <span class="string">-c</span> <span class="string">'</span></span><br><span class="line"><span class="string">      while ! nc -z redis_server 6379;</span></span><br><span class="line"><span class="string">      do</span></span><br><span class="line"><span class="string">        echo "wait for redis_server";</span></span><br><span class="line"><span class="string">        sleep 1;</span></span><br><span class="line"><span class="string">      done;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      echo "redis_server is ready!";</span></span><br><span class="line"><span class="string">      echo "start city_service here";</span></span><br><span class="line"><span class="string">      '</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure><p>这里，我们用了一种取巧的方法，<code>Ubuntu</code>中的<code>nc</code>命令可以对指定主机、指定端口进行检测，换言之，我们简单粗暴的认为，只要<code>6379</code>这个端口可以访问，就认为<code>Redis</code>准备就绪啦，因为我们没有办法在<code>city_service</code>这个容器中调用<code>redis-cli</code>，这个做法本身并不严谨，我们这里更多的是验证想法：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/Hhx4R7obZL5FBrv.png" alt="Docker Compose 启动顺序：检测 Redis" referrerpolicy="no-referrer"></div><div class="image-caption">Docker Compose 启动顺序：检测 Redis</div></figure><p>可以注意到，此时，<code>city_service</code>服务会等待<code>redis_server</code>服务，直到<code>redis_server</code>服务就绪。所以，要解决服务编排时，容器的启动顺序的问题，本质上就是把需要等待的服务、端口以及当前服务的启动命令，统一到容器的入口中。为此，官方提供了 <a href="https://github.com/vishnubob/wait-for-it" target="_blank" rel="noopener">wait-for-it</a> 这个方案，官方关于容器启动顺序的文档，可以参考：<a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">Startup Order</a>。对于上面的例子，我们可以这样改写<code>docker-compose.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/wait-for-it.sh",</span> <span class="string">"redis_server:6379"</span><span class="string">,</span> <span class="string">"--"</span><span class="string">,</span> <span class="string">"dotnet"</span><span class="string">,</span> <span class="string">"CityService.dll"</span><span class="string">]</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure><p>此时，启动容器时的效果如下，因为这个方案依赖 <a href="http://netcat.sourceforge.net/" target="_blank" rel="noopener">Netcat</a> 这样一个工具，所以，我们的容器中还需要加入这个工具，此时，可以使用下面的脚本片段：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:buster-slim as wait-for-it</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y <span class="string">"wait-for-it"</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=<span class="built_in">wait</span>-for-it /usr/bin/<span class="built_in">wait</span>-for-it .</span></span><br></pre></td></tr></table></figure><p>不过，不太明白为什么这里一直提示路径不对：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/16/jgbwuVHeJNvG5BY.png" alt="Docker Compose 启动顺序：wait-for-it.sh" referrerpolicy="no-referrer"></div><div class="image-caption">Docker Compose 启动顺序：wait-for-it.sh</div></figure><p>个人建议，最好将这个语句写在<code>Dockerfile</code>，或者试提供一个类似于<code>entrypoint.sh</code>的脚本文件。关于这个方案的更多细节，大家可以参考<a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">官方文档</a>，写这篇文章的时候，我不由得感慨：<code>Shell</code>脚本真的是太难学了(逃……。所以，点到为止。刚刚提到过，我个人觉得这种主机 + 端口号的检测方式不够严谨，因为一个端口可以<code>PING</code>通，并不代表服务一定是可用的，所以，在接下来的内容里，我会介绍基于健康检查的思路。</p><h1 id="容器的健康检查"><a href="#容器的健康检查" class="headerlink" title="容器的健康检查"></a>容器的健康检查</h1><p>不知道大家有没有这样的经历，就是你明明看到一个容器的状态变成<code>Up</code> ，可对应的微服务就是死活调不通。面对来自前端同事的戏谑与嘲讽，你不禁仰天长叹一声，开始在容器里翻箱倒柜，一通操作如虎。过了许久，你终于发现是容器内部出现了始料不及的错误。看来，容器状态显示为<code>Up</code>，并不代表容器内的服务就是可用的啊！果然，还是需要一种机制来判断容器内的服务是否可用啊！等等，这不就是传说中的健康检查？恭喜你，答对了！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/fplPBvICiEOYsKR.jpg" alt="Docker 经典集装箱形象" referrerpolicy="no-referrer"></div><div class="image-caption">Docker 经典集装箱形象</div></figure><p>在<code>Docker</code>及<code>Docker Compse</code>中，均原生支持 <a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="noopener">健康检查</a> 机制，一旦一个容器指定了<code>HEALTHCHECK</code>选项，<code>Docker</code>会定时检查容器内的服务是否可用。我们都知道，一个普通的 Docker 容器，无非是开始、运行中、停止这样三种状态，而提供了<code>HEALTHCHECK</code>选项的<code>Docker</code>容器，会在这个基础上增加健康(<strong>healthy</strong>)和非健康(<strong>unhealthy</strong>)两种状态，所以，我们应该用这两个状态来判断容器内的服务是否可用。下面是一个指定了<code>HEALTHCHECK</code>选项的容器示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="number">3.1</span>-buster-slim</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /app/publish .</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"dotnet"</span>, <span class="string">"CityService.dll"</span>]</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5s --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD curl -fs http://localhost:80/city || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>可以注意到，<code>Docker</code>原生的健康机制，需要通过<code>CMD</code>的方式来执行一个命令行，如果该命令行返回 0 ，则表示成功；返回 1，则表示失败。</p><p>此处，我们还可以配置以下三个参数，<code>--interval=&lt;间隔&gt;</code>表示健康检查的间隔，默认为30秒；<code>--timeout=&lt;时长&gt;</code>表示健康检查命令超时时间，超过该时间即表示<code>unhealthy</code>，默认为30秒；<code>--retries=&lt;次数&gt;</code>表示连续失败的次数，超过该次数即表示<code>unhealthy</code>。对于我们这里的<code>ASP.NET Core</code>应用而言，如果程序正常启动，显然这个地址是可以调通的，我们可以用这个来作为一个“探针”。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/14/QnuPZ8vsCYKbVHm.png" alt="Docker 健康检查：healthy" referrerpolicy="no-referrer"></div><div class="image-caption">Docker 健康检查：healthy</div></figure><p>我们可以注意到，在容器启动的第14秒，其状态为：<code>health：starting</code>。而等到容器启动的第16秒，其状态则为：<code>healthy</code>，这表明我们的服务是健康的。此时此刻，如果我们耍点小心思，让<code>curl</code>去访问一个不存在的地址会怎么样呢？可以注意到，此时状态变成了：<code>unhealthy</code>:</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/14/oNtX8G7UAqEDIzS.png" alt="Docker 健康检查：unhealthy" referrerpolicy="no-referrer"></div><div class="image-caption">Docker 健康检查：unhealthy</div></figure><p><code>HEALTHCHECK</code>指令除了可以直接写在<code>Dockerfile</code>中以外，还可以直接附加到<code>docker run</code>命令上，还是以上面的项目作为示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run  --name city_service -d -p 8081:80  city_service \</span><br><span class="line">--health-cmd="curl -fs http://localhost:80/city || exit 1" \</span><br><span class="line">--health-interval=3s \</span><br><span class="line">--health-timeout=5s \</span><br><span class="line">--health-retries=3</span><br></pre></td></tr></table></figure><p>甚至，我们还可以使用下面的命令来查询容器的健康状态：<code>docker inspect --format=&#39;&#39; &lt;ContainerID&gt;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Status"</span>: <span class="string">"unhealthy"</span>,</span><br><span class="line">  <span class="attr">"FailingStreak"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"Log"</span>: [&#123;</span><br><span class="line"><span class="attr">"Start"</span>: <span class="string">"2021-08-14T15:27:50.3325424Z"</span>,</span><br><span class="line"><span class="attr">"End"</span>: <span class="string">"2021-08-14T15:27:50.3813102Z"</span>,</span><br><span class="line"><span class="attr">"ExitCode"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"Output"</span>: <span class="string">""</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我个人感觉这个<code>curl</code>的写法非常别扭，尤其是当我试图在<code>docker-compose</code>中写类似命令的时候，我觉得稍微复杂一点的健康检查，还是交给脚本语言来实现吧！例如，下面是官方提供的针对<code>MongoDB</code>的健康检查的脚本<code>docker-healthcheck.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -eo pipefail </span><br><span class="line">host="$(hostname --ip-address || echo '127.0.0.1')" </span><br><span class="line">if mongo --quiet "$host/test" --eval 'quit(db.runCommand(&#123; ping: 1 &#125;).ok ? 0 : 2)'; then </span><br><span class="line">   exit 0</span><br><span class="line">fi </span><br><span class="line">   exit 1</span><br></pre></td></tr></table></figure><p>此时，<code>HEALTHCHECK</code>可以简化为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5s --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD bin/bash docker-healthcheck.sh</span></span><br></pre></td></tr></table></figure><p>更多的示例，请参考：<a href="https://github.com/docker-library/healthcheck/" target="_blank" rel="noopener">docker-library/healthcheck/</a> 以及 <a href="https://github.com/rodrigobdz/docker-compose-healthchecks" target="_blank" rel="noopener">rodrigobdz/docker-compose-healthchecks</a>。</p><p>其实，对于容器的启动顺序问题，我们还可以借助检查检查的思路来解决，因为<code>depends_on</code>并不会等待目标容器进入<code>ready</code>状态，而是等目标容器进入<code>running</code>状态。这样，就回到了我们一开始描述的现象：一个容器明明都变为<code>Up</code>状态了，可为什么接口就是死活调不通呢？因为我们无法界定这样一个<code>ready</code>状态。考虑到<code>depends_on</code>可以指定<code>condition</code>，此时，我们可以这样编写<code>docker-compose.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="string">["CMD",</span> <span class="string">"redis-cli"</span><span class="string">,</span> <span class="string">"ping"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">redis_server:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure><p>简单来说，我们使用了<code>Redis</code>内置的命令对<code>redis_server</code>服务进行健康检查，而<code>city_service</code>服务则依赖于<code>redis_server</code>服务的健康状态，只有当<code>Redis</code>准备就绪了以后，<code>city_service</code>才会开始启动。下面是实际启动过程的截图，看看是不是和我们想的一样：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/HKvjmoCdznlW6FV.png" alt="Docker 健康检查：容器启动顺序" referrerpolicy="no-referrer"></div><div class="image-caption">Docker 健康检查：容器启动顺序</div></figure><p>果然，奇怪的知识有增加了呢，我们唯一需要解决的问题，就是怎么给某一个服务做健康检查，以上！</p><h1 id="容器的网络模式"><a href="#容器的网络模式" class="headerlink" title="容器的网络模式"></a>容器的网络模式</h1><p>接下来，我们来说说<code>Docker</code>里的网络模式，特别是当我们使用<code>docker-compose</code>来编排一组服务的时候，假设我们有一个目录<code>app</code>，在这个牡蛎里我们放置了服务编排文件<code>docker-compose.yml</code>，默认情况下，<code>Docker-Compose</code>会创建一个一个名为<code>app_default</code>的网络，并且这个网络是<code>bridge</code>，即网桥模式的一个网络。什么是网桥模式呢？你可能会感到困惑，而这要从<code>Docker</code>中的网络模式开始说起，这里简单下常用的几种：</p><ul><li>host模式，或叫做主机模式，可以认为容器和主机使用相同的端口进行访问，因为容器和主机在同一个网络下，此模式下，意味着通过<code>-p</code>绑定的端口失效，因为所有容器都使用主机的网络，所以容器间可以相互通信，此模式通过<code>--network=host</code>指定。</li><li>bridge模式，或叫做网桥模式，这是<code>Docker</code>中默认的网络设置，此模式下，容器和主机有各自的IP/端口号，两者之间通过一个虚拟网桥进行通信，虚拟网桥的作用类似于物理交换机。因此，不同容器间的网络是相互隔离的，此模式通过<code>--network=bridge</code>指定。</li><li>none模式，通俗讲就是无网络模式，意味着容器是一个封闭的环境，无法通过主机访问外部的网络，这种模式在那种讲究保密性质、封闭式开发的场合应该会有一点用，可这都2021年了，难道你还能把互联网上的软件全部下载下来吗？此模式通过<code>--network=none</code>指定。</li><li>container模式，或叫做共享模式，通俗来讲，就是指一个容器共享某个已经存在的容器的<code>Network Namespace</code>，此时，该容器将不会拥有属于自己的IP/端口号等资源，因为这种模式可以节约一定的网络资源，此模式通过<code>--network=&lt;Container_ID&gt;/&lt;Container_Name&gt;</code>指定。</li></ul><p>为了帮助大家理解和区分这四种模式，博主绘制了下面的图示来补充说明：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/16/DJq3CBrmktaRNex.png" alt="容器的网络模式(主机、容器、网桥)示意图" referrerpolicy="no-referrer"></div><div class="image-caption">容器的网络模式(主机、容器、网桥)示意图</div></figure><p>通过以上的图文信息反复加深印象，相信大家可以找出点规律：</p><ul><li>如果你的容器网络与主机网络不需要隔离，那么选择主机模式(<strong>host</strong>)</li><li>如果你的应用运行在不同的容器里，并且这些容器间需要相互通信，那么选择网桥模式(<strong>bridge</strong>)</li><li>如果你的应用需要运行在一个隔绝外界网络的环境中，那么选择无网络模式(<strong>none</strong>)</li><li>如果你希望在节省网络资源的同时，实现不同容器间的通信，那么选择容器模式(<strong>container</strong>)</li></ul><p>以上四种网络模式，除了可以在<code>docker run</code>的时候指定以外，我们还可以在<code>docker-compose.yml</code>文件中指定。例如，下面表示的是一个主机模式的容器：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.8'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">cache_server:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cache_server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure><p>大多数情况下，我们只需要连接到<code>docker0</code>这个虚拟网卡即可，而如果你想为某个容器或者一组容器单独建立这样一张网卡，此时，就不得不提到<code>Docker</code>中的自定义网络功能，我们一起来看下面的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个网络：test-network</span><br><span class="line">docker network create test-network</span><br><span class="line">// 创建一个Nginx的容器：nginx_8087，使用网络：test-network</span><br><span class="line">docker run -d --name nginx_8087 --network test-network -p 8087:80 nginx:latest</span><br><span class="line">// 创建一个Nginx的容器：nginx_8088</span><br><span class="line">docker run -d --name nginx_8088 -p 8088:80 nginx:latest</span><br><span class="line">// 连接容器：nginx_8088 至网络：test-network</span><br><span class="line">docker network connect test-network nginx_8088</span><br></pre></td></tr></table></figure><p>接下来，通过下面的命令，我们可以拿到两个容器的ID，在此基础上我们看一下两个容器各自分配的IP是多少：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' &lt;ContainerID&gt;</span><br></pre></td></tr></table></figure><p>此时，我们会发现一个有趣的现象，<code>nginx_8087</code>这个容器，可以获得IP地址<code>172.17.0.2</code>，而<code>nginx_8088</code>则无法获得IP地址，这是为什么呢？这其实就是我们前面提到过的容器模式(<strong>container</strong>)，此时，<code>nginx_8088</code>这个容器实际上是和<code>nginx_8087</code>共享一个<code>Network Namespace</code>，即使它们有各自的文件系统。同样地，我们可以使用下面的命令来让容器从某个网络中断开：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 断开容器：nginx_8088 至网络：test-network</span><br><span class="line">docker network disconnect test-network nginx_8088</span><br><span class="line">// 删除网络</span><br><span class="line">docker network rm test-network</span><br></pre></td></tr></table></figure><p>是否觉得手动维护容器的网络非常痛苦？幸好，我们还有<code>Docker-Compose</code>可以用，上面两个<code>Nginx</code>的容器我们可以这样维护：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx_8087:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8087</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8087</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">  <span class="attr">nginx_8088:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8088</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8088</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">test-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>此时，我们可以注意到，<code>Docker Compose</code>会创建两个网络，即<code>network_mode_default</code>和<code>network_mode_test-network</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/16/Sgsbpt1huUlmTQM.png" alt="Docker Compose 中使用自定义网络" referrerpolicy="no-referrer"></div><div class="image-caption">Docker Compose 中使用自定义网络</div></figure><p>这说明默认网络依然存在，如果我们希望完全地使用自定义网络，此时，我们可以这样修改服务编排文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure><p>这表示默认网络会采用主机模式，相应地，你需要修改<code>nginx_8087</code>和<code>nginx_8088</code>两个容器的<code>network</code>选项，使其指向<code>default</code>。</p><p>除此之外，你还可以使用<code>external</code>指向一个已经存在的网络：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">a-existing-network</span></span><br></pre></td></tr></table></figure><p>在<code>Docker</code>中，每个容器都会分配<code>IP</code>，因为这个<code>IP</code>总是不固定的，所以，如果我们希望像虚拟机那样使用一个静态<code>IP</code>的话，可以考虑下面的做法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx_8087:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8087</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8087</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">          <span class="attr">ipv4_address:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line">  <span class="attr">nginx_8088:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8088</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8088</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">          <span class="attr">ipv4_address:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">test-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure><p>关于<code>Docker</code>及<code>Docker Compose</code>中的网络驱动，如 <a href="https://docs.docker.com/network/macvlan/" target="_blank" rel="noopener">macvlan</a>、<a href="https://docs.docker.com/network/overlay/" target="_blank" rel="noopener">overlay</a> 等等，这些显然是更加深入的话题，考虑到篇幅，不在这里做进一步的展开，对此感兴趣的朋友可以参考官方文档：<a href="https://docs.docker.com/network/" target="_blank" rel="noopener">Networking Overview</a> 以及 <a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">Networking in Compose</a>。博主写这篇文章的想法，主要是源于团队内落地<code>Docker-Compose</code>时的一次经历，当时有台虚拟机偶尔会出现<code>IP</code>被篡改的情况，而罪魁祸首居然是<code>Docker-Compose</code>，虽然最终用主机模式勉强解决了这个问题，可终究留下了难以言说的疑问，此刻，大概能稍微对<code>Docker</code>的网络有点了解。果然，越靠近底层，就是越是抽象、越是难以理解。</p><h1 id="文本小结"><a href="#文本小结" class="headerlink" title="文本小结"></a>文本小结</h1><p>本文分享了<code>Docker</code>及<code>Docker-Compose</code>中的进阶使用技巧，主要探索了服务编排场景下容器的启动顺序、健康检查、网络模式三类问题。默认情况下，<code>Docker-Compose</code>的<code>depends_on</code>选项，取决于容器是否处于<code>running</code>状态，因此，当我们有多个服务需要启动时，实际上启动顺序并不会受到<code>depends_on</code>选项的影响，因为此时容器都是<code>running</code>的状态。为了解决这个问题，官方提供了 <a href="https://github.com/vishnubob/wait-for-it" target="_blank" rel="noopener">wait-for-it</a> 的方案，这是一种利用 <a href="http://netcat.sourceforge.net/" target="_blank" rel="noopener">Netcat</a> 对<code>TCP</code>和<code>UDP</code>进行检测的机制，当检测条件被满足的时候，它会执行由用户指定的启动脚本。从这里看，其实已经有了一点健康检查的影子，而官方的健康检查，则允许用户使用更加自由的命令或者脚本去实现检测逻辑，所以，从这个角度上来讲，<code>HEALTHCHECK</code>结合<code>depends_on</code>，这才是实现容器启动顺序控制的终极方案。<code>Docker</code>的网络是一个相对复杂的概念，所以，这里就是简单的介绍了下常见的四种网络模式，更深入的话题比如网络驱动等，还需要花时间去做进一步的探索。本文示例以上传至<a href="https://github.com/Regularly-Archive/2021/tree/master/src/DockerTips" target="_blank" rel="noopener">Github</a>，供大家参考。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Docker" scheme="https://qinyuanpei.github.io/tags/Docker/"/>
    
      <category term="容器" scheme="https://qinyuanpei.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="服务编排" scheme="https://qinyuanpei.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/"/>
    
      <category term="云原生" scheme="https://qinyuanpei.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core 搭载 Envoy 实现 gRPC 服务代理</title>
    <link href="https://qinyuanpei.github.io/posts/3942175942/"/>
    <id>https://qinyuanpei.github.io/posts/3942175942/</id>
    <published>2021-08-08T22:49:47.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在构建以 gRPC 为核心的微服务架构的过程中，博主曾经写过一篇名为 <a href="https://blog.yuanpei.me/posts/2167892202/" target="_blank" rel="noopener">ASP.NET Core gRPC 打通前端世界的尝试</a> 的文章，主要是希望打通 gRPC 和 前端这样两个异次元世界，因为无论我们构建出怎样高大上的微服务架构，最终落地的时候，我们还是要面对当下前后端分离的浪潮。所以，在那篇文章中，博主向大家介绍过 gRPC-Web 、gRPC-Gateway 、封装 API 、<a href="https://github.com/qinyuanpei/Grpc.Gateway" target="_blank" rel="noopener">编写中间件</a> 这样四种方案。我个人当时更喜欢编写中间件这种方案，甚至后来博主进一步实现了 gRPC 的 “扫描” 功能。</p><p>当时，博主曾模糊地提到过，Envoy 可以提供容器级别的某种实现，这主要是指 Envoy 独有的 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">gRPC-JSON Transcoder</a> 功能。考虑到 Envoy 是一个同时支持 HTTP/1.1 和 HTTP/2 的代理软件，所以，它天然地支持基于 HTTP/2 实现的 gRPC。所谓 gRPC-JSON Transcoder，其实指 Envoy 充当了 JSON 到 Protobuf 间互相转换的角色，而它利用的正是 Envoy 中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">过滤器</a> 这一重要组件。好了，在今天这篇文章中，博主就为大家介绍一下这种基于 Envoy 的方案，如果大家困惑于如何把 gRPC 提供给前端同事使用，不妨稍事休息、冲一杯卡布奇诺，一起来探索这广阔无垠的技术世界。</p><h1 id="从-Envoy-说起"><a href="#从-Envoy-说起" class="headerlink" title="从 Envoy 说起"></a>从 Envoy 说起</h1><p>开辟鸿蒙，始有天地。上帝说，要有光，于是，就有了光。而故事的起源，则要追溯到我们最早提出的那个问题：假设我们有下面的 gRPC 服务，我们能否让它像一个 JSON API 一样被调用？ 通过查阅 Protobuf 的 <a href="https://developers.google.cn/protocol-buffers/docs/proto3#json" target="_blank" rel="noopener">官方文档</a>，我们可以发现 Protobuf 与 JSON间存在着对应关系，这是两者可以相互转化的前提。博主在编写 <a href="https://hub.fastgit.org/qinyuanpei/Grpc.Gateway/blob/master/src/Grpc.Gateway/GrpcExtensions.cs" target="_blank" rel="noopener">中间件</a> 时，同样借助了 Protobuf 暴露出来的接口 <a href="https://developers.google.cn/protocol-buffers/docs/reference/csharp/class/google/protobuf/message-parser?hl=zh-cn" target="_blank" rel="noopener">MessageParser</a>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> csharp_namespace = <span class="string">"GrpcService"</span>;</span><br><span class="line"><span class="keyword">package</span> greet;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来，这个 gPRC 服务如何和 Envoy 这个代理服务器产生关联呢？首当其冲的自然是一个路由啦：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">"/greet"</span></span><br><span class="line">  <span class="attr">route:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">grpc_service</span></span><br><span class="line">    <span class="attr">timeout:</span> </span><br><span class="line">      <span class="attr">seconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><p>这表示以 <code>/greet</code> 开头的请求会被路由到 <code>grpc_service</code> 这个集群，如果按照一般的 Envoy 使用流程，接下来，我们只需要配置对应的集群节点即可。我们前面提到过，Envoy 的这个 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">gRPC-JSON Transcoder</a> 功能，是通过过滤器来实现的，更确切地说，它是一个 HTTP 级别的过滤器，所以，我们继续耐心往下看：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http_filters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.grpc_json_transcoder</span></span><br><span class="line">  <span class="attr">typed_config:</span></span><br><span class="line">    <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder</span></span><br><span class="line">    <span class="attr">proto_descriptor:</span> <span class="string">"/etc/descriptor/greet.pb"</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"greet.Greeter"</span></span><br><span class="line">    <span class="attr">print_options:</span></span><br><span class="line">      <span class="attr">add_whitespace:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">always_print_primitive_fields:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">always_print_enums_as_ints:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">preserve_proto_field_names:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">auto_mapping:</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure><p>可以注意到，这里使用了一个叫做 <code>envoy.filters.http.grpc_json_transcoder</code> 的过滤器。对于这个过滤器而言，核心的、需要注意的地方有两个：</p><ul><li><code>proto_descriptor</code> 指向一个 Protobuf 的描述文件，这是一个二进制文件，可以由<code>protoc</code>编译器生成。</li><li><code>services</code> 表示一组服务，必须按照 <code>包名.服务名</code> 的格式进行填写，这里的示例为：<code>greet.Greeter</code>。</li></ul><p>关于如何生成二进制的 Protobuf 描述文件，我们专门放在下一节来讲，在此基础上，我们只要增加集群即可完成 Envoy 的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc_service</span></span><br><span class="line">  <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LOGICAL_DNS</span></span><br><span class="line">  <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="attr">dns_lookup_family:</span> <span class="string">V4_ONLY</span></span><br><span class="line">  <span class="attr">http2_protocol_options:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">upstream_connection_options:</span></span><br><span class="line">    <span class="attr">tcp_keepalive:</span></span><br><span class="line">      <span class="attr">keepalive_time:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">load_assignment:</span></span><br><span class="line">    <span class="attr">cluster_name:</span> <span class="string">grpc_service</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">grpc_service</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>完整的 Envoy 配置文件，请参考 <a href="https://github.com/Regularly-Archive/2021/tree/master/src/EnvoyGrpc" target="_blank" rel="noopener">这里</a>，不再占用篇幅进行说明。</p><h1 id="准备描述文件"><a href="#准备描述文件" class="headerlink" title="准备描述文件"></a>准备描述文件</h1><p>生成 Protobuf 的二进制描述文件，需要借助 <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">protoc</a> 这个命令行工具，此前我们介绍 gRPC 生态中的 gRPC-Web、gRPC-Gateway 时曾经接触过它。Envoy 正是通过这个描述文件来处理 <code>JSON</code> 和 <code>Protobuf</code> 的相互转换，博主猜测这里可能用到了类似 <a href="https://developers.google.cn/protocol-buffers/docs/reference/csharp/class/google/protobuf/message-parser?hl=zh-cn" target="_blank" rel="noopener">MessageParser</a> 的东西，Envoy 从这个二进制的描述文件中获取 gRPC 的元数据信息，并由此从 <code>JSON</code> 构建出 <code>Protobuf</code>。这里，我们还是以本文开始的 <code>.proto</code>文件为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --descriptor_set_out=./Protos/descriptor/greet.pb --include_imports Protos\greet.proto</span><br></pre></td></tr></table></figure><p>这条命令行的含义是，为 <code>Protos\greet.proto</code> 生成对应的服务描述文件 <code>/Protos/descriptor/greet.pb</code>。下图即为博主生成的服务描述文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/08/lhPofJFKytHGWja.png" alt="通过命令行生成 Protobuf 描述文件" referrerpolicy="no-referrer"></div><div class="image-caption">通过命令行生成 Protobuf 描述文件</div></figure><p>此时，我们只需要将其放到 Envoy 的目录中即可，本文中的示例位于以下路径：<code>/etc/descriptor/greet.pb</code>。好了，现在 Envoy 和 gRPC 均已就绪，我们通过 <code>docker-compose</code> 对服务进行编排：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoygateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9090:9090"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9091:9091"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">grpcservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">GrpcService/GrpcService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8082:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br></pre></td></tr></table></figure><p>启动服务后，如果我们像调用 gRPC 服务中的 <code>SayHello()</code>方法，此时，对应的路由为：<code>/greet.Greeter/SayHello</code>，即：<code>包名.服务名/方法名</code>。好了，我们用 Postman 或者 Apifox 对接口进行测试：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/08/RZpux1nwWDh6eJK.png" alt="像调用一个 JSON API 一样调用 gRPC" referrerpolicy="no-referrer"></div><div class="image-caption">像调用一个 JSON API 一样调用 gRPC</div></figure><p>至此，我们实现一开始的目的，通过 Envoy 代理 gRPC 服务以后，对于前端而言，它已不再关心，这个服务背后的服务提供者到底是什么？因为对它而言，JSON API 还是 Protobuf 已经完全没有差别。博主曾经评价它是容器级别的方案，因为它可以将多个 gRPC 服务统一到一个入口中，非常适合充当整个微服务的网关，如果你正在使用 gRPC，相信我，这会是一条必由之路。</p><p>目前，博主所在的公司，已经全面采用了这种方案，而博主则进一步在团队中推广了<code>Docker-Compose</code>，换言之，我们将多个微服务通过<code>Docker-Compose</code>进行编排，并通过 Envoy 为所有微服务提供统一入口，唯一的遗憾是，通过<code>protoc</code>生成服务描述文件这个过程没有纳入到 CI/CD 环节，靠手动生成、复制服务描述文件，到底还是会有点失落呢？如果结合前面分享过的 <a href="https://blog.yuanpei.me/posts/731808750/" target="_blank" rel="noopener">Envoy 身份认证</a>，整个微服务架构终于看起来形成闭环啦！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分享了 Envoy 中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">gRPC-JSON Transcoder</a> 功能，它可以将一个 gRPC 服务代理成一个 JSON API，从而方便前端或者是客户端去消费一个 gRPC 服务。其原理是，Envoy 中可以通过配置过滤器来实现 JSON 和 Protobuf 的相互转换，这一过程依赖 Protobuf 的元数据，故而，我们需要通过命令行工具<code>protoc</code>生成服务描述文件，我们只需要在 Envoy 中添加相关配置，就可以像调用一个 JSON API 一样调用 gRPC。至此， gRPC 与 Web 世界彻底打通，我们可以用我们熟悉的技术去消费一个 gRPC 服务。博主的 <a href="https://github.com/qinyuanpei/Grpc.Gateway" target="_blank" rel="noopener">Grpc.Gateway</a> 实现了类似的功能，如果大家感兴趣，欢迎大家前去体验一番。好了，以上就是这篇博客的全部内容啦，谢谢大家，祝各位晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Envoy" scheme="https://qinyuanpei.github.io/tags/Envoy/"/>
    
      <category term="RESTful" scheme="https://qinyuanpei.github.io/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>再话AOP，从简化缓存操作说起</title>
    <link href="https://qinyuanpei.github.io/posts/2126762870/"/>
    <id>https://qinyuanpei.github.io/posts/2126762870/</id>
    <published>2021-08-04T20:49:47.000Z</published>
    <updated>2021-10-09T03:32:42.609Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>AOP，即：<strong>面向切面编程</strong>，关于这个概念，博主其实写过好几篇<a href="https://blog.yuanpei.me/tags/AOP/" target="_blank" rel="noopener">博客</a>啦！从这个概念，我们可以引申出诸如代理模式、动态代理、装饰器模式、过滤器、拦截器等等相互关联的概念。从实现方式上而言，微软官方的 <a href="https://docs.microsoft.com/zh-cn/previous-versions/dotnet/articles/ms973857(v=msdn.10)?redirectedfrom=MSDN" target="_blank" rel="noopener">.NET Remoting</a> 提供了真实代理和透明代理的支持，我们熟悉的 <code>WebService</code> 和 <code>WCF</code> 均和这项技术息息相关，作为最早的分布式 RPC 解决方案，其本身更是与客户端的动态代理密不可分。或许，各位曾经接触过 <code>Unity</code>、<code>Castle</code>、<code>AspectCore</code>、<a href="https://www.postsharp.net" target="_blank" rel="noopener">PostSharp</a> 等等这些支持 AOP 特性的库，那么，我们是否已经抵达了 AOP 的边界呢？事实上，如果你仔细研究过 <code>Stub</code> 和 <code>Mock</code> 这样两个术语，你就发现 AOP 的应用范围远比我们想象的宽广。今天这篇文章，我不打算再介绍一遍这些第三方库的“<strong>奇技淫巧</strong>”，我更想聊聊，如何通过 AOP 来简化一个缓存操作。</p><p>缓存，一个面试时命中率100%的话题，曾记否？来自面试官的灵魂发问三连：<strong>缓存击穿</strong>、<strong>缓存穿透</strong>、<strong>缓存雪崩</strong>。与此同时，缓存是一个令人爱恨交加的东西，其一致性、持久化、高可用等等，均是实际应用中需要去考虑的东西。狭义的缓存主要指 <a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>、<a href="https://www.memcached.org" target="_blank" rel="noopener">Memcached</a> 等分布式缓存系统，而广义的缓存则可以是 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/response?view=aspnetcore-5.0" target="_blank" rel="noopener">HTTP 响应缓存</a>、EF/EF Core 查询缓存、二级缓存等等。我们都知道，使用缓存可以显著地提升软件性能，而究其本质，则是因为减少了和数据库交互的频次。于是，我们注意到，大多数的缓存代码，都是下面这样的风格：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheKey = <span class="string">"GetAllStudents"</span>;</span><br><span class="line"><span class="keyword">var</span> students = <span class="keyword">new</span> List&lt;Student&gt;();</span><br><span class="line"><span class="keyword">var</span> cacheValue = distributedCache.GetString(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(cacheValue))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 未命中缓存：从数据库查询数据 + 写缓存</span></span><br><span class="line">    students = repository.GetAll().ToList();</span><br><span class="line">    <span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(students));</span><br><span class="line">    distributedCache.Set(cacheKey, bytes);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 命中缓存：读缓存</span></span><br><span class="line">    students = JsonConvert.DeserializeObject&lt;List&lt;Student&gt;&gt;(cacheValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> students;</span><br></pre></td></tr></table></figure><p>正所谓：大道至简，“<strong>高端的食材，往往只需要最朴素的烹饪方式</strong>”。故而，最朴素的思想就是，首先从缓存中查询数据，如果数据存在则直接返回，否则从数据库中查询数据，并执行一次写缓存操作。这的确是个朴实无华的方案，因为我们每一次都要写这样的代码，其程度丝毫不亚于永远不会缺席的 <code>xxx != null</code>。写到这里，博主不由得陷入了沉思：难道真的没有更简单点的方案了吗？后来的故事大家都知道了，我们可以在方法的参数上附加 <code>[NotNull]</code> 特性。所以，接下来，我们会用类似的方案来解决缓存的问题，换言之，我们可以把我们经常写、写到不愿意再写的代码交给代理类来做，既然缓存本质上是为了查询数据，那我们就只需要关心查询数据这个行为本身。具体怎么实现的呢？我们一起来看下面的代码。</p><p>此时此刻，假设我们有这样一个接口：<code>IFakeService</code>，它通过<code>GetColors()</code>方法返回一组颜色：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFakeService</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Cacheable(CacheKeyPrefix = <span class="meta-string">"Fake"</span>, Expiration = 180)</span>]</span><br><span class="line">    <span class="function">List&lt;<span class="keyword">string</span>&gt; <span class="title">GetColors</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望，在调用这个方法的时候，可以对其返回值进行缓存，所以，可以注意到，这里添加了一个<code>[Cacheable]</code>的特性。其定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CacheableAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> CacheKeyPrefix &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Expiration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>CacheKeyPrefix</code>用于指定缓存键名前缀，<code>Expiration</code>用于指定缓存过期时间，单位为秒。接下来，博主通过<code>DispatchProxy</code>来实现动态代理，它可以视为<code>RealProxy</code>在后.NET时代的替代品：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class CacheInterceptor&lt;TCacheService&gt; : DispatchProxy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> TCacheService _realObject =&gt; ServiceProvider.GetRequiredService&lt;TCacheService&gt;();</span><br><span class="line">    <span class="keyword">private</span> ICacheSerializer _cacheSerializer =&gt; ServiceProvider.GetRequiredService&lt;ICacheSerializer&gt;();</span><br><span class="line">    <span class="keyword">private</span> IDistributedCache _distributedCache =&gt; ServiceProvider.GetRequiredService&lt;IDistributedCache&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IServiceProvider ServiceProvider &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">object</span> <span class="title">Invoke</span>(<span class="params">MethodInfo targetMethod, <span class="keyword">object</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] cacheValue;</span><br><span class="line">        <span class="keyword">var</span> returnType = targetMethod.ReturnType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// void &amp;&amp; Task</span></span><br><span class="line">        <span class="keyword">if</span> (returnType == <span class="keyword">typeof</span>(<span class="keyword">void</span>) || returnType == <span class="keyword">typeof</span>(Task))</span><br><span class="line">            <span class="keyword">return</span> targetMethod.Invoke(_realObject, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">            returnType = targetMethod.ReturnType.GetGenericArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cacheableAttribute = targetMethod.GetCustomAttribute&lt;CacheableAttribute&gt;();</span><br><span class="line">        <span class="keyword">if</span> (cacheableAttribute != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> cacheKey = GetCacheKey(cacheableAttribute, targetMethod);</span><br><span class="line">            cacheValue = _distributedCache.Get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Task&lt;T&gt;</span></span><br><span class="line">                <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">                    <span class="keyword">return</span> Task.FromResult(_cacheSerializer.Deserialize(cacheValue, returnType));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _cacheSerializer.Deserialize(cacheValue, returnType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">dynamic</span> returnValue = targetMethod.Invoke(_realObject, args);</span><br><span class="line">            cacheValue = _cacheSerializer.Serialize(returnValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Task&lt;T&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">                cacheValue = _cacheSerializer.Serialize(returnValue.Result);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> cacheOptions = <span class="keyword">new</span> DistributedCacheEntryOptions() &#123; </span><br><span class="line">              AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(cacheableAttribute.Expiration) </span><br><span class="line">            &#125;;</span><br><span class="line">            _distributedCache.Set(cacheKey, cacheValue, cacheOptions);</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targetMethod.Invoke(_realObject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，最为关键的地方是<code>Invoke()</code>方法，它负责对被代理对象的方法进行拦截，这里的被代理对象，其实就是<code>_realObject</code>，即真实对象，因为，我们最终调用的，实际上是真实对象上对应的方法。因为<code>DispatchProxy</code>在创建代理对象时，要求这个代理基类，即这里的拦截器，必须要有一个无参的构造函数。所以，我们这里用属性注入的方式来注入<code>IServiceProvider</code>。说回这个方法，首先，我们会判断它的返回值类型是不是<code>void</code>或者<code>Task</code>，因为无返回值的方法本身就不需要缓存。接下来，我们会检查当前方法上是否附加了<code>[Cacheable]</code>特性，因为我们只需要处理有这个特性的方法。接下来，通过<code>GetCacheKey()</code>方法来生成一个唯一的键名，通过这个键名我们就可以在缓存中查询数据啦，该方法的实现细节如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">GetCacheKey</span>(<span class="params">CacheableAttribute cacheableAttribute, MethodInfo methodInfo</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> segments = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(cacheableAttribute.CacheKeyPrefix))</span><br><span class="line">        segments.Add(cacheableAttribute.CacheKeyPrefix);</span><br><span class="line"></span><br><span class="line">    segments.Add(methodInfo.DeclaringType.FullName.Replace(<span class="string">"."</span>, <span class="string">"_"</span>));</span><br><span class="line"></span><br><span class="line">    segments.Add(methodInfo.Name);</span><br><span class="line"></span><br><span class="line">    methodInfo.GetParameters().ToList().ForEach(x =&gt; segments.Add(x.Name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>.Join(<span class="string">"_"</span>, segments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于分布式缓存，博主这里使用的是微软提供的<code>IDistributedCache</code>这个接口，接下来的事情就变得朴实无华起来，因为它和我们一开始写的代码一脉相承，唯一的不同是，这里考虑了<code>Task&lt;T&gt;</code>这种异步的返回值类型，同时对序列化/反序列化进行了抽象，即这里注入的<code>ICacheSerializer</code>接口，注意到<code>IDistributedCache</code>接口的<code>Set()</code>方法需要传入一个<code>byte[]</code>，显然二进制的序列化方案如 <a href="https://developers.google.cn/protocol-buffers?hl=zh-cn" target="_blank" rel="noopener">Protobuf</a> 、<a href="https://msgpack.org/" target="_blank" rel="noopener">MessagePack</a> 会更加得心应手一点。所以，我们将这一层单独抽象出来。至此，我们已经完成了最核心的部分。</p><p>对于一开始的<code>IFakeService</code>，我们提供一个简单的实现，并通过让线程阻塞的方式来模拟一个耗时操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeService</span> : <span class="title">IFakeService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">string</span>&gt; <span class="title">GetColors</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Green"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入IFakeService、ICacheSerializer、IDistributedCache</span></span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddTransient&lt;IFakeService, FakeService&gt;();</span><br><span class="line">services.AddTransient&lt;ICacheSerializer, JsonCacheSerializer&gt;();</span><br><span class="line">services.AddStackExchangeRedisCache(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Configuration = <span class="string">"localhost:6379"</span>;</span><br><span class="line">    options.InstanceName = <span class="string">"Caching.AOP.Test"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成代理对象</span></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> fakeServiceProxy = DispatchProxy.Create&lt;IFakeService, CacheInterceptor&lt;IFakeService&gt;&gt;();</span><br><span class="line">(fakeServiceProxy <span class="keyword">as</span> CacheInterceptor&lt;IFakeService&gt;).ServiceProvider = serviceProvider;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代理对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> stopWatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">    stopWatch.Start();</span><br><span class="line">    <span class="keyword">var</span> colors = fakeServiceProxy.GetColors();</span><br><span class="line">    stopWatch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">$" <span class="subst">&#123;i&#125;</span> - Invoke GetColors used <span class="subst">&#123;stopWatch.Elapsed.TotalMilliseconds&#125;</span> ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果，可以注意到，第一次调用的时候，因为缓存不存在，调用的时间相对更长一点，而当缓存存在的时候，调用的时间会明显缩短。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/04/FdafGyS7zrl53W1.png" alt="有无缓存对调用时长的影响" referrerpolicy="no-referrer"></div><div class="image-caption">有无缓存对调用时长的影响</div></figure><p>虽然这个性能提升与缓存不无关系，可对于调用者来说，它完全不用关心缓存里有没有数据这件事情，它只需要像往常一样调用接口方法即可，这就是 AOP 之于缓存的意义所在，为了证明我没有说谎，我们可以看到 Redis 中对应的数据：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/04/wkAQGMRKr8xuol3.png" alt="Redis中对应的缓存数据" referrerpolicy="no-referrer"></div><div class="image-caption">Redis中对应的缓存数据</div></figure><p>需要说明的是，这个思路同样可以扩展到<code>Unity</code>、<code>Castle</code>、<code>AspectCore</code>、<a href="https://www.postsharp.net" target="_blank" rel="noopener">PostSharp</a> 这些第三方库，实现方式上大同小异，大家可以结合自己的业务场景做相应的调整。其实，从业务上抽离出通用组件、功能作为公共库或者下沉到框架中，是及其自然而然的一件事情。这里面最关键的问题是，基础组件或者框架相对于业务方的职责范围，因为如果基础组件或者框架做得太多，业务上往往难以定制或者扩展；而如果基础组件或者框架做得太少，业务上就要写大量的辅助代码。写这篇文章的原因是，我对于一个缓存方案设计上的疑问，业务上想要缓存一张表中的数据，至少需要写 20 行代码，在下觉得这简直太离谱了，更不用说，业务方还要关心这个缓存是否可用。有人说，一个合格的前任就应该像死了一样，那么，我是不是可以说，一个合格的中间件，就应该像它从来没有来过一样，你甚至都感觉不到它的存在，可事实上它总是无所不在。也许，这听起来有点科幻的色彩，可这的确是我期待的某种自洽的、优雅的设计思路。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分享了通过 AOP 来简化缓存操作的一种思路，考虑到常规的缓存代码写法，读/写缓存与业务代码严重耦合在一起，而博主心目中的缓存应该像水、电、煤气一样普普通通，你只需要告诉我哪些数据需要缓存，而无需关心这些数据怎么缓存。基于这样一种考虑，博主基于<code>DispatchProxy</code>实现了一个针对缓存的 AOP 方案，我们只需要在接口上打上<code>[Cachable]</code>标签，它会自动对方法的返回值进行缓存，从而简化我们平时使用缓存的流程。<a href="https://www.cnblogs.com/catcher1994" target="_blank" rel="noopener">Catcher Wong</a> 大佬在其缓存框架 <a href="https://www.cnblogs.com/catcher1994/p/10806607.html" target="_blank" rel="noopener">EasyCaching</a> 同样集成了这一特性，如果大家有类似的使用场景，可以直接使用这个<a href="https://github.com/dotnetcore/EasyCaching" target="_blank" rel="noopener">框架</a>。如果大家对此有更好的想法或者思路，欢迎大家在评论区留言，本文示例已上传至 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/Caching.AOP" target="_blank" rel="noopener">Github</a>，供大家学习或者参考。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="AOP" scheme="https://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="Redis" scheme="https://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="https://qinyuanpei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="动态代理" scheme="https://qinyuanpei.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>洗衣随想曲</title>
    <link href="https://qinyuanpei.github.io/posts/3938682696/"/>
    <id>https://qinyuanpei.github.io/posts/3938682696/</id>
    <published>2021-08-02T00:13:48.000Z</published>
    <updated>2021-10-09T03:32:42.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>对我而言，洗衣服是周末的例行活动，尤其是在炎热的夏天。也许，你会自顾自地说，衣服不必攒到周末去洗，如果你愿意下班后腾出一点时间。可人的惰性，正如在太阳底下会流汗一般寻常，如果我愿意，你也许会早一点看到，这些只在周末显得安静的文字。</p><p>换这部手机时，店家附赠了一只蓝牙音响，带着物尽其用的想法，先后用它来听网易云、听微信读书、听TED。于是，在一刹那间，水龙头里的流水声、拧干衣服时的水花声、我脑海里的闪念的低吟声，都成为这只麦克风的伴奏。我开始黯然失色，这听来听去，大概是在听寂寞在唱歌。果然，微信听书的效果并不好，那机械而平静的合成音，甚至还不如地铁上的播报充满感情。最为致命的问题，微信听书像极了听老师讲课：书读完了吗？读完了！还记得讲了什么吗？完全不记得！</p><p>现实生活可不像武侠世界，没有那么多无招胜有招的奇遇。所以，有一段时间，我总觉得用听书这种方式来读书，像极了姜太公钓鱼——愿者上钩。五柳先生，好读书而不求甚解，因为观其大略，而这连看都不愿意看一眼，简直就是自欺欺人。如此反复折磨自我，发现听演讲居然是最适合打发时间的方式，特别是洗衣服的这段时间。仔细一想，大概是演讲更能做到声情并茂，古人一桌、一椅、一扇、一抚尺，就能讲一个沉浸感十足的故事。而我们从文字到图片再到视频，仿佛都不足以表达自我。在百家争鸣的战国时代，不管是合纵/连横的策略，还是法、儒、墨、兵各家，我们能听见不同的声音，虽然表达方式不过是竹简。</p><p>可今天，我们好像陷入了一个信息黑洞，网络上的信息越来越嘈杂，原本代表着开放与连接的互联网，在一个又一个的小圈子里，正在走向越来越封闭的局面。譬如，喝茶与喝咖啡，从生物学上来讲这两个行为间并无差异，可人与人之间就是会形成所谓的鄙视链，甚至连咖啡本身都会形成这种鄙视链，手冲和速溶，本质上有什么不一样吗？圈子文化的盛行，让圈子本身更加封闭，隐形门槛的提高，让圈子外的人更加不能理解圈内人的行为，比如汉服与JK，本质上不就是一件衣服吗？可人定要分出个山(寨)与正(品)的差别。人与人的关系，大致可以理解为相互炫耀、相互鄙视，而不同群体间的互相鄙视，其实加速了整个互联网的割裂，男女对立、饭圈文化……，无一不是这种割裂感的具体产物。</p><p>鲁迅先生写道，“<strong>人类的悲欢并不相通，我只是觉得他们吵闹</strong>”。人类想要互相理解彼此，除了感同身受以外，大概只有放下强烈的个人意识这一条路。可做一个精致的利己主义者，又有什么不好吗？只要我们不因为远方的声音让这个世界频频陷入大火，自私一点又有什么关系呢？罗曼蒂克不会消亡，只是我们对罗曼蒂克的要求变得越来越高。翻开历史，人类几千年的文明，一样是在这种割裂和封闭的状态下延续着，梁武帝从信佛到灭佛，汉武帝罢黜百家独尊儒术，商鞅因法而兴由法而灭……儒家与道家尚不能共治，巴基斯坦和印度更是势如水火……人们推倒了篱墙，再重新筑起篱墙，周而复始，反反复复。我由衷地想念那个百家争鸣的时代，人们有耻食周栗的觉悟、有伯牙绝弦的深情、有横槊赋诗的豪情……古人寿命不及我们、生活不如我们，可这几千年的精神世界，都是他们留给我们的。</p><p>不同于被生活磨去棱角的年轻人，一开口就是房子、车子和孩子。要知道，子在过去可是一种敬词，孔孟不必多说，老庄无须多言，前有张子连横六国，后有苏子遨游赤壁，这是否意味着，古人的精神世界远比我们丰富，毕竟我们都太枯燥了。有时候，我在地铁上看到别人面无表情地刷着抖音，如果说圈子本身让我们变得狭隘，那么信息茧房无疑会让我们变得愚蠢。你说，这个地球是不是变得越来越小，可明明我们还没有走过所有地方，不曾见过亚马逊的热带雨林，不曾见过极地的奇幻光影，不曾见过东非的荒漠草原……我们实在太容易相信那就是全部了，因为别人都这样过每一天，因为随大流不需要花时间思考什么，因为只此一次的生命实在过于短暂……越来越觉得，结婚就是用高昂的沉没成本，来阻止人们试错，每一步都走得小心翼翼的人，步步生莲，莲是三寸金莲的莲，虽然我们有耐克、有鸿星尔克、有美特斯邦威。</p><p>我喜欢逛西安这座城市的书店，因为传统书店愈发没落的今天，它需要找到一种物质和精神上的平衡，可人何尝又不是这样？每当我漫步在不同的商场，我忽然觉得，我们只是以为自己有那么多的选择，越来越多的餐饮像是流水线一般，我们寻找的那份属于自己的独特，早已在机器的转动声中消失殆尽。于是，人们开始复兴手工制作，越来越多的商家，开始在招牌上加上手工的字样。也许，现代和传统就是这样两个相互鄙视的圈子，它们互相鄙视，而又反复横跳。其实，单以甜点而论，我更喜欢中式的点心，大概是因为那些西式点心的名称，说起来要更绕口一点。泡芙、圣代、提拉米苏……像极了你学英语时的样子，每一个单词都认识，放到一起简直不知所云。以前，我在挑选饮料方面选择困难，因为总是记不住那些眼花缭乱的名字，后来手机里装了大众点评，忽然发现，每家商场里的店铺都差不多呢，这大概是一种进步，因为你没有选择。</p><p>当年我有一位高中同学，特别喜欢郭德纲的相声，报菜名、说绕口令的技艺相当纯熟，毕业后留在苏州的学而思，据说是变成了一名老师。近来教育培训行业政策有变动，不知道他是否还有心情饶舌一番。说回听书这件小事，那时，听一位作家讲金庸先生的越女剑，联想到武侠的没落，大概有几分道理可言。为什么漫威的超级英雄在这个时代更受欢迎，因为超级英雄们获得能的方式更现代化一点，无论是神话、科技、变异，这都是我们这个时代可以理解的东西，所以，我们能接受通过蛛丝发射器飞檐走壁的蜘蛛侠，唯独接受不了同样靠轻功飞檐走壁的大侠们。因为，没有人能说得清武功的来源。在一个武术成为观赏性项目的时代，我们对武功的理解，不会比神话时代好多少，我们都听过卧薪尝胆的故事，听过博浪飞锥的故事，听过图穷匕首的故事……如果世上真的有武功，大概就像我们认为的战争，对于没有亲身经历的人而言，永远都只能活在想象里，那么，武侠的起源到底从哪里开始呢？</p><p>在B站看到30多年前的西安，隐隐约约可以认出永宁门、大雁塔和钟楼，弹幕里有人打出无人机的字眼，原来，航拍这个词的含义已经等同于无人机，不管那个时候有没有无人机。同样地，现在的小孩会问，怎么通过座机打电话，我会不由得想起初/高中住校那几年，和家里联络基本都是靠座机。后来，我们有了直板手机、智能手机，再不必担心两百条短信会用完，再不必掐着时间给家里打电话，可再没有那样愿意陪你发短信的人，一个月下来甚至都打不了几个电话，流量从5块钱30兆一直涨到几十块钱，可对我来说，无非还是写写字、读读书，和过去相比并没有什么不同。人啊，总有些东西，在默默提醒着你：你在一天天地老去，永远都18岁，那比科幻电影还要科幻，除非你能从卷福手里拿到时间宝石。如果回到过去，你会如何和过去的自己谈判呢？我只知道，金庸先生穿越回吴越争霸的时代，他让阿青从白猿身上学到了武功。越王勾践卧薪尝胆、三千越甲吞吴的故事，父亲从小就同我讲过，可他也许不知道金庸先生的这个版本。</p><p>阿青被范蠡带入宫中，传授越国剑士精妙剑法，自此帮助越王勾践打败吴国、洗雪前耻，范蠡得以与情人西施重逢，可偏偏阿青喜欢上来了范蠡，没有人能阻挡阿青手中的竹棒，除了西施绝世的容貌，原来她比范蠡描述的还要美。虽然阿青放弃了寻仇，可棒头的内劲儿还是伤到了西施，自此西施落下来心口疼痛的毛病。这大概就是金庸先生心目中武功的缘起，范蠡西施放舟太湖、悠游终生，自此世上有了江湖，果然，这个说法像雷神之锤一样相当有说服力，“那些都是很好很好的，可是我偏偏不喜欢”，某种意义上来讲，功成身退的范蠡比张仪、韩信、商鞅要幸运得多，而这正是历史的迷人之处。什么？你问我衣服洗完了没有？当然洗完了！因为这些闪念，对于一个双子座而言，就像穿衣吃饭一般寻常，唯一的困难在于，我要将它写出来、同时让你看懂，以上！果然是标准的日式结尾呢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://qinyuanpei.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="https://qinyuanpei.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core 搭载 Envoy 实现微服务身份认证(JWT)</title>
    <link href="https://qinyuanpei.github.io/posts/731808750/"/>
    <id>https://qinyuanpei.github.io/posts/731808750/</id>
    <published>2021-07-25T09:41:24.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在构建以 gRPC 为核心的微服务架构的过程中，得益于 Envoy 对 gRPC 的“<strong>一等公民</strong>”支持，我们可以在过滤器中对 gRPC 服务进行转码，进而可以像调用 Web API 一样去调用一个 gRPC 服务。通常情况下， RPC 会作为微服务间内部通信的信使，例如，Dubbo、Thrift、gRPC、WCF 等等更多是应用在对内通信上。所以，一旦我们通过 Envoy 将这些 gRPC 服务暴露出来，其性质就会从对内通信变为对外通信。我们知道，对内和对外的接口，无论是安全性还是规范性，都有着相当大的区别。博主从前的公司，对内的 WCF 接口，长年处于一种”<strong>裸奔</strong>“的状态，属于没有授权、没有认证、没有文档的“<strong>三无产品</strong>”。那么，当一个 gRPC 服务通过 Envoy 暴露出来以后，我们如何保证接口的安全性呢？这就是今天这篇博客的主题，即 Envoy 作为网关如何提供身份认证功能，在这里，我们特指通过JWT，即 Json Web Token 来对接口调用方进行身份认证。</p><h1 id="搭建-Keycloak"><a href="#搭建-Keycloak" class="headerlink" title="搭建 Keycloak"></a>搭建 Keycloak</h1><p>对于 <a href="https://jwt.io" target="_blank" rel="noopener">JWT</a> ，即 Json Web Token ，我想大家应该都非常熟悉了，它是目前最流行的跨域认证解决方案。考虑到，传统的 Session 机制，在面对集群环境时，扩展性方面表现不佳。在日益服务化、集群化的今天，这种无状态的、轻量级的认证方案，自然越来越受到人们的青睐。在 ASP.NET Core 中整合JWT非常简单，因为有各种第三方库可以帮助你生成令牌，你唯一需要做的就是配置授权/认证中间件，它可以帮你完成令牌校验这个环节的工作。除此以外，你还可以选择更重量级的 <a href="https://identityserver4.readthedocs.io/en/latest/" target="_blank" rel="noopener">Identity Server 4</a>，它提供了更加完整的身份认证解决方案。在今天这篇博客里，我们使用的 <a href="https://www.keycloak.org" target="_blank" rel="noopener">Keycloak</a>，一个类似 Identity Server 4 的产品，它提供了一个更加友好的用户界面，可以更加方便的管理诸如客户端、用户、角色等等信息。其实，如果从头开始写不是不可以，可惜博主一时间无法实现 <a href="https://auth0.com/docs/tokens/json-web-tokens/json-web-key-sets" target="_blank" rel="noopener">JWKS</a>，所以，就请大家原谅在下拾人牙慧，关于 JWKS ，我们会在下一节进行揭晓。接触微服务以来，在做技术选型时，博主的一个关注点是，这个方案是否支持容器化。所以，在这一点上，显然是 Keycloak 略胜一筹，为了安装 Ketcloak ，我们准备了如下的服务编排文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">keycloak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/keycloak/keycloak:14.0.0</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KEYCLOAK_USER:</span> <span class="string">$&#123;KEYCLOAK_USER&#125;</span></span><br><span class="line">      <span class="attr">KEYCLOAK_PASSWORD:</span> <span class="string">$&#123;KEYCLOAK_PASS&#125;</span></span><br><span class="line">      <span class="attr">DB_VENDOR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_ADDR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_DATABASE:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">DB_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"7070:8080"</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br></pre></td></tr></table></figure><p>其中，<code>.env</code>文件放置了服务编排文件中使用到的环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># KEYCLOAK</span><br><span class="line">KEYCLOAK_USER&#x3D;admin</span><br><span class="line">KEYCLOAK_PASS&#x3D;admin</span><br><span class="line"># POSTGRESQL</span><br><span class="line">POSTGRESQL_DB&#x3D;keycloak</span><br><span class="line">POSTGRESQL_USER&#x3D;keycloak</span><br><span class="line">POSTGRESQL_PASS&#x3D;keycloak</span><br></pre></td></tr></table></figure><p>此时，我们运行<code>docker compose up</code>命令就可以得到一个 Keycloak 环境，它将作为我们整个微服务里的认证中心，负责对用户、角色、权限、客户端等进行管理。于此同时，接口消费方可以通过 Keycloak 获取令牌、JWKS，而 Envoy 正是利用 JWKS 来对令牌进行校验的。这个 JWKS 到底是何方神圣，我们暂且按下不表。在正式使用 Keycloak 前，我们需要做一点简单的配置工作，具体来说，就是指创建用户、角色和客户端，我们一起来看一下。</p><p>首先，是创建一个用户，这里以《天龙八部》中壮志未酬的“<strong>慕容龙城</strong>”为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/U9Pm3HFLn1y6dYB.png" alt="Keycloak 创建用户" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 创建用户</div></figure><p>《天龙八部》中提到，“<strong>慕容龙城</strong>”一心想光复大燕，可惜时不我与，正好遇上宋太祖建立宋朝，即使他创造出“<strong>斗转星移</strong>”的武功绝学，依然免不了郁郁而终的结局。慕容龙城算是第一代创业者，我们准备一个<code>Developer</code>的角色：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/H8xy3BYDz1XmWf9.png" alt="Keycloak 创建角色" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 创建角色</div></figure><p>在权限系统的设计中，角色总是需要和用户关联在一起。同样地，在 Keycloak 中，我们需要给“<strong>慕容龙城</strong>”分配一个<code>Developer</code>的角色：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/ZDui9X3weq5NMs8.png" alt="Keycloak 分配角色" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 分配角色</div></figure><p>到了“<strong>慕容复</strong>”这一代，“<strong>慕容垂</strong>”假借死亡之名秘密活动，而活跃在台前的“<strong>慕容复</strong>”，实际上是作为慕容家族的“<strong>代理人</strong>”出现。在今天这篇文章中，Envoy 会充当认证服务的代理，因为我们希望 Envoy 可以对所有进站的 API 请求进行统一的认证。所以，这里，我们还需要创建一个客户端：<code>envoy-client</code>，并为其分配客户端角色：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/MJC3dVkE7UxopyO.png" alt="Keycloak 创建客户端" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 创建客户端</div></figure><p>OK，我们都知道，<a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0</a> 有这样四种认证方式：密码模式、客户端模式、简化模式、授权码模式。这四种认证方式如何在 Keycloak 中实现呢？目前，博主基本搞清楚了前面两种。我们在创建完客户端以后，可以通过设置访问类型来决定客户端使用哪种认证方式，目前已知，当访问类型的取值为<code>public</code>时，表示密码模式。当访问类型的取值为<code>confidential</code>时，表示客户端模式。这里，我们以客户端模式为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/le5rstobVOh91m3.png" alt="Keycloak 客户端模式" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 客户端模式</div></figure><p>此时，我们就可以拿到一个重要的信息：<code>client_secret</code>，如果大家使用过客户端模式，就会知道它是获取令牌的重要参数之一。好了，当我们有了这些信息以后，该怎么样去获取令牌呢？我们只需要用 POST 的方式，将<code>grant_type</code>、<code>client_id</code>、<code>client_secret</code>、<code>username</code>、<code>password</code>、<code>scope</code>传过去即可：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/S5rgmZaGEqQkHUK.png" alt="从 Keycloak 获取令牌" referrerpolicy="no-referrer"></div><div class="image-caption">从 Keycloak 获取令牌</div></figure><p>如果需要刷新令牌，则只需要再追加一个<code>refresh_token</code>参数即可，它是我们第一次获取到的令牌：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/ukdNami5yMERWDc.png" alt="从 Keycloak 刷新令牌" referrerpolicy="no-referrer"></div><div class="image-caption">从 Keycloak 刷新令牌</div></figure><p>可能大家会疑惑，博主是从哪里知道这些 API 的端点地址的呢？其实，和 Identity Server 4 类似， Keycloak 提供了一个用于服务发现的接口地址：<code>/auth/realms/master/.well-known/openid-configuration</code>，通过这个接口地址，我们可以获得一份 API 列表：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/bDYNASUw23qLyml.png" alt="Keycloak 提供的 “服务发现” 能力" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 提供的 “服务发现” 能力</div></figure><p>可以注意到，图中有我们需要的换取令牌的接口，以及提供 JWKS 的接口：<code>/auth/realms/master/protocol/openid-connect/certs&quot;</code>，尤其第二点，它对于对我们进行下一个步骤意义重大，Envoy 能不能承担起微服务认证的重担，就看它的啦，至此， Keycloak 的搭建工作已经完成。</p><h1 id="配置-Envoy"><a href="#配置-Envoy" class="headerlink" title="配置 Envoy"></a>配置 Envoy</h1><p>在上一节内容中，博主卖了一个关子，说要等到这一节再说 JWKS 是何方神圣？不过，博主以为，“<strong>饭要一口一口吃，步子迈太大，咔，容易扯着蛋</strong>”，我们还是先来说说 JWT ，因为只要你了解了它的结构，你才能了解如何去检验一个令牌。我们说，JWT，是 JSON Web Token 的简称，那这个 JSON 到底体现在哪里呢？而这要从 JWT 的结构开始说起。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/Tdag82VsSGJxD9u.png" alt="JSON Web Token 结构说明图" referrerpolicy="no-referrer"></div><div class="image-caption">JSON Web Token 结构说明图</div></figure><p>这是一张来自 <a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a> 官网的截图，博主认为，这张图非常清晰地展示出了 JWT 的加密过程，我们熟悉的这个令牌，其实是由<code>header</code>、<code>payload</code>和<code>signature</code>三个部分组成，其基本格式为：<code>header.payload.signature</code>，细心的朋友会发现，图中生成的令牌中含有两个<code>.</code>。其中，<code>header</code>部分是一个 JSON 对象，表示类型(<strong>typ</strong>)及加密算法(<strong>alg</strong>)，常见的加密算法主要有 HMAC、RSA、ECDSA 三个系列。<code>payload</code>部分同样是一个 JSON 对象，主要用来存放实际需要传递的数据。目前，JWT 官方规定了以下7个备选字段：</p><ul><li>iss，即 issuer，表示：令牌签发人</li><li>exp，即 expiration time，表示：令牌过期时间</li><li>sub，即 subject，表示：令牌主题</li><li>aud，即 audience，表示：令牌受众</li><li>nbf，即 Not Before，表示：令牌生效时间</li><li>iat，即 Issued At，表示：令牌签发时间</li><li>jti，即 JWT ID，表示：令牌编号</li></ul><p>需要注意的是，<code>header</code>和<code>payload</code>这两部分，默认是不加密的，这意味着任何人都可以读到这里的信息，所以，一个重要的原则是，不要在<code>payload</code>中存放重要的、敏感的信息。无论是<code>header</code>还是<code>payload</code>，最终都需要通过 <a href="https://www.base64url.com/" target="_blank" rel="noopener">Base64URL</a> 算法将其转化为普通的字符串，该算法和 <a href="https://www.sojson.com/base64.html" target="_blank" rel="noopener">Base64</a> 算法类似，唯一的不同点在于它会对<code>+</code>、<code>/</code> 和 <code>=</code> 这三个符号进行替换，因为这三个符号在网址中有着特殊的含义。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/zDx765FpRMaP8mK.png" alt="Base64 & Base64URL 算法对比" referrerpolicy="no-referrer"></div><div class="image-caption">Base64 & Base64URL 算法对比</div></figure><p>第三部分，<code>signature</code>，即通常意义上的签名，主要是防止数据篡改。对于 HMAC 系列的加密算法，需要指定一个密钥，以 HMACSHA256 算法为例，其签名函数为：<code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code>。对于 RSA 和 ECDSA 这两个系列的加密算法，需要指定公钥和私钥，以 ECDSASHA512 算法为例，其签名函数为：<code>ECDSASHA512(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), PublicKey, PrivateKey)</code>。一旦计算出签名，就可以将这三部分合成一个令牌，而这就是 JWT 的产生原理，而如果我们对第一节中获得的令牌进行解密，我们就会得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/mpVo8vasYWL4gPN.png" alt="解密 Keycloak 生成的令牌" referrerpolicy="no-referrer"></div><div class="image-caption">解密 Keycloak 生成的令牌</div></figure><p>所以，JSON Web Token 中的 JSON，其实是指 <code>header</code> 和 <code>payload</code> 这两个 JSON 对象，并且我们可以注意到，Keycloak 中生成的令牌实际上携带了更多的信息，例如，客户端、IP 地址、<code>realm_access</code> 以及 <code>resource_access</code>等等，所以。 JWT 其实是一个相对宽松的规范，在实现<code>payload</code>这部分时，可以结合实际场景做更多的扩展，唯一的要求还是那句话，不要在<code>payload</code>中存放重要的、敏感的信息。至此，我们讲清楚了 JWT 的底层原理。</p><p>OK，解释清楚了 JWT，我们再来说 JWKS，这位又是何方神圣呢？我们提到，JWT 至少需要一个密钥或者一对公/私钥来进行签名的校验，因为对于<code>header</code>和<code>payload</code>这两个部分而言，它的加密算法始终都是 Base64URL，所以，我们总是可以反推出原始的 JSON 字符串。接下来，我们只需要按签名函数计算签名即可，对于 HMAC 系列的加密算法，需要指定一个密钥；对于 RSA 和 ECDSA 这两个系列的加密算法，需要指定公钥和私钥。由此，我们就可以计算出一个签名，此时，我们只需要比较两个签名是否一致即可。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/N6ybGazKBUSfE2H.png" alt="JWT 校验过程示意图" referrerpolicy="no-referrer"></div><div class="image-caption">JWT 校验过程示意图</div></figure><p>通过 JWKS 的 <a href="https://auth0.com/docs/tokens/json-web-tokens/json-web-key-sets" target="_blank" rel="noopener">官网</a>，我们可以了解到一件事情，那就是 JWKS 本质上是 Json Web Key Set 的简称，顾名思义，这是一组可以校验任意 JWT 的公钥，并且这些 JWT 必须是通过 RS256 算法进行签名的，RS256 则是我们上面这张图里的 RSA 非对唱加密算法，它需要一个公钥和一个私钥，通常强况下，私钥用来生成签名，公钥用来校验签名。这个 JWKS 呢？同样是一个 JSON 对象，它只有一个属性<code>keys</code>，以 Keycloak 中获得的 JWKS 为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/24/lQrXThYCvk9RPLm.png" alt="Keycloak 产生的 JWKS" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 产生的 JWKS</div></figure><p>关于 JWKS 的规范，大家可以通过 <a href="https://datatracker.ietf.org/doc/html/rfc7517" target="_blank" rel="noopener">RFC7515</a> 来了解，作为一种通用的规范，Identity Server 4 和 Keycloak 都实现了这一规范，所以，就今天这篇博客而言，不管是哪一种方案，它都可以和 Envoy 配合得天衣无缝。为什么这样说呢？因为我们在 Envoy 中实现 JWT 认证，其核心还是 JWKS 这一套规范。博主没有选择从头开始实现这一切，就在于这个 JWKS 有特别多的细节。总之，我们只需要知道，通过 JWKS 可以对一个令牌进行验证，而 Envoy 刚好有这样一个过滤器，下面是 Envoy 中对应的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http_filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.jwt_authn</span></span><br><span class="line">    <span class="attr">typed_config:</span></span><br><span class="line">      <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication</span></span><br><span class="line">      <span class="attr">providers:</span></span><br><span class="line">        <span class="attr">jwt_provider:</span></span><br><span class="line">          <span class="attr">issuer:</span> <span class="string">"http://192.168.50.162:7070/auth/realms/master"</span></span><br><span class="line">          <span class="attr">audiences:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"account"</span></span><br><span class="line">          <span class="attr">forward:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">remote_jwks:</span></span><br><span class="line">            <span class="attr">http_uri:</span></span><br><span class="line">              <span class="attr">uri:</span> <span class="string">"http://192.168.50.162:7070/auth/realms/master/protocol/openid-connect/certs"</span></span><br><span class="line">              <span class="attr">cluster:</span> <span class="string">keycloak</span></span><br><span class="line">              <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">prefix:</span> <span class="string">"/api/w"</span></span><br><span class="line">          <span class="attr">requires:</span></span><br><span class="line">            <span class="attr">provider_name:</span> <span class="string">jwt_provider</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">prefix:</span> <span class="string">"/api/c"</span></span><br><span class="line">          <span class="attr">requires:</span></span><br><span class="line">            <span class="attr">provider_name:</span> <span class="string">jwt_provider</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure><p>可以注意到，我们这里配置了一个叫做<code>envoy.filters.http.jwt_authn</code>的过滤器，并为这个过滤器指定了一个叫做<code>jwt_provider</code>的认证提供者，其中的<code>issuer</code>和<code>audiences</code>，我们在讲解 JWT 结构的时候提到过，最为关键的是<code>remote_jwks</code>，我们通过 Keycloak 的服务发现功能，可以获得这个地址，我们将其配置到 Envoy 中即可，Envoy 可以通过它来验证一个 JWT 的令牌，而下面的规则，表示哪些路由需要认证，这里我们假设需要对<code>/api/w</code>和<code>/api/c</code>这两个端点进行认证。所以，可以预见的是，我们可以为整个网关配置统一的认证流程，无论我们有多少个微服务。以往我们都是通过 ASP.NET Core 里的过滤器来实现应用级的认证服务，而此时此刻，我们有了容器级别的认证服务，基础设施从框架提升到了容器层面。除此以外，我们还需要为 Envoy 定义一个集群，这样读取远程 JWKS 的请求才会被正确地转发过去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">keycloak</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">keycloak</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.50</span><span class="number">.162</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">7070</span></span><br></pre></td></tr></table></figure><p>如此，整个认证服务相关的基础设施均已准备就绪，所谓“万事俱备，只欠东风”，我们还需要定义资源 API 供调用者消费，所以，接下来，我们来看看 API 如何编写。</p><h1 id="编写-API"><a href="#编写-API" class="headerlink" title="编写 API"></a>编写 API</h1><p>编写 API 非常简单，我们直接用 ASP.NET Core 创建两个项目即可，这里是两个服务：<code>CityService</code> 和 <code>WeatherService</code>。</p><p>首先，是 <code>CityService</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CityController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] Cities = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"中卫"</span>, <span class="string">"西安"</span>, <span class="string">"苏州"</span>, <span class="string">"安庆"</span>, <span class="string">"洛阳"</span>, <span class="string">"银川"</span>, <span class="string">"兰州"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;CityController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CityController</span>(<span class="params">ILogger&lt;CityController&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">var</span> rnd = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">var</span> city =  Cities[rnd.Next(Cities.Length)];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> &#123; City = city, Now = DateTime.Now &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，是 <code>WeatherService</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"Freezing"</span>, <span class="string">"Bracing"</span>, <span class="string">"Chilly"</span>, <span class="string">"Cool"</span>, <span class="string">"Mild"</span>, <span class="string">"Warm"</span>, <span class="string">"Balmy"</span>, <span class="string">"Hot"</span>, <span class="string">"Sweltering"</span>, <span class="string">"Scorching"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WeatherController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherController</span>(<span class="params">ILogger&lt;WeatherController&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">var</span> rng = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">      &#123;</span><br><span class="line">        Date = DateTime.Now.AddDays(index),</span><br><span class="line">        TemperatureC = rng.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">        Summary = Summaries[rng.Next(Summaries.Length)]</span><br><span class="line">      &#125;)</span><br><span class="line">      .ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这两个服务如何实现容器化、反向代理等等的细节，大家可以参考博主前面几篇文章，本文示例已托管到 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyJwt" target="_blank" rel="noopener">Github</a>，供大家做进一步的参考。</p><h1 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h1><p>这段时间最大的收获便是，学会了通过<code>docker-compose</code>对服务进行编排，虽然目前还有点悬而未决的东西，可一旦接触了这种略显“<strong>高端</strong>”的技巧，便再不愿回到刀耕火种、敲命令行维护<code>docker</code>环境的时代。等有时间了，博主会考虑写一点<code>docker</code>或者<code>docker-compose</code>使用技巧的文章，当然这些都是以后的事情啦！我们要活在当下啊，还是看看这个<code>docker-compose.yaml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoy_gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"6060:9090"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"6061:9091"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span><span class="string">![Envoy-Jwt-Keycloak-16.png](https://i.loli.net/2021/07/24/rCcUBWDyJVtOxkd.png)</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br><span class="line">  <span class="attr">weather_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8082:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br><span class="line">  <span class="attr">keycloak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/keycloak/keycloak:14.0.0</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KEYCLOAK_USER:</span> <span class="string">$&#123;KEYCLOAK_USER&#125;</span></span><br><span class="line">      <span class="attr">KEYCLOAK_PASSWORD:</span> <span class="string">$&#123;KEYCLOAK_PASS&#125;</span></span><br><span class="line">      <span class="attr">DB_VENDOR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_ADDR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_DATABASE:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">DB_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"7070:8080"</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br></pre></td></tr></table></figure><p>等所有的服务都启动起来以后，我们来验证下这个网关，是不是真的像我们期待的那样。注意到，Envoy 对外暴露出来的端口是<code>6060</code>，这里我们以<code>CItyService</code>为例：</p><p>首先，是不带令牌直接访问接口，我们发现接口返回了<code>401</code>状态码，并提示：<strong>Jwt is missing</strong>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/24/Bg5r8dAIbEp4eFy.png" alt="不携带令牌，Envoy 认证失败" referrerpolicy="no-referrer"></div><div class="image-caption">不携带令牌，Envoy 认证失败</div></figure><p>我们带上令牌会怎么样呢？可以注意到，接口成功地返回了数据，这表示我们的目的达到了，这些经由 Envoy 代理的 API 接口，今后都必须携带令牌进行访问：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/24/rCcUBWDyJVtOxkd.png" alt="携带令牌，Envoy 返回数据" referrerpolicy="no-referrer"></div><div class="image-caption">携带令牌，Envoy 返回数据</div></figure><p>因为 Keycloak 这个认证中心是独立于我们的应用单独存在的，所以，我们可以直接在 Keycloak 中设置令牌的过期时间、为用户分配角色、为不同的资源设置范围等等，而这一切都不需要应用程序或者 Envoy 做任何调整，开发者只需要认真地写好每一个后端服务即可，这是否就是传说中的基础设施即服务呢？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要分享了如何利用 Envoy 实现容器级别的 JWT 认证服务，在实现过程中，我们分别了解了 JWT 和 JWKS 这两个概念。其中，JWT 即JSON Web Token，是目前最为流行的跨域认证方案，一个 JWT 通常由 <code>header</code>、<code>payload</code> 和 <code>signature</code> 三个部分组成，JWT 的 JSON 主要体现在<code>header</code>和<code>payload</code>这两个 JSON 对象上，通过 Base64Url 算法实现串化，而 <code>signature</code> 部分则是由<code>header</code>和<code>payload</code>按照签名函数进行生成，主要目的是防止数据篡改。JWKS 可以利用密钥或者公/私钥对令牌进行验证，利用这一原理，Envoy 中集成了 JWKS ，它表示一组可以校验任意 JWT 的公钥，同样是一个 JSON 对象。为了获得可用的 JWKS，我们可以通过 Identity Server 4 或者 Keycloak 中提供的地址来获得这一信息，方便起见，本文选择了更为便捷的 Keycloak。最终，我们实现了一个通用的、容器级别的认证网关，调用方在消费这些 API 资源时都必须带上从认证中心获得的令牌，进而达到保护 API 资源的目的，更好地保障系统和软件安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Envoy" scheme="https://qinyuanpei.github.io/tags/Envoy/"/>
    
      <category term="JWT" scheme="https://qinyuanpei.github.io/tags/JWT/"/>
    
      <category term="Keycloak" scheme="https://qinyuanpei.github.io/tags/Keycloak/"/>
    
      <category term="认证" scheme="https://qinyuanpei.github.io/tags/%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>浪客剑心：一曲幕末时代的挽歌</title>
    <link href="https://qinyuanpei.github.io/posts/673523131/"/>
    <id>https://qinyuanpei.github.io/posts/673523131/</id>
    <published>2021-07-12T08:53:48.000Z</published>
    <updated>2021-10-09T03:32:42.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>近日，Netflix官方宣布，浪客剑心·最终章：追忆篇 将于7月30日上线，这意味着这部横跨十年时间、被誉为漫改巅峰的系列电影，终于要迎来它的落幕。人对于时间的感觉，难免会相对迟钝一点。如果将思绪拉回到2011年，对我来说，人生中无数闪光的时刻，无一不是从这一刻开始：第一次拥有互相喜欢的人、第一次拥有属于我的电脑、第一次在图书馆里借满100本书……每次听别人说到漫威十年，我总觉得一切无比陌生。回想起来，第一次到电影院看电影，始于Lemon同学请我吃石锅拌饭，对于漫威英雄们的了解，更多的是事后诸葛亮，而唯有浪客剑心系列，一直陪伴着我走过这兵荒马乱的十年。所以，当这个系列走向终点的时候，我果然还是想说点自以为是的话，因为在时代的波涛里，每一个小人物的命运，都不过是艰难挣扎着活下去。</p><p>也许，不光是此刻屏幕前的你，就连我自己完全想象不出，有一天我会对日本的影视作品产生兴趣。过去的我，是一个被人称为“不适合在现代社会”的“怪人”。彼时，我喜欢苏轼烟雨任平生的豁达，喜欢稼轩气吞万里如虎的豪迈，喜欢纳兰容若秋风画扇的悲凉……更多的时候，我是一个偏理想化、偏浪漫主义的文艺青年。在我越来越模糊的时光回忆里，全然没有火影忍者、海贼王这些日漫作品的身影，因为在喜欢安静的我看来，这些动漫人物总是在互相“攻伐”，或许是因为日/韩的语言听起来更像是“吵架”，我一度认为这些东西是聒噪而喧嚣的。直到后来，接触到半泽直树、Legal High、白色巨塔这类影视作品，终于对日本人那种听起来像是“吵架”的表演风格有所了解，而像宫崎骏、新海诚、米林宏昌等动画导演的作品，则是后来一点点接触到的，甚至连鬼灭系列完全都是一个偶然，单纯是因为，我想找一个类似无皇刃谭的作品。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/17/h4q9frIXGyATeZS.jpg" alt="绯村剑心与雪代缘战斗" referrerpolicy="no-referrer"></div><div class="image-caption">绯村剑心与雪代缘战斗</div></figure><p>第一次看浪客剑心的时候，我全然不知它是一部漫改作品。当时，除了感觉人物造型有点 cosplay 以外，更多的时候，我喜欢把当作日式古装片/武侠片。庆幸的是，浪客剑心对于幕末/明治时期的社会氛围一直刻画地不错，即使后来浪客剑心更为人所称道的，是 垣谷健治 从中国功夫电影中借鉴到的动作设计。动画版的浪客剑心，或被称之为：明治剑客浪漫谭。也许，是因为100多年的历史不远不近，更适合人们去肆意想象。所以，当我们提起明治亦或者民国，我们总是期待，那是一个浪漫的时代。浪客剑心的开场，是鸟羽伏见之战，电影中我们记住的，或许是剑心傲娇地将刀插在地上，因为最终赢得这场战争的，是剑心背后的新政府军。可历史永远比想象更残酷，末代幕府将军德川庆喜，在苍茫夜色中逃往大阪城的时候，是否会不时想起，在大坂夏之阵中独自对抗德川大军的真田幸村。历史是何其地相似，可当你恍然间惊觉，原来泛黄的书页已翻过三百余年。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/hMPNtmfHd8FKOrn.jpg" alt="鸟羽伏见战场" referrerpolicy="no-referrer"></div><div class="image-caption">鸟羽伏见战场</div></figure><p>有人说，日本幕府的毁灭始于黑船事件，自此以后便是让日本快速崛起的明治维新。如果把黑船(枪炮)看作西方工业革命的象征，明治维新无疑就是一场西洋枪炮与东瀛武士刀的角逐。所以，在这样一种背景下，浪客剑心里的矛盾冲突，其实都是新时代与旧时代的一次碰撞。禁刀令下，一个曾经双手沾满鲜血的刽子手——绯村拔刀斋，手握一柄逆刃刀，试图斩断一切囿于过去的亡魂，等到他终于放下心中的罪孽感，不再执着于过去发生的一切，脸上的十字刀疤终于消失不见。你告诉我，还有比听起来比这个更浪漫的故事吗？绯村剑心，本名心太，幼年时父母因混乱而死，在被人贩子运送途中遭山贼袭击，幸得飞天御剑流第十三代传人比古清十郎搭救并收为弟子，传授其飞天御剑流剑术。比古清十郎认为心太这个名字太过柔弱，不适合一名剑客，故将其改名为剑心。多年后，剑心与师父的意见向左，师父认为，<strong>剑是凶器，剑术就是杀人伎俩，无论是用多么华丽的词藻去粉饰终究是事实</strong>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/dFegZqaQ23J8VCP.jpg" alt="剑心与师傅比古清十郎" referrerpolicy="no-referrer"></div><div class="image-caption">剑心与师傅比古清十郎</div></figure><p>而在一个动荡的乱世，剑术固然可以锄强扶弱，可更多的或许是成为政客手里的杀人工具。一心想亲手拯救人民于水火的剑心，在下山后遇到了桂小五郎、高杉晋作等维新志士组成的奇兵队，自此成为专门暗杀幕府政要的刽子手，其出众的剑术令幕府闻风丧胆，人称刽子手拔刀斋。其实，在时代的洪流里，不管是作为刽子手的拔刀斋，还是作为浪人的剑心，其实都是一个时代的牺牲品。志志雄真实和剑心，本质上都属于同一类人，不同的是，志志雄是在新时代建立后被抛弃的人，因为身体被大面积烧伤而无法正常排汗，内心燥热的火焰终于要随无限刃而喷薄欲出，他从国外购买了铁甲舰、手下集结了十本刀，决心将这个新时代变成炼狱。明治维新，是两个新旧时代的碰撞，在这样一个大背景下，传统的武士、刽子手大量被抛弃。不管是鹈堂刃卫，还是志志雄真实，都失去了存在下去的意义，他们被鲜血和执念吞噬，试图用最极端的方式来证明自己的存在，在武侠的世界里，追求武功天下第一，是每一个习武之人的毕生追求，可禁刀令一出，大家都生活在充满法制、文明的时代，曾经的一切都仿佛不复存在。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/VtUchpjIKZeBrWL.jpg" alt="武士刀 & 警棍" referrerpolicy="no-referrer"></div><div class="image-caption">武士刀 & 警棍</div></figure><p>这种失落感相当真实，多年以前，徐克拍摄《黄飞鸿》时，曾用“铁布衫”严振东的死，表达过这种在坚船利炮面前的无力感。纵观整个浪客剑心系列，除了第一部的反派武田观柳以外，几乎没有绝对的反派。有一个人，和这些囿于过去、不愿放过自己的人形成强烈对比，那就是斋藤一，这个被称为“壬生狼”的前新选组成员，永远奉行着“恶即斩”的主观标准。在每个被人潮推着向前走的时代，没有人能独善其身，可毫无疑问，斋藤一会是适应能力最强的那一类人。显然，剑心是那种愿意向前看，可依然对过去无法释怀的那一类人。有时候，我们会在文学作品中遇到隐形主角，譬如袁崇焕之于碧血剑，而浪客剑心的隐形主角，我以为应该是替剑心打造逆刃刀的新井赤空，一个铸剑师以匠人的心态打造神兵利器，结果这些刀剑都被用作凶器去杀人。同样地，一名剑客以济世救人的心态加入维新志士这一方，结果在迎接新时代到来的过程中夺去了别人的生命。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/vHI38FRoG9MOVWf.png" alt="新井赤空 & 剑心" referrerpolicy="no-referrer"></div><div class="image-caption">新井赤空 & 剑心</div></figure><p>可以说，剑心手上的逆刃刀，其实就是新井赤空的化身，两个人在赎罪这一心理上是高度一致的，甚至剑心内心的挣扎，早已和这把逆刃刀融为一体，逆刃刀固然会伤到自己，而一个人敢于直视自己的内心，未尝不会被这份鲜血淋漓灼伤，当剑心面对一个又一个的敌人，当剑心身上的秘密一点点被揭开，剑心面对的其实一条自我灵魂的救赎之路。电影中的逆刃刀一共有两把，第一把被称之为“影打”，属于试验品。在和“天剑”宗次郎对决的过程中被名刀虎彻斩断。第二把被称之为“真打”，属于千锤百炼的真品。在关键时刻让剑心打败十本刀之一的“刀狩”泽下条张。在京都大火篇中，当剑心准备从泽下条张手中救下伊织时，剑心有过一段阐述个人理念的独白，大意是说在新时代降生的孩子，都是真正的天选之子，值得他用生命去守护。从这里可以看出，即使曾经作为一个血债累累的刽子手，剑心灵魂深处的仁慈从未丢失过，多年后，他依然还是那个选择埋葬山贼和人贩子尸体的少年心太。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/toA6xTNQyYqGIZK.png" alt="剑心对战 “天剑” 宗次郎" referrerpolicy="no-referrer"></div><div class="image-caption">剑心对战 “天剑” 宗次郎</div></figure><p>可这个角色让人着迷的地方就在于，剑心身上有着难以融合的关于救赎、杀念和仁慈的混合气质：手执逆刃刀，是为不杀之誓，是为自我救赎；在新时代拒绝传授飞天御剑流剑术，认为神谷活心流的“活人剑”更值得传承下去，是为武者之仁。在我的印象中，剑心只有两次真正动了杀心，一次是从鹈堂刃卫手中救下被“心之一方”麻痹肺部的神谷薰，一次是从“刀狩”下泽条张手中救下新井青空的孩子伊织。有时候，我会想，那个一直让剑心不要再杀人的女人可真狠心。直到后来，我终于明白，雪代巴和神谷薰，都是剑心的剑鞘，一个真正爱你的人，怎么会忍心看着你堕入修罗呢？历史的扑朔迷离，往往来自那些不经意间文过饰非的春秋笔法，浪客剑心的第三部，即传说的完结篇，在这一篇里，伊藤博文宣布，绯村拔刀斋已死，绯村剑心重生。后人已无法知晓，伊藤博文下令向铁甲站舰开炮时的心境，也许在某一瞬间，伊藤博文真的想让剑心，连同这些幕末的亡灵一起葬送于火海。如果是这样，每一个想成为时代弄潮儿的英雄，是否最后都变成了政治家的牺牲品呢？虽然我不得不承认，海滩上明治政府向武士们致敬的这一幕，一旦搭配上飞天的背景音乐，就会成为比少年热血漫还要沸腾的东西。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/R2XldmgBs47wauW.jpg" alt="明治政府向武士们致敬" referrerpolicy="no-referrer"></div><div class="image-caption">明治政府向武士们致敬</div></figure><p>美国人曾经拍过一部电影《最后的武士》，描写社会变更时期的武士精神如何走向没落。历史的车轮呼啸而过，传统在飞扬的尘土中转瞬湮没。坂本龙马、大久保利通、西乡隆盛等维新志士，在历史的长河里惊鸿一瞥，人类面对滚滚历史长河时的渺小，大概就像大海中浮沉着的一叶孤舟，无论自身多么想要划向远方，最终亦不得不面对历史的进程。在这部电影结尾，明治天皇被阿汤哥的精神感动，从他手中接过胜元的武士刀，这大概是一种艺术加工。因为真实的历史是往往要更加残酷，此后的许多年里，武士道精神被偷换为军国主义，战争给这个世界带来的伤害可谓历历在目。我们说民国浪漫，是一种“为往圣继绝学，为万世开太平”的浪漫，是那种为了一个民族的未来，而甘愿做孺子牛、上下求索的浪漫。假如剥离这层浪漫的滤镜，将历史放大到一个普通人的生活。或许啊，我们看到的会是 《觉醒年代》 里的饿殍遍野、民生多艰。同样地，我们说明治浪漫，是那如夕阳一般绝美的最后的高光时刻。因为，在每一个时代，都有这样一群人，他们在新与旧，改革与保守，东方与西方的冲突中不断地挣扎。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/17/yDOkYUMW2i8qanN.jpg" alt="绯村剑心经典红白造型" referrerpolicy="no-referrer"></div><div class="image-caption">绯村剑心经典红白造型</div></figure><p>时至今日，年轻人对国家的未来充满希望，对个人的未来充满绝望，也许是因为，在时代的潮流中，普通人甚至比不上一朵小浪花，一如被剑心斩杀的雪代巴的未婚夫清里，本质上并无对错可言，无非是阵营不同。在浪客剑心里，年幼的心太对比古清十郎说，“人死了不过都是一具尸体”。多年后，我在日剧《Unnatural》 里找到了对应的答案，中堂医生在庭审时说过的话，“人这种生物，无论是谁，切开来剥开皮都只不过是一团肉，等你死了就知道了”。说到底，我们不过是碰巧活着啦，比古清十郎和高荷惠，都曾劝诫剑心，在救人前要先学会自保。或许，爱情更是如此，我们常说，“自爱沉稳而后爱人”，《仁医》 里穿越到幕末时代的医生南方仁，怀着对生命和历史的温情与敬意，不自觉地参与到幕末的各种历史事件中，并由此领悟到，“世间的一切都是先人赐予我们的，是历史中的每个人战斗、挣扎和牺牲所赢得的，更是由无数的生命奇迹编织而成，所以，我们必须用我们的双手，给予后人更加光明的未来”。剧中南方仁的仁是医者之仁，而坂本龙马的仁是以公义超越私爱，这两者共同构成这部电视剧的主题：仁，而剑心的仁在于止杀(戈)，这是真正的武者之仁。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/17/gFtbwBVfTsU1oql.jpg" alt="守护世界上最萌的剑心" referrerpolicy="no-referrer"></div><div class="image-caption">守护世界上最萌的剑心</div></figure><p>兔死狐悲的历史总在不断重复上演，历史上的白起、韩信、伍子胥，莫不如是。所以，对于志志雄真实这样一个悲情人物，总是会让人不由心生感慨。原著中的志志雄，不单单有蓄意谋国的野心，甚至开始探索“石油”这种属于未来的科技，在被明治政府抛弃以后，强忍着身心双重折磨，如丧尸一般存活下来。他建立起一套“弱肉强食”的社会达尔文主义理论，在手下十本刀的帮助下，意图颠覆刚建立不久的明治政府。每一个时代都有想成为“弄潮儿”的人，可更多的时候，不过是让这个世界频频陷入“大火”，时代的车轮呼啸着碾过的时候，牺牲的是无数细小的浪花、尘埃，每一个人都想成为英雄，可成为英雄的代价是什么呢？一将功成万骨枯，太阳从树叶的缝隙中穿过的时候，每一片叶子都合成了叶绿素，可难免会刺痛某个躺在树下乘凉的人的眼睛。不管是人诛篇的雪代缘，还是完结篇的志志雄，时代是需要英雄，可你不必非要成为那样的人，我还是想做一个普通人，因为，活着便能创造新的回忆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="https://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="浪客剑心" scheme="https://qinyuanpei.github.io/tags/%E6%B5%AA%E5%AE%A2%E5%89%91%E5%BF%83/"/>
    
      <category term="日本" scheme="https://qinyuanpei.github.io/tags/%E6%97%A5%E6%9C%AC/"/>
    
      <category term="佐藤健" scheme="https://qinyuanpei.github.io/tags/%E4%BD%90%E8%97%A4%E5%81%A5/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core 搭载 Envoy 实现微服务的监控预警</title>
    <link href="https://qinyuanpei.github.io/posts/1519021197/"/>
    <id>https://qinyuanpei.github.io/posts/1519021197/</id>
    <published>2021-07-10T14:41:24.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在构建微服务架构的过程中，我们会接触到服务划分、服务编写以及服务治理这一系列问题。其中，服务治理是工作量最密集的一个环节，无论是服务发现、配置中心、故障转移、负载均衡、健康检查……等等，这一切的一切，本质上都是为了更好地对服务进行管理，尤其是当我们面对数量越来越庞大、结构越来越复杂的集群化环境的时候，我们需要一种科学、合理的管理手段。博主在上一家公司工作的时候，每次一出现线上故障，研发都要第一时间对问题进行排查和处理，而当时的运维团队，对于微服务的监控止步于<code>内存</code>和<code>CPU</code>，无法系统而全面的掌握微服务的运行情况，自然无法从运维监控的角度给研发部门提供方向和建议。所以，今天这篇文章，博主想和大家聊聊，如何利用Envoy来对微服务进行可视化监控。需要说明的是，本文的技术选型为<code>Envoy</code> + <code>ASP.NET Core</code> + <code>Prometheus</code> + <code>Grafana</code>，希望以一种无侵入的方式集成到眼下的业务当中。本文源代码已上传至 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyMonitor" target="_blank" rel="noopener">Github</a> ，供大家学习参考。</p><h1 id="从-Envoy-说起"><a href="#从-Envoy-说起" class="headerlink" title="从 Envoy 说起"></a>从 Envoy 说起</h1><p>在介绍 Envoy 的时候，我们提到了一个词，叫做<strong>可观测的</strong>。什么叫<strong>可观测的</strong>呢？官方的说法是， Envoy 内置了<code>stats</code>模块，可以集成诸如<code>prometheus/statsd</code>等监控方案，可以集成分布式追踪系统，对请求进行追踪。对于这个说法，是不是依然有种云里雾里的感觉？博主认为，这里用<code>Metrics</code>这个词会更准确点，即<strong>可度量的</strong>，你可以认为， Envoy 提供了某种可度量的指标，通过这些指标我们可以对 Envoy 的运行情况进行评估。如果你使用过 <a href="https://www.elastic.co/cn/what-is/elk-stack" target="_blank" rel="noopener">Elastic Stack</a> 中的 <a href="https://www.elastic.co/cn/kibana/" target="_blank" rel="noopener">Kibana</a>，就会对指标(<strong>Metrics</strong>)这个词汇印象深刻，因为 <a href="https://www.elastic.co/cn/kibana/" target="_blank" rel="noopener">Kibana</a> 正是利用日志中的各种指标进行图表的可视化的。庆幸的是，<a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a> 中拥有与 <a href="https://www.elastic.co/cn/kibana/" target="_blank" rel="noopener">Kibana</a> 类似的概念。目前， Envoy 中支持三种类型的统计指标：</p><ul><li><strong>Counter</strong>：即<strong>计数器</strong>，一种只会增加不会减少的无符号整数。例如，总请求数</li><li><strong>Gauge</strong>：即<strong>计量</strong>，一种可以同时增加或者同时减少的无符整数。例如，状态码为200的有效请求数</li><li><strong>Timer</strong>/<strong>Hitogram</strong>：即<strong>计时器</strong>/<strong>直方图</strong>，一种无符号整数，最终将产生汇总百分位值。Envoy 不区分计时器（通常以毫秒为单位）和 原始直方图（可以是任何单位）。 例如，上游请求时间（以毫秒为单位）。</li></ul><p>在今天的这篇文章中，除了 Envoy 以外，我们还需要两位新朋友的帮助，它们分别是<a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> 和 <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a>。其中，Prometheus 是一个开源的完整监控解决方案，其对传统监控系统如 Nagios、Zabbix 等的测试和告警模型进行了彻底的颠覆，形成了基于中央化的规则计算、统一分析和告警的新模型。可以说，Prometheus 是完整监控解决方案中当之无愧的后起之秀，它最为人所称道的是它强大的数据模型，在 Prometheus 中所有采集到的监控数据吗，都以指标(<strong>Metrics</strong>)的形式存储在时序数据库中。和传统的关系型数据库中使用的 SQL 不同，Prometheus 定义一种叫做 PromQL 的查询语言，来实现对监控数据的查询、聚合、可视化、告警等功能。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/12/N4tRgsYJWPLaBlS.png" alt="Prometheus & Grafana 的奇妙组合" referrerpolicy="no-referrer"></div><div class="image-caption">Prometheus & Grafana 的奇妙组合</div></figure><p>目前，社区中提供了大量的<a href="https://prometheus.io/docs/instrumenting/exporters/" target="_blank" rel="noopener">第三方系统</a>的采集功能的实现，这使得我们可以轻易地对MySQL、PostgresSQL、Consul、HAProxy、RabbitMQ， Redis等进行监控。而 Grafana 则是目前主流的时序数据展示工具，正是因为这个原因， Grafana 总是和 Prometheus 同时出现， Prometheus 中采集到监控数据以后，就可以由 Grafana 赖进行可视化。相对应地，Grafana 中有数据源的概念，除了 Prometheus 以外，它还可以使用来自 Elasticsearch 、InfluxDB 、MySQL 、OpenTSDB 等等的数据。基于这样一种思路，我们需要 Envoy 提供指标信息给 Prometheus ，然后再由 Grafana 来展示这些信息。所以，我们面临的主要问题，其实是怎么拿到 Envoy 中的指标信息，以及怎么把这些指标信息给到 Prometheus 。</p><h1 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h1><p>首先，我们来简单阐述一下原理。在 Envoy 的早期版本中，通常是通过 <a href="https://github.com/statsd/statsd" target="_blank" rel="noopener">statsd</a> 来采集 Envoy 中的信息，这些信息会被存储在 Prometheus 中，然后由 Grafana 从 Prometheus 中读取数据并展示为图表。而在 Envoy 最新的版本中，Envoy 本身就可以输出 Prometheus 需要的数据格式，故而就不再需要 <a href="https://github.com/statsd/statsd" target="_blank" rel="noopener">statsd</a> 这样一个监控工具。关于第一种方案，大家可以参考这篇文章：<a href="https://www.servicemesher.com/blog/microservices-monitoring-with-envoy-service-mesh-prometheus-grafana/" target="_blank" rel="noopener">Envoy Service Mesh、Prometheus和Grafana下的微服务监控</a>。这里，为了简单起见，我们采用第二种方案来进行集成。在接下来的例子中，我们会部署下面四个服务，我们希望在调用 gRPC 服务的时候，可以在 Grafana 看到相关的监控指标：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># prometheus</span></span><br><span class="line">  <span class="attr">prom:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/prometheus/prometheus:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./Prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:rw</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">2333</span><span class="string">:9090</span></span><br><span class="line">  <span class="comment"># envoy_gateway</span></span><br><span class="line">  <span class="attr">envoy_gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"9090:9090"</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"9091:9091"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="comment"># grpc_service</span></span><br><span class="line">  <span class="attr">grpc_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">GrpcService/GrpcService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"8082:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br><span class="line">  <span class="comment"># grafana</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">“GF_SECURITY_ADMIN_PASSWORD=Gz2020@”</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">“GF_INSTALL_PLUGINS=alexanderzobnin-zabbix-app”</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">prom</span></span><br></pre></td></tr></table></figure><p>接下来，为了让 Prometheus 可以直接读取 Envoy 中输出的指标数据，我们需要在其配置文件<code>prometheus.yml</code>中添加一个对应的任务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span> </span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'envoy'</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">'/stats/prometheus'</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">scrape_timeout:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9091']</span></span><br></pre></td></tr></table></figure><p>大家还记得 Envoy 中提供的管理接口吗？我们说 Envoy 提供了 Prometheus 格式的指标数据，其实就是指 Envoy 管理接口中的 <code>stats/prometheus</code> 接口，它对应的地址为：<code>http://localhost:9091/stats/prometheus</code>，直接访问这个地址，我们就可以得到下面的结果，这就是 Prometheus 需要的指标数据格式：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/10/PIQHEutC8SZasOF.png" alt="Prometheus 需要的指标数据格式" referrerpolicy="no-referrer"></div><div class="image-caption">Prometheus 需要的指标数据格式</div></figure><h1 id="数据源与可视化"><a href="#数据源与可视化" class="headerlink" title="数据源与可视化"></a>数据源与可视化</h1><p>现在，万事俱备，我们通过<code>docker-compose</code>启动服务即可，默认情况下，Prometheus 使用<code>9090</code>端口，Grafana 使用<code>3000</code>端口，其中，Grafana 默认的账号为<code>admin</code>/<code>admin</code>，建议大家第一次登录后，及时修改默认的账号密码。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/12/WD1bSxfy6w7cU8X.png" alt="Prometheus 运行效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">Prometheus 运行效果展示</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/10/sQyt21AKm4qr9CY.png" alt="Grafana 运行效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">Grafana 运行效果展示</div></figure><p>接下来，我们可以注意到，Prometheus 中两个 target 都已正常启动，这表示它们开始采集数据，我们还可以通过 Graph 菜单来查看当前采集到的数据。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/12/sbZTMlukpd9SrKc.png" alt="Prometheus 采集数据" referrerpolicy="no-referrer"></div><div class="image-caption">Prometheus 采集数据</div></figure><p>那么，数据采集到 Prometheus 以后，如何在 Grafana 中进行图表的可视化展示呢？首先，我们需要在 Grafana 中添加一个数据源，点击左侧第6个图标就可以找到入口。显然，这里的数据源就是 Prometheus ：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/12/3dsXEfRqFzHNvMb.png" alt="Grafana 添加数据源" referrerpolicy="no-referrer"></div><div class="image-caption">Grafana 添加数据源</div></figure><p>接下来，我们可以到官方的 <a href="https://grafana.com/grafana/dashboards" target="_blank" rel="noopener">社区</a> 里找一个 Envoy 的模板，这是一个别人做好的 Dashboard，我们暂时用这个模板来看看效果。随着学习的深入，我们会先从自定义图表开始做起，最终，我们会拥有一个属于自己的 Dashboard 。这里，我们选择一个 Dashboard 模板后，复制其ID，并在 Grafana 中进行导入，导入的时候需要选择数据源，我们选择 Prometheus 即可。接下来，就是见证奇迹的时刻：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/10/GSNo7xaWLPzeIXT.png" alt="Envoy 监控面板效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">Envoy 监控面板效果展示</div></figure><h1 id="自定义图表"><a href="#自定义图表" class="headerlink" title="自定义图表"></a>自定义图表</h1><p>好了，如果大家阅读过官方文档，就会知道，除了 Prometheus ，像常见的 MySQL、Nginx 等，都可以作为 Grafana 的数据源，如果你需要监控 Nginx 的某个指标，这会是个非常不错的思路。那么。如何按照个人/领导的要求，对 Dashboard 进行进一步的定制呢？这就要说到 Grafana 的自定义图表，这里，我们通过下面的例子来进行说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(envoy_http_rq_total&#123;envoy_http_conn_manager_prefix&#x3D;&quot;grpc_json&quot;, instance&#x3D;&quot;192.168.6.120:9902&quot;&#125;[5m])</span><br></pre></td></tr></table></figure><p>在 Prometheus 中，采用的是与 <a href="http://opentsdb.net/" target="_blank" rel="noopener">OpenTSDB</a> 类似的时序格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;&#x3D;&lt;label value&gt;, ...&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，每一个指标含有多个键值形式的标签。例如，<code>http_requests_total{method=&quot;POST&quot;}</code>表示的是所有 HTTP 请求中的 POST 请求。</p><p>此外，除了上文中提到过的 <a href="https://prometheus.io/docs/concepts/metric_types/#counter" target="_blank" rel="noopener">Counter</a> 、 <a href="https://prometheus.io/docs/concepts/metric_types/#gauge" target="_blank" rel="noopener">Gauge</a> 、<a href="https://prometheus.io/docs/concepts/metric_types/#histogram" target="_blank" rel="noopener">Histogram</a> 这三种类型，Prometheus 还支持一种叫做 <a href="https://prometheus.io/docs/concepts/metric_types/#summary" target="_blank" rel="noopener">Summary</a> 的类型。和大多数语言类似，这门被叫做 PromQL 的语言，(1)：支持常见的运算符，例如算术运算符、比较运算符、逻辑运算符、聚合运算符等等。(2)：支持大量的<a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="noopener">内置函数</a>，例如，由浮点型转换为整型的<code>floor</code>和<code>ceil</code>，计算平均速率的<code>rate</code>等等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">floor(avg(http_requests_total&#123;code&#x3D;&quot;200&quot;&#125;))</span><br><span class="line">ceil(avg(http_requests_total&#123;code&#x3D;&quot;200&quot;&#125;))</span><br><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure><p>在这里，我们给出的示例，它表示的是5分钟内 HTTP 请求的平均数目。我们可以在 Prometheus 中的 Graph 菜单对其结果进行查看：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/12/h5vwA1CjJIqs84T.png" alt="在 Prometheus 中查询 Envoy 指标数据" referrerpolicy="no-referrer"></div><div class="image-caption">在 Prometheus 中查询 Envoy 指标数据</div></figure><p>通常，我们可以在这里对查询语句做简单的调试，而如果需要将其集成到 Grafana 中，我们就需要在 Grafana 新建一个图表，可以注意到，两者的语法是完全相同的，这里唯一的不同点在于，时间间隔从固定的5分钟变成了一个变量：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/12/5YzSxcUnIPE43Xm.png" alt="在 Grafana 中查询 Envoy 指标数据" referrerpolicy="no-referrer"></div><div class="image-caption">在 Grafana 中查询 Envoy 指标数据</div></figure><p>此时，我们就完成了一个自定义图表的制作，其中的关键有两点，<strong>其一是了解每一个指标的含义，其二是了解每一个内置函数的用法</strong>。革命尚未成功，同志仍须努力。这些内容无法在一篇博客里全部讲到，如果需要做进一步的探索，还是建议大家去看<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/" target="_blank" rel="noopener">官方文档</a>，这里博主可以给大家推荐一个不错的<a href="https://www.bookstack.cn/read/prometheus_practice/promql-summary.md" target="_blank" rel="noopener">中文文档</a>。</p><h1 id="文本小结"><a href="#文本小结" class="headerlink" title="文本小结"></a>文本小结</h1><p>本文介绍了利用 <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> 和 <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a> 对 <a href="https://www.envoyproxy.io" target="_blank" rel="noopener">Envoy</a> 进行监控预警的方案。在 Envoy 的早期版本中，主流的方案都是通过 <a href="https://github.com/statsd/statsd" target="_blank" rel="noopener">statsd</a> 来采集 Envoy 的指标信息，而在 Envoy 最新版本中，它本身就可以输出 Prometheus 需要的数据格式，我们只需要在 Prometheus 的配置文件中指定<code>stats/prometheus</code>这个地址即可。Prometheus 采用了和 <a href="http://opentsdb.net/" target="_blank" rel="noopener">OpenTSDB</a> 类似的时序格式，每一个指标均含有多个键值形式的标签。Prometheus 在此基础上提供了 PromQL 查询语言，我们可以利用这个查询语言在 Grafana 中制作自定义图表，这些自定义图表可以是一个瞬时数据、可以是一个区间数据，或者是一个纯量数字，因此，我们可以按照自己的喜好去定制整个仪表盘，结合实际的业务场景来决定要关注哪些指标。除此以外，我们还可以在 Prometheus 定义<a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/" target="_blank" rel="noopener">告警规则</a>，当业务系统出现问题时，可以第一时间通知运维或者研发团队。在后端研发越来越服务化、集群化的今天，我们不能永远都盯着 CRUD 这一亩三分地，更普遍的，可能是针对 Docker、K8S、Redis、MySQL 等等基础设施的监控，扁鹊见蔡桓公的故事大家耳熟能详，防微杜渐，无论过去还是现在甚至将来都是一样的。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Envoy" scheme="https://qinyuanpei.github.io/tags/Envoy/"/>
    
      <category term="Prometheus" scheme="https://qinyuanpei.github.io/tags/Prometheus/"/>
    
      <category term="Grafana" scheme="https://qinyuanpei.github.io/tags/Grafana/"/>
    
      <category term="监控" scheme="https://qinyuanpei.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core 搭载 Envoy 实现微服务的负载均衡</title>
    <link href="https://qinyuanpei.github.io/posts/3599307336/"/>
    <id>https://qinyuanpei.github.io/posts/3599307336/</id>
    <published>2021-07-05T22:49:47.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>如果说，我们一定要找出一个词来形容这纷繁复杂的世界，我希望它会是熵。有人说，熵增定律是宇宙中最绝望的定律，<strong>所谓熵，即是指事物混乱或者无序的程度。在一个孤立系统下，熵是不断在增加的，当熵达到最大值时，系统就会出现严重混乱，直至最终走向死亡</strong>。从某种意义上来讲，它揭示了事物结构衰退的必然性，甚至于我们的人生，本来就是一场对抗熵增的旅程。熵增的不可逆性，正如时光无法倒流一般，古人说，“覆水难收”正是这个道理。同样地，当我们开始讨论微服务的划分/编写/治理的时候，当我们使用服务网格来定义微服务架构的时候……我们是否有意或者无意的增加了系统中的熵呢？<strong>一个孤立的系统尚且会因为熵增而最终走向死亡，更何况是相互影响和制约的复杂系统呢？</strong>现代互联网企业都在追求4个9(即99.99%)的高可用，这意味着年平均停机时长只有52.56分钟。在此之前。我们介绍过重试和熔断这两种故障转移的策略，而今天我们来介绍一种更朴素的策略：负载均衡。</p><h1 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h1><blockquote><p>负载均衡，即<code>Load Banlancing</code>，是一种计算机技术，用来在多个计算机(计算机集群)、网络连接、CPU、磁盘驱动器或其它资源中分配负载，以达到<strong>最优化资源使用、最大化吞吐率、最小化响应时间、避免过载的目的</strong>。</p></blockquote><p>我们可以注意到，在这个定义中，使用负载均衡技术的直接原因是<strong>避免过载</strong>，而根本原因则是为了<strong>优化资源使用</strong>，确保<strong>最大吞吐量</strong>、<strong>最小响应时间</strong>。所以，这本质上是一个局部最优解的问题，而具体的手段就是”多个”。有人说，技术世界不过是真实世界的一个镜像，联系生活中实际的案例，我们发现负载均衡比比皆是。譬如车站在面对春运高峰时增加售票窗口，银行通过多个业务窗口来为客户办理业务……等等。这样做的好处显而易见，可以大幅度地减少排队时间，增加”窗口”这个行为，在技术领域我们将其称为：<strong>水平扩展</strong>，因为有多个”窗口”，发生单点故障的概率就会大大降低，而这正是现在软件追求的三”高”：高性能、高可用、高并发。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/05/jymw8KCeEgROcZN.png" alt="银行柜员窗口示意图" referrerpolicy="no-referrer"></div><div class="image-caption">银行柜员窗口示意图</div></figure><p>每次坐地铁经过小寨，时常听到地铁工作人员举着喇叭引导人们往不同的出口方向走动。此时，工作人员就是一个负载均衡器，它要做的就是避免某一个出口人流量过载。<strong>从熵的角度来看，人流量过载，意味着无序/混乱状态加剧，现代社会通过道德和法律来对抗熵增，人类个体通过自律来对抗熵增。</strong>有时候，我会忍不住去想，大人与小孩儿愈发内卷的恶性竞争，除了给这个世界带来更多的熵以外，还能带来什么？<strong>如果参考社会达尔文主义的理论，在这个弱肉强食的世界里，增加熵是人为的选择，而同样的，你亦可以选择”躺平”。</strong></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/05/hIAUw8JHkjWnxm6.png" alt="负载均衡器示意图" referrerpolicy="no-referrer"></div><div class="image-caption">负载均衡器示意图</div></figure><p>OK，将思绪拉回到负载均衡，它所做的事情，本质上就是控制信息或者说流量流动的方向。一个网站，以集群的方式对外提供服务，你只需要输入一个域名，它就可以把请求分发到不同的机器上面去，而这就是所谓的负载均衡。目前，负载均衡器从种类上可以分为：基于<code>DNS</code>、基于<code>MAC</code>地址(二层)、基于<code>IP</code>(三层)、基于<code>IP</code>和<code>Port</code>(四层)、基于<code>HTTP</code>(七层)。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/04/giY1R8PVZB9JdWQ.jpg" alt="OSI七层模型与TCP/IP五层模型" referrerpolicy="no-referrer"></div><div class="image-caption">OSI七层模型与TCP/IP五层模型</div></figure><p>譬如，博主曾经参与过伊利的项目，它们使用的就是一个四层的负载均衡器：F5。而像更常见<code>Nginx</code>、<code>HAProxy</code>，基本都是四层和七层的负载均衡器，而<code>Envoy</code>就厉害了，它可以同时支持三/四/七层。负载均衡器需要配合负载均衡算法来使用，典型的算法有：<strong>轮询法</strong>、<strong>随机法</strong>、<strong>哈希法</strong>、<strong>最小连接数法</strong>等等，而这些算法都可以结合加权算法引出新的变式，这里就不再一一列举啦。</p><h1 id="Envoy中的负载均衡"><a href="#Envoy中的负载均衡" class="headerlink" title="Envoy中的负载均衡"></a>Envoy中的负载均衡</h1><p>通过上一篇博客，我们已经了解到，<code>Envoy</code>中一个<code>HTTP</code>请求的走向，大致会经历：客户端、侦听器(<strong>Listeners</strong>)、集群(<strong>Clusters</strong>)、终结点(<strong>Endpoints</strong>)、服务(<strong>ervices</strong>)这样几个阶段。其中，一个集群可以有多个终结点(<strong>Endpoints</strong>)。所以，这里天然地就存在着负载均衡的设计。因为，负载均衡本质上就是告诉集群，它应该选择哪一个终结点(<strong>Endpoints</strong>)来提供服务。而之所以我们需要负载均衡，一个核心的原因，其实是因为我们选择了分布式。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/02/k2DhXMudnibrzgt.png" alt="Envoy架构图：负载均衡器连接集群和服务" referrerpolicy="no-referrer"></div><div class="image-caption">Envoy架构图：负载均衡器连接集群和服务</div></figure><p>如果类比<code>RabbitMQ</code>、<code>Kafka</code>和<code>Redis</code>，你就会发现，这些产品中或多或少地都会涉及到主(<strong>Leader</strong>)、从(<strong>Follower</strong>)以及推举Leader的实现，我个人更愿意将其看作是更广义的负载均衡。最直观的，它可以分担流量，简称<strong>分流</strong>，不至于让某一台服务器满负荷做运行。其次，它可以作为故障转移的一种方案，<strong>人生在世，多一个B计划，就多一种选择。同样地，多一台服务器，就多一分底气</strong>。最后，它可以指导某一个产品或者功能的推广，通过给服务器设置不同的权重，在必要的时候，将流量局部地导入某一个环境，腾讯和阿里这样的大厂，经常利用这种方式来做<strong>灰度测试</strong>。</p><p><code>Envoy</code>中支持常用的负载均衡算法，譬如：ROUND_ROBIN(轮询)、LEAST_REQUEST(最少请求)、RING_HASH(哈希环)、RANDOM(随机)、MAGLEV(磁悬浮)、CLUSTER_PROVIDED等等。因为一个集群下可以有多个终结点，所以，在<code>Envoy</code>中配置负载均衡，本质上就是在集群下面增加终结点，而每个终结点则会对应一个服务，特殊的点在于，这些服务可能是通过同一个<code>Dockerfile</code>或者<code>Docker</code>镜像来构建的。所以，一旦理解了这一点，<code>Envoy</code>的负载均衡就再没有什么神秘的地方。例如，下面的代码片段展示了，如何为<code>WeatherService</code>这个集群应用负载均衡：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="comment"># Weather Service</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">weatherservice</span></span><br><span class="line">  <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">  <span class="comment"># ROUND_ROBIN(轮询）</span></span><br><span class="line">  <span class="comment"># LEAST_REQUEST(最少请求)</span></span><br><span class="line">  <span class="comment"># RING_HASH(哈希环)</span></span><br><span class="line">  <span class="comment"># RANDOM(随机)</span></span><br><span class="line">  <span class="comment"># MAGLEV(磁悬浮)</span></span><br><span class="line">  <span class="comment"># CLUSTER_PROVIDED</span></span><br><span class="line">  <span class="attr">lb_policy:</span> <span class="string">LEAST_REQUEST</span></span><br><span class="line">  <span class="attr">load_assignment:</span></span><br><span class="line">    <span class="attr">cluster_name:</span> <span class="string">weatherservice</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">weatherservice1</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">weatherservice2</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>是不是觉得特别简单？我想说，也许是<code>Envoy</code>更符合人的直观感受一些，理解起来本身没有太大的心智负担。最近看到一个缓存设计，居然还要依赖<code>Kafka</code>，使用者为了使用缓存这个功能，就必须先实现三个丑陋的委托，这就是所谓的心智负担，违背人类的直觉，使用缓存为什么要了解<code>Kafka</code>？到这里，你大概就能了解利用<code>Envoy</code>实现负载均衡的思路，首先是用同一个<code>Dockerfile</code>或者<code>Docker</code>镜像启动多个不同容器(服务)，然后将指定集群下面的终结点指定不同的服务，再告诉集群要用哪一种负载均衡策略即可。</p><h1 id="邂逅-ASP-NET-Core"><a href="#邂逅-ASP-NET-Core" class="headerlink" title="邂逅 ASP.NET Core"></a>邂逅 ASP.NET Core</h1><p>OK，说了这么多，这里我们还是用<code>ASP.NET Core</code>写一个例子。可以预见到的是，我们需要一个<code>Envoy</code>网关，一个<code>ASP.NET Core</code>的服务。这里，我们还是用<code>Docker-Compose</code>来编排这些服务，下面是对应的<code>docker-compose.yaml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoygateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9090:9090"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9091:9091"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">weatherservice1:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8082:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br><span class="line">  <span class="attr">weatherservice2:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8084:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br></pre></td></tr></table></figure><p>而对于<code>Envoy</code>来说，主要的工作是维护集群下的终结点信息这块儿。其实，这段配置在本文的上一节就出现过啦，你有多少个服务实例，就配置多少个终结点，请求落在哪一个实例上，就交给<code>Envoy</code>来决定好啦。故而，这里我们不再做更多的解释：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">AUTO</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"*"</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">"/api/w"</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">                  <span class="attr">prefix_rewrite:</span> <span class="string">/Weather</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">weatherservice</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="comment"># Weather Service</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">weatherservice</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">LEAST_REQUEST</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">weatherservice</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">weatherservice1</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">weatherservice2</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">/tmp/admin_access.log</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">socket_address:</span> <span class="string">&#123;</span> <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">,</span> <span class="attr">port_value:</span> <span class="number">9091</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>使用<code>docker compose up</code>启动容器，我们可以注意到熟悉的<code>ASP.NET Core</code>的身影，这意味着，我们需要的服务都成功地跑起来了。简单调用下API看看，果然，可以正确地返回结果呢(逃……果然，我是一个喜新厌旧的人，自打用了<code>Encoy</code>以后，再不想用<code>Nginx</code>来做类似的事情(逃……</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/04/lBIAyPZnSxiD3M8.png" alt="通过管理接口查看集群的请求情况" referrerpolicy="no-referrer"></div><div class="image-caption">通过管理接口查看集群的请求情况</div></figure><p>好了，如何验证我们选择的负载均衡策略呢？这是一个问题。不知道大家还记不记得<code>Envoy</code>的管理接口，它里面可以统计请求的次数，所以，我们只要看看两个服务各自请求了多少次里有好啦！这里以<code>RANDON</code>这个策略为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/04/1U8RgZxaVcOFiXK.png" alt="两个实例拥有不同的请求次数" referrerpolicy="no-referrer"></div><div class="image-caption">两个实例拥有不同的请求次数</div></figure><p>可以注意到，两个的请求次数果然是随机的呢？而如果我们换成是<code>ROUND_ROBIN</code>，你就会发现这两个数值一前一后相互追赶。选择哪一种负载均衡策略，这个按大家实际的场景去决定就好。我倒觉得，按最少请求数的策略会好一点。虽然计算机永远不知疲倦地接收人们的指令，可考虑能者多劳这种人类世界里的策略，本身充满道德绑架的意味，使用负载均衡，站在计算机的角度来看，这是避免计算机内卷的一种方案。所以啊，老板们，请不要逮着一个老实人就拼了命的剥削，多学学负载均衡算法，<strong>卓别林心目中的摩登时代，我一点都不期待，技术世界总告诉我们要严谨、冷静，可充满人情味的世界，同样值得你去热爱啊。</strong></p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文结合物理学中的熵增定律引出了负载均衡这个话题，而<strong>负载均衡的本质，就是在多个计算机(计算机集群)、网络连接、CPU、磁盘驱动器或其它资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、避免过载的目的。</strong>对于这一点，我们可以结合现实生活中的”窗口”排队来理解。<strong>负载均衡可以和水平扩展完美结合，通过降低单点的故障率，来达到提升整个系统可用性的目的</strong>。接下来，我们介绍了常见的负载均衡器分类及其算法，<code>Envoy</code>中的负载均衡配置，并结合<code>ASP.NET Core</code>编写了一个实际的案例。好了，以上就是这篇博客的全部内容啦，如果大家对于熵增定律或者负载均衡器有任何的看法，欢迎大家在评论区留言，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Envoy" scheme="https://qinyuanpei.github.io/tags/Envoy/"/>
    
      <category term="负载均衡" scheme="https://qinyuanpei.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="熵增定律" scheme="https://qinyuanpei.github.io/tags/%E7%86%B5%E5%A2%9E%E5%AE%9A%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core 搭载 Envoy 实现微服务的反向代理</title>
    <link href="https://qinyuanpei.github.io/posts/3599307335/"/>
    <id>https://qinyuanpei.github.io/posts/3599307335/</id>
    <published>2021-07-01T22:49:47.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>回想起来，博主第一次接触到<code>Envoy</code>，其实是在微软的示例项目 <a href="https://github.com/dotnet-architecture/eShopOnContainers" target="_blank" rel="noopener">eShopOnContainers</a>，在这个示例项目中，微软通过它来为<code>Ordering API</code>、<code>Catalog API</code>、<code>Basket API</code> 等多个服务提供网关的功能。当时，博主并没有对它做深入的探索。此刻再度回想起来，大概是因为那个时候更迷恋领域驱动设计(DDD)的理念。直到最近这段时间，博主需要在一个项目中用到<code>Envoy</code>，终于决定花点时间来学习一下相关内容。所以，接下来这几篇博客，大体上会以记录我学习<code>Envoy</code>的历程为主。考虑到<code>Envoy</code>的配置项特别多，在写作过程中难免会出现纰漏，希望大家谅解。如对具体的配置项存在疑问，请以官方最新的 <a href="https://www.envoyproxy.io/docs/envoy/latest/" target="_blank" rel="noopener">文档</a> 为准，本文所用的示例代码已经上传至 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyGateway" target="_blank" rel="noopener">Github</a>，大家作为参考即可。对于今天这篇博客，我们来聊聊 ASP.NET Core 搭载 Envoy 实现微服务的反向代理 这个话题，或许你曾经接触过 <a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a> 或者 <a href="https://github.com/ThreeMammals/Ocelot" target="_blank" rel="noopener">Ocelot</a>，这次我们不妨来尝试一点新的东西，譬如，通过<code>Docker-Compose</code>来实现服务编排，如果对我说的这些东西感兴趣的话，请跟随我的脚步，一起来探索这广阔无垠的技术世界吧！</p><h1 id="走近-Envoy"><a href="#走近-Envoy" class="headerlink" title="走近 Envoy"></a>走近 Envoy</h1><p><a href="https://www.envoyproxy.io/" target="_blank" rel="noopener">Envoy</a> 官网对<code>Envoy</code>的定义是：</p><blockquote><p>Envoy 是一个开源边缘和服务代理，专为原生云应用设计。</p></blockquote><p>而更进一步的定义是：</p><blockquote><p>Envoy 是专为大型现代服务导向架构设计的 L7 代理和通讯总线。</p></blockquote><p>这两个定义依然让你感到云里雾里？没关系，请看下面这张图：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/02/k2DhXMudnibrzgt.png" alt="Envoy架构图" referrerpolicy="no-referrer"></div><div class="image-caption">Envoy架构图</div></figure><p>注：<a href="https://fuckcloudnative.io/envoy-handbook/docs/gettingstarted/architecture/" target="_blank" rel="noopener">图片来源</a></p><p>相信从这张图中，大家多少能看到反向代理的身影，即下游客户端发起请求，<code>Envoy</code>对请求进行侦听(<strong>Listeners</strong>)，并按照路由转发请求到指定的集群(<strong>Clusters</strong>)。接下来，每一个集群可以配置多个终结点，<code>Envoy</code>按照指定的负载均衡算法来筛选终结点，而这些终结点则指向了具体的上游服务。例如，我们熟悉的 <a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a> ，使用<code>listen</code>关键字来指定侦听的端口，使用<code>location</code>关键字来指定路由，使用<code>proxy_pass</code>关键字来指定上游服务的地址。同样地，<a href="https://github.com/ThreeMammals/Ocelot" target="_blank" rel="noopener">Ocelot</a> 使用了类似的上下游(<strong>Upstream</strong>/<strong>Downstream</strong>)的概念，唯一的不同是，它的上下游的概念与这里是完全相反的。</p><p>你可能会说，这个<code>Envoy</code>看起来“平平无奇”嘛，简直就像是“平平无奇”的古天乐一般。事实上，<code>Envoy</code>强大的地方在于：</p><ul><li>非侵入式的架构： 独立进程、对应用透明的<code>Sidecar</code>模式</li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/02/lMnPhZzBd38tpVF.png" alt="Envoy 的 Sidecar 模式" referrerpolicy="no-referrer"></div><div class="image-caption">Envoy 的 Sidecar 模式</div></figure><ul><li>L3/L4/L7 架构：<code>Envoy</code>同时支持 OSI 七层模型中的第三层(网络层, IP 协议)、第四层(传输层，TCP / UDP 协议)、第七层(应用层，HTTP 协议)</li><li>顶级 HTTP/2 支持： 视 <code>HTTP/2</code> 为一等公民，且可以在 <code>HTTP/2</code> 和 <code>HTTP/1.1</code>间相互转换</li><li>gRPC 支持：<code>Envoy</code> 支持 <code>HTTP/2</code>，自然支持使用 <code>HTTP/2</code> 作为底层多路复用协议的 <code>gRPC</code></li><li>服务发现和动态配置：与 <code>Nginx</code> 等代理的热加载不同，<code>Envoy</code> 可以通过 <code>API</code> 接口动态更新配置，无需重启代理。</li><li>特殊协议支持：Envoy 支持对特殊协议在 L7 进行嗅探和统计，包括：<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/mongo_proxy_filter#" target="_blank" rel="noopener">MongoDB</a>、<a href="https://www.servicemesher.com/envoy/intro/arch_overview/dynamo.html#arch-overview-dynamo" target="_blank" rel="noopener">DynamoDB</a> 等。</li><li>可观测性：<code>Envoy</code> 内置 <code>stats</code> 模块，可以集成诸如 <code>prometheus/statsd</code> 等监控方案。还可以集成分布式追踪系统，对请求进行追踪。</li></ul><h1 id="Envoy配置文件"><a href="#Envoy配置文件" class="headerlink" title="Envoy配置文件"></a>Envoy配置文件</h1><p><code>Envoy</code>通过配置文件来实现各种各样的功能，其完整的配置结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"node"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"static_resources"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"dynamic_resources"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"cluster_manager"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"hds_config"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"flags_path"</span>: <span class="string">"..."</span>,</span><br><span class="line">  <span class="attr">"stats_sinks"</span>: [],</span><br><span class="line">  <span class="attr">"stats_config"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"stats_flush_interval"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"watchdog"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"tracing"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"runtime"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"layered_runtime"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"overload_manager"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"enable_dispatcher_stats"</span>: <span class="string">"..."</span>,</span><br><span class="line">  <span class="attr">"header_prefix"</span>: <span class="string">"..."</span>,</span><br><span class="line">  <span class="attr">"stats_server_version_override"</span>: <span class="string">"&#123;...&#125;"</span>,</span><br><span class="line">  <span class="attr">"use_tcp_for_dns_lookups"</span>: <span class="string">"..."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要对侦听器(<strong>Listeners</strong>)、集群(<strong>Clusters</strong>) 和 管理(<strong>Admin</strong>)这三个常用的部分来进行说明。其中，(<strong>Listeners</strong>)、集群(<strong>Clusters</strong>) 均位于 <code>static_resources</code> 节点下，而 管理(<strong>Admin</strong>) 则有一个单独的<code>admin</code>节点。</p><h2 id="侦听器-Listeners"><a href="#侦听器-Listeners" class="headerlink" title="侦听器(Listeners)"></a>侦听器(Listeners)</h2><p>侦听器，顾名思义就是侦听一个或者多个端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure><p>在这里，它表示的是侦听<code>9090</code>这个端口，这里的<code>listeners</code>是一个数组，所以，你可以同时侦听多个端口。</p><h3 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器(Filters)"></a>过滤器(Filters)</h3><p>我们知道，单单侦听一个或者多个端口，是无法完成一个<code>HTTP</code>请求的，因为它还不具备处理<code>HTTP</code>请求的能力。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/02/CQftjTErndyNh7q.png" alt="Envoy Filters 架构图" referrerpolicy="no-referrer"></div><div class="image-caption">Envoy Filters 架构图</div></figure><p>在 <code>Envoy</code> 中，这一工作由一个或者多个过滤器组成的过滤器链(<strong>Filter Chains</strong>) 来完成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">AUTO</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"*"</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">"/api/w"</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">                  <span class="attr">prefix_rewrite:</span> <span class="string">/Weather</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">weatherservice</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">"/api/c"</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">                  <span class="attr">prefix_rewrite:</span> <span class="string">/City</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">cityservice</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure><p>在这段配置中，<code>Http Connection Manager</code>表示的是位于 L3(<strong>网络层</strong>)/L4(<strong>传输层</strong>) 的过滤器，这个过滤器连接的下一个过滤器是<code>envoy.filters.http.router</code>，表示的是 L7(<strong>应用层</strong>) 的关于路由的过滤器。个人感觉，这和我们通常所说的中间件相当接近。注意到，我们在 L3/L4 这个层级上做了什么事情呢？其实应该是 TCP/IP 层面上请求转发，这里定义的路由规则如下：</p><ul><li>当外部调用者访问<code>/api/w</code>时，请求会被转发到<code>WeatherService</code>。</li><li>当外部调用者访问<code>/api/c</code>时，请求会被转发到<code>CityService</code>。</li></ul><h2 id="集群-Clusters"><a href="#集群-Clusters" class="headerlink" title="集群(Clusters)"></a>集群(Clusters)</h2><p>在过滤器部分，我们定义了路由，那么，请求的最终去向是哪里呢？这里 <code>Envoy</code> 将其称之为 集群：:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="comment"># City Service</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cityservice</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br></pre></td></tr></table></figure><p>集群本身，其实只是一个名字，并没有实际的意义，真正工作的其实是指向上游服务的终结点，我们可以为每一个集群指定一个负载均衡策略，让它决定选择哪一个终结点来提供服务。</p><h3 id="负载均衡-Load-Assignment"><a href="#负载均衡-Load-Assignment" class="headerlink" title="负载均衡(Load Assignment)"></a>负载均衡(Load Assignment)</h3><p>目前，<code>Envoy</code>支持以下负载均衡算法：</p><ul><li>ROUND_ROBIN：轮询</li><li>LEAST_REQUEST：最少请求</li><li>RING_HASH：哈希环</li><li>RANDOM：随机</li><li>MAGLEV：磁悬浮</li><li>CLUSTER_PROVIDED</li></ul><p>下面的示例展示了如何为某个集群配置负载均衡：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="comment"># Weather Service</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">weatherservice</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">LEAST_REQUEST</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">weatherservice</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">weatherservice1</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">weatherservice2</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>其中，<code>weatherservice1</code>和<code>weatherservice2</code>是同一个服务的两个容器实例，当我们使用<code>Docker-Compose</code>进行构建的时候，不需要显式地去指定每一个服务的IP地址，只要对应<code>docker-compose.yaml</code>文件中的服务名称即可。</p><h2 id="管理-Admin"><a href="#管理-Admin" class="headerlink" title="管理(Admin)"></a>管理(Admin)</h2><p>管理(<strong>Admin</strong>)这块儿相对简单一点，主要用来指定<code>Envoy</code>的的管理接口的端口号、访问日志存储路径等等：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">/tmp/admin_access.log</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">socket_address:</span> <span class="string">&#123;</span> <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">,</span> <span class="attr">port_value:</span> <span class="number">9091</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h1><p>好了，在正确配置<code>Envoy</code>以后，我们来考虑如何对这些服务进行编排，在本文的 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyGateway" target="_blank" rel="noopener">例子</a> 中，我们有两个后端服务，<code>WeatherService</code> 和 <code>CityService</code>，它们本质上是两个<code>ASP.NET Core</code>应用，我们希望通过<code>Envoy</code>来实现反向代理功能。这样做的好处是，后端服务的架构不会直接暴露给外部使用者。所以，你会注意到，在微服务架构的设计中，网关经常扮演着重要的角色。那么，如何对服务进行编排呢？这里我们使用<code>Docker-Compose</code>来完成这个工作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoygateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9090:9090"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9091:9091"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">cityservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br><span class="line">  <span class="attr">weatherservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8082:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br></pre></td></tr></table></figure><p>可以注意到，这里需要部署3个服务，其中，<code>Envoy</code>负责监听<code>9090</code>端口，即对外的网关。而两个后端服务，<code>WeatherService</code> 和 <code>CityService</code>则被分别部署在<code>8082</code>和<code>8081</code>端口。这里最重要的是<code>envoy.yaml</code>这个配置文件，我们在上一节编写的配置文件会挂在到容器目录：<code>/etc/envoy/envoy.yaml</code>。<code>Envoy</code>将如何使用这个配置文件呢？事实上，这个<code>Dockerfile</code>是这样编写的：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> envoyproxy/envoy-alpine:v1.<span class="number">16</span>-latest</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./envoy.yaml /etc/envoy.yaml</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod go+r /etc/envoy.yaml</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/local/bin/envoy"</span>, <span class="string">"-c"</span>, <span class="string">"/etc/envoy.yaml"</span>, <span class="string">"--service-cluster"</span>, <span class="string">"reverse-proxy"</span>]</span></span><br></pre></td></tr></table></figure><p>除此之外，Envoy通过<code>9091</code>端口提供管理功能，我们可以通过这个端口来获得集群、请求、统计等信息，这一特性我们将会在接下来的文章里用到：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/02/1OlNJ7um6BnLFeb.png" alt="Envoy 管理界面功能一览" referrerpolicy="no-referrer"></div><div class="image-caption">Envoy 管理界面功能一览</div></figure><p>这里，想分享一个关于<code>Envoy</code>的小技巧，当我们在指定集群的地址时，可以使用<code>docker-compose.yaml</code>中定义的服务的名称，这会比填入一个固定的<code>IP</code>地址要更优雅一点，理由非常简单，我们不希望每次都来维护这个地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Weather Service</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">weatherservice</span></span><br><span class="line">   <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">   <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">   <span class="attr">load_assignment:</span></span><br><span class="line">     <span class="attr">cluster_name:</span> <span class="string">weatherservice</span></span><br><span class="line">     <span class="attr">endpoints:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">           <span class="attr">address:</span></span><br><span class="line">             <span class="attr">socket_address:</span></span><br><span class="line">               <span class="comment"># 建议使用 docker-compose.yaml 文件中对应的服务名称来代替IP地址</span></span><br><span class="line">               <span class="attr">address:</span> <span class="string">weatherservice</span></span><br><span class="line">               <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>接下来，如果每一个服务的<code>Dockerfile</code>都编写正确的话，我们就可以通过<code>docker compose up</code>命令启动这一组服务，通过命令行下打印出来的信息，我们可以确认，基于<code>Envoy</code>的网关服务、两个基于<code>ASP.NET Core</code>的后端服务都已经成功运行起来：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/02/KMo4dn17m9p8NSg.png" alt="在 Docker-Compose 中成功启动服务" referrerpolicy="no-referrer"></div><div class="image-caption">在 Docker-Compose 中成功启动服务</div></figure><p>还记得我们的路由规则是是如何定义的吗？</p><ul><li>当外部调用者访问<code>/api/w</code>时，请求会被转发到<code>WeatherService</code>。</li><li>当外部调用者访问<code>/api/c</code>时，请求会被转发到<code>CityService</code>。</li></ul><p>实际的情况如何呢？我们不妨来验证一下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/02/YX4VywtkOCJ2rSI.png" alt="通过 Envoy 调用 WeatcherService" referrerpolicy="no-referrer"></div><div class="image-caption">通过 Envoy 调用 WeatcherService</div></figure><p>可以注意到，不管是浏览器返回的结果，还是容器内部输出的日志，都表明请求确实被转发到对应的服务上面去了，这说明我们设计的网关已经生效。至此，我们实现了基于<code>Envoy</code>的反向代理功能，有没有觉得比<code>Nginx</code>要简单一点？重要的是，基于<code>Docker-Compose</code>的服务编排使用起来真的舒适度爆棚，这意味着你会有更多的属于程序员的贤者时间。前段时间热映的电视剧《觉醒时代》，鲁迅先生写完《狂人日记》后那一滴眼泪令人动容。也许，这种如匠人一般反复雕琢、臻于完美的心境是互通的，即使人类的悲欢并不相通，对美和极致的追求竟然出奇的相似。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要介绍了 ASP.NET Core 搭载 <a href="https://www.envoyproxy.io/" target="_blank" rel="noopener">Envoy</a> 实现反向代理这一过程。对于 <code>Envoy</code>，有两个重要的定义：<strong>第一、Envoy 是一个开源边缘和服务代理，专为原生云应用设计。第二、Envoy 是专为大型现代服务导向架构设计的 L7 代理和通讯总线</strong>。相比 <a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a> 和 <a href="https://github.com/ThreeMammals/Ocelot" target="_blank" rel="noopener">Ocelot</a> ，Envoy 提供了 <code>L7</code> 级别的代理服务，支持 <code>HTTP/2</code> 和 <code>gRPC</code>，无侵入式的<code>Sidecar</code>模式可以提供与应用进程完全隔离的代理服务。接下来，博主对 <code>Envoy</code> 配置文件的结构及主要的配置项进行了说明，对于常见的 API 网关，我们应该重点关注侦听器(<strong>Listeners</strong>) 和 集群(<strong>Clusters</strong>)。最终，我们结合<code>Docker-Compose</code>对服务进行了编排，并由此构建出了一个基本的反向代理的方案。本文的源代码已托管至 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyGateway" target="_blank" rel="noopener">Github</a> ，大家可以在此基础上做进一步的探索。好了，以上就是这篇博客的的全部内容啦，欢迎大家就本文中提出的方案、代码等进行讨论，如果大家有任何意见或者建议，欢迎在评论区进行留言，谢谢大家！</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://fuckcloudnative.io/envoy-handbook/" target="_blank" rel="noopener">Envoy中文指南</a></li><li><a href="https://www.envoyproxy.io/docs/envoy/latest/" target="_blank" rel="noopener">Envoy官方文档</a></li><li><a href="https://www.cnblogs.com/sheng-jie/p/use-envoy-proxy-as-apigateways-in-eshoponcontainers.html" target="_blank" rel="noopener">eShopOnContainers 知多少[12]：Envoy Gateways</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Envoy" scheme="https://qinyuanpei.github.io/tags/Envoy/"/>
    
      <category term="网关" scheme="https://qinyuanpei.github.io/tags/%E7%BD%91%E5%85%B3/"/>
    
      <category term="反向代理" scheme="https://qinyuanpei.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core gRPC 打通前端世界的尝试</title>
    <link href="https://qinyuanpei.github.io/posts/2167892202/"/>
    <id>https://qinyuanpei.github.io/posts/2167892202/</id>
    <published>2021-06-20T21:37:36.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在构建以 gRPC 为核心的微服务架构的过程中，我们逐渐接触到了 gRPC 的过滤器、健康检查、重试等方面的内容。虽然， Protocol Buffers 搭配 HTTP/2 ，在整个传输层上带来了显著的性能提升，可当这套微服务方案面对前后端分离的浪潮时，我们能明显地有点“<strong>水土不服</strong>”。其实，如果单单是以 Protocol Buffers 来作为 HTTP 通信的载体，通过 <a href="https://github.com/dcodeIO/protobuf.js" target="_blank" rel="noopener">protobuf.js</a> 就可以实现前端的二进制化。考虑到 gRPC 实际的通信过程远比这个复杂，同时还要考虑<code>.proto</code>文件在前/后端共享的问题，所以，我们面对的其实是一个相当复杂的问题。现代的前端世界，是一个<code>React</code>、<code>Angular</code>和<code>Vue</code>三足鼎立的世界，如果这个世界不能和微服务的世界打通，我们面对的或许并不是一个真实的世界。因为博主注意到，项目中有一部分 gRPC 服务被封装为<code>Web API</code>并提供给前端，这说明大家都意识到了这个问题。所以，这篇博客想和大家分享的是，如何打通 gRPC 和 前端 两个不同的世界，这里介绍四种方式：<strong>gRPC-Web</strong>、<strong>gRpc-Gateway</strong>、<strong>封装Web API</strong>、<strong>编写中间件</strong>，希望能给大家带来一点启发。</p><h1 id="gRPC-Web"><a href="#gRPC-Web" class="headerlink" title="gRPC-Web"></a>gRPC-Web</h1><p><a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Web</a> 是官方提供的一个方案，它的原理是利用命令行工具<code>ptotoc</code>及其插件<code>protoc-gen-grpc-web</code>来生成<code>.proto</code>对应的客户端代码，这些代码经过<code>webpack</code>这类打包工具处理以后，就可以在前端使用。所以，对于 gRPC-Web ，你可以从两个方面来考虑它：第一，它支持生成强类型的客户端代码；第二，它支持在非 HTTP/2 环境下使用 gRPC 。下面是一个基本的使用流程：</p><p>首先，我们需要下载命令行工具：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">protoc</a> 及其插件：<a href="https://github.com/grpc/grpc-web/releases" target="_blank" rel="noopener">protoc-gen-grpc-web</a>。</p><p>此时，我们可以使用下面的命令来生成<code>JavaScript</code>版本的 gRPC 代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc greetjs.proto \</span><br><span class="line">  --js_out=import_style=commonjs:. \</span><br><span class="line">  --grpc-web_out=import_style=commonjs,mode=grpcwebtext:. \</span><br><span class="line">  --plugin=protoc-gen-grpc-web=C:\Users\Payne\go\bin\protoc-gen-grpc-web.exe</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>--js_out</code> 和 <code>--grpc-web_out</code> 分别指定了我们要生成的<code>JavaScript</code>代码的模块化标准，这里使用的是 <a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS</a> 规范。</li><li><code>mode=grpcwebtext</code> 指定 gRPC-Web 的数据传输方式。目前：支持两种方式，application/grpc-web-text(Base64编码，文本格式) 和 application/grpc-web+proto(二进制格式)，前者支持 Unary Calls 和 Server Streaming Calls，后者只支持 Unary Calls。</li></ul><p>在这个例子中，会生成下面两个文件，它们分别定义了<code>客户端</code>和<code>消息</code>这两个部分：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/22/Yd9A5CEONkZgBjU.png" alt="利用 protoc 生成 JavaScript 代码" referrerpolicy="no-referrer"></div><div class="image-caption">利用 protoc 生成 JavaScript 代码</div></figure><p>此时，我们可以这样编写我们的逻辑代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> proto.greet.GreeterClient(<span class="string">'http://localhost:8000'</span>);</span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> proto.greet.HelloRequest();</span><br><span class="line"><span class="keyword">var</span> metadata = &#123; &#125;</span><br><span class="line">request.setName(<span class="string">'长安书小妆'</span>);</span><br><span class="line">client.sayHello(request, metadata, <span class="function"><span class="keyword">function</span>(<span class="params">error, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你更倾向于使用类型安全的 TypeScript，你还可以按下面的方式来生成代码：</p><ul><li><code>import_style=commonjs+dts</code>: CommonJS &amp; .d.ts typings</li><li><code>import_style=typescript</code>: 100% TypeScript</li></ul><p>更多的细节请参考官方文档：<a href="https://hub.fastgit.org/grpc/grpc-web#typescript-support" target="_blank" rel="noopener">https://hub.fastgit.org/grpc/grpc-web#typescript-support</a></p><p>接下来，对于 .NET 开发者而言， gRPC-Web 意味着我们只需要简单地配置下 ASP.NET Core 的中间件管道，就可以享受到上面提供的这些便利。因为 Visual Studio 会在编译<code>.proto</code>文件时，自动帮你生成这个客户端代码，我们可以将这一技术应用到单页面应用(<strong>SPA</strong>) 和 WebAssembly 中，最典型的例子莫过于微软的 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-5.0" target="_blank" rel="noopener">Blazor</a>，它使得 gRPC 可以充当客户端与服务端间的信使。同样地，这里准备了相关的示例代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddGrpc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    app.UseGrpcWeb();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;().EnableGrpcWeb();</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大家留意一下微软官方的 <a href="https://hub.fastgit.org/grpc/grpc-dotnet/blob/master/examples/Browser/Server/wwwroot/Scripts/index.js" target="_blank" rel="noopener">示例项目</a>，就会发现和这里类似的东西，因为原理上一脉相承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; HelloRequest, HelloReply &#125; = <span class="built_in">require</span>(<span class="string">'./greet_pb.js'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; GreeterClient &#125; = <span class="built_in">require</span>(<span class="string">'./greet_grpc_web_pb.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> GreeterClient(<span class="built_in">window</span>.location.origin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nameInput = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">var</span> sendInput = <span class="built_in">document</span>.getElementById(<span class="string">'send'</span>);</span><br><span class="line"><span class="keyword">var</span> streamInput = <span class="built_in">document</span>.getElementById(<span class="string">'stream'</span>);</span><br><span class="line"><span class="keyword">var</span> resultText = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unary call</span></span><br><span class="line">sendInput.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> HelloRequest();</span><br><span class="line">    request.setName(nameInput.value);</span><br><span class="line"></span><br><span class="line">    client.sayHello(request, &#123;&#125;, (err, response) =&gt; &#123;</span><br><span class="line">        resultText.innerHTML = htmlEscape(response.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>gRPC-Web 在将 gRPC 带入前端世界的过程中，其实是牺牲了一部分重要特性的，譬如浏览器中无法实现 HTTP/2，相对应地，gRPC-Web不再支持客户端流和双向流，依然支持服务端流，博主猜测可能是利用了服务端发送事件(<strong>Server Sent Event</strong>)。不过，这并不影响我们对这个项目的敬意，感谢它将 gRPC 带入了前端的世界。</p><h1 id="gRPC-Gateway"><a href="#gRPC-Gateway" class="headerlink" title="gRPC-Gateway"></a>gRPC-Gateway</h1><p><a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Gateway</a> 同样是命令行工具<code>protoc</code>的一个插件，其原理是，读取 gRPC 服务定义，并生成一个反向代理服务器，将 RESTful JSON API 转换为 gRPC 。而两者间的对应关系，则是通过<code>.proto</code>文件中的自定义选项来维护的。简单来说，就是在我们定义 gRPC 服务的同时，增加一组选项来表明这是一个 RESTful JSON API 。目前，这个插件只支持<code>Go</code>语言的代码生成。所以，如果想玩一玩这个插件，需要大家安装好<code>Go</code>的环境。</p><p>首先，我们从 <a href="https://hub.fastgit.org/protocolbuffers/protobuf/releases/tag/v3.6.1" target="_blank" rel="noopener">Github</a> 下载 Protocol Buffers 的编译器，它负责从从<code>.proto</code>文件生成代码。</p><p>这里我们选择 Windows 版本，直接将其解压到一个非中文的路径下即可。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/21/eTfGF9hI6cPSlwR.png" alt="Protocol Buffers 的编译器" referrerpolicy="no-referrer"></div><div class="image-caption">Protocol Buffers 的编译器</div></figure><p>这里，我们需要配置下面两个环境变量：</p><ul><li>PATH：C:\Program Files\Protobuf\bin</li><li>PROTOC_INCLUDE：C:\Program Files\Protobuf\include</li></ul><p>接下来，在<code>Go</code>环境中进行以下设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway </span><br><span class="line">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger </span><br><span class="line">go install github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p>这样，我们就通过<code>Go</code>完成了<code>protoc</code>的插件的安装。此时，我们可以通过下面的命令来生成<code>Go</code>代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成Go的客户端代码</span></span><br><span class="line">protoc --proto_path=. \</span><br><span class="line">  --go_out=. \</span><br><span class="line">  --plugin=protoc-gen-go=C:\Users\Payne\go\bin\protoc-gen-go.exe \</span><br><span class="line">  ./greet.proto </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成Go的反向代理服务器端代码</span></span><br><span class="line">protoc \</span><br><span class="line">  -I C:\Users\Payne\go\pkg\mod\github.com\grpc-ecosystem\grpc-gateway@v1.9.0\third_party\googleapis\ \</span><br><span class="line">  --proto_path=. \</span><br><span class="line">  --grpc-gateway_out=. \</span><br><span class="line">  --plugin=protoc-gen-grpc-gateway=C:\Users\Payne\go\bin\protoc-gen-grpc-gateway.exe \</span><br><span class="line">  ./greet.proto</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面两个<code>.go</code>格式的文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/22/wHvUzr5OybAtfkS.png" alt="通过 grpc-gateway 生成 Go 代码" referrerpolicy="no-referrer"></div><div class="image-caption">通过 grpc-gateway 生成 Go 代码</div></figure><p>关于反向代理服务器的观点的验证，大家可以从生成的第二个文件中去发现。</p><p>而关于 <a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Gateway</a> 这个插件的使用，最直观的用法，其实应该来自<code>.proto</code>文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">syntax</span> = <span class="string">"proto3";</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//</span> <span class="string">Go里面的包名，必选</span></span><br><span class="line"><span class="attr">option</span> <span class="string">go_package = "grpc-gateway/hello-word";</span></span><br><span class="line"></span><br><span class="line"><span class="attr">package</span> <span class="string">greet;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//</span> <span class="string">Google的API注解相关的.proto文件，必选</span></span><br><span class="line"><span class="attr">import</span> <span class="string">"Protos/google/api/annotations.proto";</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service</span> <span class="string">Greeter &#123;</span></span><br><span class="line">  <span class="attr">rpc</span> <span class="string">SayHello (HelloRequest) returns (HelloReply) &#123;</span></span><br><span class="line">      <span class="attr">option</span> <span class="string">(google.api.http) = &#123; </span></span><br><span class="line">          <span class="attr">post</span>: <span class="string">"/v1/greet/sayHello"</span></span><br><span class="line">          <span class="attr">body</span>: <span class="string">"*" </span></span><br><span class="line">      <span class="attr">&#125;;</span></span><br><span class="line">  <span class="attr">&#125;;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">message</span> <span class="string">HelloRequest &#123;</span></span><br><span class="line">  <span class="attr">string</span> <span class="string">name = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">message</span> <span class="string">HelloReply &#123;</span></span><br><span class="line">  <span class="attr">string</span> <span class="string">message = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>考虑到博主并不擅长<code>Go</code>这门语言，这里我们就不再对它做进一步的探索啦！事实上，我觉得这个方案非常糟糕，因为只要修改了<code>.proto</code>文件，这个代理服务器就要重新生成，更不用说只支持<code>Go</code>这一显著的缺点啦！</p><h1 id="封装-Web-API"><a href="#封装-Web-API" class="headerlink" title="封装 Web API"></a>封装 Web API</h1><p>封装 Web API，这是一个非常朴实无华的方案，博主目前的公司就是采用这种方案，所以，你能想象得到，基本就是在控制器中调用客户端。唯一的弊病在于，这是一个非常低效的工作。当年，博主的前公司，就是风风火火地要这样替换掉WCF，结果最终还是不了了之。所以说，世间没有银弹，历史不过是一次次地重复上演。下面是一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">SayHello</span>(<span class="params">HelloRequestDTO requestDTO</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = requestDTO.Adapt&lt;HelloRequest&gt;();</span><br><span class="line">    <span class="keyword">var</span> client = _serviceProvider.GetService&lt;Greeter.GreeterClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> replay = <span class="keyword">await</span> client.SayHelloAsync(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(replay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而一旦做到这一层，其实我们是把一个未知的问题转化成一个已知的问题，这是数学家最常用的思路。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">   method: <span class="string">'POST'</span>,</span><br><span class="line">   headers: headers,</span><br><span class="line">   body: <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'长安书小妆'</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">"https://localhost:44372/Greet/SayHello"</span>, options)</span><br><span class="line">   .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">   .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">   .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure><p>那么，下一个问题，你打算用 Fetch API 还是 Axios 呢？这个问题就交给前端的朋友啦！因为，我是一个伪全栈工程师(逃。</p><h1 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h1><p>其实，读到这里，你就会明白，这才是我真正要分享的内容，而此前种种，不过是我为了丰富这个话题而抛出的它山之石。既然觉得手写 Web API 太麻烦，那么我们能不能用一种新的思路来解决这个问题呢？这里说一下博主的思路，用户传入JSON，经过中间件反序列化为<code>.proto</code>对应的类型，我们将这个类型传递给 gRPC 的客户端作为请求参数，等拿到结果以后，我们再将它序列化为 JSON 即可。这样，我们就实现了将一个 gRPC 服务转化为 Web API 的想法。下面是具体的代码，其实这个代码并不复杂，我最初打算用反射来解决，可惜 gRPC 生成的这个客户端方法重载实在太多啦，所以，我最后决定用下面的这种方式。当然啦，缺点就和 gRPC-Gateway 一样，每一个接口都要单独写，好处大概是代码量减少了好多。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义扩展方法：AddGrpcGateway</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> AddGrpcGateway&lt;TClient,TRequest,TResponse&gt;(</span><br><span class="line">  <span class="keyword">this</span> IApplicationBuilder app, </span><br><span class="line">  <span class="keyword">string</span> route, </span><br><span class="line">  Func&lt;<span class="keyword">string</span>, TRequest&gt; requestBuilder, </span><br><span class="line">  Func&lt;TClient,TRequest,TResponse&gt; responseBuilder</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt; endpoints.MapPost(route, <span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> streamReader = <span class="keyword">new</span> StreamReader(context.Request.Body))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> client = (TClient)app.ApplicationServices.GetService(<span class="keyword">typeof</span>(TClient));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> payload = <span class="keyword">await</span> streamReader.ReadToEndAsync();</span><br><span class="line">            <span class="keyword">var</span> request = requestBuilder(payload);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> reply = responseBuilder(client, request);</span><br><span class="line">            <span class="keyword">var</span> response = JsonConvert.SerializeObject(reply);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> context.Response.Body.WriteAsync(Encoding.UTF8.GetBytes(response));</span><br><span class="line">            context.Response.StatusCode = <span class="number">200</span>;</span><br><span class="line">            context.Response.ContentType = <span class="string">"application/json"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，这个方案依赖 gRPC 的客户端代码，同时需要读取 HTTP 的请求体，所以，我们还需要下面的代码作为辅助：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(opt =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        opt.Address = <span class="keyword">new</span> Uri(<span class="string">"https://localhost:8001"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们通过中间件配置一个路由即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议放在 UseEndpoints() 方法下面</span></span><br><span class="line">app.AddGrpcGateway&lt;Greeter.GreeterClient, HelloRequest, HelloReply&gt;(</span><br><span class="line">    route: <span class="string">"greet/SayHello"</span>,</span><br><span class="line">    requestBuilder: json =&gt; <span class="keyword">new</span> MessageParser&lt;HelloRequest&gt;(() =&gt; <span class="keyword">new</span> HelloRequest()).ParseJson(json),</span><br><span class="line">    responseBuilder: (client, request) =&gt; client.SayHelloAsync(request).ResponseAsync.Result</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>为了证明这个中间件真的有用，我们用 <a href="https://www.apifox.cn/" target="_blank" rel="noopener">Apifox</a> 或者 <a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">Postman</a> 测试一下看看。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/21/hEmSVqOCy9tBbdv.png" alt="自定义中间件实现 gRPC 转 API 效果" referrerpolicy="no-referrer"></div><div class="image-caption">自定义中间件实现 gRPC 转 API 效果</div></figure><p>此时，可以看到，这就真的和调用一个 Web API 一样，我们完全意识不到，这是一个 gRPC 服务。你觉得，这样子算是达到目的了吗？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>其实，本文完全是临时想起来决定要写的一篇文章，起因就是看到了项目中有人在手动地封装 gRPC 服务为 RESTful 服务，当时就在想有没有一种方案，可以让这个过程稍微好一点点。所以，你可以认为，我写这篇博客的初衷，原来就是为了炫耀我写的那几行代码。不过，人到了一定的阶段以后，不管是写作还是思考，都似乎越来越喜欢某种框架结构，这种体验就有点像是上学时候写论文一样，虽然你明确地知道自己在做什么，可当你真正要把你的思路或者过程复述出来的时候，你还是需要有一个“文献综述”的环节。我个人以为，这是一种由外及内的认知方法，通过内外世界的对比来寻找自我提升的突破口。对于本文而言，不管是 <a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Web</a> 还是 <a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Gateway</a>，从本质上来讲，它们都是 Protocol Buffers 工具链中的插件，在这个过程中发现了平时使用 gRPC 过程中被隐藏了的一部分细节，这些细节如果能和开发工具完美结合的话，就可以极大地提升我们在 gRPC 方面的开发效率，譬如 gRPC-Web 在 .NET 中的实现就利用了 MSBuild 的自定义编译任务，这就让底层的Protocol Buffers 工具链、前端构建工具等对使用者来说是无感知的，从开发体验上就给人心旷神怡的感觉。我个人还是倾向于结合 ASP.NET Core 或者容器级别的 Envoy 来解决这个问题，我觉得应该还有更好的方案，希望大家可以在评论区写下你的想法。好啦，这篇博客就先写到这里，谢谢大家！</p><h1 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h1><p>截至2021年6月25日，基于中间件的方案已支持以下特性：自动注入客户端、自动配置路由。详情请参考：<a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/GRPC.Logging/Grpc.Gateway" target="_blank" rel="noopener">https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/GRPC.Logging/Grpc.Gateway</a>。在此方案下，只需要 4 行代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.AddGrpcClients(opt =&gt; opt.Address = <span class="keyword">new</span> Uri(<span class="string">"https://localhost:8001"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...     </span></span><br><span class="line">    app.AddGrpcGateway();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="前端" scheme="https://qinyuanpei.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Web" scheme="https://qinyuanpei.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>EFCore 实体命名约定库：EFCore.NamingConventions</title>
    <link href="https://qinyuanpei.github.io/posts/3219639636/"/>
    <id>https://qinyuanpei.github.io/posts/3219639636/</id>
    <published>2021-06-17T16:37:11.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在软件开发过程中，数据库永远都是绕不开的一个话题。有时候，我们甚至会因此而获得一个名字——“<strong>CURD Boy</strong>”。虽然不过是朴实无华的“<strong>增删查改</strong>”，可隐隐然早已分出了无数的流派。在这些不同的流派中，有的人坚持“<strong>我手写我心</strong>”，认为手写<code>SQL</code>才是真正的王道，没有读过/写过成百上千行的存储过程，便不足以谈论程序员的人生。而有的人喜欢<code>ORM</code>的清晰、整洁，认为数据库和面向对象存在着天然抗阻，<code>ORM</code>更有利于推进<code>DDD</code>和微服务的落地。相信大家都听说过<code>Java</code>里的<code>SSH</code>框架，从<code>Hibernate</code>到<code>Mybatis</code>再到<code>Spring Data JPA</code>，可以说这种争论一直没有停止过。这里我们不打算讨论这个问题，我们平时使用<code>EF</code>或者<code>EFCore</code>的过程中，作为连接数据库和面向对象两个异世界的桥梁，<code>ORM</code>需要我们来告诉它，实体数据与数据库表字段的映射关系，所以，经常需要通过<code>数据注解</code>或者<code>Fulent API</code>来写各种配置。那么，有没有什么方案可以让我们偷这个懒呢？下面隆重请出本文的主角：<a href="https://github.com/efcore/EFCore.NamingConventions" target="_blank" rel="noopener">EFCore.NamingConventions</a>。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p><a href="https://github.com/efcore/EFCore.NamingConventions" target="_blank" rel="noopener">EFCore. NamingConventions</a>，目前由一个非官方的组织进行维护，代码托管在 Github 上，100％的开源项目。</p><p>如果你希望直接使用它的话，可以直接通过<code>NuGet</code>进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package EFCore.NamingConventions</span><br></pre></td></tr></table></figure><p>接下来，我们只需要在<code>DbContext</code>的 <code>OnConfiguring()</code>方法中，调用它提供的扩展方法即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)  </span></span><br><span class="line"><span class="function"></span>=&gt; optionsBuilder  </span><br><span class="line">.UseSqlite(<span class="string">"Data Source=Chinook.db"</span>)</span><br><span class="line">.UseSnakeCaseNamingConvention();</span><br></pre></td></tr></table></figure><p>或者，你可以使用依赖注入的方式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddDbContext&lt;ChinookContext&gt;(options =&gt; </span><br><span class="line">    options.UseSqlite(<span class="string">"Data Source=Chinook.db"</span>)</span><br><span class="line">          .UseSnakeCaseNamingConvention()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里我以<code>SQLite</code>数据库为例，来展示它的具体使用细节。事实上，它提供了 4 种命名约定的策略：</p><ul><li>UseSnakeCaseNamingConvention: <code>FullName</code> -&gt; <code>full_name</code></li><li>UseLowerCaseNamingConvention: <code>FullName</code> -&gt; <code>fullname</code></li><li>UseCamelCaseNamingConvention: <code>FullName</code> -&gt; <code>fullName</code></li><li>UseUpperCaseNamingConvention: <code>FullName</code> -&gt; <code>FULLNAME</code></li></ul><p>简单来说，就是当我们的实体中存在一个属性<code>FullName</code>时，它会告诉<code>EF</code>或者<code>EFCore</code>，这个属性<code>FullName</code>对应的表字段是什么。</p><p>虽然，在大多数的场景中，我们都希望属性名称和表字段一致，可你要知道，像<code>Oracle</code>这种对大小写敏感的数据库，特别喜欢自作聪明地帮你全部改成大写。</p><p>所以，在上家公司工作的时候，为了兼容<code>Oracle</code>这病态的癖好，公司里有个不成文的规定，那就是：所有实体的属性名称最好都大写。</p><p>本来大家用驼峰命名就是为了好认单词，好家伙！这下全部大写了，一眼望过去简直就是灾难，因为没有办法做到“<strong>望文生义</strong>”，如果那个时候知道这个库的存在，是不是就能解决这个问题了呢？</p><h1 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h1><p>下面我们以<code>UseSnakeCaseNamingConvention</code>为例，结合<code>SQLite</code>来做一个简单的例子。</p><p>首先，我们定义必要的实体，并为<code>DbContext</code>配置实体命名约束规则：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Album</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Album</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> AlbumId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Artist</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Artist</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，通过迁移命令来生成数据库架构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration "Init-Database" -Context ChinookContext</span><br><span class="line">Update-Database</span><br></pre></td></tr></table></figure><p>可以注意到，生成的数据库表字段会以小写+下划线的方式命名。这就是所谓的实体命名约束。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/18/cSVRWrDTbnv29Ze.png" alt="通过实体命名约束生成的 Album 表" referrerpolicy="no-referrer"></div><div class="image-caption">通过实体命名约束生成的 Album 表</div></figure><p>只要大家都看着这个约定来写实体的属性，这套机制就可以完美工作。它和<code>MVC</code>里的默认路由一样，都是属于一种“<strong>约定大于配置</strong>”的方案。</p><p>在我看来，不管是配置还是约定。当以团队为单位进行协作时，最好还是以文档的形式记录下来，否则会出现两种结局，<strong>其一是没人知道怎么配置，其二是新人不知道有这个约定</strong>。</p><p>以上就是<code>EFCore.NamingConventions</code>的基本用法，更多的细节大家可以去阅读它的<code>README</code>，因为这个库需要结合迁移功能来使用，所以，如果要在已存在的表上应用这套约束规则时，建议大家还是小心谨慎一点。</p><p>我个人觉得，它可以方便团队去制定一套数据库规范，进而去约束开发人员写出更规范的命名。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要介绍了可用于<code>EFCore</code>的实体命名约束库：<code>EFCore.NamingConventions</code>。这是一个由社区维护的、开源的项目，它可以在创建<code>DbContext</code>的时候，指定一个实体命名约束规则，即实体属性如何与数据库表字段进行对应，这是一种约定大于配置的方案，一旦团队形成了属于自己的数据库命名风格，那么，研发人员只需要按照规范为实体属性命名，例如开发人员可以使用驼峰风格的命名，而数据库管理员则可以使用下划线风格的命名。这样，就可以省略一部分字段映射的配置代码，从而提高团队研发的效率。值得说明的一点是，不管是配置还是约定。当以团队为单位进行协作时，最好还是以文档的形式记录下来，否则会出现两种结局，<strong>其一是没人知道怎么配置，其二是新人不知道有这个约定</strong>。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据存储" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="实体" scheme="https://qinyuanpei.github.io/tags/%E5%AE%9E%E4%BD%93/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="数据库" scheme="https://qinyuanpei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="EF" scheme="https://qinyuanpei.github.io/tags/EF/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core gRPC 集成 Polly 实现优雅重试</title>
    <link href="https://qinyuanpei.github.io/posts/2742255459/"/>
    <id>https://qinyuanpei.github.io/posts/2742255459/</id>
    <published>2021-06-07T15:19:11.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在上一篇 <a href="https://blog.yuanpei.me/posts/1657075397/" target="_blank" rel="noopener">博客</a> 中，我们一起探索和实现了<code>gRPC</code>的健康检查。从服务治理的角度来看，健康检查保证的是被调用的服务“健康”或者“可用”。可即使如此，我们依然会遇到，因为网络不稳定等原因而造成的服务调用失败的情形，就如同我们赖以生存的这个真实世界，本身就充满了各种不确定的因素一样，“<strong>世间唯一不变的只有变化本身</strong>”。不管是面对不稳定的服务，还是面对不确定的人生，任何时候我们都需要有一个 B 计划，甚至我们人生中的一切努力，本质上都是为了多一份自由，一份选择的自由。在微服务的世界里，我们将这种选择称之为“<strong>降级(Fallback)</strong>”，如果大家有接触过 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Hystrix</a> 或者 <a href="https://github.com/App-vNext/Polly" target="_blank" rel="noopener">Polly</a> 这类框架，就会明白我这里的所说的“<strong>降级</strong>”具体是什么。在众多的“<strong>降级</strong>”策略中，<strong>重试</strong>是一种非常朴素的策略，尤其是当你调用一个不稳定的服务的时候。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/GIBVj3sKb5zMeE1.jpg" alt="重试" referrerpolicy="no-referrer"></div><div class="image-caption">重试</div></figure><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在此之前，博主曾经介绍过 <a href="https://blog.yuanpei.me/posts/2070070822/" target="_blank" rel="noopener">HttpClient</a> 的重试。所以，今天这篇博客我们来聊聊<code>gRPC</code>的客户端重试，因为要构建一个高可用的微服务架构，除了需要高可用的服务提供者，同样还需要高可用的服务消费者。下面，博主将由浅入深地为大家分享 4 种重试方案的实现，除了 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/retries?view=aspnetcore-3.1" target="_blank" rel="noopener">官方</a> 内置的方案，基本上都需要搭配 Polly 来使用，所以，到这里你可以理解这篇博客的标题，为什么博主会 <a href="https://music.163.com/#/song?id=167720" target="_blank" rel="noopener">毁人不倦</a> 地尝试不同的重试方案，因为每一种方案都有它自身的局限性，博主想要的是一种更优雅的方案。具体来讲，主要有：<strong>基于 gRPC RetryPolicy</strong>、<strong>基于 HttpClientFactory</strong>、<strong>基于 gRPC 拦截器</strong> 以及 <strong>基于CallInvoker</strong> 4 种方案。如果大家还有更好的思路，欢迎大家在博客评论区积极留言、参与讨论。</p><h1 id="基于-gRPC-RetryPolicy"><a href="#基于-gRPC-RetryPolicy" class="headerlink" title="基于 gRPC RetryPolicy"></a>基于 gRPC RetryPolicy</h1><p>所谓的 gRPC RetryPolicy，其实是指 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/retries?view=aspnetcore-3.1" target="_blank" rel="noopener">官方</a> 提供的暂时性故障处理方案，它允许我们在创建<code>GrpcChannel</code>的时候，去指定一个重试策略：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultMethodConfig = <span class="keyword">new</span> MethodConfig &#123;</span><br><span class="line">    Names = &#123; MethodName.Default &#125;,</span><br><span class="line">    RetryPolicy = <span class="keyword">new</span> RetryPolicy &#123;</span><br><span class="line">        MaxAttempts = <span class="number">5</span>,</span><br><span class="line">        InitialBackoff = TimeSpan.FromSeconds(<span class="number">1</span>),</span><br><span class="line">        MaxBackoff = TimeSpan.FromSeconds(<span class="number">5</span>),</span><br><span class="line">        BackoffMultiplier = <span class="number">1.5</span>,</span><br><span class="line">        RetryableStatusCodes = &#123; StatusCode.Unavailable &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>, <span class="keyword">new</span> GrpcChannelOptions &#123;</span><br><span class="line">    ServiceConfig = <span class="keyword">new</span> ServiceConfig &#123; MethodConfigs = &#123; defaultMethodConfig &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>MethodConfig</code>可以为指定的方法配置一个重试策略，当传入的方法名为<code>MethodName.Default</code>时，它将应用于该通道下的所有gRPC方法。如你所见，在重试策略中我们可以指定重试次数、重试间隔等参数。<strong>这个方案本身没有太多心智上的负担，唯一的缺点是，它没有预留出可扩展的接口</strong>，以至于我们想要验证它到底有没有重试的时候，居然要通过<code>Fiddler</code>抓包这种方式，换句话讲，我们没有办法自定义整个重试行为，譬如你想在重试过程中记录日志，这种方案就会鸡肋起来，<strong>对使用者来说，这完全就是一个黑盒子</strong>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/QzjaH4VqWMnEFcb.png" alt="官方自带的 “黑盒子” 重试机制" referrerpolicy="no-referrer"></div><div class="image-caption">官方自带的 “黑盒子” 重试机制</div></figure><p>除此之外，官方还提供了一种成为 <code>Hedging</code> 重试策略作为备选方案。类似地，它通过 <code>HedgingPolicy</code> 属性来指定重试策略。对比 <code>RetryPolicy</code>，它可以同时发送单个gRPC请求的多个副本，并使用第一个成功的结果作为返回值，所以，<strong>一个显而易见的约束是，它要求这个gRPC方法是无副作用的、幂等的函数</strong>。其实，这是所有重试方案都应该考虑的一个问题，而不单单是 <code>HedgingPolicy</code>。由于这两种策略有着本质上的不同，请记住：<strong>RetryPolicy不能与HedgingPolicy一起使用。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultMethodConfig = <span class="keyword">new</span> MethodConfig &#123;</span><br><span class="line">    Names = &#123; MethodName.Default &#125;,</span><br><span class="line">    HedgingPolicy = <span class="keyword">new</span> HedgingPolicy &#123;</span><br><span class="line">        MaxAttempts = <span class="number">5</span>,</span><br><span class="line">        NonFatalStatusCodes = &#123; StatusCode.Unavailable &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>, <span class="keyword">new</span> GrpcChannelOptions &#123;</span><br><span class="line">    ServiceConfig = <span class="keyword">new</span> ServiceConfig &#123; MethodConfigs = &#123; defaultMethodConfig &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>世间的一切都是双刃剑， <code>HedgingPolicy</code> 同样打不破这铁笼一般的人间真实，虽然它可以一次发送多个<code>gRPC</code>请求，可毫无疑问的是，<strong>这是一种相当浪费的策略，因为不管有多少个请求，它始终都取第一个结果作为返回值，而剩余的结果都将会被直接抛弃</strong>。想想每一年的高考状元，大家是不是都只记住了第一名。也许，人生正是如此呢，程序世界固然是由 0 和 1 构成的虚幻世界，可何尝就不是真实世界的某种投影呢？这里请允许博主安利一部动漫<a href="https://movie.douban.com/subject/30401194/" target="_blank" rel="noopener">《你好世界》</a>，它用视觉化的方式表达了真实世界与程序世界的某种特殊联系。</p><h1 id="基于-HttpClientFactory"><a href="#基于-HttpClientFactory" class="headerlink" title="基于 HttpClientFactory"></a>基于 HttpClientFactory</h1><p>接下来，我们要介绍的是基于 <code>HttpClentFactory</code> 的重试方案。也许，大家会感到困惑，明明这篇博客说的是 <code>gRPC</code> ，为什么 <code>HttpClientFactory</code> 会出现在这里呢？其实，很多时候，我们看到的只有表面，而出奇制胜的招式往往出自你对于本质的理解。如果大家阅读过 <code>gRPC</code> 客户端部分的源代码，就会意识到这样一件事情，即，<code>gRPC</code> 底层依然用到了 <code>HttpClient</code> 这套所谓“管道式”的体系，你可以理解为，最终传输层还是要交给 <code>HttpClient</code> 来处理，而 <code>HttpClientFactory</code> 本来就支持结合 <code>Polly</code> 进行重试，所以，我们其实是针对同一个问题的不同阶段进行了切入处理。一旦想清楚这一点，下面的代码理解起来就没有难度啦：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(opt =&gt; &#123;</span><br><span class="line">    opt.Address = <span class="keyword">new</span> Uri(<span class="string">"https://localhost:8001"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.ConfigurePrimaryHttpMessageHandler(() =&gt; <span class="keyword">new</span> HttpClientHandler &#123;</span><br><span class="line">    ClientCertificateOptions = ClientCertificateOption.Manual,</span><br><span class="line">    ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) =&gt; <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">.AddPolicyHandler(</span><br><span class="line">    HttpPolicyExtensions.HandleTransientHttpError()</span><br><span class="line">    .OrResult(res =&gt; res.StatusCode != System.Net.HttpStatusCode.OK)</span><br><span class="line">    .WaitAndRetryAsync(</span><br><span class="line">      <span class="number">6</span>, </span><br><span class="line">      retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="number">2</span>, retryAttempt)) + TimeSpan.FromMilliseconds(<span class="keyword">new</span> Random().Next(<span class="number">0</span>, <span class="number">100</span>)), </span><br><span class="line">      (result, timeSpan, current, context)=&gt; &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">$"StatusCode=<span class="subst">&#123;result.Result?.StatusCode&#125;</span>"</span>);</span><br><span class="line">          Console.WriteLine(<span class="string">$"Exception=<span class="subst">&#123;result.Exception?.Message&#125;</span>"</span>);</span><br><span class="line">          Console.WriteLine(<span class="string">$"正在进行第<span class="subst">&#123;current&#125;</span>次重试，间隔<span class="subst">&#123;timeSpan.TotalMilliseconds&#125;</span>秒"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">await</span> serviceProvider.GetService&lt;Greeter.GreeterClient&gt;().SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">"长安书小妆"</span> &#125;);</span><br></pre></td></tr></table></figure><p>在这里，为了模拟网络不畅的这种场景，我们故意指定了一个错误的终结点信息。此时，我们会得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/5yamSqIzbH3heXF.png" alt="基于 HttpClientFactory 的重试方案" referrerpolicy="no-referrer"></div><div class="image-caption">基于 HttpClientFactory 的重试方案</div></figure><p>不过话又说回来，因为我们选择切入的阶段是“<strong>传输层</strong>”，所以，相对于整个 <code>RpcException</code> 而言，我们其实是找到了一个问题的子集，这意味着这个方案并不能覆盖到所有的场景，如果是在非“<strong>传输层</strong>”引发了某种异常，我们就没有办法通过这种方式去做重试处理。所以，我在一开始就说过，没有 100% 完美的解决方案，每一种方案都有它自身的局限性，这句话在这里得到了第一次印证。如果大家再回过头去看第一种方案，是不是就会发现，它里面还是使用了<code>HTTP</code>状态码作为是否重试的判断依据。所以，大家觉得呢？欢迎大家在评论区留下你的想法。</p><h1 id="基于-gRPC-拦截器"><a href="#基于-gRPC-拦截器" class="headerlink" title="基于 gRPC 拦截器"></a>基于 gRPC 拦截器</h1><p>关于 <code>gRPC</code> 的拦截器，博主专门写过一篇 <a href="https://blog.yuanpei.me/posts/1679688265/" target="_blank" rel="noopener">博客</a> 来介绍它，所以，在一开始考虑重试方案的时候，拦截器其实是最容易想到的一种方案，主要思路是利用 <code>Polly</code> 中<code>Policy</code>的<code>Execute()</code>方法，对拦截器中获取<code>gRPC</code>调用结果的过程进行包装，我们一起来看下面的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">    TRequest request,</span><br><span class="line">    ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span><br><span class="line">    AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> retryPolicy =</span><br><span class="line">        Policy&lt;AsyncUnaryCall&lt;TResponse&gt;&gt;</span><br><span class="line">        .Handle&lt;RpcException&gt;(s =&gt; s.StatusCode == StatusCode.Internal)</span><br><span class="line">        .Or&lt;WebException&gt;()</span><br><span class="line">        .OrResult(r =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> awaiter = r.GetAwaiter();</span><br><span class="line">            <span class="keyword">if</span> (awaiter.IsCompleted)</span><br><span class="line">                <span class="keyword">return</span> r.GetStatus().StatusCode == StatusCode.OK;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.ResponseAsync.Wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AggregateException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .WaitAndRetryAsync(<span class="number">3</span>, x =&gt; TimeSpan.FromSeconds(<span class="number">5</span>), (result, timeSpan, current, context) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"正在进行第<span class="subst">&#123;current&#125;</span>次重试..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retryPolicy.ExecuteAsync(() =&gt; Task.FromResult(continuation(request, context))).Result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 <code>gRPC</code> 拦截器的这种方案，它最大的问题在于异常的颗粒度太大，这句话是什么意思呢？简单来讲就是在拦截器这个层面上，你能捕捉到的只有<code>RpcException</code>，这样就使得我们难以捕获更小粒度的异常，譬如网络异常、超时异常等等。其次，<code>gPRC</code> 拦截器中大量使用了，类似<code>AsyncUnaryCall&lt;TResponse&gt;</code>这样的异步的返回值类型，这让我们在编写 Policy 的时候，多多少少会有一点不自在。综上所述，这个最容易想到的方案，本身是没有太大的问题的，最关键的问题是我们能接受什么样的异常颗粒度。而像异步返回值这种问题，只要写过一次以后，博主以为，它并不会成为我们继续探索的阻碍，这一点大家可以自己去体会。</p><p>在尝试基于拦截器的重试方案的过程中，博主发现，指定一个错误的终结点信息，<code>gRPC</code>会在进入拦截器前就引发异常。这意味着这种基于拦截器的重试方案，在面对“<strong>传输层</strong>”的异常时略显乏力，所以，从某种程度上来讲，这个方案同样是一个不完美的方案。可这世上人来人往、本无完人，我们实在没有必要耽于技术方案的绝对完美而不可自拔，当求真、莫求执，所谓“<strong>大成若缺</strong>”，可以欣赏得来缺憾之美，同样是一种幸福。</p><h1 id="基于-CallInvoker"><a href="#基于-CallInvoker" class="headerlink" title="基于 CallInvoker"></a>基于 CallInvoker</h1><p>如果说，前面的3种方案都属于“<strong>见招拆招</strong>”的外家功夫。那么，接下来我要分享的思路，绝对可以称得上是“<strong>打通任督二脉</strong>”的玄门内功。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/IOwrYtdLXGxMeHf.png" alt="gRPC客户端底层原理说明" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC客户端底层原理说明</div></figure><p>首先，博主想用一张图来讲解 <code>gRPC</code> 客户端的工作原理。从这张图中，我们可以看出，初始化一个<code>gRPC</code>的客户端，主要有<code>GrpcChannel</code>和<code>CallInvoker</code>两种构造形式，而<code>GrpcChannel</code>中的<code>CreateCallInvoker()</code>方法会返回<code>HttpClientCallInvoker</code>的一个实例。此时，我们就会发现，<code>HttpClientCallInvoker</code>是<code>CallInvoker</code>的一个子类。所以，我们基本可以判定<code>CallInvoker</code>是一个扮演着重要角色的类。继续探索，我们就会发现，<code>GrpcCallInvokerFactory</code>内部通过构造<code>GrpcChannel</code>，进而实现了<code>CreateCallInvoker()</code>方法，换句话说，本质上依然是调用了<code>GrpcChannel</code>中的<code>CreateCallInvoker()</code>方法。最终，这个<code>CallInvoker</code>实例会作为参数，传递给<code>DefaultClientActivator</code>的<code>CreateClient()</code>方法，至此我们就完成了整个<code>gRPC</code>客户端的创建工作。</p><p>好了，相信现在大家都有一个疑问，这个<code>CallInvoke</code>到底是个什么东西呢？为什么它在整个<code>gRPC</code>的底层中是如此的重要呢？其实，它就是一个平平无奇的抽象类啦，可是一旦配合着<code>gRPC</code>中的<code>Calls</code>类来使用，这个<code>CallInvoker</code>简直就是扩展<code>gRPC</code>的一个重要的桥梁，因为我们不用关心底层是如何处理<code>gRPC</code>请求/响应的，而这丝毫不影响我们对这个过程进行自定义重写。因此，按照这样的思路，我们有了下面的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GrpcCallInvoker</span> : <span class="title">CallInvoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Channel _channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> GrpcPollyPolicyOptions _pollyOptions;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrpcCallInvoker</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        GrpcPollyPolicyOptions pollyOptions</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _channel = channel;</span><br><span class="line">        _pollyOptions = pollyOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncClientStreamingCall&lt;TRequest, TResponse&gt; AsyncClientStreamingCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, </span><br><span class="line">      CallOptions options</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncClientStreamingCall&lt;TRequest, TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncClientStreamingCall(CreateCall(method, host, options)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt; AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, </span><br><span class="line">      CallOptions options</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncDuplexStreamingCall(CreateCall(method, host, options)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncServerStreamingCall&lt;TResponse&gt; AsyncServerStreamingCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, CallOptions options, </span><br><span class="line">      TRequest request</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncServerStreamingCall&lt;TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncServerStreamingCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, </span><br><span class="line">      CallOptions options, </span><br><span class="line">      TRequest request</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncUnaryCall&lt;TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncUnaryCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> TResponse BlockingUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, </span><br><span class="line">      CallOptions options, </span><br><span class="line">      TRequest request</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;TResponse&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.BlockingUnaryCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想，经过连续三篇文章的洗礼，大家对这些方法应该都不陌生了吧！下面我们来着重讲解下<code>CreateCall()</code>和<code>CreatePollyPolicy()</code>这两个方法。其中，<code>CreateCall()</code>这个方法会相对简单一点，因为它完全就是返回<code>gRPC</code>的内置类型<code>CallInvocationDetails</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> CallInvocationDetails&lt;TRequest, TResponse&gt; CreateCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">    Method&lt;TRequest, TResponse&gt; method,</span><br><span class="line">    <span class="keyword">string</span> host,</span><br><span class="line">    CallOptions options</span><br><span class="line">)</span><br><span class="line">    <span class="keyword">where</span> TRequest : <span class="keyword">class</span></span><br><span class="line">    <span class="title">where</span> <span class="title">TResponse</span> : <span class="title">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallInvocationDetails&lt;TRequest, TResponse&gt;(_channel, method, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，<code>CreatePollyPolicy()</code>这个方法就非常的明确啦，通过注入的<code>GrpcPollyPolicyOptions</code>来构造一个Policy。考虑到我们要做的是一个通用的方案，这里预留了<strong>断路器</strong>、<strong>重试</strong>、<strong>超时</strong>三种不同策略的参数。如果希望对构建Policy的过程进行自定义，则可以通过重写该方法来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Policy&lt;TResult&gt; CreatePollyPolicy&lt;TResult&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    Policy&lt;TResult&gt; policy = <span class="literal">null</span>; ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造断路器策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.CircuitBreakerCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policyBreaker = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Exception&gt;()</span><br><span class="line">            .CircuitBreaker(_pollyOptions.CircuitBreakerCount, _pollyOptions.CircuitBreakerTime);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? policyBreaker :</span><br><span class="line">                    policy.Wrap(policyBreaker) <span class="keyword">as</span> Policy&lt;TResult&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断路器降级</span></span><br><span class="line">        <span class="keyword">var</span> policyFallBack = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Polly.CircuitBreaker.BrokenCircuitException&gt;()</span><br><span class="line">            .Fallback(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">default</span>(TResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        policy = policyFallBack.Wrap(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造超时策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.Timeout &gt; TimeSpan.Zero)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policyTimeout = Policy.Timeout(() =&gt; _pollyOptions.Timeout, Polly.Timeout.TimeoutStrategy.Pessimistic);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? (Policy&lt;TResult&gt;)policyTimeout.AsPolicy&lt;TResult&gt;() :</span><br><span class="line">        policy.Wrap(policyTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时降级</span></span><br><span class="line">        <span class="keyword">var</span> policyFallBack = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Polly.Timeout.TimeoutRejectedException&gt;()</span><br><span class="line">            .Fallback(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">default</span>(TResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        policy = policyFallBack.Wrap(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造重试策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.RetryCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> retryPolicy = Policy&lt;TResult&gt;.Handle&lt;Exception&gt;().WaitAndRetry(</span><br><span class="line">          _pollyOptions.RetryCount, </span><br><span class="line">          x =&gt; _pollyOptions.RetryInterval, </span><br><span class="line">          (result, timeSpan, current, context) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"正在进行第<span class="subst">&#123;current&#125;</span>次重试，间隔<span class="subst">&#123;timeSpan.TotalSeconds&#125;</span>秒"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? retryPolicy :</span><br><span class="line">            policy.Wrap(retryPolicy) <span class="keyword">as</span> Policy&lt;TResult&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们无法修改<code>DefaultGrpcClientFactory</code>中关于<code>CallInvoker</code>这部分的逻辑，所以，我们采取了下面的“<strong>迂回战术</strong>”：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc();</span><br><span class="line">services.AddTransient&lt;GrpcCallInvoker&gt;();</span><br><span class="line">services.AddTransient&lt;Channel&gt;(sp =&gt; <span class="keyword">new</span> Channel(<span class="string">"localhost"</span>, <span class="number">5001</span>, ChannelCredentials.Insecure));</span><br><span class="line">services.AddTransient&lt;GrpcPollyPolicyOptions&gt;(sp =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GrpcPollyPolicyOptions()</span><br><span class="line">    &#123;</span><br><span class="line">        RetryCount = <span class="number">10</span>,</span><br><span class="line">        RetryInterval = TimeSpan.FromSeconds(<span class="number">1</span>),</span><br><span class="line">        CircuitBreakerCount = <span class="number">5</span>,</span><br><span class="line">        CircuitBreakerTime = TimeSpan.FromSeconds(<span class="number">6</span>),</span><br><span class="line">        Timeout = TimeSpan.FromSeconds(<span class="number">10</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callInvoker = services.BuildServiceProvider().GetService&lt;GrpcCallInvoker&gt;();</span><br><span class="line"><span class="keyword">var</span> client = (Greeter.GreeterClient)Activator.CreateInstance(<span class="keyword">typeof</span>(Greeter.GreeterClient), callInvoker);</span><br><span class="line">client.SayHello(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">"长安书小妆"</span> &#125;);</span><br></pre></td></tr></table></figure><p>此时，如果我们故意写一个错误的终结点地址，我们将会得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/m67kG1hDfgyPJKs.png" alt="基于 CallInvoker 的重试方案" referrerpolicy="no-referrer"></div><div class="image-caption">基于 CallInvoker 的重试方案</div></figure><p>因为重试 5 次后就会启动断路器，所以，这个接口在重试 5 次后就立即停止了调用，这证明我们设想的这个方案是可以完美工作的！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>写完以后，突然发现这一篇的信息量有点爆炸，尤其是<code>CallInvoker</code>这一部分，需要花点时间去阅读 <a href="https://github.com/grpc/grpc-dotnet" target="_blank" rel="noopener">gRPC</a> 的源代码。可对于博主而言，其实更加享受的是，探索 <code>gRPC</code> 重试方案的这个过程。起初，因为对拦截器更熟悉一点，所以，我最先想到的是基于拦截器的重试方案。经过博主一番验证以后，发现这是一个有缺陷的方案。这时候，我意外发现，官方提供了重试策略，可这个重试策略对于使用者来说是一个黑盒子。再后来，发现可以在 HttpClient 上做一点文章，虽然它针对的是“<strong>传输层</strong>”这个阶段。直到从网上查资料，意识到可以重写<code>CallInvoker</code>这个抽象类，这个时候终于找到了最完美的方案。所以，通过这个过程，大家可以发现，我这篇博客的写作过程，其实与我思考过程有着明显的不同。思考的过程中带入“<strong>先入为主</strong>”的意识，这让我的思考过程走了不少的弯路，而写作过程则是一个由浅入深、由表及里的顺序。也许，下一次遇到类似的问题，我会先了解一下官方有没有提供标准方案，这是我在写完这篇博客以后最大的一个感悟。好了，这篇博客就先写到这里啦，如果大家对文中的内容由意见或者建议，欢迎大家在评论区给我留言，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="Polly" scheme="https://qinyuanpei.github.io/tags/Polly/"/>
    
      <category term="重试" scheme="https://qinyuanpei.github.io/tags/%E9%87%8D%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core gRPC 健康检查的探索与实现</title>
    <link href="https://qinyuanpei.github.io/posts/1657075397/"/>
    <id>https://qinyuanpei.github.io/posts/1657075397/</id>
    <published>2021-06-01T11:37:36.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>各位朋友，大家好，欢迎大家关注我的博客。在上一篇 <a href="https://blog.yuanpei.me/posts/1679688265/" target="_blank" rel="noopener">博客</a> 中，博主和大家分享了<code>gRPC</code>的拦截器在日志记录方面的简单应用，今天我们继续来探索<code>gRPC</code>在构建微服务架构方面的可能性。其实，从博主个人的理解而言，不管我们的微服务架构是采用<code>RPC</code>方式还是采用<code>RESTful</code>方式，我们最终要面对的问题本质上都是一样的，博主这里将其归纳为：服务划分、服务编写 和 服务治理。首先，服务划分决定了每一个服务的上下文边界以及服务颗粒度大小，如果按照领域驱动设计(<strong>DDD</strong>)的思想来描述微服务，我认为它更接近于限界上下文(<strong>BoundedContext</strong>)的概念。其次，服务编写决定了每一个服务的具体实现方式，譬如是采用无状态的<code>RESTful</code>风格的<code>API</code>，还是采用强类型的、基于代理的<code>RPC</code>风格的<code>API</code>。最后，服务治理是微服务架构中永远避不开的话题，服务注册、服务发现、健康检查、日志监控等等一切的话题，其实都是在围绕着<strong>服务治理</strong>而展开，尤其是当我们编写了一个又一个的服务以后，此时该如何管理这些浩如“<strong>星</strong>”海的服务呢？所以，在今天这篇博客中，博主想和大家一起探索下<code>gRPC</code>的健康检查，希望能给大家带来一点启发。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/02/oVS3YkPIncr2xM9.jpg" alt="健康检查-服务注册-服务发现示意图" referrerpolicy="no-referrer"></div><div class="image-caption">健康检查-服务注册-服务发现示意图</div></figure><p>关于“健康检查”，大家都知道的一点是，它起到一种“防微杜渐”的作用。不知道大家还记不记得，语文课本里的经典故事《扁鹊见蔡桓公》，扁鹊一直在告知蔡桓公其病情如何，而蔡桓公讳疾忌医，直至病入骨髓、不治而亡。其实，对应到我们的领域知识，后端依赖的各种服务譬如数据库、消息队列、Redis、API等等，都需要这样一个“<strong>扁鹊</strong>”来实时地“<strong>望闻问切</strong>”，当发现问题的时候及时地采取相应措施，不要像“<strong>蔡桓公</strong>”一样病入骨髓，等到整个系统都瘫痪了，这时候火急火燎地去“救火”，难免会和蔡桓公一样，发出“悔之晚矣”的喟叹。当我们决定使用<code>gRPC</code>来构建微服务架构的时候，我们如何确保这些服务一直是可用的呢？所以，提供一种针对<code>gRPC</code>服务的健康检查方案就会显得非常迫切。这里，博主主要为大家介绍两种实现方式，它们分别是：基于<code>IHostedService</code>的实现方式 以及 基于<code>Consul</code>的实现方式。</p><h1 id="基于-IHostedService-的实现方式"><a href="#基于-IHostedService-的实现方式" class="headerlink" title="基于 IHostedService 的实现方式"></a>基于 IHostedService 的实现方式</h1><p>第一种方式，主要是利用<code>IHostedService</code>可以在程序后台执行的特点，搭配<code>Timer</code>就可以实现定时轮询。在 <a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">gRPC</a> 的 <a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">官方规范</a> 中，提供了一份<code>Protocol Buffers</code>的声明文件，它规定了一个健康检查服务必须实现<code>Check()</code>和<code>Watch()</code>两个方法。既然是官方定义好的规范，建议大家不要修改这份声明文件，我们直接沿用即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">package grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  string service = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    SERVING = 1;</span><br><span class="line">    NOT_SERVING = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line">  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要实现对应的<code>HealthCheckService</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class HealthCheckService : Health.HealthBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HealthCheckResponse&gt; <span class="title">Check</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerCallContext context</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HealthCheckResponse() &#123; </span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">Watch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      IServerStreamWriter&lt;HealthCheckResponse&gt; responseStream, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerCallContext context</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> HealthCheckResponse()&#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要实现<code>HostedHealthCheckService</code>，它实现了<code>IHostedService</code>接口，并在其中调用<code>HealthCheckService</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HostedHealthCheckService</span> : <span class="title">IHostedService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Timer _timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HostedHealthCheckService&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostedHealthCheckService</span>(<span class="params">ILogger&lt;HostedHealthCheckService&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(HostedHealthCheckService)&#125;</span> start running...."</span>);</span><br><span class="line">        _timer = <span class="keyword">new</span> Timer(DoCheck, <span class="literal">null</span>, TimeSpan.Zero, TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(HostedHealthCheckService)&#125;</span> stop running...."</span>);</span><br><span class="line">        _timer?.Change(Timeout.Infinite, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoCheck</span>(<span class="params"><span class="keyword">object</span> state</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>); ;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> Health.HealthClient(channel);</span><br><span class="line">        client.Check(<span class="keyword">new</span> HealthCheckRequest() &#123; Service = <span class="string">"https://localhost:5001"</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，是大家非常熟悉的<strong>依赖注入</strong>环节：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigureServices</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GrpcServerLoggingInterceptor&gt;());</span><br><span class="line">    services.AddHostedService&lt;HostedHealthCheckService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;HealthCheckService&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大家对上一篇博客中的拦截器还有印象，对于下面的结果应该会感到非常亲切：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/02/vx2QLUoMzXaWpZY.png" alt="基于 IHostedService 的 gRPC 健康检查" referrerpolicy="no-referrer"></div><div class="image-caption">基于 IHostedService 的 gRPC 健康检查</div></figure><p>除此以外，我们还可以直接安装第三方库：<code>Grpc.HealthCheck</code>。此时，我们需要继承<code>HealthServiceImpl</code>类并重写其中的<code>Check()</code>和<code>Watch()</code>方法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthCheckService</span> : <span class="title">HealthServiceImpl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HealthCheckResponse&gt; <span class="title">Check</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerCallContext context</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HealthCheckResponse()</span><br><span class="line">        &#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">Watch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      IServerStreamWriter&lt;HealthCheckResponse&gt; responseStream, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerCallContext context</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> HealthCheckResponse()</span><br><span class="line">        &#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们只需要在<code>HostedHealthCheckService</code>调用它即可，这个非常简单。</p><p>故，无需博主多言，相信屏幕前的你都能写得出来，如果写不出来，参考博主给出得实现即可(逃！</p><h1 id="基于-Consul-的实现方式"><a href="#基于-Consul-的实现方式" class="headerlink" title="基于 Consul 的实现方式"></a>基于 Consul 的实现方式</h1><p><a href="https://www.consul.io/" target="_blank" rel="noopener">Consul</a> 是一个由 <a href="https://www.hashicorp.com/about" target="_blank" rel="noopener">HashiCorp</a> 提供的产品，它提供了服务注册、服务发现、健康检查、键值存储等等的特性。这里，我们通过集成它的<code>SDK</code>来实现<code>gRPC</code>服务的服务注册、服务发现、健康检查，从某种程度上来讲，它无形中帮助我们实现了客户端的负载均衡，因为我们可以将每一个服务的终结点都注册到<code>Consul</code>中，而<code>Consul</code>的健康检查则可以定时移除那些不可用的服务。所以，客户端获得的终结点实际上都是可用的终结点。</p><p>首先，我们需要安装第三方库：<code>Consul</code>。接下来，我们可需要通过<code>Docker</code>安装一下<code>Consul</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull consul</span><br><span class="line">docker run --name consul -d -p 8500:8500 consul</span><br></pre></td></tr></table></figure><p>默认情况下，<code>Consul</code>的端口号为：8500，我们可以直接访问：<code>http://localhost:8500</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/02/Gjb9XhpRCI7g2w5.png" alt="Consul 界面效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">Consul 界面效果展示</div></figure><p>接下来，为了让<code>Startup</code>类看起来清爽一点，首先，我们先来写一点扩展方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定的gRPC服务添加健康检查</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> AddGrpcHealthCheck&lt;TService&gt;(<span class="keyword">this</span> IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> configuration = services.BuildServiceProvider().GetService&lt;IConfiguration&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册ConsulClient</span></span><br><span class="line">    services.AddSingleton&lt;IConsulClient, ConsulClient&gt;(_ =&gt; <span class="keyword">new</span> ConsulClient(consulConfig =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> baseUrl = configuration.GetValue&lt;<span class="keyword">string</span>&gt;(<span class="string">"Consul:BaseUrl"</span>);</span><br><span class="line">        consulConfig.Address = <span class="keyword">new</span> Uri(baseUrl);</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册gRPC服务</span></span><br><span class="line">    RegisterConsul&lt;TService&gt;(services).Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>RegisterConsul()</code>方法负责告诉<code>Consul</code>，某个服务对应的IP和端口号分别是多少，采用什么样的方式进行健康检查。</p><p>不过，由于<code>Consul</code>默认不支持<code>gRPC</code>的健康检查，所以，我们使用了更为常见的基于<code>TCP</code>方式的健康检查。你可以认为，只要服务器连接畅通，<code>gRPC</code>服务就是健康的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册指定服务到Consul</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task RegisterConsul&lt;TService&gt;(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serverHost = GetLocalIP();</span><br><span class="line">    <span class="keyword">var</span> serverPort = services.BuildServiceProvider().GetService&lt;IConfiguration&gt;().GetValue&lt;<span class="keyword">int</span>&gt;(<span class="string">"gRPC:Port"</span>);</span><br><span class="line">    <span class="keyword">await</span> RegisterConsul&lt;TService&gt;(services, serverHost, serverPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册指定服务到Consul</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task RegisterConsul&lt;TService&gt;(</span><br><span class="line">  IServiceCollection services, </span><br><span class="line">  <span class="keyword">string</span> serverHost, </span><br><span class="line">  <span class="keyword">int</span> serverPort</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> client = services.BuildServiceProvider().GetService&lt;IConsulClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> registerID = <span class="string">$"<span class="subst">&#123;<span class="keyword">typeof</span>(TService).Name&#125;</span>-<span class="subst">&#123;serverHost&#125;</span>:<span class="subst">&#123;serverPort&#125;</span>"</span>;</span><br><span class="line">    <span class="keyword">await</span> client.Agent.ServiceDeregister(registerID);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.Agent.ServiceRegister(<span class="keyword">new</span> AgentServiceRegistration()</span><br><span class="line">    &#123;</span><br><span class="line">        ID = registerID,</span><br><span class="line">        Name = <span class="keyword">typeof</span>(TService).Name,</span><br><span class="line">        Address = serverHost,</span><br><span class="line">        Port = serverPort,</span><br><span class="line">        Check = <span class="keyword">new</span> AgentServiceCheck</span><br><span class="line">        &#123;</span><br><span class="line">            TCP = <span class="string">$"<span class="subst">&#123;serverHost&#125;</span>:<span class="subst">&#123;serverPort&#125;</span>"</span>,</span><br><span class="line">            Status = HealthStatus.Passing,</span><br><span class="line">            DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">            Interval = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">            Timeout = TimeSpan.FromSeconds(<span class="number">5</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        Tags = <span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"gRpc"</span> &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Consul</code>中的健康检查，更常用的是基于<code>HTTP</code>的健康检查，简单来说，就是我们提供一个接口，供<code>Consul</code>来调用，我们可以去设置请求的头(Header)、消息体(Body)、方法(Method)等等。所以，对于这里的实现，你还可以替换为更一般的实现，即提供一个API接口，然后在这个接口中调用<code>gRPC</code>的客户端。除此以外，如果你擅长写脚本，<code>Consul</code>同样支持脚本级别的健康检查。</p><p>在这里，博主水平扩展(复制)了两套服务，它们分别被部署在<code>5001</code>和<code>6001</code>两个端口上，通过<code>Consul</code>能达到什么效果呢？我们一起来看一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigureServices</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GrpcServerLoggingInterceptor&gt;());</span><br><span class="line">    services.AddGrpcHealthCheck&lt;GreeterService&gt;();</span><br><span class="line">    services.AddGrpcHealthCheck&lt;CalculatorService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;();</span><br><span class="line">        endpoints.MapGrpcService&lt;CalculatorService&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，此时，我们注意到<code>Consul</code>中有两个服务注册进去，它们分别是：<code>GreeterService</code> 和 <code>CalculatorService</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/02/eTBj7Iqn256GXKw.png" alt="gRPC 服务成功注册到 Consul 中" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC 服务成功注册到 Consul 中</div></figure><p>以其中一个<code>CalculatorService</code>为例，我们可以注意到，它的确注册了<code>5001</code>和<code>6001</code>两个实例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/03/xlhMjJ1ZcN3nwBe.png" alt="CalculatorService 的两个实例" referrerpolicy="no-referrer"></div><div class="image-caption">CalculatorService 的两个实例</div></figure><p>至此，我们就完成了基于<code>Consul</code>的健康检查，在这里，图中的绿色标记表示服务可用。</p><h1 id="关于-gRPC-的引申话题"><a href="#关于-gRPC-的引申话题" class="headerlink" title="关于 gRPC 的引申话题"></a>关于 gRPC 的引申话题</h1><p>其实，写到这里的时候，这篇博客就该接近尾声啦，因为对于 gRPC 健康检查的探索基本都已找到答案，可我还是想聊一聊关于 gRPC 的引申话题。理由特别简单，就是在我看来，接下来要讲的这点内容，完全撑不起一篇博客的篇幅，索性就在这篇博客里顺带一提。我打算分享两个话题，<strong>其一，是 gRPC 客户端的负载均衡；其二，是 gRPC 接口的测试工具。</strong></p><h2 id="gRPC-客户端的负载均衡"><a href="#gRPC-客户端的负载均衡" class="headerlink" title="gRPC 客户端的负载均衡"></a>gRPC 客户端的负载均衡</h2><p>截止到目前为止，结合<code>Consul</code>我们已经实现了服务注册和服务发现两个功能。通过调研我们可以发现，针对服务器端的<code>gRPC</code>的负载均衡，目前主要有<code>Nginx</code>和<code>Envoy</code>两种方案，这两种相方案对要更复杂一点，博主目前所在的公司，在<code>gRPC</code>的负载均衡上感觉是个空白，这算是博主想要研究<code>gRPC</code>的一个主要原因。而在这里，由于<code>Consul</code>里注册了所有<code>gRPC</code>服务的终结点信息，所以，我们更容易想到的，其实是客户端的负载均衡，具体怎么实现呢？我们一起看一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从Consul中获取服务终结点信息</span></span><br><span class="line"><span class="keyword">var</span> consulClient = serviceProvider.GetService&lt;IConsulClient&gt;();</span><br><span class="line"><span class="keyword">var</span> serviceName = <span class="keyword">typeof</span>(TGrpcClient).Name.Replace(<span class="string">"Client"</span>, <span class="string">"Service"</span>);</span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">await</span> consulClient.Health.Service(serviceName, <span class="keyword">string</span>.Empty, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> serviceUrls = services.Response.Select(s =&gt; <span class="string">$"<span class="subst">&#123;s.Service.Address&#125;</span>:<span class="subst">&#123;s.Service.Port&#125;</span>"</span>).ToList();</span><br><span class="line"><span class="keyword">if</span> (serviceUrls == <span class="literal">null</span> || !serviceUrls.Any())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Please make sure service <span class="subst">&#123;serviceName&#125;</span> is registered in consul"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造Channel和Client</span></span><br><span class="line"><span class="keyword">var</span> serviceUrl = serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Count - <span class="number">1</span>)];</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">$"https://<span class="subst">&#123;serviceUrl&#125;</span>"</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> <span class="keyword">var</span> client = <span class="keyword">new</span> Calculator.CalculatorClient(channel);</span><br><span class="line"><span class="keyword">await</span> client.CalcAsync(<span class="keyword">new</span> CalculatorRequest() &#123; Num1 = <span class="number">10</span>, Op = <span class="string">"+"</span>, Num2 = <span class="number">12</span> &#125;);</span><br></pre></td></tr></table></figure><p>可以看出，基本思路就是从<code>Consul</code>里拿到对应服务的终结点信息，然后构造出<code>GrpcChannel</code>，再通过<code>GrpcChannel</code>构造出Client即可。</p><p>不过，博主觉得这个过程有一点繁琐，我们有没有办法让这些细节隐藏起来呢？于是，我们有了下面的改进方案：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;TGrpcClient&gt; GetGrpcClientAsync&lt;TGrpcClient&gt;(</span><br><span class="line">  <span class="keyword">this</span> IServiceProvider serviceProvider</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> consulClient = serviceProvider.GetService&lt;IConsulClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> serviceName = <span class="keyword">typeof</span>(TGrpcClient).Name.Replace(<span class="string">"Client"</span>, <span class="string">"Service"</span>);</span><br><span class="line">    <span class="keyword">var</span> services = <span class="keyword">await</span> consulClient.Health.Service(serviceName, <span class="keyword">string</span>.Empty, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> serviceUrls = services.Response.Select(s =&gt; <span class="string">$"<span class="subst">&#123;s.Service.Address&#125;</span>:<span class="subst">&#123;s.Service.Port&#125;</span>"</span>).ToList();</span><br><span class="line">    <span class="keyword">if</span> (serviceUrls == <span class="literal">null</span> || !serviceUrls.Any())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Please make sure service <span class="subst">&#123;serviceName&#125;</span> is registered in consul"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> serviceUrl = serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Count - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">$"https://<span class="subst">&#123;serviceUrl&#125;</span>"</span>);</span><br><span class="line">    <span class="keyword">var</span> constructorInfo = <span class="keyword">typeof</span>(TGrpcClient).GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(GrpcChannel) &#125;);</span><br><span class="line">    <span class="keyword">if</span> (constructorInfo == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Please make sure <span class="subst">&#123;<span class="keyword">typeof</span>(TGrpcClient).Name&#125;</span> is a gRpc client"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clientInstance = (TGrpcClient)constructorInfo.Invoke(<span class="keyword">new</span> <span class="keyword">object</span>[] &#123; channel &#125;);</span><br><span class="line">    <span class="keyword">return</span> clientInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，有没有觉得简单一点？完美！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">await</span> serviceProvider.GetGrpcClientAsync&lt;CalculatorClient&gt;();</span><br><span class="line"><span class="keyword">await</span> client.CalcAsync(<span class="keyword">new</span> CalculatorRequest() &#123; Num1 = <span class="number">1</span>, Num2 = <span class="number">2</span>, Op = <span class="string">"+"</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="gRPC-接口的测试工具"><a href="#gRPC-接口的测试工具" class="headerlink" title="gRPC 接口的测试工具"></a>gRPC 接口的测试工具</h2><p>我猜，大多数看到这个标题会一脸鄙夷，心里大概会想，就测试工具这种东西值得特地写出来吗？诚然，以前写API接口的时候，大家都是用 <a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">Postman</a> 或者 <a href="https://www.apifox.cn/" target="_blank" rel="noopener">Apifox</a> 这样的工具来进行测试的，可是突然有一天你要调试一个<code>gRPC</code>的接口，你总不能每次都调用客户端啊，所以，这里要给大家推荐两个<code>gRPC</code>接口的测试工具，它们分别是: <a href="https://github.com/fullstorydev/grpcurl" target="_blank" rel="noopener">grpcurl</a> 和 <a href="https://github.com/fullstorydev/grpcui" target="_blank" rel="noopener">grpcui</a>，它们都出自同一个人 <a href="https://github.com/fullstorydev" target="_blank" rel="noopener">FullStory</a> 之手，基于Go语言开发，简单介绍下使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 建议使用国内源</span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line">// grpcurl</span><br><span class="line">brew install grpcurl</span><br><span class="line"></span><br><span class="line">// grpcui</span><br><span class="line">go get github.com/fullstorydev/grpcui/...</span><br><span class="line">go install github.com/fullstorydev/grpcui/cmd/grpcui</span><br><span class="line"></span><br><span class="line">// 安装后的路径为：C:\Users\&lt;User&gt;\go\bin\grpcui.exe</span><br><span class="line">grpcui -bind &lt;Your-IP&gt; -plaintext &lt;Your-gRPC-Service&gt;</span><br></pre></td></tr></table></figure><p>虽然这个说明简单而直白，可我还是没能装好，我不得不祭出Docker这个神器，果然它不会令我失望：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull wongnai/grpcui</span><br><span class="line">docker run -e GRPCUI_SERVER=localhost:5001 -p 8080:8080 wongnai/grpcui</span><br></pre></td></tr></table></figure><p>这里有两个重要的参数，其中，<code>8080</code>是<code>grpcui</code>的服务地址，可以按个人喜好进行修改，<code>GRPCUI_SERVER</code>是<code>gRPC</code>服务地址，该工具运行效果如下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/03/gGMaVKquDbtdWUN.png" alt="gRPCUI 接口测试工具" referrerpolicy="no-referrer"></div><div class="image-caption">gRPCUI 接口测试工具</div></figure><p>对于使用者来说，我们只需要选择服务(service)、方法(rpc)、然后填入参数即可，个人感觉非常方便。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文探索并实现了<code>gRPC</code>服务健康检查，主要提供了两种思路：基于<code>IHostedService</code> + <code>Timer</code>的轮询的方案 以及 基于<code>Consul</code>的集服务注册、服务发现、健康检查于一身的方案。特别地，对于后者而言，我们可以顺理成章地联想到客户端的负载均衡，其原理是：<code>Consul</code>中注册了所有<code>gRPC</code>服务的终结点信息，通过<code>IConsulClient</code>可以拿到所有可用的终结点信息，只要以此为基础来构建<code>GrpcChannel</code>即可。根据这个原理，我们引申出了<code>gRPC</code>客户端负载均衡的相关话题，这里我们采用的是随机选择一个终结点信息的做法，事实上，按照一般负载均衡的理论，我们还可以采取轮询、加权、Hash等等的算法，大家可以按照自己的业务场景来选择合适的方法。最后，我们简单介绍了下<code>gRPC</code>接口测试方面的内容，它可以帮助我们更高效地编写、验证<code>gRPC</code>接口。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、参与讨论，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="健康检查" scheme="https://qinyuanpei.github.io/tags/%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    
      <category term="Consul" scheme="https://qinyuanpei.github.io/tags/Consul/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core gRPC 拦截器的使用技巧分享</title>
    <link href="https://qinyuanpei.github.io/posts/1679688265/"/>
    <id>https://qinyuanpei.github.io/posts/1679688265/</id>
    <published>2021-05-26T09:03:35.000Z</published>
    <updated>2021-10-09T03:32:42.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p><code>gRPC</code>是微软在<code>.NET Core</code> 及其后续版本中主推的 RPC 框架，它使用 <code>Google</code> 的 <code>Protocol Buffers</code> 作为序列化协议，使用 <strong>HTTP/2</strong> 作为通信协议，具有<strong>跨语言</strong>、<strong>高性能</strong>、<strong>双向流式调用</strong>等优点。考虑到，接下来要参与的是，一个以<code>gRPC</code>为核心而构建的微服务项目。因此，博主准备调研一下<code>gRPC</code>的相关内容，而首当其冲的，则是从 .NET Core 3.1 开始就有的拦截器，它类似于<code>ASP.NET Core</code>中的过滤器和中间件，体现了一种面向切面编程(<strong>AOP</strong>)的思想，非常适合在RPC服务调用的时候做某种统一处理，譬如参数校验、身份验证、日志记录等等。在今天这篇博客中，博主主要和大家分享的是，利用 .NET Core gRPC 中的拦截器实现日志记录的简单技巧，希望能给大家带来一点启发。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/28/1MgBG2uRHwEqXvt.jpg" alt="开源、多语言、高性能的 gRPC" referrerpolicy="no-referrer"></div><div class="image-caption">开源、多语言、高性能的 gRPC</div></figure><h1 id="关于-Interceptor-类"><a href="#关于-Interceptor-类" class="headerlink" title="关于 Interceptor 类"></a>关于 Interceptor 类</h1><p><code>Interceptor</code>类是 gRPC 服务拦截器的基类，它本身是一个抽象类，其中定义了下面的虚方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncClientStreamingCall&lt;TRequest, TResponse&gt; AsyncClientStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt; AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> TResponse BlockingUnaryCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task&lt;TResponse&gt; ClientStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncServerStreamingCall&lt;TResponse&gt; AsyncServerStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task DuplexStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task ServerStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task&lt;TResponse&gt; UnaryServerHandler&lt;TRequest, TResponse&gt;();</span><br></pre></td></tr></table></figure><p>整体而言，如果从通信方式上来划分，可以分为：<strong>流式调用</strong> 和 <strong>普通调用</strong>；而如果从使用方来划分，则可以分为：<strong>客户端</strong> 和 <strong>服务端</strong>。进一步讲的话，针对<strong>流式调用</strong>，它还分为：”<strong>单向流</strong>“ 和 “<strong>双向流</strong>“。关于这些细节上的差异，大家可以通过 <code>gRPC</code> 的 <a href="https://www.grpc.io/docs/what-is-grpc/core-concepts/" target="_blank" rel="noopener">官方文档</a> 来了解，这里我们给出的是每一种方法对应的用途：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>AsyncClientStreamingCall</td><td>拦截异步客户端流式调用</td></tr><tr><td>AsyncDuplexStreamingCall</td><td>拦截双向流式调用</td></tr><tr><td>AsyncUnaryCall</td><td>拦截异步普通调用</td></tr><tr><td>BlockingUnaryCall</td><td>拦截阻塞普通调用</td></tr><tr><td>AsyncServerStreamingCall</td><td>拦截异步服务端流式调用</td></tr><tr><td>ClientStreamingServerHandler</td><td>拦截客户端流式调用的服务端处理程序</td></tr><tr><td>DuplexStreamingServerHandler</td><td>拦截双向流式调用的服务端处理程序</td></tr><tr><td>ServerStreamingServerHandler</td><td>拦截服务端流式调用的服务端处理程序</td></tr><tr><td>UnaryServerHandler</td><td>拦截普通调用的服务端处理程序</td></tr></tbody></table><h1 id="实现一个拦截器"><a href="#实现一个拦截器" class="headerlink" title="实现一个拦截器"></a>实现一个拦截器</h1><p>好了，下面我们一起实现一个拦截器。这里，我们使用的是微软官方的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GreeterService : Greeter.GreeterBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GreeterService&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreeterService</span>(<span class="params">ILogger&lt;GreeterService&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HelloReply&gt; <span class="title">SayHello</span>(<span class="params">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HelloReply</span><br><span class="line">        &#123;</span><br><span class="line">            Message = <span class="string">"Hello "</span> + request.Name</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>实现服务器端的普通调用拦截，我们需要重写的方法是<code>UnaryServerHandler</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCServerLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GRPCServerLoggingInterceptor&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GRPCServerLoggingInterceptor</span>(<span class="params">ILogger&lt;GRPCServerLoggingInterceptor&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 UnaryServerHandler() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> Task&lt;TResponse&gt; UnaryServerHandler&lt;TRequest, TResponse&gt;(</span><br><span class="line">      TRequest request, ServerCallContext context, </span><br><span class="line">      UnaryServerMethod&lt;TRequest, TResponse&gt; continuation</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish."</span>);</span><br><span class="line">        _logger.LogInformation(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC请求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> LogRequest&lt;TRequest&gt;(TRequest request)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">is</span> IMessage)</span><br><span class="line">            payload = JsonConvert.SerializeObject(</span><br><span class="line">                (request <span class="keyword">as</span> IMessage)</span><br><span class="line">                .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(request <span class="keyword">as</span> IMessage))</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"Send request of <span class="subst">&#123;<span class="keyword">typeof</span>(TRequest)&#125;</span>:<span class="subst">&#123;payload&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC响应</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> LogResponse&lt;TResponse&gt;(TResponse response, AggregateException exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (response <span class="keyword">is</span> IMessage)</span><br><span class="line">                payload = JsonConvert.SerializeObject(</span><br><span class="line">                  (response <span class="keyword">as</span> IMessage)</span><br><span class="line">                  .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                  .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(response <span class="keyword">as</span> IMessage))</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span>:<span class="subst">&#123;payload&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> errorMsgs = <span class="keyword">string</span>.Join(<span class="string">";"</span>, exception.InnerExceptions.Select(x =&gt; x.Message));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span> throws exceptions: <span class="subst">&#123;errorMsgs&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>gRPC</code>而言，每一个由<code>.proto</code>声明文件生成的类，都带有一个叫做<code>Descriptor</code>的属性，我们可以利用这个属性获得<code>gRPC</code>请求和响应的详细信息。所以，在<code>LogRequest()</code>和<code>LogResponse()</code>两个方法中，我们均使用了这一思路来记录<code>gRPC</code>的报文信息，因为传输层的<code>gRPC</code>使用了二进制作为数据载体，这可以说是一种用可读性换取高效率的做法，不过幸运的是，我们在这里实现了这个小目标。</p><p>接下来，为了让这个拦截器真正生效，我们还需要修改一下<code>Startup</code>类中注册<code>gRPC</code>这部分的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GRPCServerLoggingInterceptor&gt;());</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/27/3nZXelLPVwJ7AjS.png" alt="gRPC服务器端拦截器效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC服务器端拦截器效果展示</div></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>实现客户端的普通调用拦截，我们需要重写的方法是<code>AsyncUnaryCall()</code>，依样画葫芦即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCClientLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重写 AsyncUnaryCall() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">        TRequest request,</span><br><span class="line">        ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span><br><span class="line">        AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.ResponseAsync.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.ResponseAsync.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish."</span>);</span><br><span class="line">        Console.WriteLine(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，为了让拦截器在客户端生效，我们需要这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Grpc.Core.Interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>);</span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line">channel.Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">var</span> invoker = channel.CreateCallInvoker().Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(invoker);</span><br><span class="line"><span class="keyword">await</span> client.SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">"长安书小妆"</span> &#125;);</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/28/XcwmOQbzKTJPtUj.png" alt="gRPC客户端拦截器效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC客户端拦截器效果展示</div></figure><p>客户端感觉不太好的一点就是，这个<code>Interceptor</code>传入的必须是一个实例，考虑到拦截器内部可能会依赖类似<code>ILogger</code>等等的组件，建议还是通过<code>IoC</code>容器来取得一个拦截器的实例，然后再传入<code>Intercept()</code>方法中。博主所在的项目中，则是非常“<strong>土豪</strong>”地使用了<code>PostSharp</code>，直接走动态编织的方案，果然，“<strong>这次第，怎一个羡字了得</strong>”。当然，<code>gRPC</code>的客户端，其实提供了日志相关的支持，不过，我个人感觉这个有一点无力：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggerFactory = LoggerFactory.Create(logging =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    logging.AddConsole();</span><br><span class="line">    logging.SetMinimumLevel(LogLevel.Debug);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(</span><br><span class="line">    <span class="string">"https://localhost:5001"</span>,</span><br><span class="line">    <span class="keyword">new</span> GrpcChannelOptions &#123; LoggerFactory = loggerFactory &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要分享了<code>gRPC</code>拦截器的使用技巧，<code>gRPC</code>支持一元调用(<strong>UnaryCall</strong>)、流式调用(<strong>StreamingCall</strong>)、阻塞调用(<strong>BlockingCall</strong>)，因为区分客户端和服务器端，所以，实际上会有各种各样的组合方式。<code>gRPC</code>的拦截器实际上就是选择对应的场景去重写相应的方法，其中，拦截器的基类为<code>Interceptor</code>类，这里我们都是以普通的一元调用为例的，大家可以结合各自的业务场景，去做进一步的调整和优化。这里，我们使用<code>IMessage</code>类的<code>Descriptor</code>属性来“反射”报文中定义的字段，这样就实现了针对<code>gRPC</code>服务请求/响应的日志记录功能。关于<code>gRPC</code>中日志和诊断的更进一步的话题，大家可以参考微软的 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/diagnostics?view=aspnetcore-5.0" target="_blank" rel="noopener">官方文档</a> 。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="AOP" scheme="https://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="日志" scheme="https://qinyuanpei.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>SnowNLP 使用自定义语料进行模型训练</title>
    <link href="https://qinyuanpei.github.io/posts/1772340994/"/>
    <id>https://qinyuanpei.github.io/posts/1772340994/</id>
    <published>2021-05-19T21:22:41.000Z</published>
    <updated>2021-10-09T03:32:42.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p><a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 是一个功能强大的中文文本处理库，它囊括了中文分词、词性标注、情感分析、文本分类、关键字/摘要提取、<code>TF/IDF</code>、文本相似度等诸多功能，像<strong>隐马尔科夫模型</strong>、<strong>朴素贝叶斯</strong>、<code>TextRank</code>等算法均在这个库中有对应的应用。如果大家仔细观察过博主的博客，就会发现博主使用了摘要提取这一功能来增强博客的<code>SEO</code>，即通过自然语言处理(<strong>NLP</strong>)技术，提取每一篇文章中的摘要信息。因为 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 本身使用的语料是电商网站评论，所以，当我们面对不同的使用场景时，它自带的这个模型难免会出现“水土不服”。因此，如果我们希望得到更接近实际的结果，最好的方案是使用自定义语料进行模型训练。值得庆幸的是，这一切在 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 中实施起来非常简单，并不需要我们去钻研那些高深莫测的算法。至此，就引出了今天这篇博客的主题，即 SnowNLP 使用自定义语料进行模型训练。</p><p>不知道大家是否还有印象，博主曾经在 <a href="https://blog.yuanpei.me/posts/2758545080/" target="_blank" rel="noopener">《通过Python分析2020年全年微博热搜数据》</a> 这篇文章中提到过 SnowNLP 的模型训练。当时，博主采集了整个 2020 年的微博热搜话题，因为要体现整个一年里的情感变化，博主特意找了两份微博语料，并以此为基础训练出了一个模型文件。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/26/gCcHX7vWlwsZhnI.jpg" alt="2020全年微博热搜情感变化趋势" referrerpolicy="no-referrer"></div><div class="image-caption">2020全年微博热搜情感变化趋势</div></figure><p>那么，具体是怎么样做的呢？我们一起来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> sentiment</span><br><span class="line">sentiment.train(<span class="string">'./train/neg60000.txt'</span>, <span class="string">'./train/pos60000.txt'</span>)</span><br><span class="line">sentiment.save(<span class="string">'weibo.marshal'</span>)</span><br></pre></td></tr></table></figure><p>千万不要怀疑你的眼睛，因为它真的只有短短的三行代码。简单来说，我们只需要准备一个“<strong>积极</strong>”的语料文件，一个“<strong>消极</strong>”的语料文件，它就可以训练出一个模型文件。特别注意的是，如果是在<code>Python 3.X</code>的版本下，最终生成的模型文件的扩展名将会是<code>.3</code>，下图是博主这里训练出的模型文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/20/EQnaXv3x6Vyfm7j.png" alt="SnowNLP 使用自定义语料进行模型训练" referrerpolicy="no-referrer"></div><div class="image-caption">SnowNLP 使用自定义语料进行模型训练</div></figure><p>好了，一旦训练出这个模型文件，我们就可以考虑替换掉 SnowNLP 的默认模型文件，我们可以在以下位置：<code>\Lib\site-packages\snownlp\sentiment</code> 找到下列文件。为了安全起见，我们首先将原来的模型文件重命名，然后再放入我们自己的模型文件。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/20/C5QS3uhvt1liqXc.png" alt="SnowNLP 使用自定义模型替换默认模型" referrerpolicy="no-referrer"></div><div class="image-caption">SnowNLP 使用自定义模型替换默认模型</div></figure><p>此时，我们就可以利用训练好的模型，分析某一条微博的情感倾向。这里我选取了几条我的微博，看看这个情感倾向预测的结果如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> SnowNLP</span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'我爱你，并不期待回声'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.8760737296091975</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'想找一个人，一起做老爷爷、老奶奶才做的事情，比如，替我拔一拔头上的白头发……[二哈] ​​'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.001629297651780881</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'如果两个人都不爱了，一别两宽，各生欢喜，其实是挺好的结局；可如果还有一个人爱着，对那个人来说，爱又是什么呢？'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.809651945221708</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'为了发张自拍，特意出来跑步，还有谁？[doge] ​​​'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.4041057894917053</span></span><br></pre></td></tr></table></figure><p>有人说，双子座是一个白天自愈、晚上孤独的星座，我确信这是真的，因为从我出生的那一刻起，那种宏大宇宙中的孤独感就一直笼罩着我，用一句话来形容，大概就是“<strong>热闹是人家的，我什么都没有</strong>”，因为内心世界里的两个灵魂，从来没有一刻闲歇地在纠缠和撕裂。我一直都想了解一件事情，如果这些基于概率或者是公式的算法，都可以琢磨出人类某个时刻的心境，我们期望别人能懂自己是不是太过矫情，我们是真的了解自己吗？</p><p>OK，说完微博话题这个场景，我们再来说说电影评论这个场景。回想今年过年的时候，一部<a href="https://movie.douban.com/subject/34841067/" target="_blank" rel="noopener">《你好，李焕英》</a>，成为贺岁档电影中的一匹黑马，而相比之下，<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a>则有点“<strong>滑铁卢</strong>”的感觉。为了搞清楚某一部电影真实的评价情况，此时，我们可以考虑使用 SnowNLP ，对影评的情感趋向进行打分。同样地，这里我们找了一部分影评语料，为 SnowNLP 训练一个单独的模型。接下来，我们不妨从豆瓣上抓取一定数量的影评，来验证下我们这里训练好的模型，这里以<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a>为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/22/5Mo1ncNyEO2K69j.png" alt="从豆瓣上抓取到的电影评论" referrerpolicy="no-referrer"></div><div class="image-caption">从豆瓣上抓取到的电影评论</div></figure><p>可以发现，这些影评的情感趋向介于0到0.1这个区间的数量最多，占到160以上，这意味着约有30%的观众认为这部电影是个不折不扣的烂片。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/22/1hvXtjciPlWBzD9.jpg" alt="唐人街探案3豆瓣影评情感分布" referrerpolicy="no-referrer"></div><div class="image-caption">唐人街探案3豆瓣影评情感分布</div></figure><p>目前，<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a> 在豆瓣上的评分只有5.5分，其中，2星和3星的评价占到70%以上。由于豆瓣接口的限制，我们大概只能抓到500条左右的影评信息，可即使如此，可以看出大家对这部电影的情绪多少有一点不满。博主当时看这个电影，最大的感受是里面充斥着太多强行搞笑的东西，例如开篇机场那一场打砸抢的戏份，我完全不明白它存在的意义是什么，虽然日本演员们的表演可圈可点，可在这样一个推理和叙事都非常脆弱的故事里，大概就剩下翻来覆去重复使用的搞笑伎俩啦，你敢说医院这场戏和第一部阿香家那场戏没有相似的地方吗？更不用说，医院这场戏大家都在评论里无限吐槽啦！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/22/MRsAc76vgmTEK4z.png" alt="豆瓣电影-唐人街探案3" referrerpolicy="no-referrer"></div><div class="image-caption">豆瓣电影-唐人街探案3</div></figure><p>其实，对于情感，我一直不知道该怎么来讲，可能是程序员的这份理性，让我在维系亲密关系或者说的情感的时候，有时候会生出一种近乎漠然的、置身事外的错觉，换句话说，也许是那种被人称为“<strong>天性凉薄</strong>”的东西。前任同我讲，我最爱的人其实是我自己，并不是她。因为站在她的角度上来讲，她并没有感受到我给予她的爱。我该怎么回答这个问题呢？在一切看似理性的数学计算背后，人类这些极为在乎的情感到底又是什么形式？也许有一天，两个人的感情说变淡就突然变淡，不管我们曾经说过什么样的话，在那一刻都会变得苍白无力，逐年攀升的离婚率触目惊心，可我们每个人都像扑向火焰的飞蛾，在这爱与欲望无法随心所欲的世界里，被欲望裹挟着不断向前。人会变的绝情、冷漠，我们自以为那是成长，可那不过是心变硬了，可这是我们当初期待的长大吗？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/08/HrQbtvcjeI1h9M3.png" alt="欢迎来到无法随心所欲的爱与欲望的世界" referrerpolicy="no-referrer"></div><div class="image-caption">欢迎来到无法随心所欲的爱与欲望的世界</div></figure><p>今天，听到袁隆平爷爷去世的消息，除了不断地提醒我们这代人已然老去这个事实以外，也许最大的体会应该是，我们在这个世界上追求的名利、身份和爱，最终都会无可避免地走向消亡，就如同我们身上这具躯壳一样，而真正能流传下去、泽被后世地，永远都是思想、是文化、是技术、是精神。佛家云：人死身灭，大概我们都不得不去接受这个残酷的事实，所以，请放下那些爱而不得、求而不得的执念吧，你一辈子不管遇见多少人，在某一个时候也许就会荡然无存，爱会消失、身会毁灭，这一切都是宇宙间的自然法则，与其去纠结那些“<strong>薛定谔态</strong>”的事物，不如多为这个世界做一点有意义的事情，正如尼采的那句名言，“<strong>对待生命你不妨大胆冒险一点, 因为无论如何你都要失去它</strong>”，我也许并不真正懂得人类的情感，因为它在理性面前毫无意义，世间万物毫无例外地走向那个坍塌的奇点，这难道不是一种荒凉的美感吗？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/22/kjR2nVSHlDNrCLi.jpg" alt="人的心情难道不是一个黑洞" referrerpolicy="no-referrer"></div><div class="image-caption">人的心情难道不是一个黑洞</div></figure><p>嘘，如果你读到这里，意外发现这是一篇水字数的博客，而这或许说明了一件事情，我的确是一个会懈怠、会疲倦的活生生的人。关于 SnowNLP 使用自定义语料进行模型训练的话题，这次我们就先写到这里，做数据挖掘的时候，有的人在乎的是最终的结果，而有的人享受的是整个过程，人类的情感或许是相似的，所以，学着去接受这个多样性有点多到奇葩的世界，学着去和平凡而普通的自己和解吧，欢迎大家在评论区交换想法或者观点，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="NLP" scheme="https://qinyuanpei.github.io/tags/NLP/"/>
    
      <category term="训练" scheme="https://qinyuanpei.github.io/tags/%E8%AE%AD%E7%BB%83/"/>
    
      <category term="模型" scheme="https://qinyuanpei.github.io/tags/%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="情感" scheme="https://qinyuanpei.github.io/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>假如时间有温度</title>
    <link href="https://qinyuanpei.github.io/posts/2136925853/"/>
    <id>https://qinyuanpei.github.io/posts/2136925853/</id>
    <published>2021-05-03T14:00:41.000Z</published>
    <updated>2021-10-09T03:32:42.609Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>我一直在想，世事无常，该是一种什么样的感觉。直到我读到夏目先生的《我是猫》，先生在书中不无感慨地写道，“<strong>世事变迁就像猫的眼珠一样变幻莫测</strong>”。可此时此刻，我会不由得觉得，世事无常，更像是时间突然间有了温度，“<strong>春观夜樱，夏望繁星，秋赏满月，冬会初雪</strong>”，拥有这般温度的时间毫无疑问是浪漫的，可世事无常所带来的时间的温度，更像是某种意义上的极致，譬如从地球两极瞬移到赤道，或者是一场大爆炸后突兀着的宁静。也许，四季还是那个四季，无非是我一厢情愿的自以为是，时间真的有温度吗？</p><p>这次终于可以乘坐高铁回家，可当列车以每小时250公里的速度呼啸而过时，我已来不及仔细留意车窗外的风景。我隐隐约约地觉得，外面的山丘变得平缓，时不时穿过漆黑悠长的隧道，平原上点缀着麦田和葡萄架，等到列车横跨着黄河驶过的时候，我终于确信我回到了故乡。而我不得不说，人生的境遇里实在有太多的似曾相识，正如此刻窗外的风，兀自呼啸着撼动着那棵我自小便认识的树。回家后收到的第一个消息是，家族中一位叔叔的儿子，在工作时不慎从高处摔落下来，送到医院以后终于还是没能抢救过来，听长辈们讲，彼时他们正在参加某个人的婚礼，一时间百感交集。</p><p>可以说，这是我这么多年来，第一次以一个成年人的身份去面对一个人的离开。因为逝者与我为同一辈人，所以于情于理我都要去吊唁一番。于是，快三十岁的人，第一次有了买花圈、写挽联的经历，甚至我在去见这位叔叔的时候，在脑海中浮现了多次的“还请您节哀顺变”，终于还是没能说出口来。或许是因为事出突然，有太多的身后事需要料理，留给悲伤的时间并不多。在逝者面前焚香、叩拜、鞠躬，虽然有长辈从旁指点，可整套动作还是显得有点僵硬。我终于还是想起来，这个只有27岁的年轻人，在我某次回家探亲的时候，自顾自走上前来，面带微笑的自我介绍道，“我是某某某，你不认得我了吗？”</p><p>有时候想想，我喜欢怀旧，喜欢念念不忘，或许就是因为我怕，怕生命中每一次告别都是永诀。同样可以认为是第一次的，也许是公墓，是陵园，这种从前只有在电视上见到过的东西。于是，在夕阳的映照下，半边天空被染成金黄色，而在这一片荒凉中，一座六角形的塔静静地矗立着。站在一个高坡上一眼望去，满眼都是密密麻麻的墓碑。我在想，有一天人们会不会建成更加极致的地下宫殿，就如同城市中越来越多的高楼大厦一样，唯一的不同，或许是那具比单人床还要小一点的棺木，或者是和小酒坛差不多大的骨灰盒。独自站在旷野中，风吹着塔角的铃铛不时发出响声，我敲击不锈钢柱子时，它竟然发出了沉钟一般的轰鸣，难道人真的有灵魂吗？</p><p>对于死亡，从小到大，我着实经历了不少，小学时爷爷去世，中学时有位同学被歹人杀害，大学时有位同学患白血病不治而亡，工作以后有一位同事因意外而溺水身亡……有时候想想，虽然我的人生，可能并不如别人那般精彩绝伦，可比起失去生命的他们，我能见到更多的人，见到更多的事情，这实在是幸运中的幸运。可或许是因为故事的视角发生了改变，所以，此刻比往常有了更多不由分说的感慨，就好像从前的我，虽然一样是某个事件的亲历者，但那时的我，还不大懂得死亡的意义，都说是人死灯灭，可只有你自己知道，一旦别人彻底地忘记了你，忘记了你在这世上的故事，你就大概的确真的死了罢！我们终其一生，不论记忆以文字还是影像的形式存在，所求者不过是记住别人和被别人记住，人生如朝露也好，如雪泥鸿爪也罢，也许，珍惜此时此刻，方能无惧参商永隔的痛苦吧……</p><p>很多年前，作为长孙的我，举着高过我头顶的引魂幡走在前面，风裹挟着引魂幡的纸穗呼呼作响，那时，我还不知道再也见不到一个人，将会是多么难过的一件事情。后来，我偶尔会回想起，夏天做完农活回来，坐在凉席上吃西瓜的情形，就是在那个时候，爷爷开始埋怨头上有白头发，而我则被拉去帮爷爷找白头发。再后来，我偶尔会想有个人帮我找白头发，可明明我还没到三十岁啊，直到我看到三叔后脑勺开始变白，我终于惊觉，这是二十年前的事情了。有时候想想，我人生中最美好的那几年，同这二十年的长度相比，何尝不是沧海一粟呢？人生时常如此，你觉得几十年特别漫长，可二十年你还不是就这样“弹指一挥间”，而人生又特别短暂，短暂到我们怕这次见了就再见不着彼此。这样想来，拉黑或者删除一个人，成本简直低廉到无法想象，因为失去得太容易，大家就不会有这种看似突兀的想法。浮生倥偬，失散在风里的是沙，而失散在水里的是萍，失散的人们，会有引魂幡前来招魂，然后各自相认吗？</p><p>所以，时间有温度吗？我想，该是有的，因为我们会在时间的长河里放下一盏浮灯，它承载着我们记忆深处最温暖的回忆。可也许这只是我们的一厢情愿，时间自顾自地往前走，从来不在乎人的记忆到底如何，就如同窗外呼啸而过的风，它并不懂得人类内心深处的那些情感，所以，更多的时候，我以为，时间是没有温度的，是冰冷的，是荒凉的，就像我在陵园里看到的夕阳一般冰冷，即使它被晚霞映得金黄。有时候，我会期待时间走得稍微慢一点，出于我的自私，我希望我此刻爱着的、曾经爱过的人们，都能老去地稍微慢一点，因为我怕再见不到那个人，因为我怕时间凝固成冰，因为我怕我终有一天要忘记，因为我怕我永远都赶不上时间，这或许是我想在此时此刻赋予时间的温度，如同人的正常体温37度，或许，它是如此的平静甚至是普通，可是啊，活着真的很好啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://qinyuanpei.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="时间" scheme="https://qinyuanpei.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="生死" scheme="https://qinyuanpei.github.io/tags/%E7%94%9F%E6%AD%BB/"/>
    
  </entry>
  
</feed>
