<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一个人的孤落时辰</title>
  
  <subtitle>纵有疾风起，人生不言弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinyuanpei.github.io/"/>
  <updated>2021-05-28T02:08:18.579Z</updated>
  <id>https://qinyuanpei.github.io/</id>
  
  <author>
    <name>飞鸿踏雪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.NET Core gRPC 拦截器的使用技巧分享</title>
    <link href="https://qinyuanpei.github.io/posts/1679688265/"/>
    <id>https://qinyuanpei.github.io/posts/1679688265/</id>
    <published>2021-05-26T09:03:35.000Z</published>
    <updated>2021-05-28T02:08:18.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p><code>gRPC</code>是微软在<code>.NET Core</code> 及其后续版本中主推的 RPC 框架，它使用 <code>Google</code> 的 <code>Protocol Buffers</code> 作为序列化协议，使用 <strong>HTTP/2</strong> 作为通信协议，具有<strong>跨语言</strong>、<strong>高性能</strong>、<strong>双向流式调用</strong>等优点。考虑到，接下来要参与的是，一个以<code>gRPC</code>为核心而构建的微服务项目。因此，博主准备调研一下<code>gRPC</code>的相关内容，而首当其冲的，则是从 .NET Core 3.1 开始就有的拦截器，它类似于<code>ASP.NET Core</code>中的过滤器和中间件，体现了一种面向切面编程(<strong>AOP</strong>)的思想，非常适合在RPC服务调用的时候做某种统一处理，譬如参数校验、身份验证、日志记录等等。在今天这篇博客中，博主主要和大家分享的是，利用 .NET Core gRPC 中的拦截器实现日志记录的简单技巧，希望大家喜欢。</p><h1 id="关于-Interceptor-类"><a href="#关于-Interceptor-类" class="headerlink" title="关于 Interceptor 类"></a>关于 Interceptor 类</h1><p><code>Interceptor</code>类是 gRPC 服务拦截器的基类，它本身是一个抽象类，其中定义了下面的虚方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncClientStreamingCall&lt;TRequest, TResponse&gt; AsyncClientStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt; AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> TResponse BlockingUnaryCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task&lt;TResponse&gt; ClientStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncServerStreamingCall&lt;TResponse&gt; AsyncServerStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task DuplexStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task ServerStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task&lt;TResponse&gt; UnaryServerHandler&lt;TRequest, TResponse&gt;();</span><br></pre></td></tr></table></figure><p>整体而言，如果从通信方式上来划分，可以分为：<strong>流式调用</strong> 和 <strong>普通调用</strong>；而如果从使用方来划分，则可以分为：<strong>客户端</strong> 和 <strong>服务端</strong>。进一步讲的话，针对<strong>流式调用</strong>，它还分为：”<strong>单向流</strong>“ 和 “<strong>双向流</strong>“。关于这些细节上的差异，大家可以通过 <code>gRPC</code> 的 <a href="https://www.grpc.io/docs/what-is-grpc/core-concepts/" target="_blank" rel="noopener">官方文档</a> 来了解，这里我们给出的是每一种方法对应的用途：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>AsyncClientStreamingCall</td><td>拦截异步客户端流式调用</td></tr><tr><td>AsyncDuplexStreamingCall</td><td>拦截双向流式调用</td></tr><tr><td>AsyncUnaryCall</td><td>拦截异步普通调用</td></tr><tr><td>BlockingUnaryCall</td><td>拦截阻塞普通调用</td></tr><tr><td>AsyncServerStreamingCall</td><td>拦截异步服务端流式调用</td></tr><tr><td>ClientStreamingServerHandler</td><td>拦截客户端流式调用的服务端处理程序</td></tr><tr><td>DuplexStreamingServerHandler</td><td>拦截双向流式调用的服务端处理程序</td></tr><tr><td>ServerStreamingServerHandler</td><td>拦截服务端流式调用的服务端处理程序</td></tr><tr><td>UnaryServerHandler</td><td>拦截普通调用的服务端处理程序</td></tr></tbody></table><h1 id="实现一个拦截器"><a href="#实现一个拦截器" class="headerlink" title="实现一个拦截器"></a>实现一个拦截器</h1><p>好了，下面我们一起实现一个拦截器。这里，我们使用的是微软官方的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GreeterService : Greeter.GreeterBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GreeterService&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreeterService</span>(<span class="params">ILogger&lt;GreeterService&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HelloReply&gt; <span class="title">SayHello</span>(<span class="params">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HelloReply</span><br><span class="line">        &#123;</span><br><span class="line">            Message = <span class="string">"Hello "</span> + request.Name</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>实现服务器端的普通调用拦截，我们需要重写的方法是<code>UnaryServerHandler</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCServerLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GRPCServerLoggingInterceptor&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GRPCServerLoggingInterceptor</span>(<span class="params">ILogger&lt;GRPCServerLoggingInterceptor&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 UnaryServerHandler() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> Task&lt;TResponse&gt; UnaryServerHandler&lt;TRequest, TResponse&gt;(</span><br><span class="line">      TRequest request, ServerCallContext context, </span><br><span class="line">      UnaryServerMethod&lt;TRequest, TResponse&gt; continuation</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish."</span>);</span><br><span class="line">        _logger.LogInformation(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC请求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> LogRequest&lt;TRequest&gt;(TRequest request)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">is</span> IMessage)</span><br><span class="line">            payload = JsonConvert.SerializeObject(</span><br><span class="line">                (request <span class="keyword">as</span> IMessage)</span><br><span class="line">                .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(request <span class="keyword">as</span> IMessage))</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"Send request of <span class="subst">&#123;<span class="keyword">typeof</span>(TRequest)&#125;</span>:<span class="subst">&#123;payload&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC响应</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> LogResponse&lt;TResponse&gt;(TResponse response, AggregateException exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (response <span class="keyword">is</span> IMessage)</span><br><span class="line">                payload = JsonConvert.SerializeObject(</span><br><span class="line">                  (response <span class="keyword">as</span> IMessage)</span><br><span class="line">                  .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                  .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(response <span class="keyword">as</span> IMessage))</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span>:<span class="subst">&#123;payload&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> errorMsgs = <span class="keyword">string</span>.Join(<span class="string">";"</span>, exception.InnerExceptions.Select(x =&gt; x.Message));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span> throws exceptions: <span class="subst">&#123;errorMsgs&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>gRPC</code>而言，每一个由<code>.proto</code>声明文件生成的类，都带有一个叫做<code>Descriptor</code>的属性，我们可以利用这个属性获得<code>gRPC</code>请求和响应的详细信息。所以，在<code>LogRequest()</code>和<code>LogResponse()</code>两个方法中，我们均使用了这一思路来记录<code>gRPC</code>的报文信息，因为传输层的<code>gRPC</code>使用了二进制作为数据载体，这可以说是一种用可读性换取高效率的做法，不过幸运的是，我们在这里实现了这个小目标。</p><p>接下来，为了让这个拦截器真正生效，我们还需要修改一下<code>Startup</code>类中注册<code>gRPC</code>这部分的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GRPCServerLoggingInterceptor&gt;());</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/27/3nZXelLPVwJ7AjS.png" alt="gRPC服务器端拦截器效果展示" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">gRPC服务器端拦截器效果展示</div>            </figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>实现客户端的普通调用拦截，我们需要重写的方法是<code>AsyncUnaryCall()</code>，依样画葫芦即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCClientLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重写 AsyncUnaryCall() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">        TRequest request,</span><br><span class="line">        ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span><br><span class="line">        AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.ResponseAsync.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.ResponseAsync.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish."</span>);</span><br><span class="line">        Console.WriteLine(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，为了让拦截器在客户端生效，我们需要这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Grpc.Core.Interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>);</span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line">channel.Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">var</span> invoker = channel.CreateCallInvoker().Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(invoker);</span><br><span class="line"><span class="keyword">await</span> client.SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">"长安书小妆"</span> &#125;);</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/28/XcwmOQbzKTJPtUj.png" alt="gRPC客户端拦截器效果展示" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">gRPC客户端拦截器效果展示</div>            </figure><p>客户端感觉不太好的一点就是，这个<code>Interceptor</code>传入的必须是一个实例，考虑到拦截器内部可能会依赖类似<code>ILogger</code>等等的组件，建议还是通过<code>IoC</code>容器来取得一个拦截器的实例，然后再传入<code>Intercept()</code>方法中。博主所在的项目中，则是非常“<strong>土豪</strong>”地使用了<code>PostSharp</code>，直接走动态编织的方案，果然，“<strong>这次第，怎一个羡字了得</strong>”。当然，<code>gRPC</code>的客户端，其实提供了日志相关的支持，不过，我个人感觉这个有一点无力：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggerFactory = LoggerFactory.Create(logging =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    logging.AddConsole();</span><br><span class="line">    logging.SetMinimumLevel(LogLevel.Debug);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(</span><br><span class="line">    <span class="string">"https://localhost:5001"</span>,</span><br><span class="line">    <span class="keyword">new</span> GrpcChannelOptions &#123; LoggerFactory = loggerFactory &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要分享了<code>gRPC</code>拦截器的使用技巧，<code>gRPC</code>支持一元调用(<strong>UnaryCall</strong>)、流式调用(<strong>StreamingCall</strong>)、阻塞调用(<strong>BlockingCall</strong>)，因为区分客户端和服务器端，所以，实际上会有各种各样的组合方式。<code>gRPC</code>的拦截器实际上就是选择对应的场景去重写相应的方法，其中，拦截器的基类为<code>Interceptor</code>类，这里我们都是以普通的一元调用为例的，大家可以结合各自的业务场景，去做进一步的调整和优化。这里，我们使用<code>IMessage</code>类的<code>Descriptor</code>属性来“反射”报文中定义的字段，这样就实现了针对<code>gRPC</code>服务请求/响应的日志记录功能。关于<code>gRPC</code>中日志和诊断的更进一步的话题，大家可以参考微软的 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/diagnostics?view=aspnetcore-5.0" target="_blank" rel="noopener">官方文档</a> 。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日志" scheme="https://qinyuanpei.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="AOP" scheme="https://qinyuanpei.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>SnowNLP 使用自定义语料进行模型训练</title>
    <link href="https://qinyuanpei.github.io/posts/1772340994/"/>
    <id>https://qinyuanpei.github.io/posts/1772340994/</id>
    <published>2021-05-19T21:22:41.000Z</published>
    <updated>2021-05-28T02:08:18.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p><a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 是一个功能强大的中文文本处理库，它囊括了中文分词、词性标注、情感分析、文本分类、关键字/摘要提取、<code>TF/IDF</code>、文本相似度等诸多功能，像<strong>隐马尔科夫模型</strong>、<strong>朴素贝叶斯</strong>、<code>TextRank</code>等算法均在这个库中有对应的应用。如果大家仔细观察过博主的博客，就会发现博主使用了摘要提取这一功能来增强博客的<code>SEO</code>，即通过自然语言处理(<strong>NLP</strong>)技术，提取每一篇文章中的摘要信息。因为 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 本身使用的语料是电商网站评论，所以，当我们面对不同的使用场景时，它自带的这个模型难免会出现“水土不服”。因此，如果我们希望得到更接近实际的结果，最好的方案是使用自定义语料进行模型训练。值得庆幸的是，这一切在 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 中实施起来非常简单，并不需要我们去钻研那些高深莫测的算法。至此，就引出了今天这篇博客的主题，即 SnowNLP 使用自定义语料进行模型训练。</p><p>不知道大家是否还有印象，博主曾经在 <a href="https://blog.yuanpei.me/posts/2758545080/" target="_blank" rel="noopener">《通过Python分析2020年全年微博热搜数据》</a> 这篇文章中提到过 SnowNLP 的模型训练。当时，博主采集了整个 2020 年的微博热搜话题，因为要体现整个一年里的情感变化，博主特意找了两份微博语料，并以此为基础训练出了一个模型文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/26/gCcHX7vWlwsZhnI.jpg" alt="2020全年微博热搜情感变化趋势" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">2020全年微博热搜情感变化趋势</div>            </figure><p>那么，具体是怎么样做的呢？我们一起来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> sentiment</span><br><span class="line">sentiment.train(<span class="string">'./train/neg60000.txt'</span>, <span class="string">'./train/pos60000.txt'</span>)</span><br><span class="line">sentiment.save(<span class="string">'weibo.marshal'</span>)</span><br></pre></td></tr></table></figure><p>千万不要怀疑你的眼睛，因为它真的只有短短的三行代码。简单来说，我们只需要准备一个“<strong>积极</strong>”的语料文件，一个“<strong>消极</strong>”的语料文件，它就可以训练出一个模型文件。特别注意的是，如果是在<code>Python 3.X</code>的版本下，最终生成的模型文件的扩展名将会是<code>.3</code>，下图是博主这里训练出的模型文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/20/EQnaXv3x6Vyfm7j.png" alt="SnowNLP 使用自定义语料进行模型训练" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">SnowNLP 使用自定义语料进行模型训练</div>            </figure><p>好了，一旦训练出这个模型文件，我们就可以考虑替换掉 SnowNLP 的默认模型文件，我们可以在以下位置：<code>\Lib\site-packages\snownlp\sentiment</code> 找到下列文件。为了安全起见，我们首先将原来的模型文件重命名，然后再放入我们自己的模型文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/20/C5QS3uhvt1liqXc.png" alt="SnowNLP 使用自定义模型替换默认模型" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">SnowNLP 使用自定义模型替换默认模型</div>            </figure><p>此时，我们就可以利用训练好的模型，分析某一条微博的情感倾向。这里我选取了几条我的微博，看看这个情感倾向预测的结果如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> SnowNLP</span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'我爱你，并不期待回声'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.8760737296091975</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'想找一个人，一起做老爷爷、老奶奶才做的事情，比如，替我拔一拔头上的白头发……[二哈] ​​'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.001629297651780881</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'如果两个人都不爱了，一别两宽，各生欢喜，其实是挺好的结局；可如果还有一个人爱着，对那个人来说，爱又是什么呢？'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.809651945221708</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'为了发张自拍，特意出来跑步，还有谁？[doge] ​​​'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.4041057894917053</span></span><br></pre></td></tr></table></figure><p>有人说，双子座是一个白天自愈、晚上孤独的星座，我确信这是真的，因为从我出生的那一刻起，那种宏大宇宙中的孤独感就一直笼罩着我，用一句话来形容，大概就是“<strong>热闹是人家的，我什么都没有</strong>”，因为内心世界里的两个灵魂，从来没有一刻闲歇地在纠缠和撕裂。我一直都想了解一件事情，如果这些基于概率或者是公式的算法，都可以琢磨出人类某个时刻的心境，我们期望别人能懂自己是不是太过矫情，我们是真的了解自己吗？</p><p>OK，说完微博话题这个场景，我们再来说说电影评论这个场景。回想今年过年的时候，一部<a href="https://movie.douban.com/subject/34841067/" target="_blank" rel="noopener">《你好，李焕英》</a>，成为贺岁档电影中的一匹黑马，而相比之下，<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a>则有点“<strong>滑铁卢</strong>”的感觉。为了搞清楚某一部电影真实的评价情况，此时，我们可以考虑使用 SnowNLP ，对影评的情感趋向进行打分。同样地，这里我们找了一部分影评语料，为 SnowNLP 训练一个单独的模型。接下来，我们不妨从豆瓣上抓取一定数量的影评，来验证下我们这里训练好的模型，这里以<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a>为例：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/22/5Mo1ncNyEO2K69j.png" alt="从豆瓣上抓取到的电影评论" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">从豆瓣上抓取到的电影评论</div>            </figure><p>可以发现，这些影评的情感趋向介于0到0.1这个区间的数量最多，占到160以上，这意味着约有30%的观众认为这部电影是个不折不扣的烂片。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/22/1hvXtjciPlWBzD9.jpg" alt="唐人街探案3豆瓣影评情感分布" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">唐人街探案3豆瓣影评情感分布</div>            </figure><p>目前，<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a> 在豆瓣上的评分只有5.5分，其中，2星和3星的评价占到70%以上。由于豆瓣接口的限制，我们大概只能抓到500条左右的影评信息，可即使如此，可以看出大家对这部电影的情绪多少有一点不满。博主当时看这个电影，最大的感受是里面充斥着太多强行搞笑的东西，例如开篇机场那一场打砸抢的戏份，我完全不明白它存在的意义是什么，虽然日本演员们的表演可圈可点，可在这样一个推理和叙事都非常脆弱的故事里，大概就剩下翻来覆去重复使用的搞笑伎俩啦，你敢说医院这场戏和第一部阿香家那场戏没有相似的地方吗？更不用说，医院这场戏大家都在评论里无限吐槽啦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/22/MRsAc76vgmTEK4z.png" alt="豆瓣电影-唐人街探案3" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">豆瓣电影-唐人街探案3</div>            </figure><p>其实，对于情感，我一直不知道该怎么来讲，可能是程序员的这份理性，让我在维系亲密关系或者说的情感的时候，有时候会生出一种近乎漠然的、置身事外的错觉，换句话说，也许是那种被人称为“<strong>天性凉薄</strong>”的东西。前任同我讲，我最爱的人其实是我自己，并不是她。因为站在她的角度上来讲，她并没有感受到我给予她的爱。我该怎么回答这个问题呢？在一切看似理性的数学计算背后，人类这些极为在乎的情感到底又是什么形式？也许有一天，两个人的感情说变淡就突然变淡，不管我们曾经说过什么样的话，在那一刻都会变得苍白无力，逐年攀升的离婚率触目惊心，可我们每个人都像扑向火焰的飞蛾，在这爱与欲望无法随心所欲的世界里，被欲望裹挟着不断向前。人会变的绝情、冷漠，我们自以为那是成长，可那不过是心变硬了，可这是我们当初期待的长大吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/22/q3LhYmClIT4iSwv.png" alt="欢迎来到无法随心所欲的爱与欲望的世界" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">欢迎来到无法随心所欲的爱与欲望的世界</div>            </figure><p>今天，听到袁隆平爷爷去世的消息，除了不断地提醒我们这代人已然老去这个事实以外，也许最大的体会应该是，我们在这个世界上追求的名利、身份和爱，最终都会无可避免地走向消亡，就如同我们身上这具躯壳一样，而真正能流传下去、泽被后世地，永远都是思想、是文化、是技术、是精神。佛家云：人死身灭，大概我们都不得不去接受这个残酷的事实，所以，请放下那些爱而不得、求而不得的执念吧，你一辈子不管遇见多少人，在某一个时候也许就会荡然无存，爱会消失、身会毁灭，这一切都是宇宙间的自然法则，与其去纠结那些“<strong>薛定谔态</strong>”的事物，不如多为这个世界做一点有意义的事情，正如尼采的那句名言，“<strong>对待生命你不妨大胆冒险一点, 因为无论如何你都要失去它</strong>”，我也许并不真正懂得人类的情感，因为它在理性面前毫无意义，世间万物毫无例外地走向那个坍塌的奇点，这难道不是一种荒凉的美感吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/22/kjR2nVSHlDNrCLi.jpg" alt="人的心情难道不是一个黑洞" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">人的心情难道不是一个黑洞</div>            </figure><p>嘘，如果你读到这里，意外发现这是一篇水字数的博客，而这或许说明了一件事情，我的确是一个会懈怠、会疲倦的活生生的人。关于 SnowNLP 使用自定义语料进行模型训练的话题，这次我们就先写到这里，做数据挖掘的时候，有的人在乎的是最终的结果，而有的人享受的是整个过程，人类的情感或许是相似的，所以，学着去接受这个多样性有点多到奇葩的世界，学着去和平凡而普通的自己和解吧，欢迎大家在评论区交换想法或者观点，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="NLP" scheme="https://qinyuanpei.github.io/tags/NLP/"/>
    
      <category term="训练" scheme="https://qinyuanpei.github.io/tags/%E8%AE%AD%E7%BB%83/"/>
    
      <category term="模型" scheme="https://qinyuanpei.github.io/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>假如时间有温度</title>
    <link href="https://qinyuanpei.github.io/posts/2136925853/"/>
    <id>https://qinyuanpei.github.io/posts/2136925853/</id>
    <published>2021-05-03T14:00:41.000Z</published>
    <updated>2021-05-28T02:08:18.587Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>我一直在想，世事无常，该是一种什么样的感觉。直到我读到夏目先生的《我是猫》，先生在书中不无感慨地写道，“世事变迁就像猫的眼珠一样变幻莫测”。可此时此刻，我会不由得觉得，世事无常，更像是时间突然间有了温度，“春观夜樱，夏望繁星，秋赏满月，冬会初雪”，拥有这般温度的时间毫无疑问是浪漫的，可世事无常所带来的时间的温度，更像是某种意义上的极致，譬如从地球两极瞬移到赤道，或者是一场大爆炸后突兀着的宁静。也许，四季还是那个四季，无非是我一厢情愿的自以为是，时间真的有温度吗？</p><p>这次终于可以乘坐高铁回家，可当列车以每小时250公里的速度呼啸而过时，我已来不及仔细留意车窗外的风景。我隐隐约约地觉得，外面的山丘变得平缓，时不时穿过漆黑悠长的隧道，平原上点缀着麦田和葡萄架，等到列车横跨着黄河驶过的时候，我终于确信我回到了故乡。而我不得不说，人生的境遇里实在有太多的似曾相识，正如此刻窗外的风，兀自呼啸着撼动着那棵我自小便认识的树。回家后收到的第一个消息是，家族中一位叔叔的儿子，在工作时不慎从高处摔落下来，送到医院以后终于还是没能抢救过来，听长辈们讲，彼时他们正在参加某个人的婚礼，一时间百感交集。</p><p>可以说，这是我这么多年来，第一次以一个成年人的身份去面对一个人的离开。因为逝者与我为同一辈人，所以于情于理我都要去吊唁一番。于是，快三十岁的人，第一次有了买花圈、写挽联的经历，甚至我在去见这位叔叔的时候，在脑海中浮现了多次的“还请您节哀顺变”，终于还是没能说出口来。或许是因为事出突然，有太多的身后事需要料理，留给悲伤的时间并不多。在逝者面前焚香、叩拜、鞠躬，虽然有长辈从旁指点，可整套动作还是显得有点僵硬。我终于还是想起来，这个只有27岁的年轻人，在我某次回家探亲的时候，自顾自走上前来，面带微笑的自我介绍道，“我是某某某，你不认得我了吗？”</p><p>有时候想想，我喜欢怀旧，喜欢念念不忘，或许就是因为我怕，怕生命中每一次告别都是永诀。同样可以认为是第一次的，也许是公墓，是陵园，这种从前只有在电视上见到过的东西。于是，在夕阳的映照下，半边天空被染成金黄色，而在这一片荒凉中，一座六角形的塔静静地矗立着。站在一个高坡上一眼望去，满眼都是密密麻麻的墓碑。我在想，有一天人们会不会建成更加极致的地下宫殿，就如同城市中越来越多的高楼大厦一样，唯一的不同，或许是那具比单人床还要小一点的棺木，或者是和小酒坛差不多大的骨灰盒。独自站在旷野中，风吹着塔角的铃铛不时发出响声，我敲击不锈钢柱子时，它竟然发出了沉钟一般的轰鸣，难道人真的有灵魂吗？</p><p>对于死亡，从小到大，我着实经历了不少，小学时爷爷去世，中学时有位同学被歹人杀害，大学时有位同学患白血病不治而亡，工作以后有一位同事因意外而溺水身亡……有时候想想，虽然我的人生，可能并不如别人那般精彩绝伦，可比起失去生命的他们，我能见到更多的人，见到更多的事情，这实在是幸运中的幸运。可或许是因为故事的视角发生了改变，所以，此刻比往常有了更多不由分说的感慨，就好像从前的我，虽然一样是某个事件的亲历者，但那时的我，还不大懂得死亡的意义，都说是人死灯灭，可只有你自己知道，一旦别人彻底地忘记了你，忘记了你在这世上的故事，你就大概的确真的死了罢！我们终其一生，不论记忆以文字还是影像的形式存在，所求者不过是记住别人和被别人记住，人生如朝露也好，如雪泥鸿爪也罢，也许，珍惜此时此刻，方能无惧参商永隔的痛苦吧……</p><p>很多年前，作为长孙的我，举着高过我头顶的引魂幡走在前面，风裹挟着引魂幡的纸穗呼呼作响，那时，我还不知道再也见不到一个人，将会是多么难过的一件事情。后来，我偶尔会回想起，夏天做完农活回来，坐在凉席上吃西瓜的情形，就是在那个时候，爷爷开始埋怨头上有白头发，而我则被拉去帮爷爷找白头发。再后来，我偶尔会想有个人帮我找白头发，可明明我还没到三十岁啊，直到我看到三叔后脑勺开始变白，我终于惊觉，这是二十年前的事情了。有时候想想，我人生中最美好的那几年，同这二十年的长度相比，何尝不是沧海一粟呢？人生时常如此，你觉得几十年特别漫长，可二十年你还不是就这样“弹指一挥间”，而人生又特别短暂，短暂到我们怕这次见了就再见不着彼此。这样想来，拉黑或者删除一个人，成本简直低廉到无法想象，因为失去得太容易，大家就不会有这种看似突兀的想法。浮生倥偬，失散在风里的是沙，而失散在水里的是萍，失散的人们，会有引魂幡前来招魂，然后各自相认吗？</p><p>所以，时间有温度吗？我想，该是有的，因为我们会在时间的长河里放下一盏浮灯，它承载着我们记忆深处最温暖的回忆。可也许这只是我们的一厢情愿，时间自顾自地往前走，从来不在乎人的记忆到底如何，就如同窗外呼啸而过的风，它并不懂得人类内心深处的那些情感，所以，更多的时候，我以为，时间是没有温度的，是冰冷的，是荒凉的，就像我在陵园里看到的夕阳一般冰冷，即使它被晚霞映得金黄。有时候，我会期待时间走得稍微慢一点，出于我的自私，我希望我此刻爱着的、曾经爱过的人们，都能老去地稍微慢一点，因为我怕再见不到那个人，因为我怕时间凝固成冰，因为我怕我终有一天要忘记，因为我怕我永远都赶不上时间，这或许是我想在此时此刻赋予时间的温度，如同人的正常体温37度，或许，它是如此的平静甚至是普通，可是啊，活着真的很好啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://qinyuanpei.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="时间" scheme="https://qinyuanpei.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="生死" scheme="https://qinyuanpei.github.io/tags/%E7%94%9F%E6%AD%BB/"/>
    
  </entry>
  
  <entry>
    <title>使用 HttpMessageHandler 实现 HttpClient 请求管道自定义</title>
    <link href="https://qinyuanpei.github.io/posts/2070070822/"/>
    <id>https://qinyuanpei.github.io/posts/2070070822/</id>
    <published>2021-04-28T20:25:47.000Z</published>
    <updated>2021-05-28T02:08:18.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>最近，博主偶然间在 <a href="https://www.cnblogs.com" target="_blank" rel="noopener">博客园</a> 看到一篇文章：<a href="https://www.cnblogs.com/xfrog/p/14703251.html" target="_blank" rel="noopener">ASP.NET Core 扩展库之 Http 请求模拟</a>，它里面介绍了一种利用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.net.http.httpmessagehandler?view=net-5.0" target="_blank" rel="noopener">HttpMessageHandler</a> 来实现 Http 请求模拟的方案。在日常工作中，我们总是不可避免地要和第三方的服务或者接口打交道，尤其是当我们需要面对“<strong>联调</strong>”这样一件事情的时候。通常，我们可以通过类似 <a href="https://github.com/ymfe/yapi" target="_blank" rel="noopener">YAPI</a> 这样的工具来对尚在开发中的接口进行模拟。可是，因为这种方式会让我们的测试代码依赖于一个外部工具，所以，从严格意义上讲，它其实应该属于“<strong>集成测试</strong>”的范畴。在接触前端开发的过程中，对于其中的 <a href="http://mockjs.com/" target="_blank" rel="noopener">Mock.js</a> 印象深刻。故而，当看到 .NET 中有类似实现的时候，好奇心驱使我对其中的核心，即 <code>HttpMessageHandler</code> 产生了浓厚的兴趣。平时，我们更多的是使用 <a href="https://github.com/moq/moq4" target="_blank" rel="noopener">Moq</a> 这样的库来模拟某一个对象的行为，而对一个 Http 请求进行模拟，可以说是开天辟地头一遭。带着这些问题出发，就有了今天这篇博客，通过 <code>HttpMessageHandler</code> 实现 <code>HttpClient</code> 请求管道的自定义。</p><h1 id="什么是-HttpMessageHandler？"><a href="#什么是-HttpMessageHandler？" class="headerlink" title="什么是 HttpMessageHandler？"></a>什么是 HttpMessageHandler？</h1><p>相信大家读过我提到的文章以后，都能找到这里面最核心的一个点：<code>HttpMessageHandler</code>。于是，我们今天要面对的第一个问题就是，什么是 <code>HttpMessageHandler</code>？此时，我们需要一张历久弥新的示意图，来自 <a href="https://www.asp.net/media/4071077/aspnet-web-api-poster.pdf" target="_blank" rel="noopener">微软官方</a>。这里，我们重点关注的是 <code>DelegatingHandler</code>，它继承自 <code>HttpMessageHandler</code>。通过这张图，我们能够获得哪些信息呢？</p><p>我认为，主要有以下几点：<strong>第一，HttpMessageHandler 处于整个 Http 请求管道的第一梯队，每一个路由匹配的请求都会从这里“进入”和“离开”；第二，HttpMessageHandler 可以是全局配置或者针对某个特定的路由，只要这个路由被匹配到就会执行；第三，HttpMessageHandler 可以直接构造 Http 响应并且返回，跳过剩余的管道流程</strong>。不知道大家看到这里会想到什么？坦白讲，我联想到了.NET Core 中的中间件，而唯一不同的地方或许是，中间件是 ASP.NET Core 里的概念，这里则是 ASP.NET Web API 里的概念。尤其是第三点，它对于我们的意义非常重大，因为它，我们才可以做到对一个 Http 请求进行模拟。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/28/AwLZDdqXc5KERky.png" alt="HttpMessageHandler 与 ASP.NET Web API" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">HttpMessageHandler 与 ASP.NET Web API</div>            </figure><p>而事实上，在 ASP.NET Web API 的设计中，它是由一组 <code>HttpMessageHandler</code> 经过“首尾相连”而成，这种管道式的设计使得框架本身具有很高的扩展性。虽然，作为一个服务端框架，ASP.NET Web API 最主要的作用是就是“<strong>处理请求、响应回复</strong>”，可具体采用的处理策略会因具体场景的不同而不同。所以，管道式设计的本质，就是让某一个 <code>Handler</code> 只负责某个单一的消息处理功能，在根据具体场景的不同，选择需要的 <code>Handler</code> 并将其串联成一个完整的消息处理通道。而在这里，这个负责单一的消息处理功能的 <code>Handler</code> 其实就是 <code>HttpMessageHandler</code>，因为它不单单可以对请求消息(<strong>HttpRequestMessage</strong>)进行处理，同时还可以对响应消息(<strong>HttpResponseMessage</strong>)进行处理。此时，我们就不难理解 <code>HttpMessageHandler</code> 的定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">HttpMessageHandler</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HttpMessageHandler</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">virtual</span> HttpResponseMessage <span class="title">Send</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">abstract</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许，你会忍不住问这样一个问题：<code>DelegatingHandler</code> 和 <code>HttpMessageHandler</code> 的区别是什么？ 其实，只要你稍微仔细一点，你就会发现，两者最大的区别是 <code>DelegatingHandler</code> 里新增一个叫做 <code>InnerHandler</code> 的成员，它本身就是一个 <code>HttpMessageHandler</code>。所以，聪明的你又联想到什么呢？我想，或许是一个叫做 <code>RequestDelegate</code> 的委托，还记得我们写中间件是一直都少不了的 <code>Next</code> 吗？不得不说，这里越来越有中间件的味道了。你可以立马想到的一件事情是，除了最后一个 <code>Handler</code> 是 <code>HttpMessageHandler</code> 以外，剩下的前面的所有的 <code>Handler</code> 都是 <code>DelegatingHandler</code>。为什么这样说呢？因为前面的 <code>n-1</code> 个 <code>Handler</code> 都需要串联下一个 <code>Handler</code>，只有第 <code>n</code> 个 <code>Handler</code>可以允许短路，所以，大概就相当于 <code>Use()</code> 和 <code>Run()</code> 的区别？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">DelegatingHandler</span> : <span class="title">HttpMessageHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DelegatingHandler</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DelegatingHandler</span>(<span class="params">HttpMessageHandler innerHandler</span>)</span>;</span><br><span class="line">    <span class="comment">// InnerHandler是实现管道式设计的关键</span></span><br><span class="line">    <span class="keyword">public</span> HttpMessageHandler? InnerHandler &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> HttpResponseMessage <span class="title">Send</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，此时此刻，你能否为 <code>HttpMessageHandler</code> 下一个清晰的定义呢？我想，或许可以这样理解，一种可以对 请求消息(<strong>HttpRequestMessage</strong>) 和 响应消息(<strong>HttpResponseMessage</strong>) 进行处理，同时多个 <code>HttpMessageHandler</code> 可以组成一个完整的消息处理通道的中间件。屏幕前的你又是如何理解的呢？欢迎大家在评论区留言，留下你对于 <code>HttpMessageHandler</code> 的想法或者认识。</p><h1 id="实现自定义请求管道"><a href="#实现自定义请求管道" class="headerlink" title="实现自定义请求管道"></a>实现自定义请求管道</h1><p>好了，搞清楚 <code>HttpMessageHandler</code> 是什么以后，我们就可以考虑自定义请求管道的实现啦！让我们从一个最简单的示例开始，假设我们这里定义了两个自定义的 <code>Handler</code>，它们分别是： <code>HandlerA</code> 和 <code>HandlerB</code>，我们应该如何将其应用到具体的 <code>HttpClient</code>上呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandlerA</span> : <span class="title">DelegatingHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HandlerA&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerA</span>(<span class="params">ILogger&lt;HandlerA&gt; logger</span>)</span> &#123; _logger = logger; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">"This is Handler A"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.SendAsync(request, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandlerB</span> : <span class="title">DelegatingHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HandlerB&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerB</span>(<span class="params">ILogger&lt;HandlerB&gt; logger</span>)</span> &#123; _logger = logger; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">"This is Handler B"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.SendAsync(request, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们考虑两种场景，依赖注入 和 非依赖注入。对于依赖注入的场景，我们只需要调用<code>AddHttpMessageHandler()</code>方法按顺序注册即可，不需要处理<code>InnerHandler</code>，这里遵循先注册后使用的原则；对于非依赖注入的场景，需要处理<code>InnerHandler</code>，并在构造<code>HttpClient</code>的时候作为参数传入。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddTransient&lt;HandlerA&gt;();</span><br><span class="line">services.AddTransient&lt;HandlerB&gt;();</span><br><span class="line">services.AddHttpClient(<span class="string">"MyClient"</span>, options =&gt; &#123;</span><br><span class="line">  options.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://blog.yuanpei.me/"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .AddHttpMessageHandler&lt;HandlerA&gt;()</span><br><span class="line">  .AddHttpMessageHandler&lt;HandlerB&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非依赖注入</span></span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> HandlerA() &#123; InnerHandler = <span class="keyword">new</span> HandlerB() &#125;;</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient(handler)</span><br></pre></td></tr></table></figure><p>此时，我们就可以得到下面的结果，可以注意到的是，两个<code>Handler</code>的执行顺序与注册顺序一致：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/29/URNWavrVgyzMAxe.png" alt="Handler执行顺序与注册顺序" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">Handler执行顺序与注册顺序</div>            </figure><p>好了，热身环节到此结束！下面，我们来开始实战，这里展示的是 <code>HttpMessageHandler</code> 在日志记录、请求重试 和 接口模拟等方面的应用。</p><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>对于 Http 请求的日志，我们希望记录请求的Url、Http动词、请求时长等信息，而这一点，在一个大量接入第三方接口的系统或者是以 Http 驱动的微服务架构中，常常是不可或缺的一环，对于我们排查故障、监控服务非常有用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params">HttpRequestMessage request, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> correlationId = GetCorrelationId(request);</span><br><span class="line">    <span class="keyword">using</span> (_logger.BeginScope(<span class="string">$"correlationId=<span class="subst">&#123;correlationId&#125;</span>"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> sw = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">        _logger.LogInformation(<span class="string">$"Start Processing HTTP Request <span class="subst">&#123;request.Method&#125;</span> <span class="subst">&#123;request.RequestUri&#125;</span> [Correlation: <span class="subst">&#123;correlationId&#125;</span>]"</span>);</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">base</span>.Send(request, cancellationToken);</span><br><span class="line">         _logger.LogInformation(<span class="string">$"End Processing HTTP Request in <span class="subst">&#123;sw.ElapsedMilliseconds&#125;</span>ms <span class="subst">&#123;response.StatusCode&#125;</span>, [Correlation: <span class="subst">&#123;correlationId&#125;</span>]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetCorrelationId</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">GetCorrelationId</span>(<span class="params">HttpRequestMessage request</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.Headers.TryGetValues(<span class="string">"X-Correlation-ID"</span>, <span class="keyword">out</span> <span class="keyword">var</span> values))</span><br><span class="line">        <span class="keyword">return</span> values.First();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> correlationId = Guid.NewGuid().ToString();</span><br><span class="line">    request.Headers.Add(<span class="string">"X-Correlation-ID"</span>, correlationId);</span><br><span class="line">    <span class="keyword">return</span> correlationId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/29/aORFS3ZQEw8pNbT.png" alt="HttpMessageHandler 实现日志记录" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">HttpMessageHandler 实现日志记录</div>            </figure><h2 id="请求重试"><a href="#请求重试" class="headerlink" title="请求重试"></a>请求重试</h2><p>我们知道，一个系统中接入的外部因素越多，则整个系统的稳定性越低。而国内的产品通常都喜欢”大而全”的”万物互联”，所以，最实际的问题，其实就是调用一个第三方的接口，如何保证其可靠性。所以，考虑请求的故障恢复就显得非常有意义，为此，我们可以引入<code>Polly</code>，在实现<code>SendAsync()</code>方法的时候，通过<code>Polly</code>中的超时、重试等机制对其做一层包装：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RetryableHttpMessageHandler</span> : <span class="title">DelegatingHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;RetryableHttpMessageHandler&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IAsyncPolicy&lt;HttpResponseMessage&gt; _retryPolicy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryableHttpMessageHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        ILogger&lt;RetryableHttpMessageHandler&gt; logger</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _retryPolicy = Policy&lt;HttpResponseMessage&gt;</span><br><span class="line">            .Handle&lt;HttpRequestException&gt;()</span><br><span class="line">            .Or&lt;TimeoutException&gt;()</span><br><span class="line">            .OrResult(x =&gt; (<span class="keyword">int</span>)x.StatusCode &gt;= <span class="number">400</span>)</span><br><span class="line">            .RetryAsync(<span class="number">3</span>, (ret, index) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                _logger.LogInformation(<span class="string">$"调用接口异常：<span class="subst">&#123;ret.Exception?.Message&#125;</span>，状态码：<span class="subst">&#123;ret.Result.StatusCode&#125;</span>, 正在进行第<span class="subst">&#123;index&#125;</span>次重试"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _retryPolicy.ExecuteAsync(() =&gt; <span class="keyword">base</span>.SendAsync(request, cancellationToken));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，我们这里通过<code>HttpClient</code>来请求指定的接口。因为，下面的接口实际上是不存在的。所以，理论上它会返回<code>404</code>这个状态码。而我们的重试策略是，在发生<code>HttpRequestException</code>或者<code>TimeoutException</code>异常以及 Http 响应的状态码大于 400 时，自动触发 3 次重试。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = _clientFactory.CreateClient(<span class="string">"ApiMock"</span>);</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">"/api/fail"</span>);</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/30/OaUyhNF7XYsA8mI.png" alt="HttpMessageHandler 实现请求重试" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">HttpMessageHandler 实现请求重试</div>            </figure><p>可以发现，不多不少刚好是 3 次。除了重试以外，<code>Polly</code>还支持类似超时、断路器等等不同的策略，甚至可以将它们组合起来使用，这些都属于<a href="https://github.com/App-vNext/Polly" target="_blank" rel="noopener">Polly</a>的内容，不作为本文的重点内容来讲解，感兴趣的朋友可以查阅这篇文章：<a href="https://www.cnblogs.com/willick/p/polly.html" target="_blank" rel="noopener">.NET 开源项目 Polly 介绍</a>。需要说明的是，微软官方提供的 <code>Microsoft.Extensions.Http.Polly</code>，它在<code>IHttpClientBuilder</code>上添加了一个名为<code>AddPolicyHandler()</code>的扩展方法，这里的例子可以被简化为下面这样，它和我们这里举的例子是完全一致的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义重试策略</span></span><br><span class="line"><span class="keyword">var</span> retryPolicy = Policy&lt;HttpResponseMessage&gt;</span><br><span class="line">    .Handle&lt;HttpRequestException&gt;()</span><br><span class="line">    .Or&lt;TimeoutException&gt;()</span><br><span class="line">    .OrResult(x =&gt; (<span class="keyword">int</span>)x.StatusCode &gt;= <span class="number">400</span>)</span><br><span class="line">    .RetryAsync(<span class="number">3</span>, (ret, index) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"调用接口异常：<span class="subst">&#123;ret.Exception?.Message&#125;</span>，状态码：<span class="subst">&#123;ret.Result.StatusCode&#125;</span>, 正在进行第<span class="subst">&#123;index&#125;</span>次重试"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册HttpClient并指定重试策略</span></span><br><span class="line">services.AddHttpClient(<span class="string">"ApiMock"</span>, options =&gt; &#123; </span><br><span class="line">  options.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://blog.yuanpei.me"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .AddPolicyHandler(retryPolicy);</span><br></pre></td></tr></table></figure><h2 id="接口模拟"><a href="#接口模拟" class="headerlink" title="接口模拟"></a>接口模拟</h2><p>在集成第三方接口时，在双方确定好接口以后，接口消费方会有一段时间的“黒写”时期。因为在接口提供方的接口没有正式提供前，接口消费方始终只能通过“<strong>模拟</strong>”的方式来进行测试。考虑到单元测试对 <a href="https://github.com/ymfe/yapi" target="_blank" rel="noopener">YAPI</a> 存在耦合，所以，接口模拟同样是一件意义非凡的事情。这里的思路是利用 <code>HttpMessageHandler</code> 的“<strong>短路</strong>”功能，即构造一个 <code>HttpResponseMessage</code> 并返回。</p><p>首先，我们定义一个<code>MockItem</code>类型，它含有两个委托类型的属性<code>RouteSelector</code>和<code>Executor</code>。其中，前者用来匹配路由，而后者则用来处理接口返回值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MockItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;HttpRequestMessage, <span class="keyword">bool</span>&gt; RouteSelector &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;HttpRequestMessage, HttpResponseMessage, Task&gt; Executor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要定义相应的<code>Handler</code>，这里是<code>ApiMockHttpMessageHandler</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiMockHttpMessageHandler</span>: <span class="title">DelegatingHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;ApiMockHttpMessageHandler&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEnumerable&lt;MockItem&gt; _routes;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiMockHttpMessageHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        ILogger&lt;ApiMockHttpMessageHandler&gt; logger,</span></span></span><br><span class="line"><span class="function"><span class="params">        IEnumerable&lt;MockItem&gt; routes</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _routes = routes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 匹配路由并调用其Executor属性</span></span><br><span class="line">        <span class="keyword">var</span> route = _routes.FirstOrDefault(x =&gt; x.RouteSelector?.Invoke(request));</span><br><span class="line">        <span class="keyword">if</span> (route != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">new</span> HttpResponseMessage();</span><br><span class="line">            <span class="keyword">await</span> route.Executor?.Invoke(request, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.Send(request, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的思路是，对于所有注入到<code>Ioc</code>容器中的<code>MockItem</code>，检查其路由是否匹配，如果路由匹配，则通过其指定的<code>Executor</code>对<code>HttpResponseMessage</code>进行加工并返回。为了更加方便地在<code>Ioc</code>容器中进行注入，我们为<code>IServiceCollection</code>编写了相应的扩展方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection AddMock&lt;TReturn&gt;(</span><br><span class="line">    <span class="keyword">this</span> IServiceCollection services, </span><br><span class="line">    <span class="keyword">string</span> url, HttpMethod method, TReturn @<span class="keyword">return</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mockItem = <span class="keyword">new</span> MockItem();</span><br><span class="line">    mockItem.Executor = BuildExecutor&lt;TReturn&gt;(@<span class="keyword">return</span>);</span><br><span class="line">    mockItem.RouteSelector = BuildRouteSelector(url, method);</span><br><span class="line">    <span class="keyword">return</span> services.AddTransient&lt;MockItem&gt;(sp =&gt; mockItem);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection AddMock&lt;TReturn&gt;(</span><br><span class="line">    <span class="keyword">this</span> IServiceCollection services, </span><br><span class="line">    Func&lt;HttpRequestMessage, <span class="keyword">bool</span>&gt; routeSelector, </span><br><span class="line">    Func&lt;HttpRequestMessage, HttpResponseMessage, Task&gt; executor</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mockItem = <span class="keyword">new</span> MockItem();</span><br><span class="line">    mockItem.Executor = executor;</span><br><span class="line">    mockItem.RouteSelector = routeSelector;</span><br><span class="line">    <span class="keyword">return</span> services.AddTransient&lt;MockItem&gt;(sp =&gt; mockItem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Func&lt;HttpRequestMessage, <span class="keyword">bool</span>&gt; <span class="title">BuildRouteSelector</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">string</span> url, HttpMethod method</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Func&lt;HttpRequestMessage, <span class="keyword">bool</span>&gt; selector = request =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="string">"*"</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> url.ToLower() == res.RequestUri.AbsolutePath.ToLower() &amp;&amp; method == res.Method;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> selector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Func&lt;HttpRequestMessage, HttpResponseMessage, Task&gt; BuildExecutor&lt;TReturn&gt;(TReturn @<span class="keyword">return</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Func&lt;HttpRequestMessage, HttpResponseMessage, Task&gt; executor = (request, response) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        response.StatusCode = System.Net.HttpStatusCode.OK;</span><br><span class="line">        <span class="keyword">if</span> (@<span class="keyword">return</span> <span class="keyword">is</span> HttpStatusCode)</span><br><span class="line">            response.StatusCode = (HttpStatusCode)Enum.Parse(</span><br><span class="line">                <span class="keyword">typeof</span>(HttpStatusCode),</span><br><span class="line">                @<span class="keyword">return</span>.ToString()</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (@<span class="keyword">return</span> <span class="keyword">is</span> Exception)</span><br><span class="line">            <span class="keyword">throw</span> @<span class="keyword">return</span> <span class="keyword">as</span> Exception;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (@<span class="keyword">return</span> <span class="keyword">is</span> <span class="keyword">string</span>)</span><br><span class="line">            response.Content = <span class="keyword">new</span> StringContent(@<span class="keyword">return</span> <span class="keyword">as</span> <span class="keyword">string</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            response.Content = <span class="keyword">new</span> StringContent(@<span class="keyword">return</span> == <span class="literal">null</span> ? </span><br><span class="line">                <span class="string">""</span> : JsonConvert.SerializeObject(@<span class="keyword">return</span>)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们就可以在单元测试中对接口进行模拟，这样就实现了真正意义上的单元测试：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 HttpClient并注册ApiMockHttpMessageHandler</span></span><br><span class="line">services.AddHttpClient(<span class="string">"ApiMock"</span>, options =&gt; &#123; </span><br><span class="line">  options.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://blog.yuanpei.me"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .AddHttpMessageHandler&lt;ApiMockHttpMessageHandler&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加3个模拟接口</span></span><br><span class="line">services.AddMock(<span class="string">"/api/status"</span>, HttpMethod.Get, HttpStatusCode.OK);</span><br><span class="line">services.AddMock(<span class="string">"/api/query"</span>, HttpMethod.Post, <span class="keyword">new</span> Exception(<span class="string">"帅哥你谁啊"</span>));</span><br><span class="line">services.AddMock(<span class="string">"/api/order"</span>, HttpMethod.Get, <span class="keyword">new</span> &#123; </span><br><span class="line">  OrderId = <span class="string">"OR09874"</span>, </span><br><span class="line">  CreatedBy = <span class="string">"张三"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> httpClientFactory = serviceProvider.GetRequiredService&lt;IHttpClientFactory&gt;();</span><br><span class="line"><span class="keyword">var</span> httpClient = httpClientFactory.CreateClient(<span class="string">"ApiMock"</span>);</span><br><span class="line"><span class="comment">// 调用/api/order接口</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(<span class="string">"/api/order"</span>);</span><br></pre></td></tr></table></figure><p>下图是模拟接口返回的结果，与我们期望的完全一致：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/30/k9lX12aSpcr8ReV.png" alt="HttpMessageHandler 实现接口模拟" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">HttpMessageHandler 实现接口模拟</div>            </figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>古人云：<strong>他山之石，可以攻玉</strong>。原本被接口模拟(<strong>Mock</strong>)所吸引的博主，意外地收获了 <code>HttpMessageHandler</code> 这个令人兴奋的知识点。博主认为，它是一种可以对 请求消息(<strong>HttpRequestMessage</strong>) 和 响应消息(<strong>HttpResponseMessage</strong>) 进行处理，同时多个 <code>HttpMessageHandler</code> 可以组成一个完整的消息处理通道的中间件。在此基础上，我们实现了诸如<strong>日志记录</strong>、<strong>请求重试</strong>、<strong>接口模拟</strong>等等的扩展性功能。除此以外，它还可以应用到 <strong>Http认证头处理</strong> 、<strong>客户端负载均衡</strong>等方面。</p><p>其实，从 ASP.NET、OWIN、Nancy、ASP.NET Core 这样一路走过来，你会发现，管道的概念一直都存在，无非是以不同的形式存在着，譬如 ASP.NET Core 里的中间件，其实是替代了曾经的 <code>HttpHandler</code> 和 <code>HttpModule</code>，就像时间一直都在那里，不快不慢，觉得物是人非、喜新厌旧的多半还是我们。对我而言，写到这里，最大的感慨或许是，曾经试图实现的类似 <code>Servlet</code> 的 Http Server ，现在想起来还是太年轻、太朴实了，可年轻或者朴实，难道不好吗？好了，以上就是这篇博客的全部内容了，如果你觉得这篇博客对你有所帮助或者启发，希望你可以毫不吝啬地给个一键三连。如果你对这篇博客里的内容有意见或者建议，欢迎你评论区留下你的足迹和声音，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="扩展" scheme="https://qinyuanpei.github.io/tags/%E6%89%A9%E5%B1%95/"/>
    
      <category term="HttpClient" scheme="https://qinyuanpei.github.io/tags/HttpClient/"/>
    
      <category term="Mock" scheme="https://qinyuanpei.github.io/tags/Mock/"/>
    
      <category term="管道" scheme="https://qinyuanpei.github.io/tags/%E7%AE%A1%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>ABP vNext 的实体与服务扩展技巧分享</title>
    <link href="https://qinyuanpei.github.io/posts/3619320289/"/>
    <id>https://qinyuanpei.github.io/posts/3619320289/</id>
    <published>2021-04-18T20:42:47.000Z</published>
    <updated>2021-05-28T02:08:18.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>使用 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 有一个月左右啦，这中间最大的一个收获是：ABP vNext 的开发效率真的是非常好，只要你愿意取遵循它模块化、DDD 的设计思想。因为官方默认实现了身份、审计、权限、定时任务等等的模块，所以，ABP vNext 是一个开箱即用的解决方案。通过脚手架创建的项目，基本具备了一个专业项目该有的“<strong>五脏六腑</strong>”，而这可以让我们专注于业务原型的探索。例如，博主是尝试结合 <a href="https://www.antdv.com/docs/vue/introduce-cn/" target="_blank" rel="noopener">Ant Design Vue</a> 来做一个通用的后台管理系统。话虽如此，我们在使用 ABP vNext 的过程中，还是希望可以针对性地对 ABP vNext 进行扩展，毕竟 ABP vNext 无法 100% 满足我们的使用要求。所以，在今天这篇博客中，我们就来说说 ABP vNext 中的扩展技巧，这里主要是指实体扩展和服务扩展这两个方面。我们经常在讲“<strong>开闭原则</strong>”，可扪心自问，我们每次修改代码的时候，是否真正做到了“<strong>对扩展开放，对修改关闭</strong>”呢？ 所以，在面对扩展这个话题时，我们不妨来一起看看 ABP vNext 中是如何实践“<strong>开闭原则</strong>”。</p><h1 id="扩展实体"><a href="#扩展实体" class="headerlink" title="扩展实体"></a>扩展实体</h1><p>首先，我们要说的是扩展实体，什么是实体呢？这其实是领域驱动设计(<strong>DDD</strong>)中的概念，相信对于实体、聚合根和值对象，大家早就耳熟能详了。在 ABP vNext 中，实体对应的类型为<code>Entity</code>，聚合根对应的类型为<code>AggregateRoot</code>。所以，你可以片面地认为，只要继承自<code>Entity</code>基类的类都是实体。通常，实体都会有一个唯一的标识(<strong>Id</strong>)，所以，订单、商品或者是用户，都属于实体的范畴。不过，按照业务边界上的不同，它们会在核心域、支撑域和通用域三者间频繁切换。而对于大多数系统而言，用户都将是一个通用的域。在 ABP vNext 中，其用户信息由<code>AbpUsers</code>表承载，它在架构上定义了<code>IUser</code>接口，借助于EF Core的表映射支持，我们所使用的<code>AppUser</code>本质上是映射到了<code>AbpUsers</code>表中。针对实体的扩展，在面向数据库编程的业务系统中，一个最典型的问题就是，我怎么样可以给<code>AppUser</code>添加字段。所以，下面我们以<code>AppUser</code>为例，来展示如何对实体进行扩展。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/19/dtANSYQqyDz9blw.jpg" alt="DDD 中的实体、聚合根与值对象" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">DDD 中的实体、聚合根与值对象</div>            </figure><p>实际上，ABP vNext 中提供了2种方式，来解决实体扩展的问题，它们分别是：<strong>Extra Properties</strong> 和 <strong>基于 EF Core 的表映射</strong>。在 <a href="https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities" target="_blank" rel="noopener">官方文档</a> 中，我们会得到更加详细的信息，这里简单介绍一下就好：</p><h2 id="Extra-Properties"><a href="#Extra-Properties" class="headerlink" title="Extra Properties"></a>Extra Properties</h2><p>对于第1种方式，它要求我们必须实现<code>IHasExtraProperties</code>接口，这样我们就可以使用<code>GetProperty()</code>和<code>SetProperty()</code>两个方法，其原理是，将这些扩展字段以<code>JSON</code>格式存储在<code>ExtraProperties</code>这个字段上。如果使用<code>MongoDB</code>这样的非关系型数据库，则这些扩展字段可以单独存储。参考示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置扩展字段</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">await</span> _identityUserRepository.GetAsync(userId);</span><br><span class="line">user.SetProperty(<span class="string">"Title"</span>, <span class="string">"起风了，唯有努力生存"</span>);</span><br><span class="line"><span class="keyword">await</span> _identityUserRepository.UpdateAsync(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取扩展字段</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">await</span> _identityUserRepository.GetAsync(userId);</span><br><span class="line"><span class="keyword">return</span> user.GetProperty&lt;<span class="keyword">string</span>&gt;(<span class="string">"Title"</span>);</span><br></pre></td></tr></table></figure><p>可以想象得到，这种方式使用起来没有心智方面的困扰，主要问题是，这些扩展字段不利于关系型数据库的查询。其次，完全以字符串形式存在的键值对，难免存在数据类型的安全性问题。博主的上家公司，在面对这个问题时，采用的方案就是往数据库里加备用字段，从起初的5个，变成后来的10个，最后甚至变成20个，先不说这没完没了的加字段，代码中一直避不开的，其实是各种字符串的<strong>Parse</strong>/<strong>Convert</strong>，所以，大家可以自己去体会这其中的痛苦。</p><h2 id="基于-EF-Core-的表映射"><a href="#基于-EF-Core-的表映射" class="headerlink" title="基于 EF Core 的表映射"></a>基于 EF Core 的表映射</h2><p>对于第2种方式，主要指 EF Core 里的“<strong>表拆分</strong>”或者“<strong>表共享</strong>”，譬如，当我们希望单独创建一个实体<code>SysUser</code>来替代默认的<code>AppUser</code>时，这就是表拆分，因为同一张表中的数据，实际上是被<code>AppUser</code>和<code>SysUser</code>共享啦，或者，你可以将其理解为，EF Core配置两个不同的实体时，它们的<code>ToTable()</code>方法都指向了同一张表。这里唯一不同的是，ABP vNext 中提供了一部分方法用来处理问题，因为牵扯到数据库，所以，还是需要“迁移”。下面，我们以给<code>AppUser</code>扩展两个自定义字段为例：</p><p>首先，我们给<code>AppUser</code>类增加两个新属性，<code>Avatar</code> 和 <code>Profile</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppUser : FullAuditedAggregateRoot&lt;Guid&gt;, IUser</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> Profile &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> Avatar &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  ...</span></span><br></pre></td></tr></table></figure><p>接下来，按照 EF Core 的“<strong>套路</strong>”，我们需要配置下这两个新加的字段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">builder.Entity&lt;AppUser&gt;(b =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AbpUsers</span></span><br><span class="line">    <span class="comment">// Sharing the same table "AbpUsers" with the IdentityUser</span></span><br><span class="line">    b.ToTable(AbpIdentityDbProperties.DbTablePrefix + <span class="string">"Users"</span>); </span><br><span class="line"></span><br><span class="line">    b.ConfigureByConvention();</span><br><span class="line">    b.ConfigureAbpUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Profile</span></span><br><span class="line">    b.Property(x =&gt; x.Profile)</span><br><span class="line">      .HasMaxLength(AppUserConsts.MaxProfileLength)</span><br><span class="line">      .HasColumnName(<span class="string">"Profile"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Avatar</span></span><br><span class="line">    b.Property(x =&gt; x.Avatar)</span><br><span class="line">      .HasMaxLength(AppUserConsts.MaxAvatarLength)</span><br><span class="line">      .HasColumnName(<span class="string">"Avatar"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来，通过<code>MapEfCoreProperty()</code>方法，将新字段映射到<code>IdentityUser</code>实体，你可以理解为，<code>AppUser</code>和<code>IdentityUser</code>同时映射到了<code>AbpUsers</code>这张表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avatar</span></span><br><span class="line">ObjectExtensionManager.Instance.MapEfCoreProperty&lt;IdentityUser, <span class="keyword">string</span>&gt;(</span><br><span class="line">    <span class="keyword">nameof</span>(AppUser.Avatar),</span><br><span class="line">    (entityBuilder, propertyBuilder) =&gt; &#123;</span><br><span class="line">    propertyBuilder.HasMaxLength(AppUserConsts.MaxAvatarLength);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Profile</span></span><br><span class="line">ObjectExtensionManager.Instance.MapEfCoreProperty&lt;IdentityUser, <span class="keyword">string</span>&gt;(</span><br><span class="line">      <span class="keyword">nameof</span>(AppUser.Profile),</span><br><span class="line">      (entityBuilder, propertyBuilder) =&gt; &#123;</span><br><span class="line">      propertyBuilder.HasMaxLength(AppUserConsts.MaxProfileLength);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>既然，连数据库实体都做了扩展，那么，数据传输对象(<strong>DTO</strong>)有什么理由拒绝呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ObjectExtensionManager.Instance</span><br><span class="line">    .AddOrUpdateProperty&lt;<span class="keyword">string</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserDto),</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserCreateDto),</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserUpdateDto),</span><br><span class="line">            <span class="keyword">typeof</span>(ProfileDto),</span><br><span class="line">            <span class="keyword">typeof</span>(UpdateProfileDto),</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Avatar"</span></span><br><span class="line">    )</span><br><span class="line">    .AddOrUpdateProperty&lt;<span class="keyword">string</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserDto),</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserCreateDto),</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserUpdateDto),</span><br><span class="line">            <span class="keyword">typeof</span>(ProfileDto),</span><br><span class="line">            <span class="keyword">typeof</span>(UpdateProfileDto)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Profile"</span></span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>经过这一系列的“<strong>套路</strong>”，此时，我们会发现，新的字段已经生效：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/19/WExbQrs61ltcqzy.png" alt="ABP vNext 实体扩展效果展示" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">ABP vNext 实体扩展效果展示</div>            </figure><h1 id="扩展服务"><a href="#扩展服务" class="headerlink" title="扩展服务"></a>扩展服务</h1><p>在 ABP vNext 中，我们还可以对服务进行扩展，得益于依赖注入的深入人心，我们可以非常容易地实现或者替换某一个接口，这里则指 ABP vNext 中的应用服务(ApplicationService)，例如，CrudAppService类可以帮助我们快速实现枯燥的增删改查，而我们唯一要做的，则是定义好实体的主键(<strong>Primary Key</strong>)、定义好实体的数据传输对象(<strong>DTO</strong>)。当我们发现 ABP vNext 中内置的模块或者服务，无法满足我们的使用要求时，我们就可以考虑对原有服务进行替换，或者是注入新的应用服务来扩展原有服务，这就是服务的扩展。在 ABP vNext 中，我们可以使用下面两种方法来对一个服务进行替换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过[Dependency]和[ExposeServices]实现服务替换</span></span><br><span class="line">[<span class="meta">Dependency(ReplaceServices = true)</span>]</span><br><span class="line">[<span class="meta">ExposeServices(typeof(IIdentityUserAppService))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">YourIdentityUserAppService</span> : <span class="title">IIdentityUserAppService</span>, <span class="title">ITransientDependency</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ReplaceService实现服务替换</span></span><br><span class="line">context.Services.Replace(</span><br><span class="line">    ServiceDescriptor.Transient&lt;IIdentityUserAppService, YourIdentityUserAppService&gt;()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里，博主准备的一个示例是，默认的用户查询接口，其返回信息中只有用户相关的字段，我们希望在其中增加角色、组织单元等关联信息，此时。我们可以考虑实现下面的应用服务：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUserManageAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;PagedResultDto&lt;UserDetailQueryDto&gt;&gt; GetUsersWithDetails(</span><br><span class="line">      GetIdentityUsersInput input</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们定义了<code>IUserManageAppService</code>接口，它含有一个分页查询的方法<code>GetUsersWithDetails()</code>。接下来，我们来考虑如何实现这个接口。需要说明的是，在 ABP vNext 中，仓储模式的支持由通用仓储接口<code>IRepository&lt;TEntity, TKey&gt;</code>提供，ABP vNext 会在<code>AddDefaultRepositories()</code>方法中为每一个聚合根注入对应的仓储。同样地，你可以按照个人喜好为指定的实体注入对应的仓储。由于ABP vNext 同时支持 <code>EF Core</code>、<code>Dapper</code> 和 <code>MongoDB</code>，所以，我们还可以使用<code>EfCoreRepository</code>、<code>DapperRepository</code> 以及 <code>MongoDbRepository</code>，它们都是<code>IRepository</code>的具体实现类。在下面的例子中，我们使用的是<code>EfCoreRepository</code>这个类。</p><p>事实上，这里注入的<code>EfCoreIdentityUserRepository</code>、<code>EfCoreIdentityRoleRepository</code> 以及 <code>EfCoreOrganizationUnitRepository</code>，都是<code>EfCoreRepository</code>的子类，这使得我们可以复用 ABP vNext 中关于身份标识的一切基础设施，来实现不同于官方的业务逻辑，而这就是我们所说的服务的扩展。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize(IdentityPermissions.Users.Default)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserManageAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IUserManageAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IdentityUserManager _userManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IOptions&lt;IdentityOptions&gt; _identityOptions;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> EfCoreIdentityUserRepository _userRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> EfCoreIdentityRoleRepository _roleRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> EfCoreOrganizationUnitRepository _orgRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserManageAppService</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        IdentityUserManager userManager,</span></span></span><br><span class="line"><span class="function"><span class="params">        EfCoreIdentityRoleRepository roleRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">        EfCoreIdentityUserRepository userRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">        EfCoreOrganizationUnitRepository orgRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">        IOptions&lt;IdentityOptions&gt; identityOptions</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _userManager = userManager;</span><br><span class="line">        _orgRepository = orgRepository;</span><br><span class="line">        _userRepository = userRepository;</span><br><span class="line">        _roleRepository = roleRepository;</span><br><span class="line">        _identityOptions = identityOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Authorize(IdentityPermissions.Users.Default)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;PagedResultDto&lt;UserDetailQueryDto&gt;&gt; GetUsersWithDetails(</span><br><span class="line">      GetIdentityUsersInput input</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Users</span></span><br><span class="line">        <span class="keyword">var</span> total = <span class="keyword">await</span> _userRepository.GetCountAsync(input.Filter);</span><br><span class="line">        <span class="keyword">var</span> users = <span class="keyword">await</span> _userRepository.GetListAsync(</span><br><span class="line">          input.Sorting, </span><br><span class="line">          input.MaxResultCount, </span><br><span class="line">          input.SkipCount, </span><br><span class="line">          input.Filter, </span><br><span class="line">          includeDetails: <span class="literal">true</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Roles</span></span><br><span class="line">        <span class="keyword">var</span> roleIds = users</span><br><span class="line">          .SelectMany(x =&gt; x.Roles)</span><br><span class="line">          .Select(x =&gt; x.RoleId)</span><br><span class="line">          .Distinct()</span><br><span class="line">          .ToList();</span><br><span class="line">        <span class="keyword">var</span> roles = <span class="keyword">await</span> _roleRepository</span><br><span class="line">          .WhereIf(roleIds.Any(), x =&gt; roleIds.Contains(x.Id))</span><br><span class="line">          .ToListAsync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//OrganizationUnits</span></span><br><span class="line">        <span class="keyword">var</span> orgIds = users</span><br><span class="line">          .SelectMany(x =&gt; x.OrganizationUnits)</span><br><span class="line">          .Select(x =&gt; x.OrganizationUnitId)</span><br><span class="line">          .Distinct()</span><br><span class="line">          .ToList();</span><br><span class="line">        <span class="keyword">var</span> orgs = <span class="keyword">await</span> _orgRepository</span><br><span class="line">          .WhereIf(orgIds.Any(), x =&gt; orgIds.Contains(x.Id))</span><br><span class="line">          .ToListAsync();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> items = ObjectMapper.Map&lt;List&lt;Volo.Abp.Identity.IdentityUser&gt;, List&lt;UserDetailQueryDto&gt;&gt;(users);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> role <span class="keyword">in</span> item.Roles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> roleInfo = roles.FirstOrDefault(x =&gt; x.Id == role.RoleId);</span><br><span class="line">                <span class="keyword">if</span> (roleInfo != <span class="literal">null</span>)</span><br><span class="line">                    ObjectMapper.Map(roleInfo, role);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> org <span class="keyword">in</span> item.OrganizationUnits)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> orgInfo = orgs.FirstOrDefault(x =&gt; x.Id == org.OrganizationUnitId);</span><br><span class="line">                <span class="keyword">if</span> (orgInfo != <span class="literal">null</span>)</span><br><span class="line">                    ObjectMapper.Map(orgInfo, org);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PagedResultDto&lt;UserDetailQueryDto&gt;(total, items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做一点补充说明，应用服务，即<code>ApplicationService</code>类，它集成了诸如<code>ObjectMapper</code>、<code>LoggerFactory</code>、<code>GuidGenerator</code>、国际化、<code>AsyncExecuter</code>等等的特性，继承该类可以让我们更加得心应手地编写代码。曾经，博主写过一篇关于“<strong>动态API</strong>”的<a href="https://blog.yuanpei.me/posts/4236649/" target="_blank" rel="noopener">博客</a>，它可以为我们免去从 Service 到 Controller 的这一层封装，当时正是受到了ABP 框架的启发。当博主再次在 ABP vNext 中看到这个功能时，不免会感慨逝者如斯，而事实上，这个功能真的好用，真香！下面是经过改造以后的用户列表。考虑到，在上一篇博客里，博主已经同大家分享过分页查询方面的实现技巧，这里就不再展开讲啦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/19/B6SO8Wk4EVh3Pcx.png" alt="对“用户服务”进行扩展" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">对“用户服务”进行扩展</div>            </figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>我们时常说，”<strong>对修改关闭，对扩展开放</strong>“，”<strong>单一职责</strong>“，可惜这些原则最多就出现在面试环节。当你接触了真实的代码，你会发现”<strong>修改</strong>“永远比”<strong>扩展</strong>“多，博主曾经就见到过，一个简单的方法因为频繁地”<strong>打补丁</strong>“，最后变得面目全非。其实，有时候并不是维护代码的人，不愿意去”<strong>扩展</strong>“，而是写出可”<strong>扩展</strong>“的代码会更困难一点，尤其是当所有人都不愿意去思考，一味地追求短平快，这无疑只会加速代码的腐烂。在这一点上，ABP vNext 提供了一种优秀的范例，这篇文章主要分享了 ABP vNext 中实体和服务的扩展技巧，<strong>实体扩展解决了如何为数据库表添加扩展字段的问题，服务扩展解决了如何为默认服务扩展功能的问题</strong>，尤其是后者，依赖注入在其中扮演着无比重要的角色。果然，这世上的事情，只有你真正在乎的时候，你才会愿意去承认，那些你曾经轻视过的东西，也许，它们是对的吧！好了，以上就是这篇博客的全部内容，欢迎大家在评论区留言，喜欢的话请记得点赞、收藏、一键三连。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="ABP" scheme="https://qinyuanpei.github.io/tags/ABP/"/>
    
      <category term="扩展" scheme="https://qinyuanpei.github.io/tags/%E6%89%A9%E5%B1%95/"/>
    
      <category term="实体" scheme="https://qinyuanpei.github.io/tags/%E5%AE%9E%E4%BD%93/"/>
    
      <category term="服务" scheme="https://qinyuanpei.github.io/tags/%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>ABP vNext 对接 Ant Design Vue 实现分页查询</title>
    <link href="https://qinyuanpei.github.io/posts/3670340170/"/>
    <id>https://qinyuanpei.github.io/posts/3670340170/</id>
    <published>2021-04-07T21:07:47.000Z</published>
    <updated>2021-05-28T02:08:18.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在 <a href="https://blog.yuanpei.me/posts/2151871792/" target="_blank" rel="noopener">上一篇</a> 博客中，博主和大家分享了如何在 <a href="https://docs.microsoft.com/zh-cn/ef/core/get-started/overview/first-app?tabs=netcore-cli" target="_blank" rel="noopener">EF Core</a> 中实现多租户架构。在这一过程中，博主主要参考了 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 这个框架。从上个月开始，我个人发起了一个项目，基于 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 和 <a href="https://www.antdv.com/docs/vue/introduce-cn/" target="_blank" rel="noopener">Ant Design Vue</a> 来实现一个通用的后台管理系统，希望以此来推进 <a href="https://www.jdon.com/ddd.html" target="_blank" rel="noopener">DDD</a> 和 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a> 的学习，努力打通前端与后端的“<strong>任督二脉</strong>”。因此，接下来的这段时间内，我写作的主题将会围绕 ABP vNext 和 Ant Design Vue。而在今天的这篇博客中，我们来说说 ABP vNext 对接 Ant Design Vue 实现分页查询的问题，希望能让大家在面对类似问题时有所帮助。我不打算写一个系列教程，更多的是从我个人的关注点出发，如果大家有更多想要交流的话题，欢迎大家通过评论或者邮件来留言，谢谢大家！</p><h1 id="ABP-vNext中的分页查询"><a href="#ABP-vNext中的分页查询" class="headerlink" title="ABP vNext中的分页查询"></a>ABP vNext中的分页查询</h1><p>OK，当大家接触过 ABP vNext 以后，就会了解到这样一件事情，即，ABP vNext 中默认提供的分页查询接口，在大多数情况下，通常都会是下面这样的风格。这里以角色查询的接口为例，它对应的请求地址是：<code>/api/identity/roles?SkipCount=0&amp;MaxResultCount=10</code>。此时，我们可以注意到，返回的数据结构中含有<code>totalCount</code>和<code>items</code>两个属性。其中，<code>totalCount</code>表示记录的总数目，<code>items</code>表示当前页对应的记录。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"totalCount"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"items"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Admin"</span>,</span><br><span class="line">      <span class="attr">"isDefault"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"isStatic"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"isPublic"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"concurrencyStamp"</span>: <span class="string">"cb53f2d7-159e-452d-9d9c-021629b500e0"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"39fb19e8-fb34-dfbd-3c70-181f604fd5ff"</span>,</span><br><span class="line">      <span class="attr">"extraProperties"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Manager"</span>,</span><br><span class="line">      <span class="attr">"isDefault"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"isStatic"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"isPublic"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"concurrencyStamp"</span>: <span class="string">"145ec550-7fe7-4c80-85e3-f317a168e6b6"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"39fb6216-2803-20c6-7211-76f8fe38b90e"</span>,</span><br><span class="line">      <span class="attr">"extraProperties"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，ABP vNext 中自带的分页查询，主要是通过<code>SkipCount</code>和<code>MaxResultCount</code>两个参数来实现。假设<code>MaxResultCount</code>，即分页大小为<code>m</code>，则第<code>n</code>页对应的<code>SkipCount</code>应该为<code>(n-1) * m</code>。如果大家对于<code>LINQ</code>非常熟悉的话，应该可以自然而然地联想到<code>Skip()</code>和<code>Take()</code>两个方法，这是一个非常自然的联想，因为 ABP vNext 就是这样实现分页查询的。这里以博主的“<strong>数据字典</strong>”分页查询接口为例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;PagedResultDto&lt;DataDictionaryQueryDto&gt;&gt; GetCategories(</span><br><span class="line">    GetDataDictionaryRequestInput input</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> totalCount = (<span class="keyword">await</span> _dataDictRepository.GetQueryableAsync())</span><br><span class="line">    .WhereIf(!<span class="keyword">string</span>.IsNullOrEmpty(input.Name), x =&gt; x.Name.Contains(input.Name) || x.Name == input.Name)</span><br><span class="line">    .WhereIf(!<span class="keyword">string</span>.IsNullOrEmpty(input.Description), x =&gt; x.Description.Contains(input.Description) || x.Description == input.Description)</span><br><span class="line">    .Count();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> items = (<span class="keyword">await</span> _dataDictRepository.GetQueryableAsync())</span><br><span class="line">    .WhereIf(!<span class="keyword">string</span>.IsNullOrEmpty(input.Name), x =&gt; x.Name.Contains(input.Name) || x.Name == input.Name)</span><br><span class="line">    .WhereIf(!<span class="keyword">string</span>.IsNullOrEmpty(input.Description), x =&gt; x.Description.Contains(input.Description) || x.Description == input.Description)</span><br><span class="line">    .Skip(input.SkipCount)</span><br><span class="line">    .Take(input.MaxResultCount)</span><br><span class="line">    .ToList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PagedResultDto&lt;DataDictionaryQueryDto&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">      TotalCount = totalCount,</span><br><span class="line">      Items = ObjectMapper.Map&lt;List&lt;DataDictionary&gt;, List&lt;DataDictionaryQueryDto&gt;&gt;(items)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，在 ABP vNext 中我们只需要构造好<code>TotalCount</code>和<code>Items</code>这两个属性即可。</p><h1 id="STable组件中的分页查询"><a href="#STable组件中的分页查询" class="headerlink" title="STable组件中的分页查询"></a>STable组件中的分页查询</h1><p>接下来，在 Ant Design Vue 的 Pro 版本中，我们使用<code>STable</code>组件来展示列表类的数据，关于这个组件的使用方法，大家可以参考 <a href="https://github.com/vueComponent/ant-design-vue-pro/blob/master/src/components/Table/README.md" target="_blank" rel="noopener">官方文档</a>。按照最小化可行产品(<strong>MVP</strong>)的理念，一个最简单的<code>STable</code>组件的使用，如下面所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">s-table</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"table"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">size</span>=<span class="string">"default"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:rowKey</span>=<span class="string">"(record) =&gt; record.data.id"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:columns</span>=<span class="string">"columns"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:data</span>=<span class="string">"loadData"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:rowSelection</span>=<span class="string">"&#123; selectedRowKeys: selectedRowKeys, onChange: onSelectChange &#125;"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">s-table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这个组件而言，其中最重要的地方当属<code>data</code>属性，它接受一个函数，该函数的返回值为<code>Promise</code>对象，并且有一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> STable <span class="keyword">from</span> <span class="string">'@/components'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      STable</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 表格列名</span></span><br><span class="line">        columns: [],</span><br><span class="line">        <span class="comment">// 查询条件</span></span><br><span class="line">        queryParam: &#123; &#125;,</span><br><span class="line">        <span class="comment">// 加载数据方法，必须为 Promise 对象</span></span><br><span class="line">        loadData: <span class="function"><span class="params">parameter</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> getRoles(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.queryParam, parameter))</span><br><span class="line">            .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> res.result</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        selectedRowKeys: [],</span><br><span class="line">        selectedRows: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>也许，你会好奇这个<code>parameter</code>到底是个什么东西？可如果我们将其打印出来，就会发现它其实是分页查询相关的参数：<code>Object { pageNo: 1, pageSize: 10 }</code>，而更进一步，如果深入到这个组件的源代码中，我们会注意到组件内部有一个<code>loadData()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">loadData (pagination, filters, sorter) &#123;</span><br><span class="line">  <span class="keyword">this</span>.localLoading = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> parameter = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    pageNo: (pagination &amp;&amp; pagination.current) ||</span><br><span class="line">      <span class="keyword">this</span>.showPagination &amp;&amp; <span class="keyword">this</span>.localPagination.current || <span class="keyword">this</span>.pageNum,</span><br><span class="line">    pageSize: (pagination &amp;&amp; pagination.pageSize) ||</span><br><span class="line">      <span class="keyword">this</span>.showPagination &amp;&amp; <span class="keyword">this</span>.localPagination.pageSize || <span class="keyword">this</span>.pageSize</span><br><span class="line">    &#125;,</span><br><span class="line">    (sorter &amp;&amp; sorter.field &amp;&amp; &#123;</span><br><span class="line">      sortField: sorter.field</span><br><span class="line">    &#125;) || &#123;&#125;,</span><br><span class="line">    (sorter &amp;&amp; sorter.order &amp;&amp; &#123;</span><br><span class="line">      sortOrder: sorter.order</span><br><span class="line">    &#125;) || &#123;&#125;, &#123;</span><br><span class="line">    ...filters</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">this</span>.data(parameter)</span><br><span class="line">  <span class="comment">// 对接自己的通用数据接口需要修改下方代码中的 r.pageNo, r.totalCount, r.data</span></span><br></pre></td></tr></table></figure><p>可以注意到，在<code>STable</code>组件内部，它会将分页、排序和过滤三种不同类型的参数，通过<code>Object.assign()</code>方法聚合到一个对象上，这个对象实际上就是我们刚刚打印出来的<code>parameter</code>。为什么这样说呢？因为它接下来就要调用<code>data</code>属性指向的方法啦！还记得这个<code>data</code>是什么吗？不错，它是一个函数，既然是一个函数，当然可以直接调用。到这里，我们可以获得第一个信息，即，<strong>ABP vNext 中的表格组件STable，本身封装了分页查询相关的参数，只要将这些参数传递给后端就可以实现分页查询</strong>。</p><h1 id="实现参数转换层"><a href="#实现参数转换层" class="headerlink" title="实现参数转换层"></a>实现参数转换层</h1><p>既然，这个参数和 ABP vNext 需要的参数不同，为了不修改已有的接口，我们考虑在这中间加一层转换。为此，我们定义下面的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认列表查询条件</span></span><br><span class="line"><span class="keyword">const</span> baseListQuery = &#123;</span><br><span class="line">  page: <span class="number">1</span>,</span><br><span class="line">  limit: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询条件转化</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformAbpListQuery</span> (<span class="params">query</span>) </span>&#123;</span><br><span class="line">  query.filter = query.filter === <span class="string">''</span> ? <span class="literal">undefined</span> : query.filter</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.isNaN(query.pageSize)) &#123;</span><br><span class="line">    query.pageSize = baseListQuery.limit</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.isNaN(query.pageNo)) &#123;</span><br><span class="line">    query.pageNo = baseListQuery.page</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> abpListQuery = &#123;</span><br><span class="line">    maxResultCount: query.pageSize,</span><br><span class="line">    skipCount: (query.pageNo - <span class="number">1</span>) * query.pageSize,</span><br><span class="line">    sorting: <span class="string">''</span>,</span><br><span class="line">    filter: <span class="string">''</span>,</span><br><span class="line">    ...query</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (query.sortField) !== <span class="string">'undefined'</span> &amp;&amp; query.sortField !== <span class="literal">null</span>) &#123;</span><br><span class="line">    abpListQuery.sorting = query.sortOrder === <span class="string">'ascend'</span></span><br><span class="line">      ? query.sortField</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;query.sortField&#125;</span> Desc`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> abpListQuery</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码非常简单，通过<code>transformAbpListQuery</code>函数，我们就实现了从<code>STable</code>到<code>ABP vNext</code>的参数转换。需要说明的是，这里的排序使用到了 <a href="https://github.com/zzzprojects/System.Linq.Dynamic.Core" target="_blank" rel="noopener">System.Linq.Dynamic.Core</a> 这个库，它可以实现<code>IQueryable</code>级别的、基于字符串的动态表达式构建功能，使用方法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resultSingle = queryable.OrderBy&lt;User&gt;(<span class="string">"NumberProperty"</span>);</span><br><span class="line"><span class="keyword">var</span> resultSingleDescending = queryable.OrderBy&lt;User&gt;(<span class="string">"NumberProperty DESC"</span>);</span><br><span class="line"><span class="keyword">var</span> resultMultiple = queryable.OrderBy&lt;User&gt;(<span class="string">"NumberProperty, StringProperty"</span>);</span><br></pre></td></tr></table></figure><p>所以，当它为降序排序时，我们在排序字段的后面添加<code>DESC</code>即可。关于<code>filter</code>参数，我准备做一套通用性更强的方案，所以，这里就暂时留空啦！接下来，如果大家足够细心的话，会发现<code>STable</code>组件对返回值同样有一定的要求，它要求返回值中至少含有<code>pageNo</code>、<code>totalCount</code>, <code>data</code>三个属性，而这，是我们获得的第二个信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对接自己的通用数据接口需要修改下方代码中的 r.pageNo, r.totalCount, r.data</span></span><br><span class="line"><span class="comment">// eslint-disable-next-line</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">typeof</span> result === <span class="string">'object'</span> || <span class="keyword">typeof</span> result === <span class="string">'function'</span>) </span><br><span class="line">  &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">  result.then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.localPagination = <span class="keyword">this</span>.showPagination </span><br><span class="line">    &amp;&amp; <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.localPagination, &#123;</span><br><span class="line">      current: r.pageNo, <span class="comment">// 返回结果中的当前分页数</span></span><br><span class="line">      total: r.totalCount, <span class="comment">// 返回结果中的总记录数</span></span><br><span class="line">      showSizeChanger: <span class="keyword">this</span>.showSizeChanger,</span><br><span class="line">      pageSize: (pagination &amp;&amp; pagination.pageSize) ||</span><br><span class="line">      <span class="keyword">this</span>.localPagination.pageSize</span><br><span class="line">    &#125;) || <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.localDataSource = r.data <span class="comment">// 返回结果中的数组数据</span></span><br><span class="line">    <span class="keyword">this</span>.localLoading = <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依样画葫芦，我们继续编写转换层的代码，返回值格式参考了 Ant Design Vue 中Mock接口的返回值格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询结果转化</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformAbpQueryResult</span> (<span class="params">data, message, code = <span class="number">0</span>, headers = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> responseBody = &#123; &#125;</span><br><span class="line">  responseBody.result = data</span><br><span class="line">  <span class="keyword">if</span> (message !== <span class="literal">undefined</span> &amp;&amp; message !== <span class="literal">null</span>) &#123;</span><br><span class="line">    responseBody.message = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (code !== <span class="literal">undefined</span> &amp;&amp; code !== <span class="number">0</span>) &#123;</span><br><span class="line">    responseBody.code = code</span><br><span class="line">    responseBody._status = code</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (headers !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> headers === <span class="string">'object'</span> </span><br><span class="line">    &amp;&amp; <span class="built_in">Object</span>.keys(headers).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    responseBody._headers = headers</span><br><span class="line">  &#125;</span><br><span class="line">  responseBody.timestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  <span class="keyword">return</span> responseBody</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分页查询结果转化</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">buildPagingQueryResult</span> (<span class="params">queryParam, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> data.items) &#123;</span><br><span class="line">    <span class="comment">// Ant Design Vue 中要求每行数据中必须存在字段：key</span></span><br><span class="line">    item.key = item.id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pagedResult = &#123;</span><br><span class="line">    pageSize: queryParam.pageSize,</span><br><span class="line">    pageNo: queryParam.pageNo,</span><br><span class="line">    totalCount: data.totalCount,</span><br><span class="line">    totalPage: data.totalCount / queryParam.pageSize,</span><br><span class="line">    data: data.items</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> transformAbpQueryResult(pagedResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于分页结果而言，我们会将分页大小、当前页数、总页数、总记录数及其对应的数据，统一封装到一个对象中，然后再将其传递给返回值中的<code>result</code>属性。</p><h1 id="最终对接效果"><a href="#最终对接效果" class="headerlink" title="最终对接效果"></a>最终对接效果</h1><p>好了，写了这么多，我们到底实现了一个什么效果呢？对于一开始的角色查询接口，我们可以这样封装到前端的服务层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getRoles</span> (<span class="params">query</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queryParam = transformAbpListQuery(query)</span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">      url: AppConsts.resourceService.baseUrl + <span class="string">'/api/identity/roles'</span>,</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      params: queryParam</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildPagingQueryResult(queryParam, data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们只需要实现<code>loadData()</code>方法即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getRoles, updateRole, createRole, deleteRole &#125; <span class="keyword">from</span> <span class="string">'@/api/recipe/abp.role'</span></span><br><span class="line"></span><br><span class="line">loadData: <span class="function"><span class="params">parameter</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRoles(<span class="built_in">Object</span>.assign(&#123;&#125;, parameter, <span class="keyword">this</span>.queryParam))</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res.result</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>此时，我们可以注意到，ABP vNext 与 Ant Design Vue 完美地集成在一起，并且参数的转换完全符合我们的预期。这样做的好处显而易见，我们只需要遵循 ABP vNext 的规范进行开发即可，考虑到 ABP vNext 可以直接将<code>ApplicationService</code>暴露为 API 接口，这意味着我们写完了接口，就可以立即开始前后端的联调工作，这无疑可以加快我们的研发效率！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/04/09/Uq1M4ZEOJ5VhTdl.png" alt="ABP vNext 与 Ant Design Vue 完成整合" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">ABP vNext 与 Ant Design Vue 完成整合</div>            </figure><p>好了，以上就是这篇博客的全部内容啦！这篇博客要实现的功能其实并不复杂，唯一的难点是，需要在前端和后端两个技术栈上频繁地切换上下文，这可能就是全栈开发者面临的最大挑战，因为技术世界浩如烟海，而一个人的精力终究有限，古人云：<strong>朝闻道，夕死可矣</strong>，人生百年，吾道不孤，还是请你继续努力哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="ABP" scheme="https://qinyuanpei.github.io/tags/ABP/"/>
    
      <category term="Vue" scheme="https://qinyuanpei.github.io/tags/Vue/"/>
    
      <category term="分页" scheme="https://qinyuanpei.github.io/tags/%E5%88%86%E9%A1%B5/"/>
    
      <category term="前端" scheme="https://qinyuanpei.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>浅议 EF Core 分库分表及多租户架构的实现</title>
    <link href="https://qinyuanpei.github.io/posts/2151871792/"/>
    <id>https://qinyuanpei.github.io/posts/2151871792/</id>
    <published>2021-03-27T17:47:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>各位朋友，大家好，我是 Payne，欢迎大家关注我的博客，我的博客地址是：<a href="https://blog.yuanpei.me" target="_blank" rel="noopener">https://blog.yuanpei.me</a>。最近这段时间，我一直在学习 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 框架，在整个学习过程中，我基本就是在“<strong>文档</strong>”和“<strong>源码</strong>”间来回横跳。我个人推荐大家，多去阅读一点优秀的代码，因为阅读 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 的源代码简直就是一种享受，它可以暂时让你摆脱如泥沼一般的业务代码。言归正传，<a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 是一个支持多租户架构的框架，在了解了其多租户的实现原理以后，从中收获一点微不足道的小技巧。正好前几天，刚刚同一位朋友讨论完分库、分表这类话题。因此，在今天这篇博客中，我想和大家一起探讨下 <a href="https://docs.microsoft.com/zh-cn/ef/core/get-started/overview/first-app?tabs=netcore-cli" target="_blank" rel="noopener">EF Core</a> 关于分库、分表以及多租户架构的实现。此中曲折，可以说是初窥门径，或许我无法提供给你一个开箱即用的方案，至少它可以带给你一点启发。有读者朋友建议我，不要总是写这种“<strong>高深</strong>”、“<strong>复杂</strong>”的话题，适当地迎合读者写点不需要动脑子的东西。对此，我想说，我有我个人技术上的追求，希望大家理解！</p><h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><p>首先，我们一起来探讨分库这个话题。从字面含义上了解，分库就是指<strong>应用程序拥有多个数据库，而这些数据库则拥有相同的表结构</strong>。你可能会问，为什么我们需要分库、分表？答案自然是<strong>性能</strong>，<strong>性能</strong>，还是TM的<strong>性能</strong>。我相信，大家都曾经或多或少地听到过<strong>垂直拆分</strong>、<strong>水平拆分</strong>这样的术语，下图展示了如何在<strong>数据库</strong>这一层级上进行拆分：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/03/29/nX8NBbhP9ToQa2M.png" alt="数据库的垂直拆分与水平拆分" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">数据库的垂直拆分与水平拆分</div>            </figure><p>其实，我们可以从<strong>索引存储</strong>、<strong>B+树高度</strong>、<strong>QPS</strong> 和 <strong>连接数</strong> 这四个不同的角度来审视这个话题。相关观点认为，当单表数据量达到一定量级(阿里巴巴Java开发手册中为500W)时，由于内存无法存储其索引，此时SQL查询会产生磁盘IO；行记录的大小决定了B+树的每个叶子节点能存储多少记录，所以，行记录的大小会影响B+树的高度；单个MySQL物理机实例写QPS峰值大概为1万，一旦业务量达到某个量级，这个瓶颈会逐步凸显出来；单个MySQL实例最大连接数有限，更多的访问量意味着需要更多的连接数。</p><p>在谈论分库、分表的时候，我们忍不住会去想譬如“<strong>自动分表</strong>”和“<strong>路由</strong>”这样的问题，这些子库、子表，到底是提前在数据库里分好呢，还是在运行时期间自动去拆分呢，以及我对库/表进行拆分以后，我应该怎么样找到某条数据对应的库/表。我承认，这些问题并不简单，但当我们对问题进行简化以后，分库本质上就是动态地切换数据库，对不对？无非是拆分后的数据库可能会是类似db_0、db_1等等这样的序列。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/03/29/pmhOTFkZYjAsLXq.png" alt="对 Chinook 进行水平拆分" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">对 Chinook 进行水平拆分</div>            </figure><p>对于数据库的自动拆分，博主尝试过的一种方案是：首先，通过<code>Add-Migration</code>生成迁移。然后，通过循环修改连接字符串的方式，调用<code>Context.Database.Migrate()</code>方法为一个数据库迁移表结构和种子数据。当然，有些朋友不认同在生产环境使用迁移的做法，认为对数据库的操作权限还是应该交给 DBA 来管理，这当然无可厚非。我表达的一直都是一种思路，我不想一个工作六年的人，对技术的态度永远都停留在“能跑”、“能抄”这种水平。</p><p>一旦想清楚这一层，实现起来还是非常简单的。我们在配置中准备多个数据库来模拟分库的场景，实际应用中到底是用<strong>范围</strong>、<strong>Hash</strong> 还是 <strong>配置</strong>，大家结合自己的场景来决定就好。其实，这个思路还可以用来做读写分离，无非是这个库更特殊一点，它是个从库。好了，我们一起来看下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里随机连接到某一个数据库</span></span><br><span class="line"><span class="comment">// 实际应该按照某种方式获得数据库库名后缀</span></span><br><span class="line"><span class="keyword">var</span> shardings = _options.Value.MultiTenants;</span><br><span class="line"><span class="keyword">var</span> sharding = shardings[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, shardings.Count)];</span><br><span class="line">_chinookContext.Database.GetDbConnection().ConnectionString = sharding.ConnectionString;</span><br><span class="line">Console.WriteLine(<span class="string">"--------分库场景--------"</span>);</span><br><span class="line">Console.WriteLine(_chinookContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_chinookContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_chinookContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure><p>事实上，如果选择性地忽略 “<strong>路由</strong>” 和 “<strong>自动分表</strong>” 这两个特性，我们已经在 EF 层面上局部的实现了 “<strong>分库</strong>” 功能：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/03/29/jLxlK3fro8qXSas.png" alt="分库场景" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">分库场景</div>            </figure><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>好了，聊完分库，我们再来聊聊分表。分表就是指同一个数据库里拥有多张结构(<strong>Schema</strong>)相同的表。一个典型的例子是，Excel里的多张Sheet，只要它们拥有相同的结构(<strong>Schema</strong>)，就可以视为同一类型的数据，虽然它们拥有不同的表名。和分库类似，分表的着眼点是避免产生“大表”，从而达到提高查询性能的目的。而对应到 EF(<strong>EntityFramework</strong>) 的场景中，<strong>分表本质上就是在解决 EF 动态适配表名的问题</strong>。同样的，下面两张图展示了如何在<strong>表</strong>这个层级进行拆分：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153851001-806440217.jpg" alt="表的垂直拆分" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">表的垂直拆分</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153912863-301123895.jpg" alt="表的水平拆分" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">表的水平拆分</div>            </figure><blockquote><p>图片援引自：<a href="https://www.cnblogs.com/qdhxhz/p/11608222.html" target="_blank" rel="noopener">雨点的名字 - 分库分表(1) — 理论</a></p></blockquote><p>譬如，我们以年为单位，产生了<code>Album_2020</code>和<code>Album_2021</code>两张表。那么，在已经定义好了实体<code>Album</code>的情况下，有没有办法可以让实体<code>Album</code>动态地去适配这两张表呢？或许，熟悉 EF 的你，此刻正在心里暗笑道，这有何难，只要在对应实体的<code>OnModelCreating()</code>方法中，修改<code>ToTable()</code>方法的参数就好了啊。可如果你亲自试一试，就会知道这是你的一厢情愿啦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/03/29/cIFp74gUAX2Q8xq.png" alt="针对 Album 和 Artist 按年份进行拆分" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">针对 Album 和 Artist 按年份进行拆分</div>            </figure><p>事实上，EF 针对实体和表的映射关系做了缓存，这意味着，一旦在<code>OnModelCreating()</code>方法中确定映射关系，这组映射关系将被缓存下来。在 EF 中，这组映射关系的缓存行为，由<code>IModelCacheKeyFactory</code>接口来决定，它提供了一个<code>Create()</code>方法，如果该方法的返回值与上一次相同，则不会调用<code>OnModelCreating()</code>方法。所以，我们的思路就是，让这个<code>Create()</code>方法返回不同的对象。为此，我们考虑实现<code>IModelCacheKeyFactory</code>接口，并用这个自定义实现来替换微软的默认实现。我们一起来看下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicModelCacheKeyFactory</span> : <span class="title">IModelCacheKeyFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Create</span>(<span class="params">DbContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> context <span class="keyword">is</span> ShardingContext shardingContext</span><br><span class="line">            ? (context.GetType(), shardingContext.ShardingSuffix)</span><br><span class="line">            : (<span class="keyword">object</span>)context.GetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了配合<code>DynamicModelCacheKeyFactory</code>的使用，我们还需要定义用于分表的<code>ShardingContext</code>，它继承自<code>DbContext</code>，我们为其扩展了<code>ShardingSuffix</code>属性，并通过注入的<code>IShardingPolicyProvider</code>接口来获取一个分表后缀。比如，我们有<code>Order</code>表，经过拆分后获得<code>Order_01</code>、<code>Order_02</code>这样的子表，所以，这个分表后缀其实就是01、02。没错，我们还是要去修改<code>ToTable()</code>方法中的表名，不同的是，这里的表名是动态的。注意到，<code>Create()</code>方法返回的是一个元组，所以，不同的<code>ShardingSuffix</code>会产生不同的映射关系。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShardingContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Artist&gt; Artist &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Album&gt; Album &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IShardingPolicyProvider _shardingPolicyProvider;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ShardingSuffix &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShardingContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      DbContextOptions&lt;ShardingContext&gt; options, </span></span></span><br><span class="line"><span class="function"><span class="params">      IShardingPolicyProvider shardingPolicyProvider</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _shardingPolicyProvider = shardingPolicyProvider;</span><br><span class="line">        ShardingSuffix = _shardingPolicyProvider.GetShardingSuffix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Album</span></span><br><span class="line">        <span class="comment">// 动态映射表名，譬如：Album_2021</span></span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;().ToTable(<span class="string">$"Album_<span class="subst">&#123;ShardingSuffix&#125;</span>"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;().HasKey(x =&gt; x.AlbumId);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.AlbumId).HasColumnName(<span class="string">"AlbumId"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.Title).HasColumnName(<span class="string">"Title"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.ArtistId).HasColumnName(<span class="string">"ArtistId"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Artist</span></span><br><span class="line">        <span class="comment">// 动态映射表名，譬如：Artist_2021</span></span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;().ToTable(<span class="string">$"Artist_<span class="subst">&#123;ShardingSuffix&#125;</span>"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;().HasKey(x =&gt; x.ArtistId);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;()</span><br><span class="line">          .Property(x =&gt; x.ArtistId).HasColumnName(<span class="string">"ArtistId"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;()</span><br><span class="line">          .Property(x =&gt; x.Name).HasColumnName(<span class="string">"Name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于分库、分表以后，怎么去匹配对应的库或者表，这类问题我们称之为路由问题。常见的策略主要有，<strong>范围</strong>、<strong>Hash</strong> 和 <strong>配置</strong>：</p><ul><li>范围最直观的就是按照时间来拆分，比如按年、按月、按天等等，主要的问题是分布不均匀；其次，可以按照Id的范围来划分，比如0到10万、10万到20万依次划分到不同的表里，主要的问题是热点数据带来的性能问题。</li><li>Hash主要指哈希取模。例如，可以针对用户Id做如下处理：<code>HASH(userId) % N</code>，其中，<code>N</code>表示当前拆分表的数目。可以预见的问题是，当<code>N</code>变化的时候，会产生数据迁移的需求，所以，这种方式并不利于扩容，</li><li>配置，顾名思义，就是用一张表来存储数据和子表间的映射关系，每次先按照数据的主键找到子表，然后再从子表中查询所需要的数据。好处是扩容灵活，而缺点同样明显，查询配置表，带来了额外的性能损耗。</li></ul><p>在这里，我们是使用年份来作为分表后缀的。为了方便演示，在实现<code>ShardingByYearPolicy</code>类时，我们直接使用了当前时间，这意味着我们会将<code>Album</code>实体映射到<code>Album_2021</code>这张表，以此类推。在实际使用中，更推荐大家使用 <a href="https://halo.sherlocky.com/archives/xue-hua-suan-fa-snowflake/" target="_blank" rel="noopener">雪花算法</a> 生成Id，因为这样，我们就可以通过Id反推出具体的时间范围，进而决定要映射到哪一个库、哪一张表。关于子表的生成，博主这里是通过迁移来实现的，考虑到EF自动创建数据库/表，都需要先创建迁移，所以，这并不是一个开箱即用的方案。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ShardingByYearPolicy</span> : <span class="title">IShardingPolicyProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetShardingSuffix</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;DateTime.Now.ToString(<span class="string">"yyyy"</span>)&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在我们可以编写简单的代码，来验证我们的这些想法是都正确，即使是最简单的控制台程序，我还是喜欢用依赖注入：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入ShardingContext</span></span><br><span class="line">services.AddDbContext&lt;ShardingContext&gt;(options =&gt; &#123;</span><br><span class="line">    options.UseSqlite(config.GetValue&lt;<span class="keyword">string</span>&gt;(<span class="string">"Database:Default"</span>)); </span><br><span class="line">    <span class="comment">//替换默认实现</span></span><br><span class="line">    options.ReplaceService&lt;IModelCacheKeyFactory, DynamicModelCacheKeyFactory&gt;(); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入IShardingPolicyProvider</span></span><br><span class="line">services.AddTransient&lt;IShardingPolicyProvider, ShardingByYearPolicy&gt;();</span><br></pre></td></tr></table></figure><p>接下来，我们可以通过<code>ShardingContext</code>来匹配<code>Album_2021</code>表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里应该连接到Album_2021表</span></span><br><span class="line"><span class="comment">// 实际应该按照某种方式获得表名后缀</span></span><br><span class="line">Console.WriteLine(<span class="string">"--------分表场景--------"</span>);</span><br><span class="line">Console.WriteLine(_shardingContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_shardingContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_shardingContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure><p>此时，我们会得到下面的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/03/29/Evj8wXCIsV1Ddme.png" alt="EF Core 分表效果演示" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">EF Core 分表效果演示</div>            </figure><p>至此，如果选择性地忽略 “<strong>路由</strong>” 和 “<strong>自动分表</strong>” 这两个特性，我们已经在 EF 层面上局部的实现了 “<strong>分表</strong>” 功能。怎么样，是不是还行？</p><h1 id="多租户架构"><a href="#多租户架构" class="headerlink" title="多租户架构"></a>多租户架构</h1><p>最后，我们来聊聊多租户架构这个话题。可能有朋友觉得多租户架构和分库、分表没什么关系，不好意思啊，这是个非常合理的联想，因为还真就有关系，甚至我们还能继续发散到读写分离。你想想看，多租户架构中，如果一个租户一个数据库，这是不是就是分库的场景。而在分库的场景中，如果一个是主库，一个是从库，这是不是就是读写分离的场景。在学习数学的过程中，学会转化问题是一种重要的思维，即让一个不熟悉的问题变成一个熟悉的问题，在今天这篇博客中，从分库发散到多租户、读写分离，正是这一思路的体现，通常情况下，多租户架构有多数据库和单数据库两种实现方式。</p><h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><p>多数据库，指每一个租户一个数据库。这种实现方式的好处是，租户间的数据天然隔离，数据库的访问压力天然隔离。可由于所有租户都共享一套应用程序，随着数据库越来越多，维护的成本亦越来越高。参考分库的实现，我们可以非常容易地实现租户数据库的切换。这里，我们的思路是，调用方在 HTTP 请求中加入自定义的首部字段<code>X-TenantId</code>，<code>DbContext</code>通过该字段来匹配对应的链接字符串，这样就可以实现多数据库的多租户架构：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TenantInfoProvider</span> : <span class="title">ITenantInfoProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> X_TENANT_ID = <span class="string">"X-TenantId"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IHttpContextAccessor _httpContextAccessor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TenantInfoProvider</span>(<span class="params">IHttpContextAccessor httpContextAccessor</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _httpContextAccessor = httpContextAccessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetTenantId</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> httpContext = _httpContextAccessor.HttpContext;</span><br><span class="line">        <span class="keyword">if</span> (httpContext != <span class="literal">null</span> &amp;&amp; httpContext.Request.Headers.ContainsKey(X_TENANT_ID))</span><br><span class="line">            <span class="keyword">return</span> httpContext.Request.Headers[X_TENANT_ID].FirstOrDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，假设我们<code>AppSettings.json</code>文件维护各个租户的连接字符串信息。通常，在实际场景中，我们会将这些信息存储在数据库中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Database"</span>: &#123;</span><br><span class="line">    <span class="attr">"Default"</span>: <span class="string">"Data Source=Chinook.db"</span>,</span><br><span class="line">    <span class="attr">"MultiTenants"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"tenantId"</span>: <span class="string">"01"</span>,</span><br><span class="line">        <span class="attr">"ConnectionString"</span>: <span class="string">"Data Source=Chinook01.db"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"tenantId"</span>: <span class="string">"02"</span>,</span><br><span class="line">        <span class="attr">"ConnectionString"</span>: <span class="string">"Data Source=Chinook02.db"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以通过下面的代码片段来实现租户切换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line"><span class="keyword">var</span> database = _options.Value.MultiTenants.FirstOrDefault(x =&gt; x.TenantId == tenantId);</span><br><span class="line"><span class="keyword">if</span> (database == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Invalid tenantId \"<span class="subst">&#123;tenantId&#125;</span>\""</span>);</span><br><span class="line"></span><br><span class="line">_chinookContext.Database.GetDbConnection().ConnectionString = database.ConnectionString;</span><br><span class="line">Console.WriteLine(<span class="string">"--------多租户 + 多数据库--------"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"TenantId:<span class="subst">&#123;tenantId&#125;</span>"</span>);</span><br><span class="line">Console.WriteLine(_chinookContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_chinookContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_chinookContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure><p>可以注意到，一切如我们所预料的一样，程序自动切换到<code>01</code>这个租户：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/03/29/S5QeCjzdcgG9wpT.png" alt="多租户 + 多数据库" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">多租户 + 多数据库</div>            </figure><h2 id="单数据库"><a href="#单数据库" class="headerlink" title="单数据库"></a>单数据库</h2><p>单数据库，指所有租户都在一个数据库里，使用相同的表结构(<strong>Schema</strong>)，并通过<code>TenantId</code>字段进行区分。<a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 中的多租户架构就是这种模式，而我之前的公司，则是单数据库 + 多数据库的混合模式。这种实现方式的好处是数据库非常精简，而缺点同样很明显，一旦某个租户出现问题，非常容易波及所有租户，因为所有租户都在一个数据库里，数据库的压力实际上是大家一起分担的，租户间相互影响的可能性非常大。</p><p>同样地，我们依然需要用到<code>X-TenantId</code>这个请求头，由于所有租户都在一个数据库上，我们不会再试图去修改链接字符串。EF Core 中针对实体提供了<code>HasQueryFilter()</code>扩展方法，该访问允许我们传入一个 Lambda 表达式。此时，我们所有的请求都会自动带上类似<code>Album.TenantId = &#39;xxxx&#39;</code>这样的条件，这样我们就实现了单数据库的多租户架构。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MulitiTenancyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Artist&gt; Artist &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Album&gt; Album &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ITenantInfoProvider _tenantInfoProvider;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MulitiTenancyContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      DbContextOptions&lt;MulitiTenancyContext&gt; options, </span></span></span><br><span class="line"><span class="function"><span class="params">      ITenantInfoProvider tenantInfoProvider</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _tenantInfoProvider = tenantInfoProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line"></span><br><span class="line">        modelBuilder.ApplyConfiguration(<span class="keyword">new</span> ArtistMap());</span><br><span class="line">        modelBuilder.ApplyConfiguration(<span class="keyword">new</span> AlbumMap());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用 HasQueryFilter 进行租户间数据隔离</span></span><br><span class="line">        <span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(tenantId))</span><br><span class="line">        &#123;</span><br><span class="line">            modelBuilder.Entity&lt;Album&gt;().HasQueryFilter(x =&gt; x.TenantId == tenantId);</span><br><span class="line">            modelBuilder.Entity&lt;Artist&gt;().HasQueryFilter(x =&gt; x.TenantId == tenantId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了在实体上应用这个过滤条件，参照 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 中的实现，我们定义了<code>IMulitiTenancy</code>接口，所有实体均需要实现<code>TenantId</code>字段。为了简化设计，我们直接使用字符串类型来定义租户Id，而在 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 中很多主键都被定义为 <code>Guid</code>，我们掌握核心原理即可，不用过分强求和 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 的一致。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMulitiTenancy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMulitiTenancy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Album</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Album</span> : <span class="title">IMulitiTenancy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> AlbumId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以编写简单的测试代码，来验证我们的想法是否正确。同样地，我还是使用了依赖注入：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里应该查询01租户内的Album</span></span><br><span class="line"><span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line">Console.WriteLine(<span class="string">"--------多租户 + 单数据库--------"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"TenantId:<span class="subst">&#123;tenantId&#125;</span>"</span>);</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure><p>可以注意到，打印出的 SQL 语句中自动带出了过滤条件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/03/29/7na2eIo4suLhTGY.png" alt="多租户 + 多数据库" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">多租户 + 多数据库</div>            </figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客主要探讨了 EF 在分库、分表及多租户架构上实施的可能性。分库、分表的目的是为了提高数据库的查询性能，在这个过程中，我们可以考虑<strong>范围</strong>、<strong>Hash</strong>和<strong>配置</strong>三种路由策略，它们各自有自己的优缺点，需要使用者结合业务场景去衡量。虽然分库、分表在面对百万级别以上的数据时，不失为一种提高性能的方案，可世间万物都是双刃剑，它同样带来了一系列新的问题，譬如<strong>跨库写带来的分布式事务问题，跨库读带来的Join、Count()、排序、分页等问题，数据迁移问题</strong>等等，而如果希望通过Hash(Id)来进行拆分，还需要解决<strong>全局Id唯一的问题</strong>。所以说，这是一个没有标准答案的问题，需要使用者自己去进行取舍。多租户架构、读写分离均可以看作是特殊的分库场景，<code>EF Core</code> 中新增的<code>HasQueryFilter()</code>方法则帮助我们解决了单数据库的多租户架构问题。好了，以上就是这篇博客的全部内容啦，如果大家对文中的观点有建议或者意见，欢迎大家在评论区留言，谢谢！</p><p>附本文源代码：<a href="https://github.com/Regularly-Archive/2021/tree/master/EF.Sharding" target="_blank" rel="noopener">https://github.com/Regularly-Archive/2021/tree/master/EF.Sharding</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据存储" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="数据库" scheme="https://qinyuanpei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="EF" scheme="https://qinyuanpei.github.io/tags/EF/"/>
    
      <category term="架构" scheme="https://qinyuanpei.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="多租户" scheme="https://qinyuanpei.github.io/tags/%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>源代码探案系列之 .NET Core 跨域中间件 CORS</title>
    <link href="https://qinyuanpei.github.io/posts/1276287490/"/>
    <id>https://qinyuanpei.github.io/posts/1276287490/</id>
    <published>2021-03-16T21:25:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>本文是 #<strong>源代码探案系列</strong># 第三篇，今天这篇博客，我们来一起解读下 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的 <a href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src" target="_blank" rel="noopener">CORS</a> 中间件，熟悉这个中间件的的小伙伴们，想必都已经猜出本文的主题：跨域。这确实是一个老生常谈的话题，可我并不认为，大家愿意去深入探究这个问题，因为博主曾经发现，每当工作中遇到跨域问题的时候，更多的是直接重写跨域相关的 HTTP 头。博主曾经写过一篇关于跨域的博客：<a href="https://blog.yuanpei.me/posts/3846545990/" target="_blank" rel="noopener">《聊聊前端跨域的爱恨情仇》</a>，当时是完全以前端的视角来看待跨域。所以，在今天这篇博客里，博主想带领大家从一种新的视角来看待跨域，也许，可以从中发现不一样的东西。</p><h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>关于 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的 <a href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src" target="_blank" rel="noopener">CORS</a>，大家都知道的是，可以通过<code>UseCors()</code>方法在整个 HTTP 请求管道中启用跨域中间件，或者是通过<code>AddCors()</code>方法来定义跨域策略，亦或者通过<code>[EnableCors]</code>来显式地指定跨域策略，更多的细节大家可以参考微软的<a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0" target="_blank" rel="noopener">官方文档</a>，而在这里，我想聊一点大家可能不知道的东西，譬如：服务器端如何处理来自浏览器端的跨域请求？而这一切在 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中又如何实现？带着这些问题来解读 <a href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src" target="_blank" rel="noopener">CORS</a> 中间件的源代码，我们能更快的找到我们想得到的答案。一图胜千言，请允许博主使用这张流程图来“开宗明义”，我们这就开始今天的“<strong>探案</strong>”：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/03/16/m1geMX8PfJwN3Bb.png" alt="一张图览尽 CORS 中间件" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">一张图览尽 CORS 中间件</div>            </figure><h1 id="核心部件"><a href="#核心部件" class="headerlink" title="核心部件"></a>核心部件</h1><p>对于整个 <a href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src" target="_blank" rel="noopener">CORS</a> 中间件而言，核心部件主要有：<a href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsPolicy.cs" target="_blank" rel="noopener">CorsPolicy</a>、<a href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsService.cs" target="_blank" rel="noopener">CorsService</a> 以及 <a href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsMiddleware.cs" target="_blank" rel="noopener">CorsMiddleware</a>。</p><h2 id="CorsPolicy"><a href="#CorsPolicy" class="headerlink" title="CorsPolicy"></a>CorsPolicy</h2><p>整个 <strong>CORS</strong> 中间件中，首当其冲的是<code>ICorsPolicy</code>。这个接口的作用是定义跨域的策略，我们知道<code>CORS</code>中引入了<code>Access-Control</code>系列的 HTTP 头，所以，<code>CorsPolicy</code> 本质上是在定义允许哪些 HTTP 头、HTTP 方法、源(<strong>Origin</strong>) 可以访问受限的资源，以及当跨域请求是一个复杂请求的时候，预检请求的超时时间、是否支持凭据等等：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsPolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> AllowAnyHeader &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> AllowAnyMethod &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> AllowAnyOrigin &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;<span class="keyword">string</span>, <span class="keyword">bool</span>&gt; IsOriginAllowed &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="keyword">string</span>&gt; ExposedHeaders &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="keyword">string</span>&gt; Headers &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="keyword">string</span>&gt; Methods &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="keyword">string</span>&gt; Origins &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> TimeSpan? PreflightMaxAge &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> SupportsCredentials &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>在整个中间件的设计中，与<code>CorsPolicy</code>接口产生直接联系的，是<code>CorsPolicyBuilder</code>和<code>ICorsPolicyProvider</code>。相信大家从命名上就可以了解到，前者是一个基于建造者模式的、针对 <code>CorsPolicy</code>进行“<strong>加工</strong>”的工具类，可以快速地对 跨域策略中允许的 HTTP 方法、HTTP 头、源(<strong>Origin</strong>)等信息进行修改。关于这一点，我们可以从<code>CorsPolicyBuilder</code>提供的方法签名中得到印证，而最终<code>CorsPolicyBuilder</code>通过<code>Build()</code>方法来返回一个“<strong>加工</strong>”好的<code>CorsPolicy</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsPolicyBuilder</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithOrigins</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] origins</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithHeaders</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] headers</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithExposedHeaders</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] exposedHeaders</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithMethods</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] methods</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowCredentials</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">DisallowCredentials</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyOrigin</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyMethod</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyHeader</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetPreflightMaxAge</span>(<span class="params">TimeSpan preflightMaxAge</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetIsOriginAllowed</span>(<span class="params">Func&lt;<span class="keyword">string</span>, <span class="keyword">bool</span>&gt; isOriginAllowed</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetIsOriginAllowedToAllowWildcardSubdomains</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicy <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了通过<code>CorsPolicyBuilder</code>来生成跨域策略，我们还可以通过<code>ICorsPolicyProvider</code>来生成跨域策略。如果你经常使用<code>ASP.NET Core</code>中的<strong>配置系统</strong>和<strong>依赖注入</strong>，对于这种“<strong>套路</strong>”应该不会感到陌生。这里，微软提供了一个默认实现：<code>DefaultCorsPolicyProvider</code>。<code>DefaultCorsPolicyProvider</code>本身依赖<code>CorsOptions</code>，允许使用者传入一个<code>CorsPolicy</code>的实例 或者是一个委托，来自定义跨域策略的“<strong>加工</strong>”细节，并在其内部维护一个字典，来实现<a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0#np" target="_blank" rel="noopener">具名的跨域策略</a>。如果使用者不为当前跨域策略指定名称，则会使用默认的跨域策略名称。在大多数场景下，我们并不会直接使用<code>CorsPolicyBuilder</code>，而是在<code>Startup</code>类中通过委托来定义跨域策略，两者可以说是不同层次上的跨域策略的“<strong>提供者</strong>”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultCorsPolicyProvider的GetPolicyAsync()</span></span><br><span class="line"><span class="keyword">public</span> Task&lt;CorsPolicy?&gt; GetPolicyAsync(HttpContext context, <span class="keyword">string</span>? policyName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    policyName ??= _options.DefaultPolicyName;</span><br><span class="line">    <span class="keyword">if</span> (_options.PolicyMap.TryGetValue(policyName, <span class="keyword">out</span> <span class="keyword">var</span> result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.policyTask!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NullResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CorsOptions</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDefaultPolicy</span>(<span class="params">CorsPolicy policy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDefaultPolicy</span>(<span class="params">Action&lt;CorsPolicyBuilder&gt; configurePolicy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPolicy</span>(<span class="params"><span class="keyword">string</span> name, CorsPolicy policy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPolicy</span>(<span class="params"><span class="keyword">string</span> name, Action&lt;CorsPolicyBuilder&gt; configurePolicy</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> CorsPolicy? GetPolicy(<span class="keyword">string</span> name);</span><br></pre></td></tr></table></figure><h2 id="CorsService"><a href="#CorsService" class="headerlink" title="CorsService"></a>CorsService</h2><p>OK，说完了跨域策略的“<strong>定义</strong>”，现在我们来看看跨域策略是如何被中间件“执行”的，这部分代码被定义在<code>CoreService</code>类的<code>EvaluatePolicy()</code>方法中。可以注意到，如果受限资源允许任意源(<strong>Origin</strong>)访问，则服务器端会认为这是一个不安全的跨域策略。</p><p>接下来，从<code>HttpContext</code>中提取客户端的源(<strong>Origin</strong>)，请求方法(<strong>HttpMethod</strong>)。此时，服务器端可以根据请求方法和 HTTP 头 判断当前请求是都为预检请求。按照<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noopener">CORS</a>规范，当请求方法为<code>OPTION</code>且请求头中含有<code>Access-Control-Request-Method</code>时，即表示这是一个预检请求。</p><p>至此，我们有了两种选择，预检请求会交给<code>EvaluatePreflightRequest()</code>方法去处理，非预检请求会交给<code>EvaluateRequest()</code>方法去处理。除了<code>HttpContext</code>和<code>CorsPolicy</code>这两个参数以外，它们都会接受第三个参数<code>CorsResult</code>，它里面封装了我们一开始判断出来的关于源和预检请求的信息。继续细看，我们会发现这两个方法，都调用了<code>PopulateResult()</code>方法，继续顺着这条线索下去，我们就会发现，这个方法的主要作用是，结合跨域策略设定的各种参数，进一步对上一步生成的<code>CorsResult</code>进行“<strong>加工</strong>”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CorsResult <span class="title">EvaluatePolicy</span>(<span class="params">HttpContext context, CorsPolicy policy</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (policy.AllowAnyOrigin &amp;&amp; policy.SupportsCredentials) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(Resources.InsecureConfiguration, <span class="keyword">nameof</span>(policy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> requestHeaders = context.Request.Headers;</span><br><span class="line">    <span class="keyword">var</span> origin = requestHeaders[CorsConstants.Origin];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);</span><br><span class="line">    <span class="keyword">var</span> isPreflightRequest = isOptionsRequest </span><br><span class="line">        &amp;&amp; requestHeaders.ContainsKey(CorsConstants.AccessControlRequestMethod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> corsResult = <span class="keyword">new</span> CorsResult &#123;</span><br><span class="line">        IsPreflightRequest = isPreflightRequest,</span><br><span class="line">        IsOriginAllowed = IsOriginAllowed(policy, origin),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPreflightRequest) &#123;</span><br><span class="line">        <span class="comment">//预检请求</span></span><br><span class="line">        EvaluatePreflightRequest(context, policy, corsResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非预检请求</span></span><br><span class="line">        EvaluateRequest(context, policy, corsResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> corsResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PopulateResult</span>(<span class="params">HttpContext context, </span></span></span><br><span class="line"><span class="function"><span class="params">    CorsPolicy policy, </span></span></span><br><span class="line"><span class="function"><span class="params">    CorsResult result</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> headers = context.Request.Headers;</span><br><span class="line">    <span class="keyword">if</span> (policy.AllowAnyOrigin) &#123;</span><br><span class="line">        result.AllowedOrigin = CorsConstants.AnyOrigin;</span><br><span class="line">        result.VaryByOrigin = policy.SupportsCredentials;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> origin = headers[CorsConstants.Origin];</span><br><span class="line">        result.AllowedOrigin = origin;</span><br><span class="line">        result.VaryByOrigin = policy.Origins.Count &gt; <span class="number">1</span> </span><br><span class="line">            || !policy.IsDefaultIsOriginAllowed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持凭据</span></span><br><span class="line">    result.SupportsCredentials = policy.SupportsCredentials;</span><br><span class="line">    <span class="comment">// 预检请求超时时间</span></span><br><span class="line">    result.PreflightMaxAge = policy.PreflightMaxAge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://fetch.spec.whatwg.org/#http-new-header-syntax</span></span><br><span class="line">    AddHeaderValues(result.AllowedExposedHeaders, policy.ExposedHeaders);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许的HTTP方法</span></span><br><span class="line">    <span class="keyword">var</span> allowedMethods = policy.AllowAnyMethod ?</span><br><span class="line">        <span class="keyword">new</span>[] &#123; result.IsPreflightRequest ? </span><br><span class="line">                (<span class="keyword">string</span>)headers[CorsConstants.AccessControlRequestMethod] : </span><br><span class="line">                context.Request.Method &#125; :</span><br><span class="line">        policy.Methods;</span><br><span class="line">    AddHeaderValues(result.AllowedMethods, allowedMethods);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许的HTTP头</span></span><br><span class="line">    <span class="keyword">var</span> allowedHeaders = policy.AllowAnyHeader ?</span><br><span class="line">        headers.GetCommaSeparatedValues(CorsConstants.AccessControlRequestHeaders) :</span><br><span class="line">        policy.Headers;</span><br><span class="line">    AddHeaderValues(result.AllowedHeaders, allowedHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这些参数最终的走向是哪里呢？我们注意到<code>CorsService</code>里有一个叫做<code>ApplyResult()</code>的方法，观察方法签名可以发现，它负责把跨域检测的结果应用到 HTTP 响应上，相信大家都能想到，这里会设置各种<code>Access-Control</code>系列的头，比如<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>、<br><code>Access-Control-Max-Age</code>…等等。事实上，在<code>CorsMiddleware</code>中间件中，原本就是先调用<code>EvaluateResult()</code>方法，再调用<code>ApplyResult()</code>方法。当然，实际的代码中，还需要考虑<code>[DisableCors]</code>和<code>[EnableCors]</code>两个特性的影响，会多出一点判断的代码。关于跨域的代码层面的东西，我们就先讲到这里，在下一部分，我们会专门讲<code>CORS</code>里的简单请求和复杂请求。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context, ICorsPolicyProvider corsPolicyProvider</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!context.Request.Headers.ContainsKey(CorsConstants.Origin)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [DisableCors]</span></span><br><span class="line">    <span class="keyword">var</span> corsMetadata = endpoint?.Metadata.GetMetadata&lt;ICorsMetadata&gt;();</span><br><span class="line">    <span class="keyword">if</span> (corsMetadata <span class="keyword">is</span> IDisableCorsAttribute) &#123;</span><br><span class="line">        <span class="keyword">var</span> isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);</span><br><span class="line">        <span class="keyword">var</span> isCorsPreflightRequest = isOptionsRequest </span><br><span class="line">            &amp;&amp; context.Request.Headers.ContainsKey(CorsConstants.AccessControlRequestMethod);</span><br><span class="line">        <span class="keyword">if</span> (isCorsPreflightRequest) &#123;</span><br><span class="line">            <span class="comment">// If this is a preflight request, and we disallow CORS, complete the request</span></span><br><span class="line">            context.Response.StatusCode = StatusCodes.Status204NoContent;</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// [EnableCors]</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (corsMetadata <span class="keyword">is</span> IEnableCorsAttribute enableCorsAttribute &amp;&amp;</span><br><span class="line">        enableCorsAttribute.PolicyName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Evaluate &amp;&amp; Apply</span></span><br><span class="line">        <span class="keyword">return</span> EvaluateAndApplyPolicy(context, corsPolicy);</span><br><span class="line">        <span class="function"><span class="keyword">async</span> Task <span class="title">InvokeCoreAwaited</span>(<span class="params">HttpContext context, Task&lt;CorsPolicy?&gt; policyTask</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> corsPolicy = <span class="keyword">await</span> policyTask;</span><br><span class="line">            <span class="keyword">await</span> EvaluateAndApplyPolicy(context, corsPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="再论CORS"><a href="#再论CORS" class="headerlink" title="再论CORS"></a>再论CORS</h1><p>好了，行文至此。既然这篇博客的主题是“<strong>跨域</strong>”，那么，我们不妨多说一点。我们知道，“<strong>跨域</strong>”产生的背景是，浏览器作为一个公共环境，它本身是不被信任的，所以，为了杜绝非当前域的资源，例如Cookie、API等等被“<strong>窃取</strong>”，浏览器便增加了“<strong>跨域</strong>”这一限制。而为了顺应“<strong>前后端分离</strong>”、“<strong>微服务</strong>”等等的开发思想，“<strong>跨域</strong>”这个问题开始频繁地出现在人们的视野中，从最初的<strong>JSONP</strong>，到如今成为事实标准的<strong>CORS</strong>，甚至从<strong>Vue</strong>里的代理服务器、<strong>Nginx</strong>里的反向代理，我们总是能窥出一点“<strong>跨域</strong>”的影子，“<strong>跨域</strong>”可谓是无处不在。</p><p>那么，什么是 CORS 呢？ CORS ，即跨域资源共享，是一种利用 HTTP 头部来指示服务器端对除自身以外的源(域、协议、端口)是否可以访问指定的资源。你可能会联想到<strong>OAuth2</strong>、<strong>JWT</strong>等等关于认证授权的词汇，请注意，“跨域”始终发生在浏览器端，相对于浏览器，一般意义上的客户端都被视为可信任的。除此之外，CORS提供了一种被称之为“预检”的机制，它可以用来检测服务器端支持的 HTTP 请求头、HTTP 动词，在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://media.prod.mdn.mozit.cloud/attachments/2016/10/28/14295/a21a85eaccd405d608395b4ca8d82538/CORS_principle.png" alt="为什么会发生跨域？" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">为什么会发生跨域？</div>            </figure><p>如上图所示，浏览器端，特别是<code>XMLHttpRequest</code> 、<code>Fetch API</code> 、<code>Web</code>字体 和 <code>Canvas</code>等始终遵循同源策略，<code>domain-a.com</code>和<code>domain-b.com</code>被视为两个不同域，因此，当<code>domain-a.com</code>试图访问<code>domain-b.com</code>下的资源时，就会被浏览器所限制，这就是我们所说的“<strong>跨域</strong>”。可能，这并不是一个特别好的例子，因为 HTML 中某些元素天生就被设计为允许跨域，例如：<code>image</code>、<code>iframe</code>、<code>link</code>、<code>script</code>等等。而如果我们通过“<strong>协商</strong>”来告诉<code>domain-b</code>，<code>domain-a</code>希望访问它下面的资源，这其实就是我们所说的 CORS 啦！这个“<strong>协商</strong>”过程呢，主要有两种，即 <strong>简单请求</strong> 和 <strong>复杂请求</strong>。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>我们将不触发 CORS 预检 的请求称为简单请求，通常情况下，简单请求满足下列条件：</p><ul><li>使用下列方法之一：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener">GET</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener">HEAD</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener">POST</a></li><li>除了被用户代理自动设置的首部字段(例如：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener">Connection</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent" target="_blank" rel="noopener">User-Agent</a>) 和 在 Fetch 规范中定义为 <a href="https://fetch.spec.whatwg.org/#forbidden-header-name" target="_blank" rel="noopener">禁用首部名称</a> 的其他首部，允许人为设置的字段为 Fetch 规范定义的 <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header" target="_blank" rel="noopener">对 CORS 安全的首部字段集合</a>。该集合为：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept" target="_blank" rel="noopener">Accept</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language" target="_blank" rel="noopener">Accept-Language</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language" target="_blank" rel="noopener">Content-Language</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type" target="_blank" rel="noopener">Content-Type</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#dpr" target="_blank" rel="noopener">DPR</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#downlink" target="_blank" rel="noopener">Downlink</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#save-data" target="_blank" rel="noopener">Save-Data</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#viewport-width" target="_blank" rel="noopener">Viewport-Width</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#width" target="_blank" rel="noopener">Width</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type" target="_blank" rel="noopener">Content-Type</a> 的值仅限于下列三者之一：text/plain、multipart/form-data、application/x-www-form-urlencoded</li><li>请求中的任意 <a href="">XMLHttpRequestUpload</a> 对象均没有注册任何事件监听器；<a href="">XMLHttpRequestUpload</a> 对象可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload" target="_blank" rel="noopener">XMLHttpRequest.upload</a> 属性访问。</li><li>请求中没有使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" target="_blank" rel="noopener">ReadableStream</a> 对象。</li></ul><p>对于 <strong>简单请求</strong> ，由于它的 HTTP 动词是确定的，故其跨域主要体现在服务器端返回的 HTTP 响应中，可能出现的响应头有：<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Headers</code>等。所以，如果客户端请求的<code>Origin</code>被包含在服务器端返回的<code>Access-Control-Allow-Origin</code>中，则表示跨域被允许，反之则不被允许。所以，现在大家应该能想明白，为啥那些年里大家稀里糊涂地，把<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Headers</code>设置为<code>*</code>就万事大吉了吧，而对照着中间件的代码，理解这层含义会更容易一点！</p><h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>与简单请求不同，<strong>复杂请求</strong> 要求必须首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS" target="_blank" rel="noopener">OPTIONS</a> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”<strong>预检请求</strong>“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://media.prod.mdn.mozit.cloud/attachments/2019/06/19/16753/b32f78ac26d18e3e155205e4f0057b73/preflight_correct.png" alt="预检请求" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">预检请求</div>            </figure><p>当浏览器检测到，从<code>JavaScript</code>中发起的请求需要被预检。此时，可以注意到，预检请求中同时携带了下面两个首部字段：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-<span class="function"><span class="keyword">Method</span>:</span> POST</span><br><span class="line">Access-Control-Request-Headers：X-PINGOTHER, Content-<span class="keyword">Type</span></span><br></pre></td></tr></table></figure><p>服务器在接受预检请求后，会返回以下响应头：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Allow-Origin: http://foo.example</span><br><span class="line"><span class="keyword">Access</span>-Control-Allow-Methods: POST, <span class="keyword">GET</span>, <span class="keyword">OPTIONS</span></span><br><span class="line"><span class="keyword">Access</span>-Control-Allow-Headers: X-PINGOTHER, Content-<span class="keyword">Type</span></span><br><span class="line"><span class="keyword">Access</span>-Control-Max-Age: <span class="number">86400</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>首部字段<code>Access-Control-Allow-Methods</code>表明服务器允许客户端使用 POST、GET 和 OPTIONS 方法发起请求。</li><li>首部字段<code>Access-Control-Allow-Headers</code>表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type。</li><li>首部字段<code>Access-Control-Max-Age</code>表明该响应的有效时间为 86400 秒，即 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。</li></ul><p>下面整理了 CORS 中常见的 <strong>Access-Control</strong> 系列头部字段：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Access-<span class="keyword">Control</span>-Allow-Origin</span><br><span class="line">Access-<span class="keyword">Control</span>-Expose-Headers</span><br><span class="line">Access-<span class="keyword">Control</span>-<span class="keyword">Max</span>-Age</span><br><span class="line">Access-<span class="keyword">Control</span>-Allow-Credentials</span><br><span class="line">Access-<span class="keyword">Control</span>-Allow-Methods</span><br><span class="line">Access-<span class="keyword">Control</span>-Allow-Headers</span><br><span class="line">Origin</span><br><span class="line">Access-<span class="keyword">Control</span>-Request-<span class="keyword">Method</span></span><br><span class="line">Access-<span class="keyword">Control</span>-Request-Headers</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分别从 <strong>源代码</strong> 和 <strong>规范</strong> 两个角度探讨了 “<strong>跨域</strong>” 这个话题，两者可以说是相辅相成的存在，CORS 中间件实现了 CORS 规范，而通过 CORS 规范帮助我们理解了中间件。“<strong>跨域</strong>”产生的背景是，浏览器作为一个公共环境，它本身是不被信任的，所以，为了杜绝非当前域的资源，例如Cookie、API等等被“<strong>窃取</strong>”，浏览器便增加了 “<strong>跨域</strong>” 这一限制。最初我们通过 <strong>JSONP</strong> 这种方案来解决跨域问题，而后来我们有了<strong>CORS</strong> 这种事实上的标准，其原理上利用 <strong>Origin</strong> 及 <strong>Access-Control</strong>系列的头来标识服务器端可以允许哪些源、以什么样的 HTTP 动词 / 头来访问资源，按照 CORS 规范，浏览器端发起的请求被分为： <strong>简单请求</strong> 和 <strong>复杂请求</strong> 两种，两者最大的区别是，<strong>复杂请求</strong> 必须首先通过 <strong>OPTIONS</strong> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。好了，以上就是这篇博客的全部内容啦，欢迎大家在博客评论中参与讨论，再次谢谢大家，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="源码" scheme="https://qinyuanpei.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="中间件" scheme="https://qinyuanpei.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="跨域" scheme="https://qinyuanpei.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="https://qinyuanpei.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>源代码探案系列之 .NET Core 限流中间件 AspNetCoreRateLimit</title>
    <link href="https://qinyuanpei.github.io/posts/2396015802/"/>
    <id>https://qinyuanpei.github.io/posts/2396015802/</id>
    <published>2021-03-10T21:52:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在上一篇文章中，博主带领大家一起深入了解 <a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter" target="_blank" rel="noopener">ConcurrencyLimiter</a> 这个中间件，正当我得意洋洋地向 <a href="https://www.cnblogs.com/catcher1994/" target="_blank" rel="noopener">Catcher Wong</a> 大佬吹嘘这一点小收获时，大佬一脸嫌弃地说，一个单机版的方案有什么好得意的啊。大佬言下之意，显然是指，这个中间件在分布式环境中毫无用武之地。其实，你只需要稍微想一下，就能想明白这个问题。毕竟，它只是通过<code>SeamphoreSlim</code>控制线程数量而已，一旦放到分布式环境中，这个并发控制就被大大地削弱。所以，在今天这篇文章中，博主会带领大家一起“<strong>探案</strong>” <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的限流中间件 <a href="https://github.com/stefanprodan/AspNetCoreRateLimit" target="_blank" rel="noopener">AspNetCoreRateLimite</a>，希望大家可以从中感悟到不一样的东西。对我而言，这可能是人到中年的焦虑感所催生出来的一种源动力，同时亦是为了不让那些订阅专栏的同学失望。</p><p>关于“<strong>限流</strong>”这个话题，我个人以为，它可以引申出非常多的东西，譬如“熔断”和“限流”，其实可以看作是同一类问题的“一体两面”。最早接触熔断，是源于 <strong>Spring Cloud</strong> 中的 <strong>Hystrix</strong>，它其实是指当服务不可用的时候，客户端应该采取什么样的措施去应对，实际使用中我们可能会考虑重试、超时、降级等策略。相应地，当服务端在面对来自客户端的异常流量时，就产生了“限流”这个概念，“限流”可以是线程隔离<strong>(</strong>线程数 + 队列大小限制<strong>)，可以是信号量隔离(</strong>设置最大并发请求数目<strong>)，可以是限制QPS。这里，我们讨论的主要是第三种，而实现限流的常见算法主要有</strong>计数器算法<strong>、</strong>漏桶算法<strong>和</strong>令牌桶算法<strong>。这里，<a href="https://github.com/stefanprodan/AspNetCoreRateLimit" target="_blank" rel="noopener">AspNetCoreRateLimit</a> 这个中间件，则主要使用了</strong>计数器算法**，并配合 <code>IMemoryCache</code> 和 <code>IDistributedCache</code> 分别实现了基于内存和基于分布式缓存的持久化逻辑。</p><h1 id="源代码解读"><a href="#源代码解读" class="headerlink" title="源代码解读"></a>源代码解读</h1><p>首先，使用者通过配置定义了一个或者多个规则，这些规则决定了每个客户端在访问特定终结点时，一段时间内可以访问的最大次数。 <a href="">RateLimitMiddleware</a> 通过注入的<a href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Middleware/RateLimitMiddleware.cs">IRateLimitProcessor</a> 来匹配规则，然后依次判断每个规则是否达到了限流条件。一旦达到限流条件，中间件会改变 HTTP 响应的状态码、响应头、返回值，告知使用者已达到最大调用次数。而针对每一种 <a href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Core/IRateLimitProcessor.cs" target="_blank" rel="noopener">IRateLimitProcessor</a> ，主要通过<code>ProcessRequestAsync()</code> 方法来实现计数，如果上一次的请求对应的时间戳 + 规则中时间间隔 &gt;= 当前时间，则说明请求没有过期，此时，就需要给这个计数增加1。好了，现在我们来针对 <a href="https://github.com/stefanprodan/AspNetCoreRateLimit" target="_blank" rel="noopener">AspNetCoreRateLimit</a> 中的核心部件逐个进行解读。</p><h2 id="RateLimitProcessor"><a href="#RateLimitProcessor" class="headerlink" title="RateLimitProcessor"></a>RateLimitProcessor</h2><p><code>RateLimitProcessor</code>，是一个抽象类，实现了<code>IRateLimitProcessor</code>接口，公开的方法有 3 个：<code>ProcessRequestAsync()</code>、<code>IsWhitelisted()</code> 和 <code>GetRateLimitHeaders()</code>。在此基础上，派生出<code>ClientRateLimitProcessor</code>和<code>IpRateLimitProcessor</code>两个子类。两者最大的不同在于，其所依赖的<code>Store</code>不同，前者为<code>IClientPolicyStore</code>，后者<code>IIpPolicyStore</code>，它们都实现了同一个接口<code>IRateLimitStore</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IRateLimitStore&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="keyword">bool</span>&gt; <span class="title">ExistsAsync</span>(<span class="params"><span class="keyword">string</span> id, CancellationToken cancellationToken = <span class="keyword">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task&lt;T&gt; <span class="title">GetAsync</span>(<span class="params"><span class="keyword">string</span> id, CancellationToken cancellationToken = <span class="keyword">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">RemoveAsync</span>(<span class="params"><span class="keyword">string</span> id, CancellationToken cancellationToken = <span class="keyword">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">SetAsync</span>(<span class="params"><span class="keyword">string</span> id, T entry, TimeSpan? expirationTime = <span class="literal">null</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">        CancellationToken cancellationToken = <span class="keyword">default</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，这些都是典型的基于键-值的存储，所以，不管是基于内存的IMemeryCache，还是基于分布式缓存的IDistributedCache，都可以做到无缝切换。不同的Processor，本质上是它们生成缓存键的方式不同，例如，<code>IpRateLimitProcessor</code>是用一个前缀来表示一组IP，而<code>ClientRateLimitProcessor</code>则是用通过客户端前缀和客户端Id来作为区分：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/IpRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="keyword">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policies = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$"<span class="subst">&#123;_options.IpPolicyPrefix&#125;</span>"</span>,</span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">new</span> List&lt;RateLimitRule&gt;();</span><br><span class="line">    <span class="keyword">if</span> (policies?.IpRules?.Any() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// search for rules with IP intervals containing client IP</span></span><br><span class="line">        <span class="keyword">var</span> matchPolicies = policies.IpRules</span><br><span class="line">            .Where(r =&gt; IpParser.ContainsIp(r.Ip, identity.ClientIp));</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> matchPolicies)</span><br><span class="line">        &#123;</span><br><span class="line">            rules.AddRange(item.Rules);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/ClientRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="keyword">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policy = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$"<span class="subst">&#123;_options.ClientPolicyPrefix&#125;</span>_<span class="subst">&#123;identity.ClientId&#125;</span>"</span>, </span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, policy?.Rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>RateLimitProcessor</code>而言，其实现思路是，通过<code>CounterKeyBuilder</code>及其子类来生成计数器标识(<strong>CounterId</strong>)，然后再通过<code>AsyncKeyLock</code>来实现计数，最终通过<code>IRateLimitCounterStore</code>来实现存储：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">async</span> Task&lt;RateLimitCounter&gt; <span class="title">ProcessRequestAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    ClientRequestIdentity requestIdentity, </span></span></span><br><span class="line"><span class="function"><span class="params">    RateLimitRule rule, </span></span></span><br><span class="line"><span class="function"><span class="params">    CancellationToken cancellationToken = <span class="keyword">default</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">    &#123;</span><br><span class="line">        Timestamp = DateTime.UtcNow,</span><br><span class="line">        Count = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成CounterId</span></span><br><span class="line">    <span class="keyword">var</span> counterId = BuildCounterKey(requestIdentity, rule);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于AsyncLock的计数器</span></span><br><span class="line">    <span class="comment">// serial reads and writes on same key</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">await</span> AsyncLock.WriterLockAsync(counterId).ConfigureAwait(<span class="literal">false</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> entry = <span class="keyword">await</span> _counterStore.GetAsync(counterId, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.HasValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// entry has not expired</span></span><br><span class="line">            <span class="keyword">if</span> (entry.Value.Timestamp + rule.PeriodTimespan.Value &gt;= DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// increment request count</span></span><br><span class="line">                <span class="keyword">var</span> totalCount = entry.Value.Count + _config.RateIncrementer?.Invoke() ?? <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// deep copy</span></span><br><span class="line">                counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">                &#123;</span><br><span class="line">                    Timestamp = entry.Value.Timestamp,</span><br><span class="line">                    Count = totalCount</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计数器存储</span></span><br><span class="line">        <span class="comment">// stores: id (string) - timestamp (datetime) - total_requests (long)</span></span><br><span class="line">        <span class="keyword">await</span> _counterStore.SetAsync(</span><br><span class="line">            counterId, </span><br><span class="line">            counter, </span><br><span class="line">            rule.PeriodTimespan.Value, </span><br><span class="line">            cancellationToken</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AsyncKeyLock"><a href="#AsyncKeyLock" class="headerlink" title="AsyncKeyLock"></a>AsyncKeyLock</h2><p>在分析<code>RateLimitProcessor</code>类的时候，我们提到了<code>AsyncKeyLock</code>。对于<code>AsyncKeyLock</code>的实现，我个人认为这是整个中间件的精华，因为这里出现了，和<code>SeamphoreSlim</code>一样经典的东西，这里用到了自旋锁<code>SpinLock</code>。我个人理解，<code>SpinLock</code> 约等于 <code>Interlocked</code> + 内核级别的while。这部分代码本身并不复杂，难就难在这样一个精妙的想法上面。其中，<a href="">AsyncKeyLockDoorman</a> 这个类的实现，应该是参考了微软的一篇博客—— <a href="https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-7-asyncreaderwriterlock/">Building Async Coordination Primitives, Part 7: AsyncReaderWriterLock</a>，因为<code>ReaderLockAsync()</code>、<code>WriterLockAsync()</code>、<code>ReaderRelease()</code> 和 <code>WriterRelease()</code> 这 4 个关键方法完全一样。结合限流这个场景来看，它是典型的“<strong>多写</strong>”场景，因为如果是相同的请求，那么就会产生相同的计数器标识(<strong>CounterId</strong>)，所以，这个<code>AsyncLockDoorman</code>这个类所定义的上下文边界，其实是“<strong>一读多写</strong>”的问题，所以，我们可以注意到，它里面定义了一个“写”操作的队列<code>_waitingWriters</code>，一个“读操作”的<code>_waitingReader</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncKeyLockDoorman</span>(<span class="params">Action&lt;AsyncKeyLockDoorman&gt; reset</span>)</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 多个写入者</span></span><br><span class="line">    _waitingWriters = <span class="keyword">new</span> Queue&lt;TaskCompletionSource&lt;Releaser&gt;&gt;();</span><br><span class="line">    <span class="comment">// 单个读取者</span></span><br><span class="line">    _waitingReader = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">    _status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    _readerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">false</span>));</span><br><span class="line">    _writerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">true</span>));</span><br><span class="line">    _reset = reset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于“写”操作而言，当一个新的写入者希望进来的时候，如果此时锁没有被别人占用，那么这个新的写入者会获得这个锁，状态值<code>m_status</code>会被修改为-1。反之，如果此时这个锁已经被别人占用了，那么这个新的写入者将会进入等待队列。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">WriterLockAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _status = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> _writerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> waiter = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">            _waitingWriters.Enqueue(waiter);</span><br><span class="line">            <span class="keyword">return</span> waiter.Task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于“读”操作而言，我们来思考这样一个问题，什么时候“读”操作会被允许呢？答案是这一时刻没有写入者正在“写”或者“等”，因为如果不这样的话，就会发生我们平常所说的“<strong>脏读</strong>”，所以，这种情况下，就必须强迫“读取者”去等待写入者“空闲”下来。此时，不难理解<code>ReadLockAsync()</code>的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">ReaderLockAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status &gt;= <span class="number">0</span> &amp;&amp; _waitingWriters.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++_status;</span><br><span class="line">            <span class="keyword">return</span> _readerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++_readersWaiting;</span><br><span class="line">            <span class="keyword">return</span> _waitingReader.Task.ContinueWith(t =&gt; t.Result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们把视线拉回到<code>AsyncKeyLock</code>，它负责维护一组<code>AsyncKeyLockDoorman</code>，其内部部通过一个字典来维护<code>CounterId</code>和<code>AsyncKeyLockDoorman</code>间的关系。与此同时，为了减少创建·AsyncKeyLockDoorman·带来的性能损耗，它使用一个栈来存储<code>AsyncKeyLockDoorman</code>。每次获取<code>AsyncKeyLockDoorman</code>的过程，本质上就是为指定的<code>Key</code>分配<code>AsyncKeyLockDoorman</code>的过程，同时会更新其引用数<code>RefCount</code>。相应地，释放<code>AsyncKeyLockDoorman</code>的过程，本质上就是减少其引用数<code>RefCount</code>，从字典中移除指定<code>Key</code>，“<strong>归还</strong>”对象池的过程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AsyncKeyLockDoorman <span class="title">GetDoorman</span>(<span class="params"><span class="keyword">string</span> key</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AsyncKeyLockDoorman doorman;</span><br><span class="line">    <span class="keyword">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (!Keys.TryGetValue(key, <span class="keyword">out</span> doorman))</span><br><span class="line">        &#123;</span><br><span class="line">            doorman = (Pool.Count &gt; <span class="number">0</span>) ? Pool.Pop() : </span><br><span class="line">                <span class="keyword">new</span> AsyncKeyLockDoorman(ReleaseDoorman);</span><br><span class="line">            doorman.Key = key;</span><br><span class="line">            Keys.Add(key, doorman);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doorman.RefCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doorman;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReleaseDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReleaseDoorman</span>(<span class="params">AsyncKeyLockDoorman doorman</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (--doorman.RefCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Keys.Remove(doorman.Key);</span><br><span class="line">            <span class="keyword">if</span> (Pool.Count &lt; MaxPoolSize)</span><br><span class="line">            &#123;</span><br><span class="line">                doorman.Key = <span class="literal">null</span>;</span><br><span class="line">                Pool.Push(doorman);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RateLimitMiddleware"><a href="#RateLimitMiddleware" class="headerlink" title="RateLimitMiddleware"></a>RateLimitMiddleware</h2><p>OK，到这里，我们再回过头去看<strong>源代码解读</strong>这里的内容，大概就可以串起来整合中间件的调用链路，<code>Middleware</code>-&gt;<code>RateLimteProcessor</code>-&gt;<code>AsyncKeyLock</code>-&gt;<code>AsyncKeyLockDoorman</code>，坦白来讲，我一直没能想明白为什么要用<code>SpinLock</code>？难道仅仅是为了减少等待时间、提高性能吗？经过精简，我们发现，整个中间件的<code>Invoke()</code>方法，大致要经历下面几个阶段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查限流是否启用</span></span><br><span class="line">    <span class="keyword">if</span> (_options == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户身份</span></span><br><span class="line">    <span class="keyword">var</span> identity = <span class="keyword">await</span> ResolveIdentityAsync(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查白名单</span></span><br><span class="line">    <span class="keyword">if</span> (_processor.IsWhitelisted(identity))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取限流规则</span></span><br><span class="line">    <span class="keyword">var</span> rulesDict = <span class="keyword">new</span> Dictionary&lt;RateLimitRule, RateLimitCounter&gt;();</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">await</span> _processor.GetMatchingRulesAsync(</span><br><span class="line">        identity, </span><br><span class="line">        context.RequestAborted</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> rule <span class="keyword">in</span> rules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取计数器数目</span></span><br><span class="line">        <span class="keyword">var</span> rateLimitCounter = <span class="keyword">await</span> _processor.ProcessRequestAsync(</span><br><span class="line">            identity, </span><br><span class="line">            rule, </span><br><span class="line">            context.RequestAborted</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (rule.Limit &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 请求未过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Timestamp + rule.PeriodTimespan.Value &lt; DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Count &gt; rule.Limit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 各种记日志，告诉调用者多长时间后再重试</span></span><br><span class="line">                <span class="keyword">var</span> retryAfter = rateLimitCounter.Timestamp.RetryAfterFrom(rule);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 中止请求</span></span><br><span class="line">                <span class="keyword">await</span> ReturnQuotaExceededResponse(context, rule, retryAfter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Limit &lt;= 0, 相当于直接不允许放行，中止请求</span></span><br><span class="line">            <span class="keyword">await</span> ReturnQuotaExceededResponse(</span><br><span class="line">                context, </span><br><span class="line">                rule, </span><br><span class="line">                <span class="keyword">int</span>.MaxValue.ToString(System.Globalization.CultureInfo.InvariantCulture)</span><br><span class="line">            ); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置X-Rate-Limit头</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>作为 <a href="https://blog.yuanpei.me/posts/18417412/" target="_blank" rel="noopener">并发限制</a> 这一篇的“姊妹篇”，这一篇的难度相对上一篇堪称“高山仰止”，主要的难点是 <strong>SpinLock</strong> 、“一读多写”的异步读写锁 <strong>AsyncKeyLock</strong> 以及 <strong>AsyncKeyLockDoorman</strong> 。如果大家感兴趣的话，可以去搜索一下 <strong>AsyncKeyLock</strong> 这个关键字，大家就会发现在好多<a href="https://github.com/SixLabors/ImageSharp.Web/" target="_blank" rel="noopener">开源项目</a> 中都能找到类似的代码片段，莫非这是某种神奇的算法吗？阅读源代码，其实是一个无法“立竿见影”的学习方法，有时候我们要通过叙述或者表达来输出我们对待一件事物的看法。这是因为，我们自以为是的“学会”和真正的“学会”，这两者间可能千差万别，就像我最近在用 <a href="https://abp.io" target="_blank" rel="noopener">ABP vNext</a> 搭建一个小项目，阅读文档的时候，眼睛觉得它“学会”了，而实际需要需要扩展或者替换 ABP 的实体/服务的时候。我的手会告诉我，它真的“不会”。做一个知难行易的“调包”侠也许会非常容易，可正因为如此，你要凸显自我就会非常困难。世上的事情，“<strong>夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</strong>”，哪怕就是增长一下见识呢，你说对吧……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="源码" scheme="https://qinyuanpei.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="中间件" scheme="https://qinyuanpei.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="限流" scheme="https://qinyuanpei.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>源代码探案系列之 .NET Core 并发限制中间件 ConcurrencyLimiter</title>
    <link href="https://qinyuanpei.github.io/posts/18417412/"/>
    <id>https://qinyuanpei.github.io/posts/18417412/</id>
    <published>2021-03-04T20:13:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>打算开一个新的专栏——<strong>源代码探案系列</strong>，目的是通过源代码来探索更广阔的技术世界。因为我越来越意识到，我可能缺乏一个结构化的知识体系，虽然处在一个碎片化的时代，从外界接收了大量的信息，可这些碎片化的信息，到底能不能转化为自身可用的知识，其实是需要去认真思考一番。尤其是当我注意到，许多人工作多年，在经历过从“<strong>生手</strong>”到“<strong>熟练工</strong>”这种蜕变以后，居然还是会害怕原理性内容的考察。我承认，程序员这个职业更像是一个“<strong>手艺人</strong>”，可我更想说一句古人的话——<strong>君子不器</strong>。什么是器呢？“<strong>形而上者谓之道，形而下者谓之器</strong>”，用一句更直白的话来说，就是“<strong>不能知其然而不知其所以然</strong>”，这是我一个非CS科班出身的程序员，想去写这样一个专栏的初衷，因为在我看来，“<strong>器</strong>”是永远学不完的，而“<strong>道</strong>”虽然听起来虚无缥缈，实则“<strong>朝闻道，夕死可矣</strong>”。</p><p>作为这个专栏的第一篇博客，我打算从 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的 <a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter" target="_blank" rel="noopener">ConcurrencyLimiter</a> 这个中间件开始。并发是一个爱恨交织的话题，我们喜欢高并发，因为这是程序员跻身高手行列的好机会；我们厌恶并发，因为它引入了多线程、锁、信号量这些复杂的东西。相信大家都曾被并发困扰过，古人云：<strong>他山之石，可以攻玉</strong>，还有什么比阅读源代码更朴实无华的“学习”呢？你找大牛，大牛可能忙着开会、做PPT；你找同事，同事里可能十个有八个都不知道啊。这个中间件的核心是 <code>IQueuePolicy</code> ，其位于以下<a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter/src/QueuePolicies" target="_blank" rel="noopener">位置</a>，它定义了两个核心的方法：<code>TryEnterAsync()</code> 和 <code>OnExit()</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IQueuePolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ValueTask&lt;<span class="keyword">bool</span>&gt; <span class="title">TryEnterAsync</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其默认实现<code>QueuePolicy</code>中，<code>TryEnterAsync()</code>方法，决定着一个请求是会被拒绝还是接受。具体是怎么做呢？它定义了一个最大的并发请求数目，如果实际数超过了最大的并发请求数目，那么请求将会被拒绝。反之，请求将被接受。再仔细看，我们就会发现，它内部使用了<code>SeamphoreSlim</code>和<code>Interlocked</code>，所以，聪明的小伙伴们应该立马会联想到，这两种锁各自的作用是什么。</p><p>其中，<code>Seamphore</code> 是一个 Windows 内核中的一个同步信号量，适用于在多个有限的线程资源中共享内存资源，它就像一个栅栏，本身具有一定的容量，当线程数量达到这个容量后，新的线程就无法再通过，直到某个线程执行完成。<code>SeamphoreSlim</code>是<code>Seamphore</code>优化后的版本，在性能上表现更好一点，更推荐大家使用<code>SeamphoreSlim</code>。</p><p>而 <code>Interlocked</code> 的则是我们熟悉的原子操作，它可以在多个线程中，对共享的内存资源进行原子加或者原子减操作。在这里，<code>Interlocked</code>主要用来控制并发请求数的加和减。如果当前的并发请求数小于最大的并发请求数，表示还可以允许新的请求进来，此时，<code>TryEnterAsync()</code>方法会返回true。如果此时的并发请求数大于最大的并发请求数，则需要对当前请求数进行减操作，此时，<code>TryEnterAsync()</code>方法会返回false。</p><p>一旦搞清楚这一点，结合中间件的代码，我们可以非常容易地想明白,这个并发控制的实现思路。下面是<code>QueuePolicy</code>中<code>TryEnterAsync()</code>和<code>OnExit()</code>两个方法的实现，分别代表了“<strong>加锁</strong>”和“<strong>解锁</strong>”两个不同的阶段。某种程度上，<code>Seamphore</code>更像一个水闸，每次可以通过的“<strong>流量</strong>”是固定的，超出的部分会被直接“<strong>拒绝</strong>”：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“加锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ValueTask&lt;<span class="keyword">bool</span>&gt; <span class="title">TryEnterAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a return value of 'false' indicates that the request is rejected</span></span><br><span class="line">    <span class="comment">// a return value of 'true' indicates that the request may proceed</span></span><br><span class="line">    <span class="comment">// _serverSemaphore.Release is *not* called in this method, </span></span><br><span class="line">    <span class="comment">// it is called externally when requests leave the server</span></span><br><span class="line">    <span class="keyword">int</span> totalRequests = Interlocked.Increment(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//当前请求次数 &gt; 最大请求次数，返回false表示拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (totalRequests &gt; _maxTotalRequest) &#123;</span><br><span class="line">        Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="keyword">bool</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Task task = _serverSemaphore.WaitAsync();</span><br><span class="line">    <span class="keyword">if</span> (task.IsCompletedSuccessfully) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="keyword">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SemaphoreAwaited(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“解锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _serverSemaphore.Release();</span><br><span class="line">    Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="揭秘-StackPolicy"><a href="#揭秘-StackPolicy" class="headerlink" title="揭秘 StackPolicy"></a>揭秘 StackPolicy</h1><p>除了<code>QueuePolicy</code>这种实现以外，官方还提供了<code>StackPolicy</code>的实现。从名称上，我们就能大致区分出它们的不同，因为我相信大家都能拎得清“队列”和“栈”。在实现<code>StackPolicy</code>的过程中，首先会判断是否还有访问请求次数<code>_freeServerSpots</code>，直接返回true，确保中间件可以继续执行。如果<code>_queueLength</code>和我们设置的队列最大容量相同，此时，表示队列已满，需要先取消之前的请求，并保留后来的请求。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ValueTask&lt;<span class="keyword">bool</span>&gt; <span class="title">TryEnterAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_freeServerSpots &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="keyword">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列已满，则取消之前的请求，即_head</span></span><br><span class="line">        <span class="keyword">if</span> (_queueLength == _maxQueueCapacity) &#123;</span><br><span class="line">            _hasReachedCapacity = <span class="literal">true</span>;</span><br><span class="line">            _buffer[_head].Complete(<span class="literal">false</span>);</span><br><span class="line">            _queueLength--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> tcs = _cachedResettableTCS ?? </span><br><span class="line">            = <span class="keyword">new</span> ResettableBooleanCompletionSource(<span class="keyword">this</span>);</span><br><span class="line">        _cachedResettableTCS = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_hasReachedCapacity || _queueLength &lt; _buffer.Count) &#123;</span><br><span class="line">            _buffer[_head] = tcs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _buffer.Add(tcs);</span><br><span class="line">        &#125;</span><br><span class="line">        _queueLength++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// increment _head for next time</span></span><br><span class="line">        <span class="comment">// 如果_head = 最大队列容量，则_head需要移动至首位</span></span><br><span class="line">        _head++;</span><br><span class="line">        <span class="keyword">if</span> (_head == _maxQueueCapacity) &#123;</span><br><span class="line">            _head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tcs.GetValueTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_queueLength == <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots++;</span><br><span class="line"></span><br><span class="line">            f (_freeServerSpots &gt; _maxConcurrentRequests) &#123;</span><br><span class="line">                _freeServerSpots--;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"OnExit must only be called once per successful call to TryEnterAsync"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step backwards and launch a new task</span></span><br><span class="line">    <span class="keyword">if</span> (_head == <span class="number">0</span>) &#123;</span><br><span class="line">        _head = _maxQueueCapacity - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _head--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _buffer[_head].Complete(<span class="literal">true</span>);</span><br><span class="line">    _queueLength--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，现在，你可以感受到这两种策略的差异了，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。此时，如果我们再回过头来看 <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs" target="_blank" rel="noopener">ConcurrencyLimiterMiddleware</a> 这个中间件的实现，就会有种恍然大悟的感觉。</p><h1 id="揭秘-Middleware"><a href="#揭秘-Middleware" class="headerlink" title="揭秘 Middleware"></a>揭秘 Middleware</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we only ever call GetResult once on the TryEnterAsync ValueTask b/c it resets.</span></span><br><span class="line">    <span class="comment">// 以下代码片段，其实都是调用IQueuePolicy.TryEnterAsync()</span></span><br><span class="line">    <span class="keyword">var</span> waitInQueueTask = _queuePolicy.TryEnterAsync();</span><br><span class="line">    <span class="keyword">bool</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitInQueueTask.IsCompleted) &#123;</span><br><span class="line">        ConcurrencyLimiterEventSource.Log.QueueSkipped();</span><br><span class="line">        result = waitInQueueTask.Result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> (ConcurrencyLimiterEventSource.Log.QueueTimer())</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">await</span> waitInQueueTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当result为true，表示请求被接收，此时，让中间件继续执行</span></span><br><span class="line">    <span class="comment">// 切记：调用_queuePolicy.OnExit()来释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> _next(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            _queuePolicy.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里就是请求被拒绝的情况，修改状态码以及输出错误信息</span></span><br><span class="line">        ConcurrencyLimiterEventSource.Log.RequestRejected();</span><br><span class="line">        ConcurrencyLimiterLog.RequestRejectedQueueFull(_logger);</span><br><span class="line">        context.Response.StatusCode = StatusCodes.Status503ServiceUnavailable;</span><br><span class="line">        <span class="keyword">await</span> _onRejected(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就理清了整个中间件的运作机制，<a href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs" target="_blank" rel="noopener">ConcurrencyLimiterMiddleware</a> 中注入了<code>IQueuePolicy</code>这个接口，当一个新的请求进来，中间件会调用<code>IQueuePolicy</code>接口的<code>TryEnterAsync()</code>方法，该方法决定了一个请求是会被接受还是拒绝。当请求被接受的时候，中间件会调用<code>_next(context)</code>让请求继续往下走；当请求被拒绝的时候，中间件会修改 HTTP 状态码(503) 和 返回值，保证调用者可以收到错误信息。这就是这个中间件全部的秘密。而如果要在项目中使用这个中间件，同样是非常简单的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 中间件基本法，先注册后使用</span></span><br><span class="line"><span class="comment">// ConfigureServices()</span></span><br><span class="line"><span class="comment">// 或者 services.AddQueuePolicy()</span></span><br><span class="line">services.AddStackPolicy(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.MaxConcurrentRequests = <span class="number">2</span>;</span><br><span class="line">    options.RequestQueueLimit = <span class="number">25</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure()</span></span><br><span class="line">app.UseConcurrencyLimiter();</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，主要揭秘了 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的 <a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter" target="_blank" rel="noopener">ConcurrencyLimiter</a> 中间件，这个中间件的主要功能是控制 ASP.NET Core 中的请求并发。作为这个中间件的核心，微软为 <code>IQueuePolicy</code> 接口提供了 <code>QueuePolicy</code> 和 <code>StackPolicy</code> 两种不同的策略实现。其中，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。对于我们而言，这个中间件最值得学习的地方，其实是<code>SeamphoreSlim</code>和<code>Interlocked</code>，我们经常提到“<strong>锁</strong>”，其实，“<strong>锁</strong>”不单单是指 .NET 中<code>Monitor</code>的语法糖，即<code>lock</code>关键字，在同步信号量以及线程同步的相关话题中，我们还会接触到譬如 <strong>Mutex(互斥锁)</strong>、ReaderWriterLockSlim、<strong>Interlocked(原子操作)</strong>、<strong>SpinLock(自旋锁)</strong> 以及 SeamphoreSlim 等等不同的“<strong>锁</strong>”。除此之外，还有譬如AutoResetEvent、ManualResetEvent 和 ManualResetEventSlim 等等的同步信号量。如果有读者朋友对此感兴趣，可以到 MSDN 上去搜索相关的关键字，能让博主本人和大家从中有所收获，这是我坚持写下去的理由。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="源码" scheme="https://qinyuanpei.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="并发" scheme="https://qinyuanpei.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="中间件" scheme="https://qinyuanpei.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>通过 EmbededFileProvider 实现 Blazor 的静态文件访问</title>
    <link href="https://qinyuanpei.github.io/posts/3789745079/"/>
    <id>https://qinyuanpei.github.io/posts/3789745079/</id>
    <published>2021-02-23T05:37:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>重构我的 <a href="https://blog.yuanpei.me" target="_blank" rel="noopener">独立博客</a> ，是博主今年的计划之一，这个基于 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 的静态博客，最早搭建于2014年，可以说是比女朋友更亲密的存在，陪伴着博主走过了毕业、求职以及此刻的而立之年。其间虽然尝试过像 <a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a> 和 <a href="https://www.gohugo.org/" target="_blank" rel="noopener">Hugo</a> 这样的静态博客生成器，可是考虑到模板、插件等周边生态，这个想法一直被搁置下来。直到最近，突然涌现出通过 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">Blazor</a> 重写博客的想法，尤其是它对于 <a href="https://webassembly.org/" target="_blank" rel="noopener">WebAssembly</a> 的支持，而类似 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a> 和 <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>的组件化开发模式，在开发体验上有着同样不错的表现。所以，今天这篇博客就来聊聊在重写博客过程中的一点收获，即如何让 Blazor 访问本地的静态文件。</p><h1 id="从内嵌资源说起"><a href="#从内嵌资源说起" class="headerlink" title="从内嵌资源说起"></a>从内嵌资源说起</h1><p>首先，我们要引入一个概念，即：内嵌资源。我们平时接触的更多的是本地文件系统，或者是 FTP 、对象存储这类运行在远程服务器上的文件系统，这些都是非内嵌资源，所以，内嵌资源主要是指那些没有目录层级的文件资源，因为它会在编译的时候“<strong>嵌入</strong>”到动态链接库(DLL)中。一个典型的例子是<code>Swagger</code>，它在<code>.NET Core</code>平台下的实现是<a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore" target="_blank" rel="noopener">Swashbuckle.AspNetCore</a>，它允许使用自定义的HTML页面。这里可以注意到，它使用到了<code>GetManifestResourceStream()</code>方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// requires file to be added as an embedded resource</span></span><br><span class="line">    c.IndexStream = () =&gt; GetType().Assembly</span><br><span class="line">        .GetManifestResourceStream(<span class="string">"CustomUIIndex.Swagger.index.html"</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实，这里使用的就是一个内嵌资源。关于内嵌资源，我们有两种方式来定义它：</p><ul><li>在 Visual Studio 中选中指定文件，在其属性窗口中选择生成操作为嵌入的资源：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/23/Zftpl5UFnmcLK49.png" alt="如何定义一个文件资源为内嵌资源" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">如何定义一个文件资源为内嵌资源</div>            </figure><ul><li>在项目文件(<strong>.csproj</strong>)中修改对应<code>ItemGroup</code>节点，参考示例如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">"Microsoft.NET.Sdk.Web"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EmbeddedResource</span> <span class="attr">Include</span>=<span class="string">"_config.yml"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CopyToOutputDirectory</span>&gt;</span>Always<span class="tag">&lt;/<span class="name">CopyToOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">EmbeddedResource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就完成了内嵌资源的定义。而定义内嵌资源，本质上还是为了在运行时期间去读取和使用，那么，自然而然地，我们不禁要问，该怎么读取这些内嵌资源呢？在<code>Assembly</code>类中，微软为我们提供了下列接口来处理内嵌资源：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> ManifestResourceInfo <span class="title">GetManifestResourceInfo</span>(<span class="params"><span class="keyword">string</span> resourceName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span>[] <span class="title">GetManifestResourceNames</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Stream <span class="title">GetManifestResourceStream</span>(<span class="params">Type type, <span class="keyword">string</span> name</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Stream <span class="title">GetManifestResourceStream</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>GetManifestResourceNames()</code>方法用来返回所有内嵌资源的名称，<code>GetManifestResourceInfo()</code>方法用来返回指定内嵌资源的描述信息，<code>GetManifestResourceStream()</code>方法用来返回指定内嵌资源的文件流。为了方便大家理解，这里我们准备了一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.GetExecutingAssembly();</span><br><span class="line"><span class="keyword">var</span> resources = assembly.GetManifestResourceNames();</span><br><span class="line">resources.ToList().ForEach(x =&gt; Console.WriteLine(x));</span><br><span class="line"><span class="comment">//ConsoleApp.A.B.示例文档.txt</span></span><br><span class="line"><span class="comment">//ConsoleApp.A._config.yml</span></span><br><span class="line"><span class="keyword">var</span> fileInfo = assembly.GetManifestResourceInfo(resources[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> fileStream = assembly.GetManifestResourceStream(resources[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>此时，我们会发现，内嵌资源都是使用类似<code>A.B.C.D</code>这样的形式来表示资源路径的，因为内嵌资源本身是没有目录层级的。现在，如果我们再回过头去看<code>Swagger</code>的示例，就不难理解为什么会有<code>CustomUIIndex.Swagger.index.html</code>这样一个奇怪的值，因为它对应着实际的物理文件路径，如下图所示，示例代码中输出的资源路径和实际的物理路径存在着对应关系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/23/jgqxFTPt2OnHMyh.png" alt="项目中的物理路径与内嵌资源路径对照" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">项目中的物理路径与内嵌资源路径对照</div>            </figure><h1 id="EmbededFileProvider"><a href="#EmbededFileProvider" class="headerlink" title="EmbededFileProvider"></a>EmbededFileProvider</h1><p>OK，那么在了解了内嵌资源以后，接下来，我们需要关注的是<code>EmbededFileProvider</code>。需要说明的是，在<code>ASP.NET Core</code>中，微软是通过<code>IFileProvider</code>这个接口来解决文件读取问题的，典型的使用场景有静态文件中间件、Rozar模板引擎以及WWWRoot目录定位等等，通常情况下，我们使用<code>PhysicalFileProvider</code>更多一点，它和<code>EmbededFileProvider</code>一样，都实现了<code>IFileProvider</code>接口，所以，<code>ASP.NET Core</code>可以从不同的来源访问文件信息。</p><p>显然，<code>EmbededFileProvider</code>正是为了内嵌资源而生，它在内部使用到了<code>Assembly</code>类中和内嵌资源相关的接口.所以，除了上面的方式，我们还可以通过下面的方式来访问内嵌资源，需要注意的是，使用<code>EmbededFileProvider</code>需要引用<code>Microsoft.Extensions.FileProviders.Embedded</code>，大家可以比较一下这两种方式地差异：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.GetExecutingAssembly();</span><br><span class="line"><span class="keyword">var</span> provider = <span class="keyword">new</span> EmbeddedFileProvider(assembly);</span><br><span class="line"><span class="comment">//注意，这里写"."或者""都可以</span></span><br><span class="line"><span class="keyword">var</span> resouces = provider.GetDirectoryContents(<span class="string">"."</span>).ToList();</span><br><span class="line"><span class="keyword">var</span> fileInfo = provider.GetFileInfo(resouces[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> fileStream = fileInfo.CreateReadStream();</span><br></pre></td></tr></table></figure><p>除此以外，<code>IFileProvider</code>还有一个最重要的功能，即<code>Watch()</code>方法，它可以监听文件的变化，并返回一个<code>IChangeToken</code>。有没有一种似曾相识燕归来的感觉？没错，博主曾经在 <a href="https://blog.yuanpei.me/posts/835719605/" target="_blank" rel="noopener">基于选项模式实现.NET Core的配置热更新</a> 这篇文章中介绍过它，它是实现配置热更新的关键。事实上，<code>FileConfigurationSource</code>这个类中有一个<code>Provider</code>属性，而它对应的类型恰好是<code>IFileProvider</code>，这难道是巧合吗？不，仔细顺着这条线，我们大概就能明白微软的良苦用心，我们的配置文件自然是来自文件系统，而考虑到内嵌资源的存在，我们面对的文件系统其实是一个广义的文件系统，它可以是物理文件、内嵌文件、Glob、对象存储(<strong>OSS</strong>)等等</p><h1 id="Blazor的奇妙缘分"><a href="#Blazor的奇妙缘分" class="headerlink" title="Blazor的奇妙缘分"></a>Blazor的奇妙缘分</h1><p>好了，千呼万唤始出来，现在终于要讨论 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">Blazor</a> 这个话题啦！众所周知，静态博客生成器里主要存在着两种配置，即站点配置和主题配置，<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 里甚至还支持从特定文件夹里加载自定义的数据。所以，对于静态博客而言，它需要有从外部加载数据这个特性。我们知道，<a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">Blazor</a> 分为服务器和客户端两个版本，两者的区别主要在于 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-5.0" target="_blank" rel="noopener">Rozar</a> 模板由谁来渲染，前者相当于服务端渲染(<strong>SSR</strong>) + <a href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/javascript-client?view=aspnetcore-5.0" target="_blank" rel="noopener">SignalR</a>，而后者则是基于 <a href="https://webassembly.org/" target="_blank" rel="noopener">WebAssembly</a>，它可以直接在浏览器中加载。显然，后者更接近我们静态博客生成器的想法。由于 Hexo 使用 Yaml 作为配置语言，所以，为了读取原来 Hexo 博客的配置，参考 <a href="https://www.cnblogs.com/nianming/p/7097338.html" target="_blank" rel="noopener">实现自己的.NET Core配置Provider之Yaml</a> 这篇博客实现了一个YamlConfigurationProvider。</p><p>在使用的过程中，遇到的问题是，它无法识别配置文件的路径。原因很简单，经过编译的 Blazor 会被打包为 WebAssembly ，而 WebAssembly 在前端加载以后，原来的目录层级早已荡然无存。此时，基于物理文件的 <code>PhysicalFileProvider</code> 将无法工作。解决方案其实大家都能想到，换一种<code>IFileProvider</code>的实现就好了啊！至此，奇妙的缘分产生了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">YamlConfigurationProvider</span> : <span class="title">FileConfigurationProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> FileConfigurationSource _source;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YamlConfigurationProvider</span>(<span class="params">FileConfigurationSource source</span>) : <span class="title">base</span>(<span class="params">source</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> path = _source.Path;</span><br><span class="line">        <span class="keyword">var</span> provider = _source.FileProvider;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = provider.GetFileInfo(path).CreateReadStream())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//核心问题就是这个Stream的来源发生了变化</span></span><br><span class="line">            <span class="keyword">var</span> parser = <span class="keyword">new</span> YamlConfigurationFileParser();</span><br><span class="line">            Data = parser.Parse(stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实，<a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/fundamentals/configuration?view=aspnetcore-3.1" target="_blank" rel="noopener">官方文档</a>中提到过，Blazor 的配置文件默认从 WWWRoot 下的<code>appsettings.json</code>加载，所以，对于像JSON这类静态文件，可以注入HttpClient，以API的方式进行访问。例如，官方文档中推荐的加载配置文件的方式为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient()</span><br><span class="line">&#123;</span><br><span class="line">    BaseAddress = <span class="keyword">new</span> Uri(builder.HostEnvironment.BaseAddress)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">builder.Services.AddScoped(sp =&gt; httpClient);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前方有语法糖，高甜:)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> http.GetAsync(<span class="string">"cars.json"</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> stream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line"></span><br><span class="line">builder.Configuration.AddJsonStream(stream);</span><br></pre></td></tr></table></figure><p>而经过我们这样改造以后，我们还可以这样加载配置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">builder.Configuration.AddYamlFile(</span><br><span class="line">    provider:<span class="keyword">new</span> EmbeddedFileProvider(Assembly.GetExecutingAssembly()),</span><br><span class="line">    path: <span class="string">"_config.yml"</span>,</span><br><span class="line">    optional:<span class="literal">false</span>,</span><br><span class="line">    reloadOnChange:<span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一旦这些配置注入到 IoC 容器里，我们就可以纵享无所不在的依赖注入，这里以某个组件为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@using Microsoft.Extensions.Configuration</span><br><span class="line">@inject IConfiguration Configuration</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container-fluid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-row DreamCat-content-header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container fade-scale in"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>@Configuration["title"]<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">"subtitle"</span>&gt;</span>@Configuration["subtitle"]<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样地，对于组件内的数据，在大多数场景下，我们可以这样来处理，还是因为有无所不在的依赖注入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@page "/"</span><br><span class="line">@layout MainLayout</span><br><span class="line"></span><br><span class="line">@inject HttpClient httpClient</span><br><span class="line">@using BlazorBlog.Core.Domain.Blog;</span><br><span class="line">@using BlazorBlog.Web.Shared.Partials;</span><br><span class="line">@if (posts != null &amp;&amp; posts.Any())</span><br><span class="line">&#123;</span><br><span class="line">    foreach (var post in posts)</span><br><span class="line">    &#123;</span><br><span class="line">        //这是一个自定义组件</span><br><span class="line">        <span class="tag">&lt;<span class="name">PostItem</span> <span class="attr">Model</span>=<span class="string">post</span>&gt;</span><span class="tag">&lt;/<span class="name">PostItem</span>&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@code</span><br><span class="line">&#123;</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">Post</span>&gt;</span> posts &#123; get; set; &#125;</span><br><span class="line">    protected override async Task OnInitializedAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        posts = await httpClient.GetFromJsonAsync&lt;List&lt;Post&gt;&gt;("content.json");</span><br><span class="line">        await base.OnInitializedAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以给大家展示下尚在开发中的静态博客：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/23/wMED8k6SbqITpma.png" alt="基于 Balzor 的静态博客" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">基于 Balzor 的静态博客</div>            </figure><p>理论上任何文件都可以这样做，主要是考虑到配置这种信息，用依赖注入会更好一点，这样每一个组件都可以使用这些配置，而如果是以 API 的形式集成，以目前 Blazor 打包以后加载的效果来看，页面会有比较大的“<strong>空白期</strong>”。我更加疑惑的是，如果 Blazor 打包后的体积过大，那么浏览器自带的存储空间是否够用呢？一句话总结的话， Blazor 是一个写起来非常舒服的框架，可未来是否会像当年的 Sliverlight 一样，这还要看大家对 WebAssembly 的接受程度，可谓是“<strong>路漫漫其修远兮</strong>”啊……</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，是博主由一个个“<strong>闪念</strong>”而串联起来的脑洞，作为一个实验性质的尝试，希望通过 Blazor 的客户端模式(<strong>WebAssembly</strong>) 实现一个静态博客，而在这个过程中，需要解决 Balzor 读取本地文件的问题，由此，我们引入了这篇博客的主题之一，即：<code>EmbededFileProvider</code>。顺着这条线索，我们梳理了内嵌的文件资源、<code>IFileProvider</code>接口、<code>FileConfigurationProvider</code>、<code>FileConfigurationSource</code>等等一系列看起来毫无关联的概念。事实上，“<strong>冥冥之中自有天意</strong>”，这一切怎么会毫无关联呢？我们最终从文件系统看到了配置系统，聊到了 Blazor 中的配置问题，这里我们熟悉的依赖注入、配置系统都得以延续下来。其实，单单就解决这个问题而言，完全不值得专门写一篇博客，<strong>可从一个点辐射到整个面的这种感悟，在人生的成长中更显得弥足珍贵，希望我们每一个人都能多多跳脱出自己的视角，去努力的看一看这个丰富多彩的世界，在多样性与多元化中去寻找整体上的统一，这是作为技术人员的我，一生都想去探索的哲学</strong>。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论中留下你的想法或者建议，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="Blazor" scheme="https://qinyuanpei.github.io/tags/Blazor/"/>
    
      <category term="文件" scheme="https://qinyuanpei.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="WebAssembly" scheme="https://qinyuanpei.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>低代码，想说爱你不容易</title>
    <link href="https://qinyuanpei.github.io/posts/2637069146/"/>
    <id>https://qinyuanpei.github.io/posts/2637069146/</id>
    <published>2021-02-15T12:37:47.000Z</published>
    <updated>2021-05-28T02:08:18.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>一直想写篇文章，聊一聊“<strong>低代码</strong>”这个话题。一方面，“<strong>低代码</strong>”这个概念确实非常火，其热度丝毫不亚于曾经的“<strong>中台</strong>”。有人说，2021年是属于“<strong>云原生</strong>”的时代，看起来我们每一年都在被技术的“<strong>娱乐圈</strong>”抛弃，明明连 <code>Kubernetes</code> 都还没有入门呢？人们已然在欢呼雀跃般地声称要抛弃 <code>Docker</code> 。这个世界有时就是如此地魔幻，明明我们生活在一个拥有大量基础设施的时代，我们不必再像前辈们“刀耕火种”一般地去开发软件，可我们的生存空间为什么就越来越狭窄了呢？拼多多事件过去没有多久，腾讯的阳光普照奖再次让“<strong>打工魂</strong>”觉醒，也许果真像大鱼海棠里设定的一样，人的记忆只有7秒。而另一方面，我想结合我最近开发“<strong>工作流</strong>”的感受，来吐槽下这个看起来美好的“<strong>低代码</strong>”。也许，对企业而言，引入“<strong>低代码</strong>”的确能减少研发成本，可博主并不认为，它会降低业务本身的复杂性，如果所有声称“<strong>低代码</strong>”或者“<strong>无代码</strong>”的项目，最终依然需要研发人员来作为收场。对此，我想说，对不起，这不是我想要的“<strong>低代码</strong>”。</p><h1 id="低代码发展现状"><a href="#低代码发展现状" class="headerlink" title="低代码发展现状"></a>低代码发展现状</h1><p>或许，一个人成熟的标志就是，在面对一个未知的事物的时候，决不会不由分说地一通吐槽，就像一个人在职场上，你不能永远都只是学会抱怨，相对于抱怨，人们更希望听到的是解决方案。所以，一个人的成长，本质上就是不断学会为自己、为别人找解决方案的过程，前者是为了认识自我，而后者是为了交换资源。所以，在听我吐槽“<strong>低代码</strong>”前，不妨先一起来看看低代码的发展现状。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/15/j6dAcDPEopHSLCa.png" alt="低代码产品发展现状" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">低代码产品发展现状</div>            </figure><h2 id="国外趋势"><a href="#国外趋势" class="headerlink" title="国外趋势"></a>国外趋势</h2><p>有人认为，“<strong>低代码</strong>”的兴起源于钉钉的低代码应用 <a href="https://www.aliwork.com/" target="_blank" rel="noopener">易搭</a> 的落地。诚然，巨头企业的每一个动向都引领着整个行业的风潮，可低代码这个概念最早要追溯到1980年。彼时，<strong>IBM</strong> 的快速应用程序开发工具(<strong>RAD</strong>)被冠以新的名字——低代码，这是低代码这个概念首次面向大众，此后的40年里，国外诞生了诸如 <a href="https://www.outsystems.com/" target="_blank" rel="noopener">Outsystem</a> 、<a href="https://www.mendix.com/" target="_blank" rel="noopener">Mendix</a> 、 <a href="https://www.zoho.com/creator/developers/" target="_blank" rel="noopener">Zoho Creator</a> 等等的产品，整体发展相对缓慢。直到2015年以后，AWS、Google、Microsoft 和 Oracle 等巨头开始入局低代码领域。2018年，西门子更是宣布以 6 亿欧元收购低代码应用开发领域的领导者 <a href="https://www.mendix.com/" target="_blank" rel="noopener">Mendix</a> 、快速应用开发的低代码平台 <a href="https://www.outsystems.com/" target="_blank" rel="noopener">Outsystem</a> 获得 3.6 亿美金的投资，低代码平台市场开始火爆起来，我们所熟悉的 <a href="https://docs.microsoft.com/zh-cn/power-platform/" target="_blank" rel="noopener">Power Platform</a>，其实就是微软的低代码开发平台，低代码领域通常都需要大量的积累和研发，需要有10到20年左右的技术沉淀。</p><h2 id="国内风云"><a href="#国内风云" class="headerlink" title="国内风云"></a>国内风云</h2><p>国内的低代码领域，相比国外发展起步较晚，可依然涌现出像<a href="https://www.newdao.net/" target="_blank" rel="noopener">牛刀</a>、<a href="https://www.apicloud.com/" target="_blank" rel="noopener">APICloud</a>、<a href="https://www.ivx.cn/" target="_blank" rel="noopener">iVX</a>、<a href="https://www.dadayun.cn/index" target="_blank" rel="noopener">搭搭云</a>、氚云、简道云、云表、<a href="https://www.aliwork.com/" target="_blank" rel="noopener">宜搭云</a>等等产品。从整体上而言，这类这类产品基本上都提供了可视化搭建环境，都声称无需编码即可完成业务系统的搭建。其实，从一名程序员的初心出发，我们所做的一切努力都是为了以后不写代码。经常有人问，怎么样可以做到零缺陷、零 Bug ，其实不写代码就好啦！我们并不担心低代码让我们失业，相反地，如果低代码可以消化掉 30% 的垃圾项目，那么，我们将会有更多的时间去做些有意义的事情，而不是在一个“<strong>劣币驱逐良币</strong>”的市场里，靠着 <code>996</code> 来争个你死我活。而从低代码的商业价值角度来看，<a href="https://www.salesforce.com" target="_blank" rel="noopener">Salesforce</a>、<a href="https://www.appian.co.uk/" target="_blank" rel="noopener">Appian</a>、<a href="https://www.joget.org/" target="_blank" rel="noopener">Joget</a> 这三家公司均已上市，<a href="https://www.mendix.com/" target="_blank" rel="noopener">Mendix</a> 和 <a href="https://www.outsystems.com/" target="_blank" rel="noopener">Outsystem</a> 更是估值 10 亿美元以上的独角兽公司，这正是巨头们入局低代码的原因所在。</p><p>低代码领域，目前关注的重点主要集中在：<strong>表单生成和处理</strong>、<strong>工作流生成和管理</strong>、<strong>办公协作</strong>、<strong>人力资源</strong>、<strong>客户关系</strong>、<strong>ERP</strong> 等企业应用上，就如同 <strong>SAP</strong> 、<strong>金蝶</strong>、 <strong>SCM</strong> 等企业软件一样，每一个软件都曾声称能帮助企业解决某一类问题，低代码领域同样遵循“<strong>二八原则</strong>”，即 80% 的场景，通过定义的方法论、方式、工具集能够实现；而剩下的 20% 的场景或许实现不了，需要使用者通过扩展的方式来自行解决。譬如，针对大多数企业都存在的 CRUD 的需求，通过在线的 Excel 表格来实现基于表的业务驱动。例如 <a href="https://www.seatable.cn/" target="_blank" rel="noopener">SeaTable</a> 就是这类主打协同工作的产品；针对大多数企业都存在的审批类的需求，则可以通过可视化的工作流设计系统来完成。例如 <a href="https://www.grapecity.com.cn/aboutus" target="_blank" rel="noopener">葡萄城</a> 的 <a href="https://www.grapecity.com.cn/developer/spreadjs" target="_blank" rel="noopener">SpreadJS</a> 和 <a href="https://www.grapecity.com.cn/solutions/huozige" target="_blank" rel="noopener">活字格</a> ，同样可以视为低代码平台，甚至早期的 .NET 开发者被人“黑”只会拖控件，这难道不是广义上的低代码吗？</p><h1 id="低代码产品形态"><a href="#低代码产品形态" class="headerlink" title="低代码产品形态"></a>低代码产品形态</h1><p>搞清楚整个低代码的发展现状以后，那么，整个低代码领域主要的产品形态有哪些呢？了解其主要的产品形态，对于我们形成低代码的直观印象非常有帮助。在我看来，主要分为四类：</p><ul><li>表单生成类：以 <a href="https://www.aliwork.com/" target="_blank" rel="noopener">宜搭云</a> 和 <a href="https://www.jnpfsoft.com/" target="_blank" rel="noopener">JNPF</a> 为代表，主张通过可视化的设计器来完成页面布局、编排、设计，即所谓的“所见即所得”，类似的还有 <a href="https://www.ivx.cn/" target="_blank" rel="noopener">iVX</a>。</li><li>工作流生成类：以 Mendix 和 Outsystems 为代表，提供组件式的服务，通过编排工作流来实现特定的业务，即通过流程图的方式来实现业务逻辑部分，不同的节点代表不同的功能，不同的线条代表不同的分支。</li><li>协同工作类：以 <a href="https://www.seatable.cn/" target="_blank" rel="noopener">SeaTable</a> 为代表，基于表的业务驱动开发平台，可以以不同的维度管理数据、对数据可视化、共享协作等等，同时具备自动化规则、脚本运行等能力。</li><li>服务聚合类：以 <a href="https://www.apicloud.com/" target="_blank" rel="noopener">APICloud</a> 为代表，基于API聚合的组件市场工具，通过流程管理工具，可以管理整个应用的开发周期，从产品、设计开始，到研发测试和运营。</li></ul><p>所以，整体而言，低代码产品的核心是<strong>表单引擎</strong> 和 <strong>流程引擎(BPM)</strong>，外围支撑是<strong>BI引擎</strong>、<strong>*协同工作</strong>、<strong>服务聚合</strong>等等，目前，市面上主流的低代码产品，表单引擎和流程引擎(BPM)基本是标配，所以，严格地说起来，上面的分类并不严谨，因为基本上都是混合式的产品形态。下面是部分低代码产品的截图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/15/sY4r1ZHevJlKIE6.png" alt="某“低代码”二维码应用" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">某“低代码”二维码应用</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/15/u6AIRJGCeV4hPSg.png" alt="某“低代码”人力资源管理系统" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">某“低代码”人力资源管理系统</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/15/4DyZAzi53wVEn6p.png" alt="某“低代码”可视化搭建系统" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">某“低代码”可视化搭建系统</div>            </figure><h1 id="低代码研发痛点"><a href="#低代码研发痛点" class="headerlink" title="低代码研发痛点"></a>低代码研发痛点</h1><p>相信大家都知道了，接下来的内容是本文真正的重点。为什么要这样说呢？这主要和博主自身的工作有关系，简单来说，公司需要一个想象中的可视化设计器，业务人员只需要通过拖拽就可以完成业务逻辑的编排，而开发人员则需要负责对外输出组件供业务人员使用。这听起来特别像我们刚刚讨论的第二种产品形态对不对？听起来非常美好对不对？我承认这个想法真的符合潮流、非常的“低代码”。所以，我们前期采用了微软的 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/windows-workflow-foundation/" target="_blank" rel="noopener">Windows Workflow Foundation</a> 框架，使用以后的效果大概是下面这个样子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/15/hYpq4nCk5BsFdHi.jpg" alt="Windows Workflow Foundation 设计器" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">Windows Workflow Foundation 设计器</div>            </figure><h2 id="多人协作不便"><a href="#多人协作不便" class="headerlink" title="多人协作不便"></a>多人协作不便</h2><p>那么，我们在这个过程中到底遇到了哪些问题呢？首先，这种可视化编辑的场景，遇到的第一个问题就是<strong>多人协作</strong>，如果你使用过腾讯文档、钉钉文档这类在线文档类产品，你应该能领悟到我说的这个点。微软的这个框架是采用<code>XMAL</code>这种格式来储存数据的，虽然理论上可以通过 <code>Git</code> 实现多人协作，实际维护起来表示非常地麻烦，所以，我们最终由单人去维护这些工作流。那么，更广义上的低代码又该如何解决这个问题呢？流程图这种东西，就是一种看起来非常清晰，改起来非常麻烦的东西，就像一条锁链一样，你要不停地断开和接上。</p><h2 id="孱弱的表达能力"><a href="#孱弱的表达能力" class="headerlink" title="孱弱的表达能力"></a>孱弱的表达能力</h2><p>其次，是流程图这种表现方式的“表达”问题，就像你如果需要在<code>SQL</code>里表示循环要用到游标一样，这类工作流都无法表达程序三个结构中的循环，更不用说<strong>表达力孱弱</strong>的表达式啦，所以，这就造成一个非常尴尬的问题，你在流程图里写不了太复杂的表达式，一旦业务人员写不出来，就需要开发人员去写辅助性质的代码，类似<strong>正则</strong>、<strong>字符串插值</strong>、<strong>字符串处理</strong>、格式化等等的函数或者API非常缺乏。当然，我最无法忍受的，就是组件与组件间传值的方式，你除了返回JSON和写表再没有其它方式，更何况这个JSON返回给某个组件了，人家还未必能直接解析直接使用呢？因为编辑器无法绑定这种复杂的数据结构。</p><h2 id="混乱的变量和参数"><a href="#混乱的变量和参数" class="headerlink" title="混乱的变量和参数"></a>混乱的变量和参数</h2><p>接下来，我最想吐槽的是，关于<strong>全局变量</strong>和<strong>参数</strong>的问题，在流程图中你经常需要各个分支的标志位(Flag)或者是临时变量，然后你就看到了那种“变量满天飞”的混乱局面，简直像极了你刚开始写的代码，你需要顺着每个线条，逐个点开每个组件的属性面板，查看它都使用了哪些参数或者变量，至此，你终于明白了它的数据是如何流动的。从前，乡愁是成千上万行的代码；现在，乡愁是剪不断理还乱的“<strong>蜘蛛网</strong>”。多年前，我对虚幻引擎(<strong>Unreal</strong>)的蓝图功能有多么憧憬；多年后，我对这种基于流程引擎的低代码就有多排斥。尤其是，当我需要复用某一段逻辑的时候，我只能小心翼翼地选中节点和线条，然后再拷贝过去。</p><h2 id="动态计算-事件顺序-黑盒子"><a href="#动态计算-事件顺序-黑盒子" class="headerlink" title="动态计算/事件顺序/黑盒子"></a>动态计算/事件顺序/黑盒子</h2><p>最后，我参考了一位被 <a href="https://powerapps.microsoft.com/zh-cn/" target="_blank" rel="noopener">Power Apps</a> 所折磨的朋友的意见，除了上面提到的这些问题， <strong>属性</strong>面板或者<strong>公式</strong>无法使用动态计算的值，类似<code>Vue</code> 里面的计算属性，从实际使用的体验来看，这类以流程引擎和表单引擎为主要卖点的低代码工具，其实都会存在这样的问题，而面对这种问题，一般只能通过<code>trick</code>的手段来解决。同样地，<a href="https://powerapps.microsoft.com/zh-cn/" target="_blank" rel="noopener">Power Apps</a> <strong>事件顺序的不确定</strong>问题，因为低代码实际上是框架提供了某种机制，可以帮你完成某个事情，所以，低代码内部对于使用者来说，完全就是一个<strong>黑盒子</strong>，譬如 <a href="https://powerapps.microsoft.com/zh-cn/" target="_blank" rel="noopener">Power Apps</a> 在无网络的环境下使用会卡顿，调试起来非常不便等等。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>坦白来讲，这篇博客实在没什么“技术含量”，无非是按照一个月前的计划在整理内容。我对“低代码”持一种中立的态度，作为程序员，我是希望有这样的技术来简化流程，可以让研发人员从枯燥的“增删改查”中解放出来，留出时间去做更多有意义、有价值的事情。当我了解了低代码和零代码的差异以后，我突然明白，我需要的其实是零代码，因为我希望那帮业务人员能自己搞定，这样就不用再来烦我，可经历这段时间的“低代码”，我清醒地认识到，这个想法根本不现实。<strong>一来业务人员并不像他们想象的那样，除了不会写代码以外无所不能；二来业务的复杂性满足守恒定律，它永远不会消失，只会从一种形式变成另一种形式</strong>。<strong>也许，低代码真的能帮企业省不少钱；也许，企业最喜欢做的事情，就是花点小钱招人外包做这种事情。但我依然想告诫开发者们，不要去追逐这些看起来美好的东西，对企业来说，它今天使用 A 技术，明天使用 B 技术，完全无关紧要。可对于个人而言，这个选择显得非常重要。看一看曾经的 SAP 咨询顾问就知道了，如果有一天 SAP 都倒闭了，你掌握着这些只有在 SAP 上能发挥作用的技术有什么用呢？对技术人员来说，学习通用型的知识和技能，永远比把鸡蛋放在一个篮子里要更保险</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程" scheme="https://qinyuanpei.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="低代码" scheme="https://qinyuanpei.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
      <category term="行业" scheme="https://qinyuanpei.github.io/tags/%E8%A1%8C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>记一次失败的 ThoughtWorks 面试经历</title>
    <link href="https://qinyuanpei.github.io/posts/2837181325/"/>
    <id>https://qinyuanpei.github.io/posts/2837181325/</id>
    <published>2021-02-09T20:37:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>年前朋友问我，要不要试试 ThoughtWorks 澳洲线的岗位。对于这家号称“<strong>世界上面试最难</strong>”的公司，多少还是有一点畏惧，直到朋友安慰我说，它们这次有中级的岗位，还是可以试一试的，梦想还是要有的，万一实现了呢？自此，我凑齐了西安. NET圈子里的四大“天花板”公司的面试：<strong>葡萄城</strong>、<strong>活跃网络</strong>、<strong>奥博杰天</strong>、<strong>ThoughtWorks</strong> ，而对于我来说，亦有幸见识到世界上最难的面试，虽然后来事实证明，这个世界上没有太多的逆袭，可我还是想分享一下我的这次面试经历，因为它让我知道，在过去的两年里，我在哪些方面取得进步，在哪些方面存在不足。当我写下这篇博客的时候，我即将在今年夏天迎来我的29岁，果然我还是希望自己能再努力一点，因为不想让平行世界里的某个人失望。</p><h1 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h1><p>关于ThoughtWorks 的社招流程，大体上由<strong>HomeWork</strong>、<strong>Pair Programming</strong> 和 <strong>Face-to-face Interviews</strong>  3个部分组成，其中，HomeWork，即家庭作业，原则上给3天时间来完成，不过据说可以向 HR 申请更多的时间来完成。<strong>Pair Programming</strong> 和 <strong>Face-to-face Interviews</strong> 通常是安排到同一天来进行的，前者时间为1.5小时，即传说中的结对编程，面试时会有一左一右两名面试官看着你现场写代码。后者时间为1小时，即传说中的技术文化面试，考察技术的深度、广度以及对 Thought Works 敏捷文化的认同感。</p><h2 id="HomeWork"><a href="#HomeWork" class="headerlink" title="HomeWork"></a>HomeWork</h2><p>2月18日，下班以后接到HR小姐姐的电话，在明确了我投简历的意向以后，我收到了HR小姐姐的邮件，基本上就是一个家庭作业，三选一提交，需要在三天内完成。我选择了Conference Track Management 这道题目，因为白天要上班，所以，我为此而连续肝了三个晚上。</p><p>坦白说，不同的阶段对这道题目的理解是不同的，在做家庭作业的阶段，你以为这道题考察的是职责分离和设计模式；而等到结对编程的阶段，你终于意识到，这其实是个背包问题。当然，这并不是说我会错了意，考虑到面试官有上帝视角，他们更容易看清楚问题的全貌。或许，面试官想最想看到的，恰恰就是你从冰山一角到目窥全牛这一瞬间的反应。</p><p>当我接到HR小姐姐的通知，这份作业Review通过时，我内心是非常激动的，因为这意味着我获得了去ThoughtWorks面试的“入场券”。可当我事后再以上帝视角去看待这个题目，我内心又变得非常难过，因为无论怎么看这份作业，都会觉得它设计得并不好，尤其是当它引入弹性时间这个因素以后，我一直深陷于如何从Part 1 到 Part 2，是不是按 Part 2 重新设计会更好一点？此时此刻，终于能理解面试官反馈的，关于扩展性方面的问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/09/7Ae6bSmujgvsB9G.jpg" alt="作业反馈01" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">作业反馈01</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/09/NEQ9YmjMtHbI8eL.jpg" alt="作业反馈02" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">作业反馈02</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/09/v6fluwU1bi4akBH.jpg" alt="作业反馈03" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">作业反馈03</div>            </figure><p>关于这部分，我个人建议多多关注：</p><ul><li>编程风格：编码规范、项目结构、代码坏味道等。</li><li>语言特性：澳洲线岗位需要熟悉 .NET Core，所以，我使用 .NET Core 完成整个项目的编写。</li><li>设计模式：选择合适的设计模式，遵循 SOLID 原则。</li><li>TDD：一定要有单元测试代码，这一点TW最为看中。如果写的好，一定是加分项。建议遵循AAA原则来编写用例。</li><li>程序满足要求：程序一定满足题目要求，可执行，运行结果满足题意，这是最基本的要求。</li></ul><h2 id="Pair-Programming"><a href="#Pair-Programming" class="headerlink" title="Pair Programming"></a>Pair Programming</h2><p>提交作业后，等了一周多的时间，1月29日，HR 小姐姐终于联系我了，正如我上文所述，当时听到这个消息非常激动，因为终于有机会去 ThoughtWorks 这家世界上面试最难的公司去看看，ThoughtWorks 西安办公室位于环普产业园，这个地方相信大家都非常熟悉啦！当时算上周末，我给了自己 5 天时间去准备面试，因为我觉得面对 ThoughtWorks 的面试还是要重视一点，虽然后来好多问题都没有被问到。</p><p>结对编程是基本上就是，两个面试官一左一右地坐在你旁边，采用聊天和探讨的方式一起写代码，刚开始本来是用电视投屏“直播”的方式，后来因为 HDMI 接口接触不良的缘故，两位面试官干脆就直接看我电脑屏幕啦！在这个环节，个人感觉解释编码思路花时间太多，重构完有一个用例没有通过。最重要的是，家庭作业阶段的设计不利于现场新需求的开展，所以，这些因素综合起来，导致我结对变成这个部分表现得不好，希望大家引以为戒啊。</p><p>整个结对编程时长为一个半小时(1.5h)，在这段时间，你需要<strong>讲解编码思路</strong>、<strong>完成代码重构</strong>和<strong>完成现场作业</strong>，时间上还是非常紧凑的，回想起那天下午的两个半小时，有种像参加高考的感觉：你以为时间会很长，结果发现时间完全不够用。看起来轻松的氛围下，其实在不经意间考察你的沟通能力、工程能力和学习能力，ThoughtWorks 的面试，往往就是这样的朴实无华且“有趣”……</p><p>对于这部分，我个人建议多多关注：</p><ul><li>工程能力：语言特性、调试能力、设计能力等。像TW非常重视快捷键的使用，频繁使用鼠标会拉低印象分。</li><li>沟通能力：善于倾听和表达、以及理解需求的能力，需要你在面试官的引导下完成需求确认，这个阶段一样可以展示你技术的深/广度，但建议最好长话短说。</li><li>学习能力：要求你对TDD、敏捷开发等有一定的好奇心，面试官教给你的新东西/思路，能否举一反三、学以致用，我是在重构的过程中得到了面试官的指导，对此我表示感谢。</li><li>适应能力：能否以开放的态度接受面试官的重构意见，当意见不一致时，能否有理有据地、自信地表达你的观点，我遇到的问题是，面试官认为我混淆了职责分离和组件依赖。</li></ul><h2 id="Face-to-face-Interviews"><a href="#Face-to-face-Interviews" class="headerlink" title="Face-to-face Interviews"></a>Face-to-face Interviews</h2><p>结对编程环节结束以后，正当我还在关注那个失败用例的时候，两位新的面试官就走了进来，就这样，我迎来了那天下午的“<strong>技术文化面试</strong>”，考虑到天气的原因，我那天穿了一件鬼灭之刃的卫衣就去参加面试了，可那个小房间的闷热还是让人焦躁不安，一杯放凉的白开水，完全不足以缓解那种闷热的感觉。ThoughtWorks 的办公室和大多数外包公司的办公室没有什么区别，不同的是，它的办公室摆满了各种 <strong>O’Reilly</strong> 的动物书，至少在氛围上确实像它对外所展示的那样重视技术。</p><p>在这个环节，我遇到了很多的开放型问题，譬如<strong>你经历过的、印象最深刻的项目是什么</strong>，<strong>你在项目中遇到问题以后都是怎么样去解决的</strong>，<strong>你所在项目的人员配置、研发流程是什么样的……等</strong>等，虽然一开始还是经典的“自我介绍”，可我感觉我在回答这些开放型问题的时候，缺乏一种系统性思考或者某种方法论，它和回答技术问题不同，有时候我们需要层层展开、关注细节，可是在这样的问题上，它需要的是简洁而准确的答案。面试期间，面试官不止一次提示我听清楚她的问题，难道真的是我的沟通能力出了问题吗？</p><p>坦白来讲，这次我准备的很多面试题都没有被问到，我以为至少会问一下.NET Core、微服务 和 DDD 这些东西的。我同样不太明白的，是关于项目经历方面的，为什么面试官会认为，工作中主要负责的内容就是由我一个人单打独斗来的呢？我承认我这几年，性格上收敛了许多，没有了攻击性和对抗性，变成了一个非常随和的人，可我本质上并不是一个喜欢兜售或者推销的人，我并不觉得无法口若悬河是缺乏自信的表现。后来，面试官就考察了一下我的口语，本来就是口干舌燥，说到为什么选择 ThoughtWorks 的时候，大脑有一点卡壳，一边在组织中文，一边在想怎么翻译成英文，还有什么比结结巴巴地说完一段英语更让人难过的呢？</p><p>对于这个部分，我个人建议多多关注：</p><ul><li>系统思考：结合工作经验，不断去提炼类似架构方向、敏捷开发、项目管理方面的内容，不要永远局限在一个点上看待问题，不管是表达还是编程，都采用系统性、结构化的思路来梳理，要做到清晰、准确、完整。</li><li>自信：ThoughtWorks 是一家咨询服务公司，所以，很多研发都是顶着咨询师的头衔，个人觉得还是自信一点，会就是会，正常交流，不会的话，就虚心接受，表现出后期愿意去学习的状态。</li><li>协作能力：能否影响和带动团队中的人一起学习、成长，ThoughtWorks 盛行学习和分享的文化，你一定听说过它们的技术雷达、洞见。</li><li>沟通能力：这体现在你能否和客户正常地沟通、能否和团队成员达成有效的协作，虽然程序员都不大喜欢说话，但你至少应该能传达出正确的声音、能理解来自别人的观点。</li><li>动机：对 ThoughtWorks 的意愿性/认同度，为什么会考虑 ThoughtWorks 等这些问题。</li></ul><h1 id="面试心得"><a href="#面试心得" class="headerlink" title="面试心得"></a>面试心得</h1><p>其实，当天面试一结束，我就知道这次面试大概率是凉了。回去的路上，我和老大哥说了我面试的过程，老大哥说，“<strong>让我冷静，要对自己有信心</strong>”。果然，第二天下午，收到HR小姐姐的回复，说面试没有通过，看了下面试官反馈的意见，<strong>主要是在结对编程过程中重构做得不好，对重构的意义不太明确；其次是面试官觉得我在沟通方面还不够大胆，希望我可以在发展他人方面做出改变</strong>。</p><p>听到这话，怎么突然就有种传销的感觉呢？说到影响别人，从12年开始写博客至今，我自认为我的博客还是帮助到了很多人，可能面试官一直觉得我在单打独斗吧，都2021年了，早就不是求伯君、雷军这些前辈们单打独斗写软件的时代啦，所以，果然还是我的表达出现了问题吗？我的朋友们经常批评说我沉迷于技术无法自拔，可我同样见过30多岁怕别人问原理的“中年”程序员，原本这个行业因为门槛低而越来越内卷，而这个圈子里的人又不以技术为重，有太多单纯为了钱而进入这个行业的人。可当整个行业都越来越“体力”劳动的时候，有很多浮躁的人跑来你面前说，技术并不重要类似的话，这个世界到底怎么了呢？</p><p>我想说什么呢？我认为技术因素和非技术因素都很重要，其实写作一直是我练习表达的一种方式。也许，在那些能言善辩的人眼中，我们这些“闷葫芦”都是些内向的、不太会沟通的人吧！这次面试结束以后，<strong>我打算找点系统性思考方面的书来看看，继续背单词增加词汇量，利用空闲时间来练习口语</strong>。<strong>我从来不认为，一个技术人员努力钻研技术有什么不对，因为这是一个技术人员的基本功。沟通能力能做到妙语生花是一种艺术，而我，追求的目标非常简单，即有条理的、清晰的、结构化的表达，我不追求所谓“高情商”的话术，人类时常因为这些模棱两可的字眼而相互误会，因为信息失真，因为信息冗余</strong>。当然，此刻我的首要目标是，完成那个家庭作业的重构，因为它写得实在是太糟糕啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="面试" scheme="https://qinyuanpei.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="求职" scheme="https://qinyuanpei.github.io/tags/%E6%B1%82%E8%81%8C/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="ThoughtWorks" scheme="https://qinyuanpei.github.io/tags/ThoughtWorks/"/>
    
  </entry>
  
  <entry>
    <title>从 C# 1.0 到 C# 9.0，历代 C# 语言特性一览</title>
    <link href="https://qinyuanpei.github.io/posts/3918433482/"/>
    <id>https://qinyuanpei.github.io/posts/3918433482/</id>
    <published>2021-02-01T22:36:47.000Z</published>
    <updated>2021-05-28T02:08:18.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><h1 id="C-版本历史记录"><a href="#C-版本历史记录" class="headerlink" title="C# 版本历史记录"></a>C# 版本历史记录</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/31/VKRu1xATWYkLqyi.png" alt="从 C# 1.0 到 C# 9.0，历代 C# 语言特性一览" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">从 C# 1.0 到 C# 9.0，历代 C# 语言特性一览</div>            </figure><blockquote><p>说明：因为Markdown下维护这样复杂的表格有一点麻烦，故，这里以图片形式展示出来，如后续内容有更新，请点击 <a href="https://47e58366.wiz06.com/wapp/pages/view/share/s/17VodC2zTAUm24Wzmx3lTnAV2RQJG_0B0AX52FeKVL2zBkmZ" target="_blank" rel="noopener">这里</a> 访问原始笔记链接。<a href="https://www.wiz.cn/index.html" target="_blank" rel="noopener">为知笔记</a> 的表格渲染在移动端表现不佳，为了获得更好的阅读体验，请在电脑端访问查看。</p></blockquote><h1 id="C-版本特性说明"><a href="#C-版本特性说明" class="headerlink" title="C# 版本特性说明"></a>C# 版本特性说明</h1><p>现在是 2021 年，相信 C# 7.0 以前的版本大家都应该没有什么问题，因为像博主这样的 90 后“中年”男人，接触的都是这个版本的 C#。所以，在这里我们主要讲解大家C# 7.0、8.0 以及 9.0 的语法特性。考虑到文章篇幅有限，这里选取的都是博主个人比较喜欢的语法特性，如果这里没有你喜欢的特性，请参考文章末尾的<strong>参考链接</strong>。如果这里的特性你都不喜欢，请你马上关掉这个网页，愿这个世界：Love &amp; Peace。可能你会感觉到我说话变得小心翼翼起来，因为这个世界上有种叫做“<strong>杠精</strong>”的生物，当它从我的只言片语里读出那些挫败感的时候，终于有了嘲笑我们这批步入30岁行列的90后的底气，没错，我在最近的博客评论中被读者“嘲讽”了，让暴风雨来得更猛烈一些吧！</p><h2 id="C-7-0"><a href="#C-7-0" class="headerlink" title="C# 7.0"></a>C# 7.0</h2><p>在 C# 7.0 中，我个人比较喜欢的特性主要有以下几个：<strong>元组和弃元</strong>、<strong>更多的 expression-bodied 成员</strong>、<strong>out 变量</strong>、<strong>异步 Main 方法</strong>、<strong>模式匹配</strong> 和 <strong>引发表达式</strong>。</p><h3 id="元组和弃元"><a href="#元组和弃元" class="headerlink" title="元组和弃元"></a>元组和弃元</h3><p>这个概念乍听起来可能会有一点陌生，其实，按我的理解，这就是增强的元组语法，终于可以摆脱<code>Item1</code>、<code>Item2</code>……啦：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//示例1</span></span><br><span class="line">(<span class="keyword">string</span> Alpha, <span class="keyword">string</span> Beta) namedLetters = (<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"<span class="subst">&#123;namedLetters.Alpha&#125;</span>, <span class="subst">&#123;namedLetters.Beta&#125;</span>"</span>);</span><br><span class="line"> <span class="comment">//示例2</span></span><br><span class="line"><span class="keyword">var</span> alphabetStart = (Alpha: <span class="string">"a"</span>, Beta: <span class="string">"b"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"<span class="subst">&#123;alphabetStart.Alpha&#125;</span>, <span class="subst">&#123;alphabetStart.Beta&#125;</span>"</span>);</span><br><span class="line"><span class="comment">//示例3</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">string</span> label = <span class="string">"Colors used in the map"</span>;</span><br><span class="line"><span class="keyword">var</span> pair = (count, label);</span><br><span class="line">Console.WriteLine(pair);</span><br></pre></td></tr></table></figure><p>有一段时间，前端同事总和我吹嘘 ES6 里面的解构多么多么好用！对此，我想说，C# 一样可以解构，假设我们现在有下面的一个方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> (<span class="keyword">string</span>, <span class="keyword">double</span>, <span class="keyword">double</span>) GetLocation() </span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">var</span> city = <span class="string">"西安市"</span>;</span><br><span class="line">    <span class="keyword">var</span> lat = <span class="number">33.42</span>d;</span><br><span class="line">    <span class="keyword">var</span> lon = <span class="number">107.40</span>d;</span><br><span class="line">    <span class="keyword">return</span> (city, lon, lat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是简化后的元组的用法，如果是以前，我们还需要返回一个<code>Tuple&lt;string, double, double&gt;</code>。此时，如果我们需要解析城市名称及其经纬度，可以这样做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例4</span></span><br><span class="line">(<span class="keyword">string</span> city, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat) = GetLocation();</span><br><span class="line">Console.WriteLine(<span class="string">$"<span class="subst">&#123;city&#125;</span>,(<span class="subst">&#123;lon&#125;</span>,<span class="subst">&#123;lat&#125;</span>)"</span>);</span><br></pre></td></tr></table></figure><p>OK，那么什么又是弃元呢？继续以上面的代码为例，如果我不关心经纬度，只需要城市名称又该怎么办呢？人家的方法返回的是一个3元的结果，而我们只需要其中的1元，此时，就有了所谓弃元的概念：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">string</span> city, _, _) = GetLocation();</span><br><span class="line">Console.WriteLine(<span class="string">$"<span class="subst">&#123;city&#125;</span>"</span>);</span><br></pre></td></tr></table></figure><p>在 C# 中可以使用下划线<code>_</code>来表示要舍弃的元，是为弃元，怎么样？你学会了吗？</p><h3 id="更多的-expression-bodied-成员"><a href="#更多的-expression-bodied-成员" class="headerlink" title="更多的 expression-bodied 成员"></a>更多的 expression-bodied 成员</h3><p>这部分同样是经过强化的 Lambda 表达式，之前我们可以在成员函数和 只读属性上使用 Lambda 表达式，而现在，我们可以将其运用在<code>构造函数</code>、<code>终结器</code>以及 <code>get</code>和<code>set</code>访问器：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expression-bodied constructor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExpressionMembersExample</span>(<span class="params"><span class="keyword">string</span> label</span>)</span> =&gt; <span class="keyword">this</span>.Label = label;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expression-bodied finalizer</span></span><br><span class="line">~ExpressionMembersExample() =&gt; Console.Error.WriteLine(<span class="string">"Finalized!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> label;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expression-bodied get / set accessors.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Label</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; label;</span><br><span class="line">    <span class="keyword">set</span> =&gt; <span class="keyword">this</span>.label = <span class="keyword">value</span> ?? <span class="string">"Default label"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="out变量"><a href="#out变量" class="headerlink" title="out变量"></a><code>out</code>变量</h3><p>个人认为，这是一个非常不错的改进，终于不用再单独声明<code>out</code>变量啦：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">int</span>.<span class="constructor">TryParse(<span class="params">input</span>, <span class="params">out</span> <span class="params">int</span> <span class="params">result</span>)</span>)</span><br><span class="line">    Console.<span class="constructor">WriteLine(<span class="params">result</span>)</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Console.<span class="constructor">WriteLine(<span class="string">"Could not parse input"</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="异步-Main-方法"><a href="#异步-Main-方法" class="headerlink" title="异步 Main 方法"></a>异步 <code>Main</code> 方法</h3><p>顾名思义，<code>Main</code> 方法现在可以支持 <code>async</code> 关键字啦：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This could also be replaced with the body</span></span><br><span class="line">    <span class="comment">// DoAsyncWork, including its await expressions:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> DoAsyncWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有返回值的情况下，可以考虑返回<code>Task</code>:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> async <span class="built_in">Task</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">await <span class="title">SomeAsyncMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>主要是针对 <code>is</code> 和 <code>switch</code> 语句提供了增强的语法。在这里，对于前者来说，我们可以将判断和赋值两个步骤合二为一：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ComputeAreaModernIs</span>(<span class="params"><span class="keyword">object</span> shape</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shape <span class="keyword">is</span> Square s)</span><br><span class="line">        <span class="keyword">return</span> s.Side * s.Side;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">is</span> Circle c)</span><br><span class="line">        <span class="keyword">return</span> c.Radius * c.Radius * Math.PI;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">is</span> Rectangle r)</span><br><span class="line">        <span class="keyword">return</span> r.Height * r.Length;</span><br><span class="line">    <span class="comment">// elided</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">        message: <span class="string">"shape is not a recognized shape"</span>,</span><br><span class="line">        paramName: <span class="keyword">nameof</span>(shape));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于后者来说，主要打破了传统 <code>switch</code> 语句的常量模式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ComputeArea_Version3</span>(<span class="params"><span class="keyword">object</span> shape</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> Square s <span class="keyword">when</span> s.Side == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> Circle c <span class="keyword">when</span> c.Radius == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> Square s:</span><br><span class="line">            <span class="keyword">return</span> s.Side * s.Side;</span><br><span class="line">        <span class="keyword">case</span> Circle c:</span><br><span class="line">            <span class="keyword">return</span> c.Radius * c.Radius * Math.PI;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">                message: <span class="string">"shape is not a recognized shape"</span>,</span><br><span class="line">                paramName: <span class="keyword">nameof</span>(shape));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引发表达式"><a href="#引发表达式" class="headerlink" title="引发表达式"></a>引发表达式</h3><p>这个主要是针对 <code>throw</code> 关键字的增强，当我看到微软的文档的时候，我突然意识到，这个语法其实我用了很久啦！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景A：条件运算符</span></span><br><span class="line"><span class="keyword">string</span> arg = args.Length &gt;= <span class="number">1</span> ? args[<span class="number">0</span>] :</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"You must supply an argument"</span>);</span><br><span class="line"><span class="comment">//场景B：Null合并运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; name;</span><br><span class="line">    <span class="keyword">set</span> =&gt; name = <span class="keyword">value</span> ??</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(</span><br><span class="line">          paramName: <span class="keyword">nameof</span>(<span class="keyword">value</span>), </span><br><span class="line">          message: <span class="string">"Name cannot be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//场景C：Lambda表达式</span></span><br><span class="line"><span class="function">DateTime <span class="title">ToDateTime</span>(<span class="params">IFormatProvider provider</span>)</span> =&gt;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidCastException(<span class="string">"Conversion to a DateTime is not supported."</span>);</span><br></pre></td></tr></table></figure><p>以上，就是 C# 7.0 中我个人比较喜欢的语法特性。需要了解所有 C# 7.0 语法特性的小伙伴们，则可以参考这里：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-7" target="_blank" rel="noopener">C# 7.0 - C# 7.3 中的新增功能</a>。</p><h2 id="C-8-0"><a href="#C-8-0" class="headerlink" title="C# 8.0"></a>C# 8.0</h2><p>在 C# 8.0 中，我个人比较喜欢的特性主要有以下几个：<strong>默认接口方法</strong>、<strong>异步流</strong>、<strong>索引和范围</strong>。</p><h3 id="默认接口方法"><a href="#默认接口方法" class="headerlink" title="默认接口方法"></a>默认接口方法</h3><p>关于这个，我觉得有点多此一举，如果一定要有一个默认行为，那你用继承来实现不就好啦，接口本来就是用来实现的啊摔！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChineseSayHello</span> : <span class="title">ISayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Who &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> DefaultPersopn = <span class="string">"Anumouse"</span>;</span><br><span class="line">    <span class="keyword">string</span> Who &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Who = DefaultPersopn;</span><br><span class="line">         Console.WriteLine(<span class="string">$"Hello, <span class="subst">&#123;Who&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子里，<code>ChineseSayHello</code>没有实现<code>SayHello()</code>方法不影响编译，因为<code>ISayHello</code>有默认实现，可正因为如此，<code>SayHello()</code>方法属于<code>ISayHello</code>，不属于<code>ChineseSayHello</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，可以编译</span></span><br><span class="line"><span class="keyword">var</span> sayHello = <span class="keyword">new</span> ChineseSayHello() <span class="keyword">as</span> ISayHello;</span><br><span class="line">sayHello.SayHello();</span><br><span class="line"><span class="comment">//错误，无法编译</span></span><br><span class="line"> <span class="keyword">var</span> sayHello = <span class="keyword">new</span> ChineseSayHello();</span><br><span class="line">sayHello.SayHello();</span><br></pre></td></tr></table></figure><h3 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h3><p>该特性可以看作是<code>IEnumerable&lt;T&gt;</code>的一个延伸，即<code>IAsyncEnumerable&lt;T&gt;</code>，主要有下面三个属性：</p><ul><li>它是用 async 修饰符声明的。</li><li>它将返回 IAsyncEnumerable<T>。</li><li>该方法包含用于在异步流中返回连续元素的 <code>yield return</code> 语句。</li></ul><p>下面是一个来自微软官方的基本示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成异步流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> System.Collections.Generic.<span class="function">IAsyncEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GenerateSequence</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举异步流</span></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> number <span class="keyword">in</span> <span class="title">GenerateSequence</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和异步流相关的一个概念是：异步可释放，即 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iasyncdisposable" target="_blank" rel="noopener">System.IAsyncDisposable</a>，这个可以参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/garbage-collection/implementing-disposeasync" target="_blank" rel="noopener">实现 DisposeAsync 方法</a>。</p><h3 id="索引和范围"><a href="#索引和范围" class="headerlink" title="索引和范围"></a>索引和范围</h3><p>关于这个，我们换一种说法，可能大家就能接受啦！是什么呢？答案是：切片。切片语法博主经常在 Python 中使用，想不到有生之年居然可以在 C# 里用到这个语法。不过，这个语法糖怎么看都不甜啊，因为没那味儿！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">// index from start index from end</span></span><br><span class="line">    <span class="string">"The"</span>, <span class="comment">// 0 ^9</span></span><br><span class="line">    <span class="string">"quick"</span>, <span class="comment">// 1 ^8</span></span><br><span class="line">    <span class="string">"brown"</span>, <span class="comment">// 2 ^7</span></span><br><span class="line">    <span class="string">"fox"</span>, <span class="comment">// 3 ^6</span></span><br><span class="line">    <span class="string">"jumped"</span>, <span class="comment">// 4 ^5</span></span><br><span class="line">    <span class="string">"over"</span>, <span class="comment">// 5 ^4</span></span><br><span class="line">    <span class="string">"the"</span>, <span class="comment">// 6 ^3</span></span><br><span class="line">    <span class="string">"lazy"</span>, <span class="comment">// 7 ^2</span></span><br><span class="line">    <span class="string">"dog"</span> <span class="comment">// 8 ^1</span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//取最后一个元素</span></span><br><span class="line">Console.WriteLine(<span class="string">$"The last word is <span class="subst">&#123;words[^<span class="number">1</span>]&#125;</span>"</span>);</span><br><span class="line"><span class="comment">//获取第一个元素到第三个元素</span></span><br><span class="line"><span class="keyword">var</span> quickBrownFox = words[<span class="number">1.</span><span class="number">.4</span>];</span><br><span class="line"><span class="comment">//获取倒数第一个元素到倒数第二个元素</span></span><br><span class="line"><span class="keyword">var</span> lazyDog = words[^<span class="number">2.</span>.^<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取全部元素</span></span><br><span class="line"><span class="keyword">var</span> all = words[..];</span><br><span class="line"><span class="comment">//获取开始到第三个元素</span></span><br><span class="line"><span class="keyword">var</span> firstPhrase = words[.<span class="number">.4</span>];</span><br><span class="line"><span class="comment">//获取结束到倒数第二个元素</span></span><br><span class="line"><span class="keyword">var</span> lastPhrase = words[<span class="number">6.</span>.];</span><br></pre></td></tr></table></figure><p>看起来这些东西在 Python 里都有啊，到底是哪里除了问题呢？我觉得更多的是符号上的不同吧， <code>^</code> 这个符号除了表示指数的意思以外，还有按位进行异或运算的意思，所以，这个语法糖加进来以后就会显得相当混乱，而 <code>..</code> 这个符号显然没有 <code>:</code> 写起来方便啊，所以，虽然 C# 从 C# 8.0 开始有了切片语法，可这不是我想要的切片语法啊！</p><p>以上，就是 C# 8.0 中我个人比较喜欢的语法特性。需要了解所有 C# 8.0 语法特性的小伙伴们，则可以参考这里：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-8" target="_blank" rel="noopener">C# 8.0 中的新增功能</a>。</p><h2 id="C-9-0"><a href="#C-9-0" class="headerlink" title="C# 9.0"></a>C# 9.0</h2><p>在 C# 9.0 中，我个人比较喜欢的特性主要有以下几个：<strong>Record</strong>、<strong>顶级语句</strong>、<strong>模式匹配增强</strong>。</p><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p><code>record</code> 是 C# 9.0 中提供的一个新的关键字，地位上等同于 <code>class</code> 和 <code>struct</code>，中文翻译为：记录类型。这是一种引用类型，它提供合成方法来提供值语义，从而实现相等性。 默认情况下，记录是不可变的。简而言之，<code>record</code> 是不可变的引用类型。你可能会说，我们为什么要搞这么一个类型出来呢？难道 <code>class</code> 不香吗？</p><p>我觉得如果要回答这个问题，可以借鉴 <code>DDD</code> 中的<code>实体</code> 和 <code>值对象</code>这两个概念。<code>实体</code> 通常都有一个唯一的标识并且在整个生命周期中具有连续性，这一类角色通过 <code>class</code> 来实现一直都工作得很好。例如，每一个 <code>User</code> 都会有一个唯一的<code>UserId</code> ，我们使用 <code>UserId</code> 来判断其相等性。而 <code>值对象</code> 则是指那些没有唯一的标识、不可变的、通过属性来判断相等性。例如，我们有一个地址 <code>Address</code>，它由省、市、区、县和详细地址组成，那么，问题来了，如果两个 <code>Address</code> 的省、市、区、县和详细地址都相同，这两个 <code>Address</code> 是不是同一个地址呢？常识告诉我们：不会，因为它们是不同的实例。</p><p>这就是 <code>record</code> 出现的原因，对于上面的这个问题，我们可以来解决：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">record Address</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Province &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> District &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> County &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr1 = <span class="keyword">new</span> Address() &#123; Province = <span class="string">"陕西省"</span>, City = <span class="string">"西安市"</span>, District = <span class="string">"雁塔区"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> addr2 = <span class="keyword">new</span> Address() &#123; Province = <span class="string">"陕西省"</span>, City = <span class="string">"西安市"</span>, District = <span class="string">"雁塔区"</span> &#125;;</span><br><span class="line">Console.WriteLine(<span class="string">$"addr1 == addr2：<span class="subst">&#123;addr1 == addr2&#125;</span>"</span>);</span><br></pre></td></tr></table></figure><p>想想以前我们是怎么做的呢？是不是要写类似下面这样的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (addr1.Province == addr2.Province &amp;&amp; addr1.City == addr2.City) &#123;</span><br><span class="line">    <span class="comment">//属性太多啦，我就不一个一个地比较啦，懂得都懂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这就是 <code>record</code> 存在的意义。除此之外呢，这个关键字更多的是语法层面上的，实际上从编译出来的 IL 来看，它本质上依然是一个类，并且它是不可变的。定义记录类型时，编译器会合成其他几种方法：</p><ul><li>基于值的相等性比较方法</li><li>替代 GetHashCode()</li><li>复制和克隆成员</li><li>PrintMembers 和 ToString()</li></ul><p>那么，你可能还会有疑问，假如我定义了两个不同的记录类型，它们都拥有相同的属性成员，如果按值相等来判断的话，岂不是这两个不同的记录类型变成相同的了？这么重要的问题，微软怎么可能没有想到呢？编译器会合成一个 <code>EqualityContract</code> 属性，该属性返回与记录类型匹配的 <code>Type</code> 对象。在这里，微软再一次发挥了<code>元组</code>的威力，对于上面定义的地址，我们可以继续使用解构语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(province, city, district, county) = addr1;</span><br></pre></td></tr></table></figure><p>当然，我相信哪怕到2090年，这个世界上依然会有“<strong>杠精</strong>”：你说这玩意儿不能变？我就想变怎么办？答案是使用<code>with</code>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> record Person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastName &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FirstName &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="keyword">string</span> first, <span class="keyword">string</span> last</span>)</span> =&gt; (FirstName, LastName) = (first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Bill"</span>, <span class="string">"Wagner"</span>);</span><br><span class="line">Person brother = person with &#123; FirstName = <span class="string">"Paul"</span> &#125;; <span class="comment">// 修改FirstName的副本</span></span><br><span class="line">Person clone = person with &#123; &#125;; <span class="comment">// 空集副本</span></span><br></pre></td></tr></table></figure><p>好了，关于记录类型就先为大家介绍到这里，更详细的说明可以参考这里：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/tutorials/exploration/records" target="_blank" rel="noopener">使用记录类型</a>。</p><h3 id="顶级语句"><a href="#顶级语句" class="headerlink" title="顶级语句"></a>顶级语句</h3><p>顶级语句，这个又是一个听起来非常模糊的概念对不对？ 大家可以看一下这篇文章：<a href="https://www.runoob.com/w3cnote/write-hello-world-program-26-different-programming-languages.html" target="_blank" rel="noopener">26 种不同的编程语言的 “Hello World” 程序</a>。怎么样，在众多解释型的语言中，C#、Java 甚至 C++ 的 “<strong>Hello World</strong>” 是不是都看起来有一点臃肿？</p><p>好了，现在可以梦想成真啦！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><p>如果觉得这样还显得臃肿，可以省略 <code>using</code> 部分：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><p>当然啦，一个项目里显然只能有一个文件可以使用顶级语句，你可以理解为这些代码运行在一个看不见的<code>Main()</code>方法中，而<code>Main()</code>方法显然只能有一个，相比下来，Python 就自由多啦，不过<code>if __name__ == &#39;__main__&#39;</code>的老梗就不再这里展开啦！</p><h3 id="模式匹配增强"><a href="#模式匹配增强" class="headerlink" title="模式匹配增强"></a>模式匹配增强</h3><p>感觉微软在模式匹配的道路上越走越远啊，说好的语法糖呢？这简直是毒药，7.0 里面眼花缭乱的<code>switch</code>都还没学会呢！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsLetter</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">char</span> c</span>)</span> =&gt;</span><br><span class="line">    c <span class="keyword">is</span> &gt;= <span class="string">'a'</span> and &lt;= <span class="string">'z'</span> or &gt;= <span class="string">'A'</span> and &lt;= <span class="string">'Z'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsLetterOrSeparator</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">char</span> c</span>)</span> =&gt;</span><br><span class="line">    <span class="function">c <span class="title">is</span> (<span class="params">&gt;= <span class="string">'a'</span> and &lt;= <span class="string">'z'</span></span>) <span class="title">or</span> (<span class="params">&gt;= <span class="string">'A'</span> and &lt;= <span class="string">'Z'</span></span>) or '.' or ','</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">is</span> not <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就是 C# 9.0 中我个人比较喜欢的语法特性。需要了解所有 C# 9.0 语法特性的小伙伴们，则可以参考这里：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-9" target="_blank" rel="noopener">C# 9.0 中的新增功能</a>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history" target="_blank" rel="noopener">C# 发展历史</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-7" target="_blank" rel="noopener">C# 7.0 - C# 7.3 中的新增功能</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-8" target="_blank" rel="noopener">C# 8.0 中的新增功能</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-9" target="_blank" rel="noopener">C# 9.0 中的新增功能</a></li><li><a href="https://www.cnblogs.com/MingsonZheng/p/11273700.html" target="_blank" rel="noopener">C# 版本与 .NET 版本对应关系以及各版本的特性</a></li><li><a href="https://www.cnblogs.com/microsoft-zyl/p/9093748.html" target="_blank" rel="noopener">C# 语言历史版本特性（C# 1.0到C# 8.0汇总）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="总结" scheme="https://qinyuanpei.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="CSharp" scheme="https://qinyuanpei.github.io/tags/CSharp/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="语言" scheme="https://qinyuanpei.github.io/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>通过Python分析2020年全年微博热搜数据</title>
    <link href="https://qinyuanpei.github.io/posts/2758545080/"/>
    <id>https://qinyuanpei.github.io/posts/2758545080/</id>
    <published>2021-01-24T22:36:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>几天前， <a href="https://www.cnblogs.com/catcher1994" target="_blank" rel="noopener">Catcher Wong</a> 大佬告诉我，他终于写完了2020年的年终总结。在看完大佬的年终总结以后，我有一种“<strong>前浪被后浪拍死在沙滩上</strong>”的感觉，正如当学生时都看“<strong>别人家的孩子</strong>”，工作以后看的都是“<strong>别人的年终总结</strong>”。我们的生活，其实就是由“<strong>别人</strong>”和“<strong>我们</strong>”交织在一起，而更多的时候，是成为“<strong>大多数</strong>”的“<strong>我们</strong>”，去关注成为“<strong>少数</strong>”的“<strong>别人</strong>”。我想说的是，世间万物互为装饰，就像卞之琳在《断章》里写道，“<strong>明月装饰了你的窗子，你装饰了别人的梦</strong>”。<strong>即便一个人在历史长河中，尤如一叶飘泊不定的孤舟在波涛中摇荡，可每一朵浪花都曾以自己的方式美丽过</strong>，所以，看“别人”的生活，联想“我们”的生活，这便是我同2020告别的一种方式，为此，博主决定抓取2020年全年366天的微博热搜，通过可视化的方式来串联起2020年的回忆。</p><h1 id="热搜抓取"><a href="#热搜抓取" class="headerlink" title="热搜抓取"></a>热搜抓取</h1><p>首先，我们来考虑微博热搜的数据来源。 <a href="https://weibo.com/" target="_blank" rel="noopener">微博</a> 官方提供了一个热搜排行榜的页面：<a href="https://s.weibo.com/top/summary" target="_blank" rel="noopener">https://s.weibo.com/top/summary</a>，可惜这个网站只支持查看当天的热搜，显然这无法满足我们的需求。在搜索引擎的帮助下，找到了两个网站，它们分别是：<a href="https://www.weibotop.cn/" target="_blank" rel="noopener">微博时光机</a> 和 <a href="https://www.enlightent.cn/research/rank/weiboSearchRank" target="_blank" rel="noopener">热搜神器</a>。经过一番权衡，决定选择页面结构更简单一点的 <a href="https://www.weibotop.cn/" target="_blank" rel="noopener">微博时光机</a> 。</p><p>通过抓包，可以快速获得两个关键的接口，它们分别是 <a href="https://www.weibotop.cn/apis/androidrouter/?versioncode=1&=&data=WyJnZXRjbG9zZXN0dGltZSIsWyIyMDIxLTAxLTIwVDIzOjA4OjAyIl1d" target="_blank" rel="noopener">获取timeId接口</a> 和 <a href="https://www.eecso.com/test/weibo/apis/currentitems.php?timeid=326021" target="_blank" rel="noopener">获取历史热搜接口</a>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/22/1pFhJkgodvP5U3G.png" alt="Firefox抓包示意图" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">Firefox抓包示意图</div>            </figure><p>简单来说，我们指定一个日期，第一个接口会返回<code>timeId</code>。接下来，通过这个<code>timeId</code>调用第二个接口就可以获得热搜数据。仔细观察的话，第一个接口传递的<code>data</code>参数像是一个<code>BASE64</code>加密后的结果，尝试解密后发现我的猜想是对的，加密前的内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"getclosesttime"</span>,[<span class="string">"2021-01-20T23:08:02"</span>]]</span><br></pre></td></tr></table></figure><p>这意味着我们只需要改变这里的日期就可以啦，因此，我们的思路无非就是从2020年1月1日开始，依次请求热搜接口获取数据，直到2020年12月31日。这里想顺便吐槽下这个网站的接口设计，居然清一色地全部用数组来返回结果，难道是为了省掉这几个字段来节省流量吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/22/G9x8LiybNanBVg2.png" alt="接口返回值说明-1" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">接口返回值说明-1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/22/zamj3Fntp9kbQws.png" alt="接口返回值说明-2" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">接口返回值说明-2</div>            </figure><p>吐槽归吐槽，这里我们可以非常容易地写出对应的代码，由于日期和<code>timeId</code>的对应关系是固定的，为了减少后续的请求数量，我们使用<code>MongoDB</code>来对数据进行持久化。同样地，抓取热搜采用了类似的方式，因为历史热搜同样是确定的数据，这里只给出关键的代码，<strong>并不代表你可以无脑地复制、粘贴</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获取指定日期对应的timeId</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_timeId</span><span class="params">(date, cookie)</span>:</span></span><br><span class="line">    cacheKey = date.strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">    records = list(store.find(TABLE_TIME_ID, &#123;<span class="string">'date'</span>: cacheKey&#125;))</span><br><span class="line">    <span class="keyword">if</span> len(records) &gt; <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">return</span> records[<span class="number">0</span>][<span class="string">'timeId'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = <span class="string">"[\"getclosesttime\",[\"&#123;d&#125;\"]]"</span>.format(d=cacheKey)</span><br><span class="line">        data = base64.b64encode(data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        url = <span class="string">'https://www.weibotop.cn/apis/androidrouter/?versioncode=1&amp;=&amp;data='</span> + str(data, <span class="string">'utf-8'</span>)</span><br><span class="line">        data = request(url, cookie)</span><br><span class="line">        timeId = json.loads(data)[<span class="number">0</span>]</span><br><span class="line">        store.insert(TABLE_TIME_ID, [&#123;<span class="string">'date'</span>: cacheKey, <span class="string">'timeId'</span>: timeId &#125;])</span><br><span class="line">        <span class="keyword">return</span> timeId</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定timeId对应的热搜</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weibo_trending</span><span class="params">(timeId, cookie)</span>:</span></span><br><span class="line">    records = list(store.find(TABLE_TRENDING, &#123;<span class="string">'timeId'</span>: timeId&#125;))</span><br><span class="line">    <span class="keyword">if</span> len(records) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> records</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = <span class="string">'https://www.eecso.com/test/weibo/apis/currentitems.php?timeid='</span> + timeId</span><br><span class="line">        data = request(url, cookie)</span><br><span class="line">        data = json.loads(data)</span><br><span class="line">        trendings = list(map(<span class="keyword">lambda</span> x:&#123;<span class="string">'title'</span>:x[<span class="number">0</span>], <span class="string">'createdDate'</span>:x[<span class="number">1</span>], <span class="string">'updatedDate'</span>:x[<span class="number">2</span>], <span class="string">'rank'</span>:int(x[<span class="number">3</span>])&#125;, data))</span><br><span class="line">        <span class="keyword">for</span> trending <span class="keyword">in</span> trendings:</span><br><span class="line">            trending[<span class="string">'timeId'</span>] = timeId</span><br><span class="line">            trending[<span class="string">'href'</span>] = <span class="string">'https://s.weibo.com/weibo?q='</span> + trending[<span class="string">'title'</span>]</span><br><span class="line">            trending[<span class="string">'createdDate'</span>] = datetime.datetime.strptime(trending[<span class="string">'createdDate'</span>], <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">            trending[<span class="string">'updatedDate'</span>] = datetime.datetime.strptime(trending[<span class="string">'updatedDate'</span>], <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">        store.insert(TABLE_TRENDING, trendings)</span><br><span class="line">        <span class="keyword">return</span> trendings</span><br></pre></td></tr></table></figure><p>至此，我们就完成了微博热搜数据的抓取工作！</p><h1 id="热搜分析"><a href="#热搜分析" class="headerlink" title="热搜分析"></a>热搜分析</h1><p>好了，在采集到这些热搜数据以后，我们就可以着手准备热搜数据的分析工作啦！其实，目前这份热搜数据挺简陋的，它只有热搜话题、上榜时间、更新时间以及话题热度这样四个关键字段。而作为辅助，我们增加了热搜话题的链接，如果后续需要更详尽的信息，可能需要从这里来寻找突破口。在今天这篇博客里，我们主要从下面四个维度来分析和挖掘2020年全年的微博热搜：</p><h2 id="全年热搜热度分析"><a href="#全年热搜热度分析" class="headerlink" title="全年热搜热度分析"></a>全年热搜热度分析</h2><p>首先，我们要分析的是全年热搜的热度。何谓热度呢？我个人认为，可以从话题的使用频率和话题的持续时间两个方面来考虑，即，一个话题转发或者参与的人越多，话题持续的时间越长，则认为该话题越“热”。例如罗翔老师说2020年进入了“<strong>全民网课</strong>”的时代，因为“网课”是一个热门话题，而当时的背景则是因为疫情原因无法上学(班)，一时间远程会议/办公/教育变得炙手可热。所以，分析全年的热搜热度，可以让我们去关注每个月都发生了什么事情，而这样，我们就有了和这个世界建立联系的思绪，想想当时的你在做什么，心里又作何感想，这会是一件非常有趣的事情：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/26/OvqeDkFz8IRnKbc.jpg" alt="2020全年微博热搜热度变化趋势" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">2020全年微博热搜热度变化趋势</div>            </figure><p>首先，我们看到的是：<strong>2020全年微博热搜热度变化趋势</strong>。通过这张图，我们可以注意到：在3月份左右国内疫情得到控制以后，大家都渐渐地回归到日常的工作和生活中，相应地，人们在社交媒体上的关注是逐渐下降的，直到7月份以后逐渐开始出现回升。我个人认为可能与下面这件事情有关，<strong>第一，是腾讯公司因为一份虚假合同而起诉老干妈的事件；第二、因为疫情而姗姗来迟的高考推迟到了7月7日和7月8日这两天；第三、张一山、宋妍霏、阚清子、宋茜等一众明星频频登上热搜榜。</strong>对于前两个因素，可以覆盖整个7月份的大多数时间段；对于第三个因素，更多的是从微博这样一个泛娱乐化的平台的属性去考虑，还有什么比吃明星的瓜更开心的事情吗？再往后，我们都知道，迎来了美国大选，不管这场大选闹出了多少风波，此时此刻，终于尘埃落定。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/26/A2gsuvdGqCylpoP.jpg" alt="2020全年微博热搜数量变化趋势" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">2020全年微博热搜数量变化趋势</div>            </figure><p>接下来，我们看到的是：2020全年微博热搜数量变化趋势。通过这张图，我们可以注意到：热搜数量的变化趋势整体上是吻合热搜热度的变化趋势的，两者的“<strong>低谷</strong>”都出现在7月份，不同的是热搜数量的变化要更为“<strong>缓和</strong>”一点，这可能和新浪微博的热搜榜单有一定的关系，不知道是不是因为微博的推荐算法，决定了每个月“<strong>吃瓜</strong>”的次数是差不多的，可如果没有算法来约束这一切，完全由用户及其粉丝自行主导，这会不会演变成现实版的美国大选呢？我特别心疼那位新浪微博的研发小哥<a href="https://weibo.com/u/2006147847" target="_blank" rel="noopener">@丁振凯</a>，<strong>人生中三次遭遇热搜引发的“宕机”：结婚时撞上鹿晗公布恋情，海外度假时撞上双宋官宣、老婆待产撞上华晨宇承认和张碧晨未婚生有一女，简直永远都在扩容的路上</strong>，被誉为“<strong>史上最惨新浪程序员</strong>”一点都不冤枉啊……</p><h2 id="全年热搜情感分析"><a href="#全年热搜情感分析" class="headerlink" title="全年热搜情感分析"></a>全年热搜情感分析</h2><p>李诞在2020年年底策划了一期反跨年晚会，从头到尾都是脱口秀这种“语言类”节目，在这期节目里，有人以毛不易的“歌词”调侃了2020年大家的心境变化，从“<strong>像我这样优秀的人</strong>”到“<strong>消愁</strong>”，有时候打脸就是这么的猝不及防。坦白来说，我有段时间过得特别“<strong>丧</strong>”，“<strong>丧</strong>”到要靠《当幸福来敲门》来打鸡血。那么，整个2020年“<strong>活</strong>”在热搜里的人们的心态变化又是怎么样的呢？所以，接下来我们通过 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 对2020年全年的热搜话题的情感倾向进行分析，到底大家是过得“<strong>积极</strong>”还是“<strong>消极</strong>”呢，让我们一起拭目以待，为了达到更好的效果，博主提前对 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 进行了训练，因为 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 自带的语料库主要是电商评论，与我们此刻的场景多少有一点差异。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/26/gCcHX7vWlwsZhnI.jpg" alt="2020全年微博热搜情感变化趋势" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">2020全年微博热搜情感变化趋势</div>            </figure><p>果然，2020年真的是“<strong>丧</strong>”到家啦，366天里平均置信概率在0.5以上的堪称寥寥啊。我有时候会想，我们常常希望在感情中有足够的安全感，希望对方可以“懂”我。诚然，我可以从一个人的朋友圈、微博去分析对方的情感变化，可身为人类的我们，并不是冷冰冰的计算机器。多年后，当我懊恼于曾经没有进行及时的沟通的时候，我静静地坐在电脑面前，你说这些字里行间没有透露出足够充足地信息，可我们依然有办法去反映过去一年里的喜怒哀乐。世事无常，每天都开开心心地面对，固然是心向往之，而生命中更朴实无华地大多数时刻，其实就是此刻如白开水一般索然无味，如果理性的思维最终还是要输给感性的直觉，我希望我可以两者兼有之，今年可能要在外地一个人度过春节啦，希望我的心情可以超过0.5呢……</p><h2 id="全年热搜词云分析"><a href="#全年热搜词云分析" class="headerlink" title="全年热搜词云分析"></a>全年热搜词云分析</h2><p>其实，在做这个分析的时候，我一直在想，也许“<strong>新冠</strong>”或者“<strong>疫情</strong>”这样的字眼会成为2020年的共同记忆吧！至少对博主这样即将步入中年的90后而言，这场疫情留下的深刻记忆丝毫不亚于08年的汶川地震。可转念间又安慰自己道，相比国外愈演愈烈的疫情，我们在三月份左右的时候就基本得到了控制，如果说互联网是没有记忆的，人们对这一切应该会遗忘地非常快，就像这热搜榜上的话题，简直是“你方唱罢我登场”。可惜，互联网的确是有记忆的，即使过去了整整一年，这一切还是通过数据被挖掘出来。这里，我们通过结巴分词对热搜话题进行分词，再通过这些关键词来绘制词云。对于这个结果，突然就变得感性起来，可能这就是所谓的“冥冥之中自有天意”吧，甚至对于2021年来说，<strong>疫情</strong>目前依然是人们关注的热搜话题：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/22/dTVD9lNIP4OwefC.png" alt="2020年全年微博热搜关键词词云" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">2020年全年微博热搜关键词词云</div>            </figure><h2 id="全年热搜人物分析"><a href="#全年热搜人物分析" class="headerlink" title="全年热搜人物分析"></a>全年热搜人物分析</h2><p>曾经在知乎上读到过这样一句话，“<strong>人们宁愿去关心一个蹩脚电影演员的吃喝拉撒和鸡毛蒜皮，而不愿了解一个普通人波涛汹涌的内心世界</strong>”，这句话如果放到2020年的语境中，或许就是，人们在危难的时候会突然关心“<strong>国士无双</strong>”，而在安稳的时候则会更关注“<strong>娱乐八卦</strong>”，考虑到新浪微博是借鉴新浪博客的“名人效应”而起家，所以，我更关心在过去一年里有哪些人都登上过热搜。说实话，我挺怀念某位七十多岁高龄的老人，他和我奶奶差不多同龄，在这个“丧”如此普遍的年代，他带给了我们多少欢乐啊，虽然我预感到会有许多明星靠着“<strong>否认</strong>”、“<strong>道歉</strong>”、“<strong>心疼</strong>”、“<strong>回应</strong>”、“<strong>声明</strong>”等等字眼而登上热搜，可我还是想知道答案啊……</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/25/ZV2zgo7Ssi6XFL8.png" alt="2020全年微博热搜上榜人物分析.png" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">2020全年微博热搜上榜人物分析.png</div>            </figure><p>果然，“<strong>说曹操曹操到</strong>”，2020年以压倒性优势多次登上微博热搜的，居然真的是前美国总统特朗普。虽然说这位美国前总统喜欢孜孜不倦地发推特，史称“<strong>推特治国</strong>”，可在一个某明星代孕风波快速令“<strong>拼夕夕</strong>”事件烟消云散的社交平台上，这位老人能频频进入我们的视野，大概就能说明过去一年里国际形势的风起云涌。我们嘲笑他为“懂王”，甚至“亲切”地称之为“川建国”同志。<strong>有一段时间里，好像每一个人都觉得自己比这位老人更会做总统；同样地，好像每一个人都觉得自己比张小龙更懂得微信</strong>。我无意讨论政治相关的东西，可我依然感谢这位老人在疫情期间带给我们的欢乐，因为我并不觉得，他像媒体眼中的那样滑稽而愚蠢，一个能在商人、明星和总统多重身份中切换自如的人，无论如何会都有他的过人之处，疫情这件事情，换一个人来当这个总统未必会做得比他好。回过头来看，他在2020年都做了哪些事情呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/25/9FL8ZMc6blYjy5u.png" alt="2020年特朗普的微博热搜" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">2020年特朗普的微博热搜</div>            </figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>其实，在规划这篇博客的时候，我一直在想，该以一种什么样的心态去回顾2020，因为当我看着“<strong>别人</strong>”的年终总结的时候，总有一种难以言说的失落感。一方面，时间在不经意间匆匆逝去，身边的一切都在刻意地想你强调着“<strong>物是人非</strong>”。而另一方面，你需要去面对诸如买房、结婚这种所谓“<strong>某某年龄应该去做的事情</strong>”。当我看到身边的同事，整天坐在一起讨论的无外乎是房子、车子、股票等一切所谓“投资”的事情的时候，我时而会觉得他们有一点枯燥，就是那种我们曾经都不愿意成为的“中年人”。等翻过年，我即将迎来我的29岁，可令人心动的Offer里的“<strong>背水辉</strong>”一样的被嫌弃的年纪，而距离IT行业所谓的“<strong>35岁</strong>”门槛还剩下年时间。</p><p>虽然给自己订了几个目标，可有时候难免会感到懈怠，尤其是当你意识到你再无法抓住某一样东西的时候，或许，你唯一的能做的事情，就是让自己永远不要忘记吧！写数据挖掘相关的内容，不管是在数据的抓取还是分析阶段，都需要投入大量的精力去试验，结合实际去调整写作的方向，在这篇博客中甚至还花了大量时间去训练 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a>。“<strong>悟已往之不谏，知来者之可追</strong>”，2021年flag我在心里记下来，我不想写出来，因为我怕到时候脸会疼，如果大家觉得这篇博客对你有帮助，欢迎<strong>点赞</strong>和<strong>收藏</strong>，如果可以<strong>一键三连</strong>，那就更好啦！2020，再见！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="可视化" scheme="https://qinyuanpei.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="微博" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E5%8D%9A/"/>
    
      <category term="热搜" scheme="https://qinyuanpei.github.io/tags/%E7%83%AD%E6%90%9C/"/>
    
  </entry>
  
  <entry>
    <title>基于 Python 和 Selenium 实现 CSDN 一键三连自动化</title>
    <link href="https://qinyuanpei.github.io/posts/3148958651/"/>
    <id>https://qinyuanpei.github.io/posts/3148958651/</id>
    <published>2021-01-19T22:35:47.000Z</published>
    <updated>2021-05-28T02:08:18.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>最近一段时间，博主感觉到了某种危机感，或者说是每一个不再年轻的人都会面对的问题，即，怎么面对来自更年轻的“后浪”们的压力，自打国内IT行业有了35岁这个不成文的“门槛”以后，年轻的“后浪”们仿佛有了更多将“前浪”们拍死在岸上的勇气，我辈忍不住要叹一声后生可畏啊！我认识的 <a href="https://www.cnblogs.com/catcher1994" target="_blank" rel="noopener">Catcher Wong</a> 正是这样一位大佬，此君虽然比我小三岁，可在技术的广/深度以及经验的丰富程度上，足以令我这个”老人”汗颜，单单 <a href="https://github.com/dotnetcore/EasyCaching" target="_blank" rel="noopener">EasyCaching</a> 这一项，就令人望尘莫及啦！我看着他的时候，一如当年 Wesley 大哥看着我的时候，可能这就是某种轮回，姑且执浊酒一杯，致我们终将老去的青春。</p><h1 id="不正经的Kimol君"><a href="#不正经的Kimol君" class="headerlink" title="不正经的Kimol君"></a>不正经的Kimol君</h1><p>关注<a href="https://blog.csdn.net/kimol_justdo" target="_blank" rel="noopener">Kimol君</a>，最早源于他在我博客里留言，作为礼尚往来，我回访了他的博客，然后发现此人人如其名，非常的”不正经”，他的博客访问量出奇地高，在CSDN里写博客多年，深知现在不比从前有运营梦鸽和大白两位小姐姐帮忙推荐到首页，普通的内容很少有机会拥有这样的曝光机会，而像 <a href="https://blog.csdn.net/guolin_blog" target="_blank" rel="noopener">郭霖</a> 这种从 10 年前后开始写移动开发系列博客的“大神”或者是以图形学为主要写作方向的 <a href="https://qianmo.blog.csdn.net/" target="_blank" rel="noopener">诗人“浅墨”</a> ，在通篇都是干货的情况下，长期保持着不错的人气。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/23/hEfkz6xBpildT4o.jpg" alt="这萌萌哒求赞的表情我是做不来的" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">这萌萌哒求赞的表情我是做不来的</div>            </figure><p>起初，我以为此君的流量来自于标题党，譬如<a href="https://blog.csdn.net/kimol_justdo/article/details/108912073" target="_blank" rel="noopener">《学会这招，小姐姐看你的眼神将不一样》</a> 和 <a href="https://blog.csdn.net/kimol_justdo/article/details/110152915" target="_blank" rel="noopener"> 《震惊！小伙竟然用Python找出了马大师视频中的名场面》</a>这几篇，非常像UC编辑部和微信公众号的风格。我是一个擅长学习的人，主动去借鉴了他博客中的优点，比如尝试使用轻松、幽默的文风，在文章开头放入目录，适当“蹭”热点等等，我甚至专门致敬了一篇博客： <a href="https://qinyuanpei.blog.csdn.net/article/details/110713267" target="_blank" rel="noopener">《厉害了！打工人用Python分析西安市职位信息》</a>。而整个1月份，我就只有一篇博客流量高一点，就这还不是特别正经的”技术”博客，而此君的流量则是一个又一个的1w+ ，可我实在想不通，一个不到100行的Python脚本，真就值得花那么多的流量，真就值得上百条的评论吗？这里放张图大家感受一下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/23/lsB65XjhgY4nZeJ.png" alt="不知道该说什么好" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">不知道该说什么好</div>            </figure><p>仔细研究了他博客里评论的风格，发现有大量类似“夸夸群”风格的评论，就是那种读起来确实像对方读过了你的文章，可实际一想就觉得这是那种“放之四海而皆准”的话。我最近知道了一位大佬的博客，我惊奇地发现，此君居然在上面留过言，我顺着大佬的博客继续找，发现一个非常有意思的事情，此君曾经给我留言过的内容，居然出现在了别人的博客底下，而从这篇博客的评论里继续找，你会发现好像有一个团队专门在做这种事情，互相点赞、互相评论，甚至这些留言都是来自一篇博客都没有的”新人”，至此，基本可以断定，此君“不讲武德”，用作弊的方式在刷流量！当然，他自己都承认了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/23/7tHqCNkdceUFXxD.png" alt="作弊实锤" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">作弊实锤</div>            </figure><h1 id="年轻人不讲”武德”"><a href="#年轻人不讲”武德”" class="headerlink" title="年轻人不讲”武德”"></a>年轻人不讲”武德”</h1><p>OK，既然现在的年轻人都把心思用到这种事情上，作为一个老年人，必须要让他知道什么叫“耗子尾汁”，我们技术做一点正经事儿不行吗？其实，博客园的博客质量相比 CSDN 是要高出许多的，而正因为如此，CSDN 在全力转在线教育/课程以后，博客这个板块就再无往日的“生气”，如果每个人都像他一样，天天跑别人底下刷评论，发一点不痛不痒的话，甚至是推广某个小圈子里的QQ群，那真正优质的内容又如何能被大家看到呢？博主曾经加过这样的QQ群，你以为是交流技术的群吗？其实是为了推广某个Python 课程，博主本想交流一下<a href="https://qinyuanpei.blog.csdn.net/article/details/110977903" target="_blank" rel="noopener">“半泽直树”</a>，然后就被群管理员给删除了！此君大概是抓取Python 板块排名靠前的博客，通过程序来刷存在感。</p><p>对此，我想说，这玩意儿用 Selenium + Python 简直和闹着玩一样，毕竟在了解网页结构以后，直接上 jQuery 操作 DOM 即可，甚至连抓包都不需要，不信你看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> fake_useragent</span><br><span class="line"><span class="keyword">import</span> os, json, time, random</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, profile)</span>:</span></span><br><span class="line">        os.environ[<span class="string">'TEMPDIR'</span>] = os.path.join(os.path.abspath(<span class="string">'.'</span>), <span class="string">'profile'</span>)</span><br><span class="line">        firefoxProfile = webdriver.FirefoxProfile(profile) </span><br><span class="line">        fireFoxOptions = webdriver.FirefoxOptions()</span><br><span class="line">        self.driver = webdriver.Firefox(</span><br><span class="line">            firefox_options=fireFoxOptions, </span><br><span class="line">            firefox_profile=firefoxProfile</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 批量点赞</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行点赞</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            flag = self.driver.execute_script(<span class="string">"return $('#is-like-span').text().trim()"</span>) == <span class="string">"已赞"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                self.driver.execute_script(<span class="string">"$('#is-like-span').click()"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量收藏</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行收藏</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            flag = self.driver.execute_script(<span class="string">"return $('#is-collection').text()"</span>) == <span class="string">"已收藏"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                self.driver.execute_script(<span class="string">"$('#is-collection').click()"</span>)</span><br><span class="line">                self.driver.execute_script(<span class="string">"$('.csdn-collection-submit').click()"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量关注</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">follow</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行关注</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            flag = <span class="string">'已关注'</span> <span class="keyword">in</span> self.driver.execute_script(</span><br><span class="line">                <span class="string">"return $($('.toolbox-list').children()[6]).find('a').text().trim()"</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                self.driver.execute_script(<span class="string">"$($('.toolbox-list').children()[6]).find('a').click()"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量一键三连</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iloveyuou</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行三连</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            self.driver.execute_script(<span class="string">"$($('.toolbox-list').children()[7]).find('p').click()"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量留言</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">comment</span><span class="params">(self, urls, texts)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行评论</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            text = random.choice(texts)</span><br><span class="line">            self.driver.execute_script(<span class="string">f"$('#comment_content').text('<span class="subst">&#123;text&#125;</span>')"</span>)</span><br><span class="line">            self.driver.execute_script(<span class="string">f"$('.btn-comment').click()"</span>)</span><br><span class="line">            <span class="comment"># CSDN对评论间隔有要求，那就再睡一会儿</span></span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 热门文章</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hotRank</span><span class="params">(self, channel)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        抓取某个话题下的热门文章</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        url = <span class="string">f'https://blog.csdn.net/phoenix/web/blog/hotRank?page=0&amp;pageSize=25&amp;child_channel=<span class="subst">&#123;channel&#125;</span>'</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0'</span>,</span><br><span class="line">            <span class="string">'Cookie'</span>:<span class="string">'uuid_tt_dd=10_220300310-1611402514139-727015; dc_session_id=10_1611402514139.129755; dc_sid=37a633fe075b2698beeae6fb9c306fb4'</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        response.raise_for_status()</span><br><span class="line">        data = json.loads(response.text)</span><br><span class="line">        <span class="keyword">if</span> (data[<span class="string">'code'</span>] == <span class="number">200</span> <span class="keyword">and</span> data[<span class="string">'message'</span>] == <span class="string">'success'</span>):</span><br><span class="line">            <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x:x[<span class="string">'articleDetailUrl'</span>], data[<span class="string">'data'</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>我们都知道，在通常情况下，Selenium 每次运行时都会打开一个浏览器， 可这个浏览器呢，相对于我们平时使用的浏览器来说是“独立”的，因为细心的朋友一定会发现，虽然我们在 <code>Chrome</code> 或者 <code>Firefox</code> 中早已登录过了某个网站，可此时此刻，当 Selenium 启动浏览器窗口的时候，我们发现这个网站依然是需要登录的。为什么要讨论这个问题呢？因为如果我们希望对 CSDN 实现“一键三连”，登录这一步是必不可少的步骤。那么，有没有一种办法，可以让 Selenium 共享我们本地浏览器中的 Cookie 信息呢？因为只要有了Cookie，我们就可以专注于实现“一键三连”这部分。相信大家都看过上面的代码啦，答案当然是有的，我们为其指定一个配置文件的路径即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 Firefox 配置文件</span></span><br><span class="line"><span class="comment"># 默认路径：C:\\Users\\&lt;User&gt;\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\XXXX.default</span></span><br><span class="line"><span class="comment"># 参考链接：https://support.mozilla.org/zh-CN/kb/用户配置文件</span></span><br><span class="line">profile_dir = <span class="string">'C:\\Users\\YuanPei\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\xypbnthd.default-release'</span></span><br><span class="line">firefoxProfile = webdriver.FirefoxProfile(profile_dir) </span><br><span class="line">fireFoxOptions = webdriver.FirefoxOptions()</span><br><span class="line">webdriver.Firefox(firefox_options=fireFoxOptions, firefox_profile=firefoxProfile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Chrome 配置文件</span></span><br><span class="line"><span class="comment"># 默认路径：C:\\Users\\&lt;User&gt;\\AppData\Local\Google\Chrome\User Data</span></span><br><span class="line">profile_dir = <span class="string">'C:\\Users\\YuanPei\\AppData\Local\Google\Chrome\User Data'</span></span><br><span class="line">chromeOptions = webdriver.ChromeOptions()  </span><br><span class="line">chromeOptions.add_argument(<span class="string">'user-data-dir='</span> + os.path.abspath(profile_dir))  </span><br><span class="line">webdriver.Chrome(chrome_options=chromeOptions)</span><br></pre></td></tr></table></figure><p>这样，Selenium 启动的就不再是一个“裸”的浏览器，我们平时使用的各种配置、插件等等都会被原封不动地加载到 Selenium 中，这其中同样了我们的 Cookie，所以，当大家看到我的代码的时候，会发现这里没有做任何登录相关的事情，这其实是在用“时间”换取技术实现的“简单”，因为要额外加载大量的信息，所以，Selenium 启动的时候会变得缓慢起来，经过博主自己测试，Firefox 启动大概需要1分钟左右，熬过这1分钟接下来就是坦途啦！</p><p>其实，除此以外，关于登录这个问题，我们还有一种方案是对Cookie进行持久化。简而言之，就是利用 Selenium 的<code>get_cookies()</code> 和 <code>add_cookie()</code> 这一组API，第一次打开某个网站的时候，首先人为地或者模拟登录，此时可以获得Cookie并对其进行序列化，而访问那些需要登陆的资源时，则可以对Cookie进行反序列化并将其加载到 Selenium 环境中，基本的代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存Cokie到本地文件</span></span><br><span class="line">cookies = driver.get_cookies()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"cookies.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">json.dump(cookies, fp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地文件加载Cookie</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"cookies.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">cookies = json.load(fp)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">driver.add_cookie(cookie)</span><br></pre></td></tr></table></figure><p>下面来做一个简单的演示， <a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a> 有一个类似微博热搜的 <a href="https://blog.csdn.net/rank/list" target="_blank" rel="noopener">博客榜单</a>。这里，我们会从中筛选前 5 的博客链接来进行“一键三连”操作。与此同时，博主选取了一部分这些年轻人们喜欢用的评论，就在刚刚，我在这篇博客 <a href="https://blog.csdn.net/m0_46405703/article/details/112912541" target="_blank" rel="noopener">《第十二届蓝桥杯模拟赛Python组（第一期）》</a> 下面再次发现 <a href="https://blog.csdn.net/kimol_justdo" target="_blank" rel="noopener">Kimol君</a> 的身影，年轻人你不讲武德啊！我就想起了《开讲啦》里面惹恼易中天教授的那位学生，一个人的文章写得好，大家愿意去读去看，这自然是好事，可正因为梦鸽和大白这些小姐姐们都不在了，这个社区的内容质量完全由点赞、评论、收藏数这些因素在左右着，作为一名博客作者，我更希望别人能真的在读完我的文章后，或者能找出我考虑不周的地方，或者可以就某一个问题深入讨论一番，我发现社区里都喜欢动辄加别人QQ或者微信，可如果这种毫无意义地灌水的评论，这一切又有什么意义呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你经常收到这些评论，千万不要“飘”</span></span><br><span class="line"><span class="comment"># 你觉得这些话都是真心的吗？</span></span><br><span class="line">comments = [</span><br><span class="line">    <span class="string">'代码之路任重道远，愿跟博主努力习之。'</span>,</span><br><span class="line">    <span class="string">'学起来，头秃的那种~'</span>,</span><br><span class="line">    <span class="string">'写的太好了，很实用'</span>,</span><br><span class="line">    <span class="string">'好文！希望博主以后多多分享哈！'</span>,</span><br><span class="line">    <span class="string">'哇，好棒啊，崇拜的小眼神，欢迎回赞，回评哦~~~'</span>,</span><br><span class="line">    <span class="string">'收藏从未停止，学习从未开始。'</span>,</span><br><span class="line">    <span class="string">'大佬，看了您的文章，内心的仰慕之情油然而生，赶紧给大佬点个赞！'</span>,</span><br><span class="line">    <span class="string">'太赞了！666666'</span></span><br><span class="line">]</span><br><span class="line">proxy = Proxy(<span class="string">'C:\\Users\\YuanPei\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\xypbnthd.default-release'</span>)</span><br><span class="line"><span class="comment"># 热搜前5名的文章</span></span><br><span class="line">urls = proxy.hotRank(<span class="string">'python'</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 批量留言，刷存在感</span></span><br><span class="line">proxy.comment(urls, comments)</span><br><span class="line"><span class="comment"># 一键三连</span></span><br><span class="line">proxy.iloveyuou(urls)</span><br></pre></td></tr></table></figure><p>当然啦，像我这里提供的关于点赞(vote)、收藏(collect)、关注(follow)等等方法，同样是可以使用的，这里就不再一一例举啦！本身都是基于 <code>jQuery</code> 来操作DOM，理解上应该没有太大难度，虽然我不大喜欢用 <code>jQuery</code> 写业务代码，可对于爬虫这种事情，自然是越简单越好，因为我不想再去学一门操作 DOM 的语言：XPath， 而关于 Selenium 驱动的安装、配置等细节，可以参考博主的这篇文章：</p><p><a href="https://qinyuanpei.blog.csdn.net/article/details/111351111" target="_blank" rel="noopener">作为技术宅的我，是这样追鬼滅の刃的</a></p><p>博主最近新开了一个付费专栏：<a href="https://blog.csdn.net/qinyuanpei/category_7444699.html" target="_blank" rel="noopener">Python数据挖掘系列</a>，主要介绍关于爬虫、PyECharts、结巴分词、Pandas、Matplotlib、SnowNLP、OpenCV等数据挖掘相关内容，如果大家喜欢或者感兴趣，欢迎订阅。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区，就你对于这篇博客的想法或者意见进行讨论，再次谢谢大家！如果 <a href="https://blog.csdn.net/kimol_justdo" target="_blank" rel="noopener">Kimol君</a> 恰好读至此处，最好能一键三连，我权当作为你打广告的广告费啦，哈哈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://qinyuanpei.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="自动化" scheme="https://qinyuanpei.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Selenium" scheme="https://qinyuanpei.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>使用多线程为你的Python爬虫提速的N种姿势，你会几种？</title>
    <link href="https://qinyuanpei.github.io/posts/3247093203/"/>
    <id>https://qinyuanpei.github.io/posts/3247093203/</id>
    <published>2021-01-14T20:35:47.000Z</published>
    <updated>2021-05-28T02:08:18.587Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>最近博主在优化一个爬虫程序，它是博主在2017年左右刚接触 Python 时写下的一个程序。时过境迁，当 Python 2.X 终于寿终正寝成为过去，当博主终于一只脚迈进30岁的大门，一切都来得猝不及防，像一阵龙卷风裹挟着回忆呼啸而去。和大多数学习 Python 的人一样，博主学习 Python 是从写爬虫开始的，而这个爬虫程序刚好是那种抓取“宅男女神”的程序，下载图片无疑是整个流程里最关键的环节，所以，整个优化的核心，无外乎提升程序的稳定性、提高抓取速度。所以，接下来，我会带大家走近 Python 中的多线程编程，涉及到的概念主要有<code>线程(池)</code>、<code>进程(池)</code>、<code>异步I/O</code>、<code>协程</code>、<code>GIL</code>等，而理解这些概念，对我们而言是非常重要的，因为它将会告诉你选择什么方案更好一点。想让你的爬虫更高效、更快吗？在这里就能找到你的答案。</p><h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>现在，假设我们有一组图片的地址(URL)，我们希望通过<code>requests</code>来实现图片的下载，为此我们定义了<code>Spider</code>类。在这个类中，我们提供了<code>getImage()</code>方法来完成下载这个动作。我们可以非常容易地写出一个“单线程”的版本，但这显然这不是我们今天这篇博客的目的。此时，我们来考虑一个问题，怎么样实现一个“多线程”的版本？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        self.session = requests.session()</span><br><span class="line">        self.session.headers[<span class="string">'User-Agent'</span>] = fake_useragent.UserAgent().random</span><br><span class="line">        self.session.headers[<span class="string">"Referer"</span>] = <span class="string">"https://www.nvshens.org"</span></span><br><span class="line">        self.urls = urls</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImage</span><span class="params">(self, url, fileName, retries=<span class="number">5</span>)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;threading.currentThread().name&#125;</span> -&gt; <span class="subst">&#123;url&#125;</span>'</span>)</span><br><span class="line">            response = self.session.get(url, </span><br><span class="line">              allow_redirects=<span class="literal">False</span>, </span><br><span class="line">              timeout=<span class="number">10</span>, </span><br><span class="line">              proxies=<span class="literal">None</span></span><br><span class="line">            )</span><br><span class="line">            response.raise_for_status()</span><br><span class="line">            data = response.content</span><br><span class="line">            imgFile = open(fileName, <span class="string">'wb'</span>)</span><br><span class="line">            imgFile.write(data)</span><br><span class="line">            imgFile.close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> :</span><br><span class="line">            <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">                retries -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.getImage(url, fileName, retries):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h1 id="线程与线程池"><a href="#线程与线程池" class="headerlink" title="线程与线程池"></a>线程与线程池</h1><p>既然提到了线程，我们会非常自然地想到 <code>Thread</code> 和 <code>ThreadPool</code> ，而这几乎是所有编程语言里都有的通用型概念。可是，Python 中的多线程其实是一种“假”的多线程，这又从何说起呢？答案是<strong>全局解释器锁</strong>(<strong>GIL</strong>)，原来在设计 Python 解释器的时候，为了保证同时只有一个线程在运行，引入了这样一个锁，你可以类比游戏开发时主循环的概念来辅助理解。那为什么又说 Python 中的多线程是一种“假”的多线程呢？这是因为它没法发挥出多核的优势，每个线程在执行前都要先获得 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock" target="_blank" rel="noopener">GIL</a> ，这就导致一个问题，即使你有多个核心，线程永远只能用到其中一个核，因为多线程在 Python 中只能交替执行。以一言蔽之， Python 中 I/O 密集型任务相比 CPU 密集型任务更能充分发挥多线程的好处。所以，像爬虫这种和网络打交道的事物，是非常适合使用多线程来提高效率的。在这里，我们我们要介绍的是 <code>Thread</code> 和 <code>ThreadPool</code> 以及 <code>ThreadPoolExecutor</code>。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>首先，我们需要了解的是，Python 中的 Thread ，实际上先后有<code>thread</code>和<code>threading</code>两种模块，它们的关系有一点像 .NET 里的<code>Thread</code>和<code>Task</code>，考虑到<code>thread</code>的使用频率非常低，这里我们更推荐大家使用<code>threading</code>，它提供了更高级的、完全的线程管理。例如，我们现在面临的这个“多线程”下载的问题，使用<code>threading</code>的话可以这样解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Thread下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByThread</span><span class="params">(self)</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(self.urls)):</span><br><span class="line">        thread = threading.Thread(</span><br><span class="line">          target=self.getImage, </span><br><span class="line">          args=(self.urls[index], <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>,)</span><br><span class="line">        )</span><br><span class="line">        threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        thread.start()</span><br></pre></td></tr></table></figure><p>可以注意到，当我们需要构造一个线程时，只需要指定<code>target</code>和<code>args</code>两个参数，其中，前者是指线程执行的方法，后者是指传递给线程所执行的方法的参数。当我们需要启动线程时，只需要调用线程的<code>start()</code>方法，而通过<code>setDaemon()</code>方法则可以设置一个线程为守护线程。关于守护线程，这里简单说明一下，一旦一个线程被设置为守护线程，那么，只要线程执行的方法中存在等待时间譬如<code>time.sleep(1)</code>，此时等待时间下面的代码都不会再执行。如果线程中执行的方法是一个耗时的操作，此时，我们还可以通过<code>join()</code>方法来阻塞主线程，以确保主线程再子线程执行完后再结束。除了这种函数式的使用方法以外，我们还可以通过继承<code>Thread</code>类并重写其<code>run()</code>方法的方式，对于这一点可以参考官方文档中的<a href="https://docs.python.org/zh-cn/3/library/threading.html#thread-objects" target="_blank" rel="noopener">线程对象</a>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/15/I6jZ35R8dDvJUsW.png" alt="使用Thread下载" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用Thread下载</div>            </figure><h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p>对于线程，我们都知道它是作为一种系统资源而存在的，所以，和这个世界上的大多数资源一样，无法供我们肆意地挥霍和浪费。在 <a href="https://blog.yuanpei.me/posts/2414960312/" target="_blank" rel="noopener">.NET Core中对象池(Object Pool)的使用</a> 这篇博客中，我曾经大家介绍过“对象池”这种设计，和这篇博客中所提到的原理一样，线程池相对于普通线程而言多了一种可复用的可能性，这意味着我们可以用有限的线程来下载可能无限多的图片资源。在 Python 中我们使用 <code>threadpool</code> 模块来实现线程池的功能，需要注意的是这是一个第三方的模块。下面，我们来一起看看具体的使用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ThreadPool下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByThreadPool</span><span class="params">(self, poolSize=<span class="number">3</span>)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        args.append((<span class="literal">None</span>, &#123;<span class="string">'url'</span>: self.urls[index], <span class="string">'fileName'</span>: <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>&#125;))</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = threadpool.ThreadPool(poolSize)</span><br><span class="line">    requests = threadpool.makeRequests(self.getImage, args)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> requests]</span><br><span class="line">    pool.wait()</span><br></pre></td></tr></table></figure><p>在这里，我们声明了一个指定大小的线程池，通过一个方法<code>getImage()</code>和一组参数<code>args</code>来构造“请求”，再将这些请求全部放进线程池里，此时，线程池会自动等待这些“请求”执行完毕。这里唯一比较难理解的，可能是如何构造参数<code>args</code>，尤其是当被执行的方法需要传递多个参数的时候。其实这里有两种传参的方式，第一种是按数组来解构，此时我们可以写<code>[([&#39;&#39;,&#39;&#39;], None), ([&#39;&#39;,&#39;&#39;], None)]</code>；而第二种则是按字典来解构，此时我们可以写<code>[(None, {&#39;url&#39;:&#39;&#39;, &#39;fileName&#39;:&#39;&#39;}), (None, {&#39;url&#39;:&#39;&#39;, &#39;fileName&#39;:&#39;&#39;})</code>。两者的区别主要在<code>None</code>的位置，不知道大家有没有发现规律。这里我们准备了张图片，而线程池最大线程是3个，理论上某个线程会被重复使用，实际结果又是如何呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/15/kGgPXS8vHMwxoIN.png" alt="使用ThreadPool下载" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用ThreadPool下载</div>            </figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>对于<a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a>，相信不用我多说什么，你就能知道它是做什么的吧，这就是博主反复提及的命名规范的问题。简而言之，Python 在 <code>concurrent.futures</code>中为我们提供了 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a> 和 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">ProcessPoolExecutor</a> 两个高级接口，它们都继承自同一个抽象类<code>Executor</code>，它可以让我们在线程池或者进程池中异步地执行回调函数，属于官方提供的标准的“<strong>线程池</strong>”和“<strong>进程池</strong>”模块，下面，我们来一起看看具体的使用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ThreadPoolExecutor下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByThreadPoolExecutor</span><span class="params">(self, poolSize=<span class="number">3</span>)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">      args.append(&#123;<span class="string">'url'</span>: self.urls[index], <span class="string">'fileName'</span>: <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>&#125;)</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=poolSize)</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        task = pool.submit(self.getImage(arg[<span class="string">'url'</span>], arg[<span class="string">'fileName'</span>]), arg)</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    wait(tasks, return_when=ALL_COMPLETED)</span><br><span class="line">    <span class="comment"># tasks = pool.map(lambda arg:self.getImage(arg['url'], arg['fileName']), args)</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>submit()</code>方法和<code>map()</code>方法的区别，前者相当于声明线程后并不立即执行，故而，需要<code>wait()</code>方法来等待所有任务执行结束；而后者则相当于声明线程并理解执行，故而，返回值实际是每一个任务执行的结果的集合，这里就隐隐有一点 .NET 中 <code>Task</code> 的味道啦！同样地，我们给了一个最大线程数：3，它能否得到和<code>threadpool</code> 类似的结果呢？我们拭目以待：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/15/jeJTHlkiuors4zw.png" alt="使用ThreadPoolExecutor下载" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用ThreadPoolExecutor下载</div>            </figure><h1 id="进程与进程池"><a href="#进程与进程池" class="headerlink" title="进程与进程池"></a>进程与进程池</h1><p>看到这里，可能有读者朋友会忍不住吐槽，博主你三十岁不到，怎么越来越糊涂了啊，你这博客标题明明写的是多线程，怎么写着写着就写到进程上来了呢？其实，这里是紧接着 GIL 这个话题来讲的。既然 Python 中的多线程更适合 I/O 密集型的任务，那么，是不是说 Python 不适合处理 CPU 密集型的任务呢？答案是否定的，我们这里将多进程理解为并行就会更容易想明白一点。我们都知道操作系统可以同时执行多个任务，而这每一个任务其实就是一个进程，而每个进程内又可以同时执行多个子任务，这每一个子任务其实就是一个线程。这样说，我们或许就能明白，这意味着，如果我们的确需要并行地去处理某些任务，进程(池)或许是个不错的选择。同样地，这里介绍的是，<code>Process</code>、<code>ProcessPool</code> 和 <code>ProcessPoolExecutor</code>。</p><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>关于进程，我个人感觉比线程要更好理解一点，因为不论是 Windows 下的任务管理器，亦或者是我们经常听到的“杀进程”，它都不算是一个特别陌生或者抽象的概念，而线程这种东西呢，大概是只有程序员会关注，同时爱之弥深、恨之弥切的一种事物。庆幸的是，在 Python 中线程与进程在代码的编写上是非常相似的，这里我们需要用到的是<code>multiprocessing</code>模块，下面，我们来一起看看 Python 中的进程的的使用方法，你会发现只需要改一下<code>threading.Thread()</code>这部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Process下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByProcess</span><span class="params">(self)</span>:</span></span><br><span class="line">    process = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(self.urls)):</span><br><span class="line">        proc = multiprocessing.Process(</span><br><span class="line">          target=self.getImage, </span><br><span class="line">          args=(self.urls[index], <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>,)</span><br><span class="line">        )</span><br><span class="line">        process.append(proc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> proc <span class="keyword">in</span> process:</span><br><span class="line">        proc.start()</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果，可以发现它都是在主线程上运行：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/16/oyJKlOCazQX3RcZ.png" alt="使用Process下载" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用Process下载</div>            </figure><h2 id="ProcessPool"><a href="#ProcessPool" class="headerlink" title="ProcessPool"></a>ProcessPool</h2><p>既然有“线程池”，又怎么能少得了进程池呢？同样地，它位于<code>multiprocessing</code>模块中，通过<code>apply()</code>方法来执行某个任务，下面是一个基本的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用multiprocessing.Pool()下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByProcessPool</span><span class="params">(self, poolSize=<span class="number">3</span>)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        args.append((self.urls[index], <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>, ))</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = multiprocessing.Pool(poolSize)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        pool.apply(self.getImage, arg)</span><br></pre></td></tr></table></figure><p>有朋友难免会好奇“进程池”和“线程池”有什么不一样，我想，下面这张图会告诉你答案：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/15/jGKQ2qnVtz9c4DL.png" alt="使用multiprocessing.Pool()下载" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用multiprocessing.Pool()下载</div>            </figure><h2 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h2><p>和 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a> 类似，我们还可以使用 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">ProcessPoolExecutor</a> 来实现“进程池”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ProcessPoolExecutor下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByProcessPoolExecutor</span><span class="params">(self, poolSize=<span class="number">3</span>)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        args.append(&#123;<span class="string">'url'</span>: self.urls[index], <span class="string">'fileName'</span>: <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>&#125;)</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = ProcessPoolExecutor(max_workers=poolSize)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        pool.submit(self.getImage(arg[<span class="string">'url'</span>], arg[<span class="string">'fileName'</span>]), arg)</span><br></pre></td></tr></table></figure><p>可以看到，“进程池”中的代码都是在主线程上执行的，这一点和<code>multiprocessing.Pool()</code>完全一致：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/16/iCFSawkEMjN2PzO.png" alt="使用ProcessPoolExecutor下载" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用ProcessPoolExecutor下载</div>            </figure><h1 id="协程与异步I-O"><a href="#协程与异步I-O" class="headerlink" title="协程与异步I/O"></a>协程与异步I/O</h1><p>其实，如果单单从 I/O 密集型和 CPU 密集型两种场景而言，这篇博客到这里就差不多应该结束啦！不过呢，博主好奇 Scrapy 这个爬虫框架的实现原理，发现它是基于 Twisted 这样一个异步网络框架，考虑到目前为止，我们通过 <code>requests</code> 来下载图片都是采用同步的方式，除了任务调度上的优化以外，任务本身还存在一定的优化空间，所以，这里就顺带着一起整理出来，这里主要结合 <code>asyncio</code> 和 <code>requests</code> 来对 Python 中关于异步 I/O 、协程等的使用方法进行演示和说明。</p><h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/asyncio.html" target="_blank" rel="noopener">asyncio</a> 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async/await</strong> 语法，它是构建 I/O 密集型和高层级 <strong>结构化</strong> 网络代码的最佳选择。它提供了类似并发地执行<a href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a>、网络 I/O 和进程间通信(<strong>IPC</strong>)、<a href="https://docs.python.org/zh-cn/3.7/library/asyncio-eventloop.html#asyncio-event-loop" target="_blank" rel="noopener">事件循环</a>等等的能力，例如，我们可以通过下面的代码来创建和使用<a href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(what, delay)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="string">'你好'</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="string">'Hello'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式1</span></span><br><span class="line"><span class="comment"># Python 3.7 + </span></span><br><span class="line">asyncio.rum(main())</span><br><span class="line"><span class="comment"># Python 3.7 -</span></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>参考官方文档，我们还可以使<code>create_task()</code>方法来创建<code>asyncio</code>的并发任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Python 3.7 + </span></span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="string">'你好'</span>, <span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="string">'Hello'</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="comment"># Python 3.7 -</span></span><br><span class="line">    task1 = asyncio.get_event_loop().(say_after(<span class="string">'你好'</span>, <span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.get_event_loop().(say_after(<span class="string">'Hello'</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>这是因为 Python 中的协程、任务 和 Future 都是可等待对象，故而，凡有 <strong>async</strong> 处皆可 <strong>await</strong> ，果然，主流编程语言的最终走向是如此的一致啊，回头想想 .NET 中 Thread 、 ThreadPool 、 Task 的进化历程，是不是有种“<strong>天下大势，分久必合</strong>”的感觉呢？</p><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>好了，当我们对异步 I/O、协程有了一个基本的了解以后，我们就可以考虑结合着 <code>requests</code> 来做一点小小的尝试，我们大多数时候写的 <code>requests</code> 相关的代码，基本上都是博主这里<code>getImage()</code>类似的画风，最多再加上流式传输(Stream) 和 <code>iter_content</code>。为了配合异步 I/O来使用，我们这里需要定义一个异步的方法<code>getImageAsync()</code>，一起来看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getImageAsync</span><span class="params">(self, url, fileName, retries=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;threading.currentThread().name&#125;</span> -&gt; <span class="subst">&#123;url&#125;</span>'</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: fake_useragent.UserAgent().random,</span><br><span class="line">            <span class="string">'Referer'</span>: <span class="string">"https://www.nvshens.org"</span></span><br><span class="line">        &#125;</span><br><span class="line">        future = asyncio.get_event_loop().run_in_executor(</span><br><span class="line">            <span class="literal">None</span>, </span><br><span class="line">            functools.partial(requests.get, url, headers=headers)</span><br><span class="line">        )</span><br><span class="line">        response = <span class="keyword">await</span> future</span><br><span class="line">        data = response.content</span><br><span class="line">        imgFile = open(fileName, <span class="string">'wb'</span>)</span><br><span class="line">        imgFile.write(data)</span><br><span class="line">        imgFile.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">await</span> self.getImageAsync(url, fileName, retries):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>接下来，我们还需要定义<code>downloadAsync()</code>方法，这里我们使用了<code>create_task()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">downloadAsync</span><span class="params">(self)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        url = self.urls[index]</span><br><span class="line">        fileName = <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.get_event_loop().create_task(self.getImageAsync(url, fileName))</span><br></pre></td></tr></table></figure><p>此时，我们可以在入口函数中这样调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spider = Spider(urls)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(spider.downloadAsync())</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure><p>看看结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/16/mhtcT78dswjgERa.png" alt="异步I/O + Requests 实现并行下载]" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">异步I/O + Requests 实现并行下载]</div>            </figure><p>这里，针对本文中提到的各种方法，博主做了一个简单对比：</p><table><thead><tr><th>项目</th><th>时间</th></tr></thead><tbody><tr><td>Thread</td><td>0:00:01.789790</td></tr><tr><td>ThreadPool</td><td>0:00:00.134065</td></tr><tr><td>ThreadPoolExecutor</td><td>0:00:06.510224</td></tr><tr><td>Process</td><td>0:00:00.100506</td></tr><tr><td>ProcessPool</td><td>0:00:11.046871</td></tr><tr><td>ProcessPoolExecutor</td><td>0:00:02.226153</td></tr><tr><td>AsyncIO</td><td>0:00:04.096083</td></tr></tbody></table><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文从线程(池)、进程(池)和异步 I/O 三个方面探讨和尝试了多线程编程在 Python 爬虫领域的简单应用。其实，除了以上这些优化的思路以外，我们还可以借助队列(<strong>Queue</strong>)这类数据结构来改善现有方案的设计，大家可以注意到我给<code>getImage()</code>方法增加了错误重试的机制，这同样是为了增强爬虫程序的健壮性，而关于这个错误重试机制，考虑通过装饰器来进行改良则又是一个新的努力的方向，所以说，没有 deadline 才能让我们不断地自我改善，而有 deadline 只能让我们赶紧做完赶紧清净。好了，以上就是这篇博客的全部内容啦，最后要送给大家一个福利，本文中援引的爬虫程序已开源，地址是：<a href="https://github.com/qinyuanpei/zngirls" target="_blank" rel="noopener">https://github.com/qinyuanpei/zngirls</a>，感兴趣的朋友可以自己去玩一玩，你懂的哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="多线程" scheme="https://qinyuanpei.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="技巧" scheme="https://qinyuanpei.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://qinyuanpei.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>实现网页长截图的常见思路总结</title>
    <link href="https://qinyuanpei.github.io/posts/3406626380/"/>
    <id>https://qinyuanpei.github.io/posts/3406626380/</id>
    <published>2021-01-09T20:37:47.000Z</published>
    <updated>2021-05-28T02:08:18.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>作为一个经常写博客的人，我有时会在<a href="https://weibo.com/" target="_blank" rel="noopener">微博</a>上分享博客内容，可不知道从什么时候开始，国内互联网越来越丧失信仰，所有的厂商都在试图打造一个<strong>“只进不出”</strong>的信息孤岛，进而达到增强<strong>“用户黏度”</strong>的目的。以微博为例，微博中的外链永远都会被转化为短地址，并且无法通过微博内置的浏览器进行跳转。即使你通过手动复制链接的方式打开链接，你依然需要至少两个步骤方能见到<strong>“庐山真面目”</strong>。借鉴/抄袭这一陋习的还有<a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a>，花时间做了一个第三方链接跳转提示页面，唯独不愿意在上面加一个a标签，你还是要手动复制黏贴。坦白说，我觉得国内互联网正在丧失着信仰，看起来电商、物流、外卖、打车、支付……此起彼伏逐渐渗透到我们生活的方方面面，成为名副其实的<strong>“互联网+”</strong>，可在信息泛滥的今天，我们越来越难找到真正有价值的信息……既然外链注定要被屏蔽掉，那我就勉为其难地顺应潮流发<strong>“长截图”</strong>咯，所以，接下来我会为大家分享实现网页<strong>“长截图”</strong>的常见思路，希望对有类似烦恼或者需求的小伙伴们有所帮助。</p><h1 id="通过浏览器实现"><a href="#通过浏览器实现" class="headerlink" title="通过浏览器实现"></a>通过浏览器实现</h1><p>要实现网页长截图，显然是和网页打交道，而和网页打交道最多的是谁呢？自然是我们每天都要用的浏览器啦！值得庆幸的是，不管是 Chrome 还是 Firefox ，我们都可以通过它们来是实现这个想法。</p><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p>对于 Chrome 来说，我们只需要“F12”打开开发者工具，并在其中找到“控制台”选项卡，在平时输入 JavaScript 脚本的地方(即 Console 选项卡)输入<code>Ctrl + Shift + P</code>命令，然后你会得到一个类似 VSCode 命令行体验的输入窗口，接下来，输入：<code>Capture full size screenshot</code>并回车。此时，我们就可以得到完整的页面截图。而如果你希望截取网页中的一部分，则可以在选中指定 DOM 元素后采用相同的方式输入命令：<code>Capture node screenshot</code>。此外，更常用的截取浏览器可见范围内的内容，可以使用：<code>Capture screenshot</code>。可能相对于一般可以进行拖拽截图的工具而言，这个方案显得有点笨拙且简陋，可它真的可以完美地实现我们的想法，而且不需要安装任何扩展或者插件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/10/9kNwf8b2rnCiuop.png" alt="使用 Chrome 的截图功能" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用 Chrome 的截图功能</div>            </figure><h2 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h2><p>对于 Firefox 而言，它本身自带截图功能，并且支持拖拽截图，对于我们这些需要长截图的人而言，唯一需要做的就是点击几下数据，确实要比敲命令行要简单一点、友好一点，我个人更喜欢用 Firefox 一点，因为 Chrome 正在从屠龙少年变成恶龙，为了让这个世界上不是只有 Chrome 一种浏览器内核，我决定支持一下 Firefox ，2020年因为疫情的原因， Mozila 裁员25%约250人，这家几乎靠着理想主义在维护 Gecko 内核的公司，之后可能再无法和 Google 的 Chrome 抗衡，而这个世界只有一种浏览器的时代我们都曾经经历过，它的名字叫做 IE6 ，不禁令人感慨，简直是开放 Web 的罗曼蒂克消亡史。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/10/CgNzF8DA4fYGcHM.png" alt="使用 Firefox 的截图功能" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用 Firefox 的截图功能</div>            </figure><h1 id="通过Selenium实现"><a href="#通过Selenium实现" class="headerlink" title="通过Selenium实现"></a>通过Selenium实现</h1><p>在我的认知中，有浏览器的地方就有爬虫，而有爬虫的地方就有 <a href="https://www.selenium.dev/" target="_blank" rel="noopener">Selenium</a> 。原本好端端的UI自动化测试框架，怎么就助纣为虐做起爬虫来了呢？其实，主要原因是它提供了一个可以和浏览器交互的环境，从某种意义上来讲，<a href="https://www.selenium.dev/" target="_blank" rel="noopener">Selenium</a> 、<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">PhantomJS</a> 以及 <a href="https://github.com/microsoft/playwright-python" target="_blank" rel="noopener">Playwright</a> 都可以认为是类似的技术，这里我们以Selenium为例，而通过Selenium实现网页长截图则主要有两种方式：其一，是构造一个足够“大”的浏览器，然后调用<code>save_screenshot()</code>方法进行截图；其二，是通过“拖拽”滚动条来滚动截图，然后再通过<code>PIL</code>进行拼接，下面来看具体的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_screenshot</span><span class="params">(url, fp_pic)</span>:</span></span><br><span class="line">    fireFoxOptions = webdriver.FirefoxOptions()</span><br><span class="line">    fireFoxOptions.set_headless()</span><br><span class="line">    driver = webdriver.Firefox(firefox_options=fireFoxOptions)</span><br><span class="line">    driver.get(url)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 设置浏览器宽度和高度</span></span><br><span class="line">    width = driver.execute_script(</span><br><span class="line">      <span class="string">"return document.documentElement.scrollWidth"</span></span><br><span class="line">    )</span><br><span class="line">    height = driver.execute_script(</span><br><span class="line">      <span class="string">"return document.documentElement.scrollHeight"</span></span><br><span class="line">    )</span><br><span class="line">    driver.set_window_size(width, height)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 截图</span></span><br><span class="line">    driver.save_screenshot(fp_pic)</span><br><span class="line">    driver.close()</span><br></pre></td></tr></table></figure><p>这里我使用的是 Firefox 的驱动，喜欢 Chrome 的按个人喜好即可，这里我假设你已经掌握了 Python 和 Selenium，如果需要一点辅助知识，可以参考博主的这篇文章：<a href="https://blog.yuanpei.me/posts/3602353334/" target="_blank" rel="noopener">作为技术宅的我，是这样追鬼滅の刃的</a> 。这种方式的“长截图”实现起来非常简单，可是因为需要构造一个非常“大”的浏览器，所以，如果页面适配没有做好的话，可能会出现页面元素变形的问题，其次，这种方式生成的图片体积普遍比较大，所以，从总体上看主要就是这两个缺点。而“滚动截图”实现起来会稍微复杂一点，因为里面会涉及到一小部分计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_screenshot2</span><span class="params">(url, fp_pic)</span>:</span></span><br><span class="line">    fireFoxOptions = webdriver.FirefoxOptions()</span><br><span class="line">    fireFoxOptions.set_headless()</span><br><span class="line">    driver = webdriver.Firefox(firefox_options=fireFoxOptions)</span><br><span class="line">    driver.fullscreen_window() <span class="comment"># 全屏窗口</span></span><br><span class="line">    driver.get(url)</span><br><span class="line">    window_height = driver.get_window_size()[<span class="string">'height'</span>] <span class="comment"># 窗口高度</span></span><br><span class="line"> </span><br><span class="line">    page_height = driver.execute_script(</span><br><span class="line">      <span class="string">'return document.documentElement.scrollHeight'</span></span><br><span class="line">    ) <span class="comment"># 页面高度</span></span><br><span class="line">    driver.save_screenshot(<span class="string">'temp.png'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> page_height &gt; window_height:</span><br><span class="line">        n = page_height // window_height <span class="comment"># 需要滚动的次数</span></span><br><span class="line">        base_mat = np.atleast_2d(Image.open(<span class="string">'temp.png'</span>)) <span class="comment"># 打开截图并转为二维矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        driver.execute_script(</span><br><span class="line">          <span class="string">f'document.documentElement.scrollTop=<span class="subst">&#123;window_height * (i+<span class="number">1</span>)&#125;</span>;'</span></span><br><span class="line">        )</span><br><span class="line">        time.sleep(<span class="number">.5</span>)</span><br><span class="line">        driver.save_screenshot(<span class="string">f'temp_<span class="subst">&#123;i&#125;</span>.png'</span>) <span class="comment"># 保存截图</span></span><br><span class="line">        mat = np.atleast_2d(Image.open(<span class="string">f'temp_<span class="subst">&#123;i&#125;</span>.png'</span>)) <span class="comment"># 打开截图并转为二维矩阵</span></span><br><span class="line">        base_mat = np.append(base_mat, mat, axis=<span class="number">0</span>) <span class="comment"># 拼接图片的二维矩阵</span></span><br><span class="line">        Image.fromarray(base_mat).save(fp_pic, format=<span class="string">'PNG'</span>)</span><br><span class="line">        os.remove(<span class="string">f'temp_<span class="subst">&#123;i&#125;</span>.png'</span>)</span><br><span class="line"></span><br><span class="line">    os.remove(<span class="string">'temp.png'</span>)</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><p>这个方案本身没有太大的问题，可如果你的网页是那种页面滚动时头部固定的设计，譬如类似博主的博客这样的风格，此时这种方案就会有一点问题，每次截取都会包含头部这部分，和我们最后想要实现的效果有一点出入，如果可以计算出头部的高度，截图或者拼接的时候把这个高度考虑进去，就可以彻底解决这个问题，可这样这个问题就从一个通用型问题变成一个局部型问题啦，果然，世上没有完美的解决方案呢……</p><h1 id="通过JavaScript实现"><a href="#通过JavaScript实现" class="headerlink" title="通过JavaScript实现"></a>通过JavaScript实现</h1><p>有人可能要说，博主你好偏心，为什么 Python 都出来了，作为前端三剑客之一的 JavaScript 还没有出现？嗯，对此我想说——你不用说，我知道不就是<strong>“人生苦短，我用Python”</strong>吗？人家前端世界里有个叫做 <a href="http://html2canvas.hertzen.com/" target="_blank" rel="noopener">html2canvas</a> 的库，博主你可有耳闻？我笑了笑，我并没有看了看我的劳力士，因为我没有劳力士。好吧，既然这里提到了这个库，那就来说说这个库的实现思路吧，人家不是说了嘛？一切可以实现的东西，最终可以用 JavaScript 来实现，我们来看看具体的代码实现，这里，首先准备一个HTML文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./html2canvas.min.js'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"overflow: hidden;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">style</span>=<span class="string">"height: 768px; overflow: hidden;"</span>&gt;</span></span><br><span class="line">        请输入URL: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"capture"</span>&gt;</span>截取<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">"view"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">v-bind:src</span>=<span class="string">'url'</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">width</span>=<span class="string">"100%"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">height</span>=<span class="string">"100%"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">frameborder</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">ref</span>=<span class="string">"view"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>非常简单，输入一个地址，然后通过一个iframe进行预览，点击按钮进行截图。下面给出JavaScript代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            url: <span class="string">'https://regularly-archive.github.io/2020/Matrix/'</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            capture: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> iframe = self.$refs.view.contentWindow;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> iframeBody = iframe.document.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">                html2canvas(iframeBody).then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.body.appendChild(canvas);</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//canvas转图片</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> canvasImg = canvas.toDataURL(<span class="string">"image/png"</span>);</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//模拟下载</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span></span><br><span class="line">                    a.href = canvasImg;</span><br><span class="line">                    a.download = self.url;</span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"MouseEvents"</span>)</span></span><br><span class="line"><span class="actionscript">                    event.initMouseEvent(<span class="string">"click"</span>, <span class="literal">true</span>, <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                       <span class="built_in">window</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>)</span></span><br><span class="line">                    a.dispatchEvent(event)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下，你可以点击 <a href="https://regularly-archive.github.io/2020/html2canvas/" target="_blank" rel="noopener">这里</a> 访问在线演示DEMO：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/11/KO9Hx4gbLlzkUDG.gif" alt="使用html2canvas实现的长截图" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">使用html2canvas实现的长截图</div>            </figure><p>这里使用iframe可能会引入跨域的问题，大家可以参考我的这篇文章：<a href="https://blog.yuanpei.me/posts/3846545990/" target="_blank" rel="noopener">聊聊前端跨域的爱恨情仇</a> ，而 <a href="http://html2canvas.hertzen.com/" target="_blank" rel="noopener">html2canvas</a> 本身就提供了关于跨域问题的解决方案，大家可以参考这里：<a href="http://html2canvas.hertzen.com/configuration" target="_blank" rel="noopener">http://html2canvas.hertzen.com/configuration</a>。</p><h1 id="通过第三方工具实现"><a href="#通过第三方工具实现" class="headerlink" title="通过第三方工具实现"></a>通过第三方工具实现</h1><p>我知道程序员都喜欢自己去折腾，如果是前无古人、后无来者的东西，我建议去折腾，因为梦想还是要有的，万一实现了呢？而我们这个圈子里同样有一句经典的话，叫做“不要重复制造轮子”，所以，博主这里找到了几个轮子供大家参考，不喜欢在冬天动手写代码的人，可以收藏下这几个工具，这个冬天实在是太冷了，冷到什么程度呢?大概听见笑话都不大愿意笑，用罗翔老师的话说这叫做搞笑未遂。</p><h2 id="wkhtml2image"><a href="#wkhtml2image" class="headerlink" title="wkhtml2image"></a>wkhtml2image</h2><p><a href="https://wkhtmltopdf.org/downloads.html" target="_blank" rel="noopener">wkhtml系列</a>，一个命令行工具，可以将本地HTML文件或者远程URL指向的网页转化为图片，该系列产品中还有wkhtml2pdf，顾名思义，网页转PDF，实际使用过程中基本没什么问题，输出的图片1:1还原网页，唯一的缺点是偶尔会丢失样式，尤其是页面中引入了第三方的JavaScript或者CSS的时候，整体上远程URL比本地HTML要稳定一点，推荐系数：4星。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/10/YtlZdITauS7eGv4.png" alt="长截图03.png" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">长截图03.png</div>            </figure><h2 id="PickFrom"><a href="#PickFrom" class="headerlink" title="PickFrom"></a>PickFrom</h2><p><a href="https://zh.pickfrom.net/html2png" target="_blank" rel="noopener">PickFrom</a>，一个在线的网页转图片的服务，填写URL然后点击按钮即可，提供免费预览一部分图片的功能，完整图片的查看、下载均需要支付一定费用，服务质量还可以，但不适合我们这种被迫“白嫖”的穷人家的孩子，土豪们随意，推荐系数：4星</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/10/m273LUTZxsKHeb4.png" alt="PickFrom" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">PickFrom</div>            </figure><h2 id="Tiomg"><a href="#Tiomg" class="headerlink" title="Tiomg"></a>Tiomg</h2><p><a href="https://tiomg.org/webpage-screenshot" target="_blank" rel="noopener">Tiomg</a>，接下来是博主要重点推荐，它和 <a href="https://zh.pickfrom.net/html2png" target="_blank" rel="noopener">PickFrom</a> 提供着相同的服务，唯一不同的是，它是完全免费的，我现在主要用这个来工具来生成“长截图”，不错，我背叛了上面我写的那些代码，为什么要重复造轮子呢？有时候我想不明白，为什么国内公司都喜欢那种“大而全”的软件，恨不得要拥有竞争对手所有的特性，可明明大家都“卷”成这样了，为什么不试试差异化的路线呢？可能，是因为低端竞争太多吧！推荐系数：5星</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/01/10/injWyCsFNOVZSgT.png" alt="Tiomg" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">Tiomg</div>            </figure><p>冬天实在是没有动力去写有技术含量的东西啊！关于“长截图”这个话题，差不多是从一周前开始关注、做实验的，所以，请允许在下偶尔写这样一篇“水文”吧！关于“视频是不能P的系列”，因为 Dlib 安装起来实在讨厌，而 OpenCV 提供的 68 特征点算法目前只支持 C++ ，研究起来难免要花一点时间，好了，这篇博客暂时先写到这里吧，博主要先去冬眠啦，再见!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="独立博客" scheme="https://qinyuanpei.github.io/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="Selenium" scheme="https://qinyuanpei.github.io/tags/Selenium/"/>
    
      <category term="长截图" scheme="https://qinyuanpei.github.io/tags/%E9%95%BF%E6%88%AA%E5%9B%BE/"/>
    
      <category term="工具" scheme="https://qinyuanpei.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>温故而知新，由ADO.NET与Dapper所联想到的</title>
    <link href="https://qinyuanpei.github.io/posts/2621074915/"/>
    <id>https://qinyuanpei.github.io/posts/2621074915/</id>
    <published>2020-12-30T12:49:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p> 这段时间在维护一个“遗产项目”，体验可以说是相当地难受，因为它的数据持久化层完全由ADO.NET纯手工打造，所以，你可以在项目中看到无所不在的DataTable，不论是读操作还是写操作。这个DataTable让我这个习惯了Entity Framework的人感到非常别扭，我并不排斥写手写SQL语句，我只是拥有某种自觉并且清醒地知道，自己写的SQL语句未必就比ORM生成的SQL语句要好。可至少应该是像Dapper这种程度的封装啊，因为关系型数据库天生就和面向对象编程存在隔离，所以，频繁地使用DataTable无疑意味着你要写很多的转换的代码，当我看到<code>DbConnection</code>、<code>DbCommand</code>、<code>DbDataReader</code>、<code>DbDataAdapter</code>这些熟悉的“底层”的时候，我意识到我可以结合着Dapper的实现，从中梳理出一点改善的思路，所以，这篇博客想聊一聊<strong>ADO.NET</strong>、<strong>Dapper</strong>和<strong>Dynamic</strong>这三者间交叉的部分，希望能给大家带来新的启发。</p><h1 id="重温ADO-NET"><a href="#重温ADO-NET" class="headerlink" title="重温ADO.NET"></a>重温ADO.NET</h1><p>相信大家都知道，我这里提到的<code>DbConnection</code>、<code>DbCommand</code>、<code>DbDataReader</code>、<code>DbDataAdapte</code>以及<code>DataTable</code>、<code>DataSet</code>，实际上就是ADO.NET中核心的组成部分，譬如<code>DbConnection</code>负责管理数据库连接，<code>DbCommand</code>负责SQL语句的执行，<code>DbDataReader</code>和<code>DbDataAdapter</code>负责数据库结果集的读取。需要注意的是，这些类型都是抽象类，而各个数据库的具体实现，则是由对应的厂商来完成，即我们称之为“驱动”的部分，它们都遵循同一套接口规范，而<code>DataTable</code>和<code>DataSet</code>则是“装”数据库结果集的容器。关于ADO.NET的设计理念，可以从下图中得到更清晰的答案：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/12/31/dEN2tajehboDiTl.png" alt="ADO.NET架构" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">ADO.NET架构</div>            </figure><p>在这种理念的指引，使用ADO.NET访问数据库通常会是下面的画风。博主相信，大家在各种各样的<code>DbHelper</code>或者<code>DbUtils</code>中都见过类似的代码片段，在更复杂的场景中，我们会使用<code>DbParameter</code>来辅助<code>DbCommand</code>，而这就是所谓的<strong>SQL参数化查询</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = Path.Combine(Directory.GetCurrentDirectory(), <span class="string">"Chinook.db"</span>);</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> connection = <span class="keyword">new</span> SQLiteConnection(<span class="string">$"Data Source=<span class="subst">&#123;fileName&#125;</span>"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (connection.State != ConnectionState.Open) connection.Open();</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> command = connection.CreateCommand())</span><br><span class="line">    &#123;</span><br><span class="line">        command.CommandText = <span class="string">"SELECT AlbumId, Title, ArtistId FROM [Album]"</span>;</span><br><span class="line">        command.CommandType = CommandType.Text;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//套路1：使用DbDataReader读取数据</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> reader = command.ExecuteReader())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (reader.Read())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//各种眼花缭乱的写法:)</span></span><br><span class="line">                Console.WriteLine(<span class="string">$"AlbumId=<span class="subst">&#123;reader.GetValue(<span class="number">0</span>)&#125;</span>"</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">$"Title=<span class="subst">&#123;reader.GetFieldValue&lt;<span class="keyword">string</span>&gt;(<span class="string">"Title"</span>)&#125;</span>"</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">$"ArtistId=<span class="subst">&#123;reader.GetInt32(<span class="string">"ArtistId"</span>)&#125;</span>"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//套路2：使用DbDataAdapter读取数据</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> adapter = <span class="keyword">new</span> SQLiteDataAdapter(command))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> dataTable = <span class="keyword">new</span> DataTable();</span><br><span class="line">            adapter.Fill(dataTable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里经常会引发的讨论是，<code>DbDataReader</code>和<code>DbDataAdapter</code>的区别以及各自的使用场景是什么？简单来说，前者是按需读取/只读，数据库连接会一直保持；而后者是一次读取，数据全部加载到内存，数据库连接用完就会关掉。从资源释放的角度，听起来后者更友好一点，可显然结果集越大占用的内存就会越多。而如果从易用性上来考虑，后者可以直接填充数据到<code>DataSet</code>或者<code>DataTable</code>，前者则需要费一点周折，你看这段代码是不是有点秀操作的意思：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种眼花缭乱的写法:)</span></span><br><span class="line">Console.WriteLine(<span class="string">$"AlbumId=<span class="subst">&#123;reader.GetValue(<span class="number">0</span>)&#125;</span>"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"Title=<span class="subst">&#123;reader.GetFieldValue&lt;<span class="keyword">string</span>&gt;(<span class="string">"Title"</span>)&#125;</span>"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"ArtistId=<span class="subst">&#123;reader.GetInt32(<span class="string">"ArtistId"</span>)&#125;</span>"</span>);</span><br></pre></td></tr></table></figure><p>在这个“遗产项目”中，<code>DbDataReader</code>和<code>DbDataAdapter</code>都有所涉猎，后者在结果集不大的情况下还是可以的，唯一的遗憾就是<code>DataTable</code>和<code>LINQ</code>的违和感实在太强烈了，虽然可以勉强使用<code>AsEnumerable()</code>拯救一下，而前者就有一点魔幻了，你能看到各种<code>GetValue(1)</code>、<code>GetValue(2)</code>这样的写法，这简直就是成心不想让后面维护的人好过，因为加字段的时候要小心翼翼地，确保字段顺序不会被修改。明明这个世界上有<a href="https://github.com/StackExchange/Dapper" target="_blank" rel="noopener">Dapper</a>、<a href="https://github.com/donet5/SqlSugar" target="_blank" rel="noopener">SqlSugar</a>、<a href="https://smartsql.net/" target="_blank" rel="noopener">SmartSql</a>这样优秀的ORM存在，为什么就要如此执著地写这种代码呢？是觉得MyBatis在XML里写SQL语句很时尚吗？</p><p>所以，我开始尝试改进这些代码，我希望它可以像Dapper一样，提供<code>Query&lt;T&gt;()</code>和<code>Execute()</code>两个方法足矣！如果要把结果集映射到一个具体的类型上，大家都能想到使用反射，我更想实现的是Dapper里的<code>DapperRow</code>，它可以通过“·”或者字典的形式来访问字段，现在的问题来了，你能实现类似Dapper里DapperRow的效果吗？因为想偷懒的时候，dynamic不比DataRow更省事儿吗？那玩意儿光转换类型就要烦死人了，更不用说要映射到某个DTO啦！</p><h1 id="实现DynamicRow"><a href="#实现DynamicRow" class="headerlink" title="实现DynamicRow"></a>实现DynamicRow</h1><p>通过阅读Dapper的源代码，我们知道，Dapper中用<a href="https://github.com/StackExchange/Dapper/blob/main/Dapper/SqlMapper.DapperTable.cs" target="_blank" rel="noopener">DapperTable</a>和<a href="https://github.com/StackExchange/Dapper/blob/main/Dapper/SqlMapper.DapperRowMetaObject.cs" target="_blank" rel="noopener">DapperRow</a>替换掉了DataTable和DataRow，可见这两个玩意儿有多不好用，果然，英雄所见略同啊，哈哈哈！其实，这背后的一切的功臣是<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.dynamic.idynamicmetaobjectprovider?view=net-5.0" target="_blank" rel="noopener">IDynamicMetaObjectProvider</a>，通过这个接口我们就能实现类似的功能，我们熟悉的<code>ExpendoObject</code>就是最好的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> person = <span class="keyword">new</span> ExpandoObject(); </span><br><span class="line">person.FirstName = <span class="string">"Sherlock"</span>; </span><br><span class="line">person.LastName = <span class="string">"Holmes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价形式</span></span><br><span class="line">(person <span class="keyword">as</span> IDctionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;)[<span class="string">"FirstName"</span>] = <span class="string">"Sherlock"</span>;</span><br><span class="line">(person <span class="keyword">as</span> IDctionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;)[<span class="string">"LastName"</span>] = <span class="string">"Holmes"</span>;</span><br></pre></td></tr></table></figure><p>这里，我们用一种简单的方式，让DynamicRow继承者DynamicObject，下面一起来看具体的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicRow</span> : <span class="title">DynamicObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDataRecord _record;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicRow</span>(<span class="params">IDataRecord record</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _record = record;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">TryGetMember</span>(<span class="params">GetMemberBinder binder, <span class="keyword">out</span> <span class="keyword">object</span> result</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> index = _record.GetOrdinal(binder.Name);</span><br><span class="line">        result = index &gt; <span class="number">0</span> ? _record[binder.Name] : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//支持像字典一样使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> <span class="keyword">this</span>[<span class="keyword">string</span> field] =&gt;</span><br><span class="line">       _record.GetOrdinal(field) &gt; <span class="number">0</span> ? _record[field] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>DynamicObject</code>这个类型而言，里面最重要的两个方法其实是<code>TryGetMember()</code>和<code>TrySetMember()</code>，因为这决定了这个动态对象的读和写两个操作。因为我们这里不需要反向地去操作数据库，所以，我们只需要关注<code>TryGetMember()</code>即可，一旦实现这个方法，我们就可以使用类似<code>foo.bar</code>这种形式访问字段，而提供一个索引器，则是为了提供类似<code>foo[&quot;bar&quot;]</code>的访问方式，这一点同样是为了像Dapper看齐，无非是Dapper的DynamicRow本来就是一个字典！</p><p>现在，我们来着手实现一个简化版的Dapper，给<code>IDbConnection</code>这个接口扩展出<code>Query&lt;T&gt;()</code>和<code>Execute()</code>两个方法，我们注意到<code>Query&lt;T&gt;()</code>需要用到<code>DbDataReader</code>或者<code>DbDataAdapter</code>其一，对于<code>DbDataAdapter</code>而言，它的实现完全由具体的子类决定，所以，对于<code>IDbConnection</code>接口而言，它完全不知道对应的子类是什么，此时，我们只能通过判断<code>IDbConnection</code>的类型来返回对应的DbDataAdapter。读过我之前<a href="https://blog.yuanpei.me/posts/3086300103/" target="_blank" rel="noopener">博客</a>的朋友，应该对Dapper里的数据库类型的字典有印象，不好意思，这里历史要再次上演啦！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="keyword">dynamic</span>&gt; <span class="title">Query</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="keyword">string</span> sql, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">object</span> param = <span class="literal">null</span>, IDbTransaction trans = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reader = connection.CreateDataReader(sql);</span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">DynamicRow</span>(<span class="params">reader <span class="keyword">as</span> IDataRecord</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;T&gt; Query&lt;T&gt;(<span class="keyword">this</span> IDbConnection connection, <span class="keyword">string</span> sql,</span><br><span class="line">  <span class="keyword">object</span> param = <span class="literal">null</span>, IDbTransaction trans = <span class="literal">null</span>) </span><br><span class="line">  where T : class, new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> reader = connection.CreateDataReader(sql);</span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="title">return</span> (<span class="params">reader <span class="keyword">as</span> IDataRecord</span>).Cast&lt;T&gt;(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>CreateDataReader()</code>和<code>Cast()</code>都是博主自定义的扩展方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IDataReader <span class="title">CreateDataReader</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="keyword">string</span> sql</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> command = connection.CreateCommand();</span><br><span class="line">    command.CommandText = sql;</span><br><span class="line">    command.CommandType = CommandType.Text;</span><br><span class="line">    <span class="keyword">return</span> command.ExecuteReader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static T Cast&lt;T&gt;(this IDataRecord record) where T:class, new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="function"><span class="keyword">var</span> property <span class="keyword">in</span> <span class="title">typeof</span>(<span class="params">T</span>).<span class="title">GetProperties</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> index = record.GetOrdinal(property.Name);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> propertyType = property.PropertyType;</span><br><span class="line">        <span class="keyword">if</span> (propertyType.IsGenericType &amp;&amp; </span><br><span class="line">          propertyType.GetGenericTypeDefinition() == <span class="keyword">typeof</span>(Nullable&lt;&gt;))</span><br><span class="line">            propertyType = Nullable.GetUnderlyingType(propertyType);</span><br><span class="line">        property.SetValue(instance, </span><br><span class="line">          Convert.ChangeType(record[property.Name], propertyType));</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>Execute()</code>方法则要简单的多，因为从<code>IDbConnection</code>到<code>IDbCommand</code>的这条线，可以直接通过<code>CreateCommand()</code>来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="keyword">string</span> sql, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">object</span> param = <span class="literal">null</span>, IDbTransaction trans = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> command = connection.CreateCommand();</span><br><span class="line">    command.CommandText = sql;</span><br><span class="line">    command.CommandType = CommandType.Text;</span><br><span class="line">    <span class="keyword">return</span> command.ExecuteNonQuery();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现参数化查询"><a href="#实现参数化查询" class="headerlink" title="实现参数化查询"></a>实现参数化查询</h1><p>大家可以注意到，我这里的参数param完全没有用上，这是因为<code>IDbCommand</code>的<code>Paraneters</code>属性显然是一个抽象类的集合。所以，从<code>IDbConnection</code>的角度来看这个问题的时候，它又不知道这个参数要如何来给了，而且像Dapper里的参数，涉及到集合类型会存在<code>IN</code>和<code>NOT IN</code>以及批量操作的问题，比普通的字符串替换还要稍微复杂一点。如果我们只考虑最简单的情况，它还是可以尝试一番的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetDbParameter</span>(<span class="params"><span class="keyword">this</span> IDbCommand command, <span class="keyword">object</span> param = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (param == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (param <span class="keyword">is</span> IDictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用字典作为参数</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> arg <span class="keyword">in</span> param <span class="keyword">as</span> IDictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;)</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">var</span> newParam = command.CreateParameter();</span><br><span class="line">              newParam.ParameterName = <span class="string">$"@<span class="subst">&#123;arg.Key&#125;</span>"</span>;</span><br><span class="line">              newParam.Value = arg.Value;</span><br><span class="line">              command.Parameters.Add(newParam);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用匿名对象作为参数</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> property <span class="keyword">in</span> param.GetType().GetProperties())</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">var</span> propVal = property.GetValue(param);</span><br><span class="line">              <span class="keyword">if</span> (propVal == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">var</span> newParam = command.CreateParameter();</span><br><span class="line">              newParam.ParameterName = <span class="string">$"@<span class="subst">&#123;property.Name&#125;</span>"</span>;</span><br><span class="line">              newParam.Value = propVal;</span><br><span class="line">              command.Parameters.Add(newParam);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地，为了能在<code>Query&lt;T&gt;()</code>和<code>Execute()</code>两个方法中使用参数，我们需要修改相关的方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="keyword">string</span> sql, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">object</span> param = <span class="literal">null</span>, IDbTransaction trans = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> command = connection.CreateCommand();</span><br><span class="line">    command.CommandText = sql;</span><br><span class="line">    command.CommandType = CommandType.Text;</span><br><span class="line">    command.SetDbParameter(param);</span><br><span class="line">    <span class="keyword">return</span> command.ExecuteNonQuery();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IDataReader <span class="title">CreateDataReader</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="keyword">string</span> sql, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">object</span> param = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> command = connection.CreateCommand();</span><br><span class="line">    command.CommandText = sql;</span><br><span class="line">    command.CommandType = CommandType.Text;</span><br><span class="line">    command.SetDbParameter(param);</span><br><span class="line">    <span class="keyword">return</span> command.ExecuteReader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，唯一的问题就剩下<code>DbType</code>和<code>@</code>啦，前者在不同的数据库中可能对应不同的类型，后者则要面临Oracle这朵奇葩的兼容性问题，相关内容可以参考在这篇博客：<a href="https://blog.yuanpei.me/posts/3086300103/" target="_blank" rel="noopener">Dapper.Contrib在Oracle环境下引发ORA-00928异常问题的解决</a>。到这一步，我们基本上可以实现类似Dapper的效果。当然，我并不是为了重复制造轮子，只是像从Dapper这样一个结果反推出相关的技术细节，从而可以串联起整个ASO.NET甚至是Entity Framework的知识体系，工作中解决类似的问题非常简单，直接通过NuGet安装Dapper即可，可如果你想深入了解某一个事物，最好的方法就是亲自去探寻其中的原理。现在基础设施越来越完善了，可有时候我们再找不回编程的那种快乐，大概是我们内心深处放弃了什么…..</p><p>考虑到，从微软的角度，它鼓励我们为每一家数据库去实现数据库驱动，所以，它定义了很多的抽象类。而从ORM的角度来考虑，它要抹平不同数据库的差异，Dapper的做法是给<code>IDbConnection</code>写扩展方法，而针对每个数据库的“方言”，实际上不管什么ORM都要去做这部分“脏活儿”，以前是分给数据库厂商去做，现在是交给ORM设计者去做，我觉得ADO.NET里似乎缺少了一部分东西，它需要提供一个IDbAdapterProvider的接口，返回IDbAdapter接口，这样就可以不用关心它是被如何创建出来的。你看，同样是设计接口，可微软和ServiceStack俨然是两种不同的思路，这其中的差异，足可窥见一斑矣！实际上，Entity Framework就是在以ADO.NET为基础发展而来的，在这个过程中，还是由厂商来实现对应的Provider。此时此刻，你悟到了我所说的“温故而知新”了嘛？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文实则由针对DataSet/DataTable的吐槽而引出，在这个过程中，我们重新温习了ADO.NET中<code>DbConnection</code>、<code>DbCommand</code>、<code>DbDataReader</code>、<code>DbDataAdapter</code>这些关键的组成部分，而为了解决DataTable在使用上的种种不变，我们想到了借鉴Dapper中的DapperRow来实现“动态查询”，由此引出了.NET中实现dynamic最重要的一个接口：<code>IDynamicMetaObjectProvide</code>，这使得我们可以在查询数据库的时候返回一个dynamic的集合。而为了更接近Dapper一点，我们基于扩展方法的形式为<code>IDbConnection</code>编写了<code>Query&lt;T&gt;()</code>和<code>Execute()</code>方法，在数据库读写层面上彻底终结了DataSet/DataTable的生命。最后，我们实现了一个简化版本的参数化查询，同样是借鉴Dapper的思路。这说明一件什么事情呢？<strong>当你在一个看似合理、结局固定的现状中无法摆脱的时候，“平躺”虽然能让你获得一丝喘息的机会，但与此同时，你永远失去了跳出这个层级去看待事物的机会</strong>，就像我以前吐槽同事天天用<code>StringBuider</code>拼接字符串一样，一味地吐槽是没有什么用的，重要的是你会选择怎么做，所以，后来我向大家推荐了<a href="https://github.com/dotliquid/dotliquid" target="_blank" rel="noopener">Linquid</a>，<strong>2021年已经来了，希望你不只是增长了年龄和皱纹</strong>，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="技巧" scheme="https://qinyuanpei.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Dapper" scheme="https://qinyuanpei.github.io/tags/Dapper/"/>
    
      <category term="ADO.NET" scheme="https://qinyuanpei.github.io/tags/ADO-NET/"/>
    
      <category term="Dynamic" scheme="https://qinyuanpei.github.io/tags/Dynamic/"/>
    
  </entry>
  
  <entry>
    <title>视频是不能P的系列：OpenCV人脸检测</title>
    <link href="https://qinyuanpei.github.io/posts/2997581895/"/>
    <id>https://qinyuanpei.github.io/posts/2997581895/</id>
    <published>2020-12-25T22:49:47.000Z</published>
    <updated>2021-05-28T02:08:18.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>恍惚间，2020年已接近尾声，回首过去这一年，无论是疫情、失业还是“996”，均以某种特殊的方式铭刻着这一年的记忆。也许，是这个冬天的西安雾霾更少一点。所以，有时透过中午的一抹冬阳，居然意外地觉得春天的脚步渐渐近了，甚至连圣诞节这种“洋节日”都感到亲切而且期待，我想，这大概是我丧了一段时间的缘故吧！可不管怎样，人们对未来的生活时常有一种“迷之自信”，果然生还还是要继续下去的呀！趁着最近的时间比较充裕，我决定开启一个信息的系列：视频是不能P的。这是互联网上流传的一个老梗了，正所谓“视频是不能P的，所以是真的”。其实，在如今这个亦真亦假的世界里，哪里还有什么东西是不能PS的呢？借助人工智能“改头换面”越来越轻而易举，而这背后关于隐私和伦理的一连串问题随之而来，你越来越难以确认屏幕对面的那个是不是真实的人类。所以，这个系列会以OpenCV作为起点，去探索那些好玩、有趣的视频/图像处理思路，通过技术来证明视频是可以被PS的。而作为这个系列的第一篇，我们将从一个最简单的地方开始，它就是人脸检测。</p><h1 id="第一个入门示例"><a href="#第一个入门示例" class="headerlink" title="第一个入门示例"></a>第一个入门示例</h1><p>学习OpenCV最好的方式，就是从官方的示例开始，我个人非常推荐的两个教程是 <a href="https://docs.opencv.org/3.4/db/d28/tutorial_cascade_classifier.html" target="_blank" rel="noopener">OpenCV: Cascade Classifier</a> 和 <a href="https://pythonexamples.org/python-opencv/" target="_blank" rel="noopener">Python OpenCV Tutorial</a>，其次是 <a href="https://blog.csdn.net/poem_qianmo" target="_blank" rel="noopener">浅墨大神</a> 的<a href="https://blog.csdn.net/poem_qianmo/category_9262318.html" target="_blank" rel="noopener">【OpenCV】入门教程</a>，不同的是， <a href="https://blog.csdn.net/poem_qianmo" target="_blank" rel="noopener">浅墨大神</a> 的教程主要是使用C++，对于像博主这样的“不学无术”的人，这简直无异于从入门到放弃，所以，建议大家结合自己的实际情况，选择适合自己的“难度”。好了，思绪拉回我们这里，在OpenCV中实现人脸检测，主要分为以下三个步骤，即，首先，定义联级分类器<strong>CascadeClassifier</strong>并载入指定的模型文件；其次，对待检测目标进行灰度化和直方图均衡化处理；最后，对灰度图调用<code>detectMultiScale()</code>方法进行检测。下面是一个简化过的入门示例，使用世界上最省心的Python语言进行编写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤1: 定义联级分类器CascadeClassifier并载入指定的模型文件</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">'./haarcascades/haarcascade_frontalface_alt2.xml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2: 对待检测目标进行灰度化和直方图均衡化处理</span></span><br><span class="line">target = cv2.imread(<span class="string">'target.jpg'</span>)</span><br><span class="line">target_gray = cv2.cvtColor(target, cv2.COLOR_BGR2GRAY)</span><br><span class="line">target_gray = cv2.equalizeHist(target_gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3: 人脸检测</span></span><br><span class="line">faces = faceCascade.detectMultiScale(target_gray)</span><br><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.rectangle(target, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4: 展示结果</span></span><br><span class="line">cv2.imshow(<span class="string">'Face Detection'</span>, target)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>正常情况下，你会得到下面的结果，这里选取的素材是经典日剧《半泽直树》：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/12/25/DcQRW32aUTBx5lY.png" alt="OpenCV人脸检测效果展示" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">OpenCV人脸检测效果展示</div>            </figure><p>怎么样？是不是被OpenCV的强大给震惊到了？下面我们针对每个步骤做更详细的说明：</p><ul><li>第1行引入OpenCV，需要我们安装OpenCV的<a href="https://pypi.org/project/opencv-python/" target="_blank" rel="noopener">Python版本</a>。</li><li>第4行实例化级联分类器CascadeClassifier，关于这个级联分类器，它是OpenCV下做目标检测的模块，内置<strong>Haar</strong>、<strong>HOG</strong>和<strong>LBP</strong>三类特性算法，而所谓“级联”，则是指它通过多个强分类器串联实现最终分类的思路。在初始化级联分类器的时候，需要载入指定的模型文件，这些模型文件是官方提前训练好的，可以从<a href="https://github.com/opencv/opencv/tree/master/data/haarcascades" target="_blank" rel="noopener">Github</a>上进行下载，不同的模型文件对应不同的功能，这里使用的<code>haarcascade_frontalface_alt2.xml</code>主要针对面部检测，而像<code>haarcascade_eye_tree_eyeglasses.xml</code>则可以对眼睛进行检测。除此之外，我们还通过训练获得自己的模型文件，当然，这一切都是后话啦！</li><li>第7~9行，我们载入了一张图片素材，并对其进行了灰度化和直方图均衡化处理。这里需要关注的三个函数是：<a href="">imread</a>、<a href="https://docs.opencv.org/3.4/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab">cvtColor</a> 和 <a href="https://docs.opencv.org/3.4/d6/dc7/group__imgproc__hist.html#ga7e54091f0c937d49bf84152a16f76d6e" target="_blank" rel="noopener">equalizeHist</a>，它们的作用分别是读取图片、转换颜色和直方图均衡化处理。其中，对人脸检测而言，灰度图是必要的条件，而直方图均衡化则是可选的一个过程。</li><li>第12~14行，通过 <a href="https://docs.opencv.org/3.4/d1/de5/classcv_1_1CascadeClassifier.html#aaf8181cb63968136476ec4204ffca498" target="_blank" rel="noopener">detectMultiScale</a> 方法我们就可以对待检测目标进行检测，关于它的参数，常用的有scaleFactor、minNeighbors、minSize、maxSize，它可以对人脸检测做进一步的细节上控制，对于我们而言，我们更关心检测的结果，这里我们将检测到的人脸区域以矩形的方式绘制出来。</li><li>第17~19行，主要是为了方面大家观察结果，实际使用中可能会输出为文件或者实时渲染，这里需要关注的重点函数是：<a href="https://docs.opencv.org/3.4/df/d24/group__highgui__opengl.html#gaae7e90aa3415c68dba22a5ff2cefc25d" target="_blank" rel="noopener">imshow</a>，顾名思义，它可以让图片展示在窗口中，类似我们这个示例中的效果。</li></ul><h1 id="柴犬界的“网红”"><a href="#柴犬界的“网红”" class="headerlink" title="柴犬界的“网红”"></a>柴犬界的“网红”</h1><p>曾经，有“好事者”分析过微信和QQ的年度表情，表情包文化流行的背后，实际上表达方式多样化的一种体现，例如：“笑哭”这一符号，固然有哭笑不得的含义在里面，可又何尝不是<strong>二十多岁人生总是边哭边笑的真实写照</strong>呢？而“捂脸”这一符号在我看来更多的是一种无可奈何，甚至有一种自我嘲讽的意味在里面。至于“呲牙”，<strong>朴实无华的微笑背后，大抵是看惯了庭前花开花落，可以“不以物喜，不以己悲”地笑对人生吧</strong>！其实，在这许许多多地表情里，我最喜欢的是微博里的“Doge”，这个眉清目秀的“狗头”能表达出各种丰富的含义，相比之下，微信里的“Doge”就有一点拙劣的模仿的意味了，俗话说<strong>“狗头保命”</strong>，在一个互联网信仰缺失的时代，用这样一种表情作为人类的保护色，又是不是一种反讽呢？而大家都知道，这个“Doge”表情，实际上是源于一个叫做<a href="https://baike.baidu.com/item/Homestar%20Runner" target="_blank" rel="noopener">Homestar Runner</a>的网上动画系列，其原型则来源于一只名为<a href="https://baijiahao.baidu.com/s?id=1567521374438179&wfr=spider&for=pc" target="_blank" rel="noopener">Kabosu</a>的柴犬，由于它融合了萌宠和故意搞笑两大特点，因此在网络上迅速走红，并由此衍生出一系列二次创作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/12/26/i3OZfYwHvugT6JU.png" alt="微信年度表情" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">微信年度表情</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/12/26/lN9ZgjuXxfs54cF.jpg" alt="QQ年度表情" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">QQ年度表情</div>            </figure><p>现在，让我们唤醒身体里的中二灵魂，通过OpenCV让这个柴犬界的网红出现在我们面前。这里的思路是，在检测到人脸后，在人脸区域绘制一个“狗头”表情，为此，我们需要定义一个<code>copyTo()</code>函数，它可以将一张小图(MaskImage)绘制到大图(SrcImage)的指定位置，我们一起来看它的具体实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyTo</span><span class="params">(srcImage, maskImage, x, y, w, h)</span>:</span></span><br><span class="line">    <span class="comment"># 按照区域大小对maskImage进行缩放</span></span><br><span class="line">    img_h, img_w, _ = maskImage.shape</span><br><span class="line">    img_scale = h / img_h</span><br><span class="line">    new_w = int(img_w * img_scale)</span><br><span class="line">    new_h = int(img_h * img_scale)</span><br><span class="line">    img_resize = cv2.resize(maskImage ,(new_w ,new_h))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># “粘贴”小图到大图的指定位置</span></span><br><span class="line">    <span class="keyword">if</span> (srcImage.shape[<span class="number">2</span>] != maskImage.shape[<span class="number">2</span>]):</span><br><span class="line">        y1, y2 = y, y + img_resize.shape[<span class="number">0</span>]</span><br><span class="line">        x1, x2 = x, x + img_resize.shape[<span class="number">1</span>]</span><br><span class="line">        alpha_s = img_resize[:, :, <span class="number">3</span>] / <span class="number">255.0</span></span><br><span class="line">        alpha_l = <span class="number">1.0</span> - alpha_s</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            srcImage[y1:y2, x1:x2, c] = (</span><br><span class="line">                alpha_s * img_resize[:, :, c] + alpha_l * srcImage[y1:y2, x1:x2, c]</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        srcImage[y:y + img_resize.shape[<span class="number">0</span>], x:x + img_resize.shape[<span class="number">1</span>]] = img_resize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> srcImage</span><br></pre></td></tr></table></figure><p>在这里，我们首先要关注这样一件事情，即OpenCV默认使用的是由R、G、B组成的三通道，可对于像PNG这种格式的图片，它会含有一个Alpha通道。这样，当我们尝试把一张含Alpha通道的小图，“粘贴”到只有R、G、B三个通道的大图上时，就会出现通道数对不上的问题，所以，这个函数实际上对这种情况做了特殊处理。其次，每一个OpenCV中的图片，即Mat，其shape属性是一个由三个元素组成的元组，依次为图片高度、图片宽度和图片通道数。“黏贴”的过程实际上是修改对应位置处的像素信息。好了，现在，我们来修改一下第一版的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1: 定义联级分类器CascadeClassifier并载入指定的模型文件</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">'./haarcascades/haarcascade_frontalface_alt2.xml'</span>)</span><br><span class="line"><span class="comment"># cv2.IMREAD_UNCHANGED表示保留Alpha通道信息</span></span><br><span class="line">doge = cv2.imread(<span class="string">'doge-4.png'</span>, cv2.IMREAD_UNCHANGED) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2: 对待检测目标进行灰度化和直方图均衡化处理</span></span><br><span class="line">target = cv2.imread(<span class="string">'target.jpg'</span>)</span><br><span class="line">target_gray = cv2.cvtColor(target, cv2.COLOR_BGR2GRAY)</span><br><span class="line">target_gray = cv2.equalizeHist(target_gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3: 人脸检测</span></span><br><span class="line">faces = faceCascade.detectMultiScale(target_gray)</span><br><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">    target = copyTo(target, doge, x, y, w, h) <span class="comment"># 粘贴“狗头”表情至每一个面部区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4: 展示结果</span></span><br><span class="line">cv2.imshow(<span class="string">'Face Detection'</span>, target)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>此时，我们就可以得到下面的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/12/26/Y9Al67cnvtgWmBz.png" alt="全员Doge!" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">全员Doge!</div>            </figure><p>其实，我本人更喜欢这张，一张充满精神污染意味的图片：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/12/26/8QaJlR5XIxLftCo.png" alt="来自神烦狗的精神污染" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">来自神烦狗的精神污染</div>            </figure><h1 id="视频级PS入门"><a href="#视频级PS入门" class="headerlink" title="视频级PS入门"></a>视频级PS入门</h1><p>OK，相信到这里为止，各位读者朋友，都已经顺着博主的思路实现了图片级别的“PS”，既然我们这个系列叫<strong>做视频是不能P的</strong>，那么大家要问了，视频到底能不能P呢？答案显然是可以，不然博主写这个系列就不是“人脸检测”而是“人肉打脸”啦！下面，我们来继续对今天的这个例子做一点升级。考虑在OpenCV中，<strong>VideoCapture</strong>可以通过摄像头捕捉视频画面，所以，我们只需要把这个“狗头”绘制到每一帧画面上，就可以实现视频级别的PS啦！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1: 定义联级分类器CascadeClassifier并载入指定的模型文件</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">'./haarcascades/haarcascade_frontalface_alt2.xml'</span>)</span><br><span class="line">doge = cv2.imread(<span class="string">'doge-4.png'</span>, cv2.IMREAD_UNCHANGED)</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>) <span class="comment">#笔记本自带摄像头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    ret, frame = cap.read() </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤2: 对待检测目标进行灰度化和直方图均衡化处理</span></span><br><span class="line">    <span class="comment"># 读取视频中每一帧</span></span><br><span class="line">    target = frame</span><br><span class="line">    target_gray = cv2.cvtColor(target, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    target_gray = cv2.equalizeHist(target_gray)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤3: 人脸检测</span></span><br><span class="line">    faces = faceCascade.detectMultiScale(target_gray)</span><br><span class="line">    <span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">        target = copyTo(target, doge, x, y, w, h)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤4: 展示结果</span></span><br><span class="line">    cv2.imshow(<span class="string">'Face Detection'</span>, target)</span><br><span class="line">    <span class="comment"># 按Q退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release() </span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>一起来看看实现的效果吧！可能当你看完这篇博客的时候，你会觉得我写这玩意儿到底有什么用？不好意思，这玩意儿还真有用！它解决了像博主这样腼腆、不敢在公开场合抛头露面的人的困惑。暴走大事件里“王尼玛”一直戴着头罩，所以，很多人都好奇他本人到底长什么样子，如果当时能考虑这个思路的话，是不是可以不用一直戴着头罩。同样地，还有在浪客剑心真人版里饰演志志雄真实的藤原龙也，全身上下缠满绷带的造型其实对演员来说是非常不友好的，如果当时能考虑这个思路的话，是不是演员可以不用受那么大的罪。如果说这些都有些遥远的话，那么，至少在采访后期希望保护受访者隐私的场景下，这个思路是完全可行的，就像大家看到的它可以完全的遮挡住我的脸，而类似的打马赛克等等技术，本质上还是对图像进行处理，甚至美颜相机里的各种特效，底层都离不开OpenCV里的这些算法。怎么样？现在有没有觉得博主其实是一个非常有趣的人，哈哈!</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/12/26/CZi4SYOgzsoy8Qk.gif" alt="视频级别的“PS”" title="" referrerpolicy="no-referrer">                </div>                <div class="image-caption">视频级别的“PS”</div>            </figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客主要分享了OpenCV在人脸检测方面的简单应用，OpenCV中的CascadeClassifier整合<strong>Haar</strong>、<strong>HOG</strong>和<strong>LBP</strong>三类特性算法，通过预置的模型文件可以实现不同程度的目标检测功能，而在人脸检测的基础上，我们可以通过训练来实现简单的人脸识别，正如今年爆发的新冠疫情让人脸识别出现新的挑战一样，虽然人脸识别的场景正在变得越来越复杂，可作为一个世界上最流行的计算机视觉库，OpenCV中的各种模块、算法还是一如既往的经典。结合imread()、resize()、cvtColor()等等的方法，我们可以将“狗头”表情贴到图片或者视频中的人脸区域，而这个思路可以为人脸遮挡相关的场景做一点探索。</p><p>在一个流行美颜的时代，人们对于别人甚至自己的期望在无限拔高，像博主本人一直不怎么喜欢拍照，有时候我们埋怨别人没有把我们拍得好看一点，可那究竟是你眼中的自己还是别人眼中的自己呢？正如相亲的时候，人们总喜欢把最好的、美化过的一面展示给别人，因为只有这样才能让别人对你产生兴趣，可往往现实的落差会让这种来得快的兴趣消失得更快。所以，我想说，虽然在技术面前万物似乎皆可“PS”，可对于我们自己而言，你是否了解真正的自己呢？关于我博客的写作风格，我一直不确定是要用偏严谨还是偏活泼的方式来表达，因为眼看着被后浪们一点点超越，这实在是种难以言说的感觉，欢迎大家在评论区留下你对博客内容或者观点的想法，祝大家周末愉快，一个人一样要活得浪漫！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="OpenCV" scheme="https://qinyuanpei.github.io/tags/OpenCV/"/>
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="图像处理" scheme="https://qinyuanpei.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="人脸检测" scheme="https://qinyuanpei.github.io/tags/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
</feed>
