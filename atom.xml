<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一个人的孤落时辰</title>
  
  <subtitle>纵有疾风起，人生不言弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinyuanpei.github.io/"/>
  <updated>2022-03-07T01:40:22.302Z</updated>
  <id>https://qinyuanpei.github.io/</id>
  
  <author>
    <name>飞鸿踏雪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gRPC 流式传输极简入门指南</title>
    <link href="https://qinyuanpei.github.io/posts/953529732/"/>
    <id>https://qinyuanpei.github.io/posts/953529732/</id>
    <published>2022-02-18T09:34:36.000Z</published>
    <updated>2022-03-07T01:40:22.302Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>最近一直在研究 gRPC 的 <a href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md" target="_blank" rel="noopener">ServerReflection</a>，顾名思义，这是 gRPC 里提供的反射接口，当你需要获取某个接口的描述信息，或者是希望动态调用 gRPC 的时候，这一切就会变得非常有用，如果你经常使用 <a href="https://github.com/fullstorydev/grpcui/" target="_blank" rel="noopener">gRPC UI</a> 这款工具来调试 gRPC 接口，那么，你一定会注意到一件事情，即它要求服务端必须支持 ServerReflection API，而这一点在 ASP.NET Core 中已经得到支持，对此感兴趣的朋友可以参考<a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/test-tools?view=aspnetcore-6.0#set-up-grpc-reflection" target="_blank" rel="noopener">官方文档</a>。当然，这并不是我想表达的重点(我就知道)。重点是什么呢？在使用 ServerReflection API 的过程中，我发现它采用了 gRPC 双向流的方式来进行交互，在过去的日子里，我研究过诸如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events" target="_blank" rel="noopener">Server-Sent Events</a> 等等服务器推送的技术，我意识到这是一个非常接近的技术，所以，今天这篇文章，我们来一起聊聊 gRPC 中的流式传输。</p><h1 id="从-HTTP-2-说起"><a href="#从-HTTP-2-说起" class="headerlink" title="从 HTTP/2 说起"></a>从 HTTP/2 说起</h1><p>首先，我想说，流式传输并不是一个新的概念，这一切就好像，即使你从来没有听过流媒体的概念，可这并不妨碍你追剧、刷短视频，隐隐然有种“不识庐山真面目，只缘身在此山中”的感觉。随着网络带宽和硬件水平的不断提升，越来越多的云服务变得像水、电、天然气一样寻常，以此作喻，流式传输，就像你打开水龙头，此时，水就会源源不断地流出来，并且可以做到随用随取。因此，流式传输实际上就是指通过网络传输媒体，例如音频、视频等的技术统称，服务器可以连续地、实时地向客户端发送数据，而客户端不必等所有数据发送完就可以访问这些数据。按照实现方式的不同，流式传输可以分为 <code>实时流式传输</code> 和 <code>顺序流式传输</code> 两种，前者通常指<code>RTP/RTCP</code>，典型的场景是直播；后者通常是指由 Nginx、Apache 等提供支持的顺序下载。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="gRPC-流式传输极简入门指南/HTTP_1.1_vs_HTTP_2.0.png" alt="HTTP/1.1 vs HTTP/2" referrerpolicy="no-referrer"></div><div class="image-caption">HTTP/1.1 vs HTTP/2</div></figure><p>如果你对 HTTP/2 有一定了解的话，就会知道它最为人所知的特性是多路复用。在 HTTP/1.1 的时代，同一个时刻只能对一个请求进行处理或者响应，换句话说，下一个请求必须要等当前请求处理完才能继续进行，与此同时，浏览器为了更快地加载页面资源，对同一个域名下的请求并发数进行了限制，所以，你会注意到一个有趣的现象，部分网站会使用多个 CDN 加速的域名，而这正是为了规避浏览器的这一限制，HTTP/1.1 时代，可以称为“半双工模式”。到了 HTTP/2 的时代，多路复用的特性让一次同时处理多个请求成为了现实，并且同一个 TCP 通道中的请求不分先后、不会阻塞，是真正的“全双工通信”。一个和本文更贴近的概念是流，HTTP/2 中引入了流(Stream) 和 帧(Frame) 的概念，当 TCP 通道建立以后，后续的所有操作都是以流的方式发送的，而二进制帧则是组成流的最小单位，属于协议层上的流式传输。</p><h1 id="gRPC-中的流式传输"><a href="#gRPC-中的流式传输" class="headerlink" title="gRPC 中的流式传输"></a>gRPC 中的流式传输</h1><p>OK，现在我们正式开始 gRPC 流式传输的话题。首先，对于一个 gRPC 接口而言，它的起源是 Protobuf 定义。所以，一个最为直观的认识是从 Protobuf 定义入手：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> SimplePing(PingRequest) <span class="keyword">returns</span> (PingReply)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端流式 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ClientStreamPing(stream PingRequest) <span class="keyword">returns</span> (PingReply)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端流式 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ServerStreamPing(PingRequest) <span class="keyword">returns</span> (stream PingReply)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向流式 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> BothStreamPing(stream PingRequest) <span class="keyword">returns</span> (stream PingReply)</span>;</span><br></pre></td></tr></table></figure><p>可以注意到，相比普通的 RPC 方法(UnaryCall)，采用流式传输的 gRPC 接口，主要是多了一个<code>stream</code>关键字。当该关键字修饰参数时，表示这是一个客户端流式的 gRPC 接口；当该参数修饰返回值时，表示这是一个服务器端流式的 gRPC 接口；当该关键字同时修饰参数和返回值时，表示这是一个双向流式的 gRPC 接口。作为类比，双向流式的 gRPC 接口，约等于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket</a>，即客户端、服务器端都可以以流的形式收/发数据；服务器端流式的 gRPC 接口，约等于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events" target="_blank" rel="noopener">Server-Sent Events</a>，即服务器端以流的形式发数据。同理，客户端流式的 gRPC 接口，即客户端以流的的形式发数据。</p><p>我为什么会突然对这个话题产生兴趣呢？个人以为，主要有两个原因：其一，是工作中使用流式传输的机会不多，即使遇到数据量特别大的场合，大家想到的一定是修改 gRPC 数据传输的大小，而不是采用流式传输的做法；其二，是我注意到像 <a href="https://istio.io/" target="_blank" rel="noopener">Istio</a>、<a href="https://www.envoyproxy.io/" target="_blank" rel="noopener">Envoy</a>、<a href="https://nacos.io/zh-cn/" target="_blank" rel="noopener">Nacos</a> 等项目，内部都是用 gRPC 作为通信协议，当你需要实现一个控制平面的时候，你会发现那里有大量的流式 gRPC 接口等着你去实现。此前，我有一点关乎 gRPC 的想法，譬如动态地为 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">gRPC-JSON Transcoder</a> 生成配置信息、利用 <a href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md" target="_blank" rel="noopener">ServerReflection</a> 扩展 Swagger 等等，毫无疑问，这一切都需要你去了解 gRPC 的流式传输，一组重要的 API 是 <code>IAsyncStreamReader&lt;T&gt;</code> 和 <code>IAsyncStreamReader&lt;T&gt;</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、调用 ServerReflection 获取 gRPC 服务</span></span><br><span class="line"><span class="keyword">var</span> callResult = _serverReflectionClient.ServerReflectionInfo(</span><br><span class="line">    deadline: deadline, </span><br><span class="line">    cancellationToken: cancellationToken</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义一个 Task 来解析服务端响应的流</span></span><br><span class="line"><span class="keyword">var</span> resolveServiceListTask = Task.Run(<span class="keyword">async</span> () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">await</span> callResult.ResponseStream.MoveNext(cancellationToken))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> service <span class="keyword">in</span> callResult.ResponseStream.Current.ListServicesResponse.Service)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(service.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、客户端以流的方式写入参数</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> ServerReflectionRequest() &#123; ListServices = <span class="string">""</span> &#125;;</span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.WriteAsync(request);</span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.CompleteAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、客户端以流的方式读出结果</span></span><br><span class="line"><span class="keyword">await</span> resolveServiceListTask;</span><br></pre></td></tr></table></figure><p>如图所示，你大概可以理解 gRPC 流式传输的运作过程，<code>RequestStream</code> 实现了 <code>IAsyncStreamWriter&lt;T&gt;</code> 接口，负责流的写入，调用 <code>CompleteAsync()</code> 方法时表示数据已经写完；<code>ResponseStream</code> 实现了 <code>IAsyncStreamReader&lt;T&gt;</code> 接口，负责流的读取，典型的迭代器模式，如果你听说过 C# 8.0 里的异步流(AsyncStream)，就应该会知道，它属于可枚举类(Enumerable)异步变体，我相信，<code>MoveNext()</code> 和 <code>Current</code> 就不需要再做多余的解释啦，哈哈！</p><h2 id="客户端流"><a href="#客户端流" class="headerlink" title="客户端流"></a>客户端流</h2><p>对于客户端流式 gRPC 接口而言，客户端负责写入流，服务器端负责读取流，所以，<code>ClientStreamPing()</code> 会生成下面的方法签名，这里是一个简单的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;PingReply&gt; <span class="title">ClientStreamPing</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    IAsyncStreamReader&lt;PingRequest&gt; requestStream, </span></span></span><br><span class="line"><span class="function"><span class="params">    ServerCallContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从 IAsyncStreamReader&lt;T&gt; 中读取流并放入队列</span></span><br><span class="line">    <span class="keyword">var</span> requestQueue = <span class="keyword">new</span> Queue&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">await</span> requestStream.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        requestQueue.Enqueue(requestStream.Current.RequestId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队列中取出数据并返回</span></span><br><span class="line">    <span class="keyword">if</span> (requestQueue.TryDequeue(<span class="keyword">out</span> <span class="keyword">var</span> requestId))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PingReply() &#123; RequestId = requestId, Message = <span class="string">"OK"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PingReply() &#123; RequestId = <span class="keyword">string</span>.Empty, Message = <span class="string">""</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，客户端对应实现如下，继续沿用 <code>IAsyncStreamWriter&lt;T&gt;</code> 的套路：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callResult = heartBeatClient.ClientStreamPing();</span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.WriteAsync(<span class="keyword">new</span> PingRequest() &#123; </span><br><span class="line">    RequestId = GetCurrentTimeStamp().ToString() </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.CompleteAsync();</span><br><span class="line"><span class="keyword">var</span> reply = <span class="keyword">await</span> callResult.ResponseAsync;</span><br></pre></td></tr></table></figure><h2 id="服务器端流"><a href="#服务器端流" class="headerlink" title="服务器端流"></a>服务器端流</h2><p>服务器端的流式 gRPC，意味着服务端会通过 <code>IAsyncStreamWriter&lt;T&gt;</code> 以流的方式写入数据：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">ServerStreamPing</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">     PingRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">     IServerStreamWriter&lt;PingReply&gt; responseStream, </span></span></span><br><span class="line"><span class="function"><span class="params">     ServerCallContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    responseStream.WriteAsync(<span class="keyword">new</span> PingReply() &#123; </span><br><span class="line">        RequestId = request.RequestId, </span><br><span class="line">        Message = <span class="string">"OK"</span> </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，客户端还是像使用普通方法一样调用即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reply = heartBeatClient.ServerStreamPing(<span class="keyword">new</span> PingRequest() &#123; </span><br><span class="line">    RequestId = GetCurrentTimeStamp().ToString() </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="双向流"><a href="#双向流" class="headerlink" title="双向流"></a>双向流</h2><p>一旦我们熟悉了这个套路，理解双向流就再没有什么难度，客户端和服务器端都用 <code>IAsyncStreamWriter&lt;T&gt;</code> 和 <code>IAsyncStreamWriter&lt;T&gt;</code> 进行读写即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读数据</span></span><br><span class="line"><span class="keyword">var</span> requestQueue = <span class="keyword">new</span> Queue&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">await</span> requestStream.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    requestQueue.Enqueue(requestStream.Current.RequestId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写数据</span></span><br><span class="line"><span class="keyword">while</span> (requestQueue.TryDequeue(<span class="keyword">out</span> <span class="keyword">var</span> requestId))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> PingReply() &#123; </span><br><span class="line">        RequestId = requestId, </span><br><span class="line">        Message = <span class="string">"OK"</span> </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，客户端采用类似的做法，这里我们发 10 次心跳看看：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  写数据</span></span><br><span class="line"><span class="keyword">var</span> callResult = heartBeatClient.BothStreamPing();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> callResult.RequestStream.WriteAsync(<span class="keyword">new</span> PingRequest() &#123; </span><br><span class="line">        RequestId = GetCurrentTimeStamp().ToString() </span><br><span class="line">    &#125;);</span><br><span class="line">    Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.CompleteAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读数据</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">await</span> callResult.ResponseStream.MoveNext(CancellationToken.None))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> reply4 = callResult.ResponseStream.Current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们就可以得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="gRPC-流式传输极简入门指南/gRPC-Streaming.png" alt="gRPC 双向流效果演示" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC 双向流效果演示</div></figure><p>个人感觉，这个可以用在那些需要做双向通信的场合，譬如心跳检测、数据看板、日志监控等等，坦白来讲，相对于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events" target="_blank" rel="noopener">Server-Sent Events</a> 等等服务器推送技术，gRPC 的双向流优势并不显著，唯一的优势可能是 HTTP/2 多路复用带来的性能上的提升。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>最近的状态一直不太好，因为工作中的琐事消耗了大量精力。因而，这篇平淡如白开水般的线性叙事，委实不能被称之为一篇博客，而这大概就是我这段时间的真实写照。作为一名双子座，我的好奇心常常引导着我去关注那些意外的收获，就像 gRPC 里的流式传输，本质上因为我想通过 <a href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md" target="_blank" rel="noopener">ServerReflection</a> 为 gRPC 构建一份 Swagger 风格的 API 文档，这个工作目前还有些悬而未决的问题。当然，在这个过程中，大致搞懂了如何去动态调用一个 gRPC 接口，因为 <a href="https://github.com/qinyuanpei/FluentGrpc.Gateway" target="_blank" rel="noopener">FluentGrpc.Gateway</a> 目前依赖 gRPC 生成客户端代码，或者说这种建立在动态链接库上的方案有一定的缺陷。类似地，工作中发现 Envoy 的 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">gRPC-JSON Transcoder</a> 插件，需要手动配置每一个 gRPC 服务，开始琢磨怎么能让这个过程更智能一点，发现需要 Envoy 的 xDS API、了解控制平面，这种感觉就像在挖一口井，能不能看到水我不知道，每一铲子下去都有意外收获，这种探险的感觉非常有趣，唯一的平衡点在于，主动的发现永远都会比被动的接受花更多的时间。这篇流水账主要介绍了 gRPC 里流式传输，即客户端流、服务器端流和双向流，如果你足够有心，不妨回过头看看这篇文章 <a href="/posts/1679688265/">ASP.NET Core gRPC 拦截器的使用技巧分享</a>，我相信你会有不一样的感悟，好了，这就是全部的内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="教程" scheme="https://qinyuanpei.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Streaming" scheme="https://qinyuanpei.github.io/tags/Streaming/"/>
    
  </entry>
  
  <entry>
    <title>烟波梦影，从天国王朝到刺客信条</title>
    <link href="https://qinyuanpei.github.io/posts/861688878/"/>
    <id>https://qinyuanpei.github.io/posts/861688878/</id>
    <published>2022-02-03T18:30:45.000Z</published>
    <updated>2022-03-07T01:40:22.330Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>最近看了一部叫做<a href="https://movie.douban.com/subject/1309071/" target="_blank" rel="noopener">《天国王朝》</a>的电影，主要讲述了第三次十字军东征时期的一段故事：法兰克铁匠巴利安，因为受到失散多年的父亲的召唤，亦是为了替自杀而死的妻子寻求救赎，来到了三教圣城——耶路撒冷。其间，父亲亡故，巴利安承袭了爵位和封地，甚至得到了西贝拉公主的青睐，可这依然无法阻止他深陷十字军的政治漩涡。当时，身染麻风病的耶路撒冷王鲍德温四世与阿拉伯传奇英雄萨拉丁，维持着基督教与伊斯兰教之间脆弱的和平；而以居伊和雷纳德为首的好战势力，则通过袭击穆斯林的方式不断挑起争端。战争终于不可避免地爆发了，这正是历史上著名的哈丁之战。此后，狮心王理查一世独自面对东方世界的滚滚黄沙，东西方的军事、宗教和文化碰撞出火花，更是堪比双子星一般的存在。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="P9832764530.jpg" alt="天国王朝中的巴利安男爵形象" referrerpolicy="no-referrer"></div><div class="image-caption">天国王朝中的巴利安男爵形象</div></figure><h1 id="圣城耶路撒冷"><a href="#圣城耶路撒冷" class="headerlink" title="圣城耶路撒冷"></a>圣城耶路撒冷</h1><p>熟悉刺客信条系列的朋友，此刻应该会想到，这个系列的第一部作品，正是取材于第三次十字军东征时期，主角阿泰尔则是活跃在该时期的一名叙利亚刺客。因为电影中出现了刺客的敌对势力——<a href="https://baike.sogou.com/v74701.htm" target="_blank" rel="noopener">圣殿骑士(团)</a>。所以，我觉得透过历史去打通电影和游戏会是一件非常有趣的事情。也许，中世纪时期发生的事情，到今天已然无法做到存伪去真，可正如我曾经迷恋过亚瑟王从石头中拔出(伊甸)圣剑的故事一样，圆桌骑士或者说骑士本身，在一个(中二)男人眼中是接近武侠小说里侠客的存在。所以，在一个武侠没落的时代，你就不难理解，我为什么会喜欢上刺客信条这样一款游戏。虽然，这些骑士相当迷信，动辄要通过决斗让上帝来裁决，可就像塞万提斯笔下的<a href="https://book.douban.com/subject/24854061/" target="_blank" rel="noopener">堂·吉诃德</a>一样，当他准备大战风车的那一刻，你又会觉得他是一个英雄。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Altaïr.png" alt="刺客信条中阿泰尔施展信仰之跃" referrerpolicy="no-referrer"></div><div class="image-caption">刺客信条中阿泰尔施展信仰之跃</div></figure><p>故事要从哪里说起呢？我想，应该从鲍德温四世那场著名的战役——蒙吉萨之战说起。那一年，年仅16岁的鲍德温四世，率领3000人击败了20000人的萨拉丁军队。这段历史带给我的震撼，丝毫不亚于中国历史上的官渡之战和淝水之战。如果你对此毫无概念，不妨对比一下孙权的合肥之战，当时的孙权号称有100000人的兵力，而张辽只有800人，史称“孙十万与张八百”。这一场战役令鲍德温四世获得了极好的威望，而雷纳德则因为参与了这场战役而成为主战派的首领。可惜，这场堪称为传奇的胜利仅仅为耶路撒冷换来了两年的和平。1779年鲍德温四世兵败泉水谷，病情的恶化令他的身体每况愈下，到1785年他因麻风病去世的时候，他只有24岁，电影里始终以面具示人的就是鲍德温四世。后期的耶路撒冷王国，基本是由他的姐夫居伊以及雷蒙德三世把持，朝局的不稳定无疑加速了耶路撒冷王国的覆灭。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="P2355584352.jpg" alt="天国王朝中的鲍德温四世形象" referrerpolicy="no-referrer"></div><div class="image-caption">天国王朝中的鲍德温四世形象</div></figure><p>相传，鲍德温四世出生时，是由其伯父鲍德温三世主持洗礼的。当时，国王鲍德温三世决定把自己的名字作为礼物赠送给这个新生儿，一旁的大臣开玩笑地说道，“作为一国之王，如果只是赠送一个名字，是否显得太过吝啬了呢？”。国王听完以后，大笑一声，指着圣(真)十字架说道，“那我就再送一份礼物给他——耶路撒冷之王”。后来，鲍德温三世突然得了重症，而他又没有子女。于是，他的侄子，即鲍德温四世继承了他的王位，成为了新一任的国王。对于历史而言，我们永远无法假设，我们无法想象这个16岁就击萨拉丁的少年，如果没有染上麻风病，又会在历史上留下怎么样的故事？本片的男主角巴利安，其原型在历史上被称为“伊贝林的巴利安男爵”，曾经参与过蒙吉萨之战，支持雷蒙德三世摄政，基本可以认为是主和派。电影中主张袭击穆斯林的，主要是居伊、雷纳德以及圣殿骑士团。</p><h1 id="十字军与圣殿骑士"><a href="#十字军与圣殿骑士" class="headerlink" title="十字军与圣殿骑士"></a>十字军与圣殿骑士</h1><p>好了，现在总算和刺客信条产生某种联系了。在刺客信条第一部中，圣殿骑士主要是以十字军的形象出现。事实上，十字军东征是由天主教教会发起的解放圣地耶路撒冷的一项运动，因为按照基督教、伊斯兰教、犹太教各自的说法，耶路撒冷都是它们心目中的圣地。可是，从十一世纪末开始，耶路撒冷及其周边的拜占庭地区，一直都被穆斯林占领。因此，罗马教廷以解放圣地的名义发动了多次东征，这些东征的军队服饰均以红十字作为标志，故而称为“十字军”。十字军占领耶路撒冷以后，很多欧洲人前往圣地朝圣，为了保护这些朝圣者的安全、攻击异教徒，1名法国贵族和8名骑士建立了军事性质的修会，因为其地点位于所罗门神殿的遗址上，故又称为圣殿骑士团。类似的组织，还有医院骑士团、条顿骑士团。其实，在初代刺客信条中，阿泰尔的刺杀对象里就有医院骑士团的成员。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="P2355584519.jpg" alt="天国王朝中的十字军形象" referrerpolicy="no-referrer"></div><div class="image-caption">天国王朝中的十字军形象</div></figure><p>从今天的角度来看，所谓的“讨伐异教徒”的圣战，其本身并不见得有多么神圣，神殿骑士团侵略和掠夺的成分更多一点，反倒是育碧用自由和秩序的命题，让圣殿骑士多了一点人性的光辉，从三代开始，圣殿骑士和刺客都不再是那种非黑即白的设定，甚至到法国大革命前夕，双方都意识到合作的可能性，可惜，这一切终究毁在各自阵营里的狂热分子手上，就像耶路撒冷王国是毁在一个毫无军事素养的居伊一样。法国刺客<a href="https://assassinscreed.huijiwiki.com/wiki/阿尔诺·多里安" target="_blank" rel="noopener">亚诺·多利安</a>不无遗憾地说到，“<strong>现在我懂了，诸行并非都得到允许，而是教条本身即为一种警告</strong>”。我们继续说回电影，截止到1187年，通过著名的哈丁之战，萨拉丁终于夺回圣地耶路撒冷，甚至缴获了钉死过耶稣的真十字架，他凭借自己出色的军事才能，一举收复了包括阿卡在内的众多港口城市，彻底切断了十字军在海上的补给线。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="P7297435160.jpg" alt="天国王朝中的萨拉丁形象" referrerpolicy="no-referrer"></div><div class="image-caption">天国王朝中的萨拉丁形象</div></figure><p>当然，不甘心的十字军，决定以英格兰国王理查一世(狮心王)和 法兰西国王腓力二世为主力，开始积极筹备又一次的十字军东征，大战一触即发。这一年，阿泰尔22岁，此时的他尚未成为刺客大师，但已然成为组织中的骨干力量。直到1191年，26岁的阿泰尔，被导师阿尔莫林派去所罗门圣殿遗址取得金苹果时，年轻而高傲的阿泰尔准备高调刺杀圣殿骑士罗伯特，这一举动把兄弟会成员马利克等彻底暴露在危险之中。而后面的故事我们都知道了，阿泰尔被剥夺了等级和武器，去完成刺杀9个圣殿骑士的任务。历史上的罗伯特，正是在前一年跟随狮心王舰队参与第三次十字军东征，甚至在1192年受封圣殿骑士团大师，可惜当他遇到阿泰尔的时候，这条仕途注定要永远地停留在1193年9月23日那一天。而这，大概就是，袖剑之下，众生平等，万物为虚，万事皆允。</p><h1 id="世界的十字路口"><a href="#世界的十字路口" class="headerlink" title="世界的十字路口"></a>世界的十字路口</h1><p>转眼间，时间来到12世纪，狮心王和萨拉丁，西方和东方，基督教和伊斯兰教，都在这一刻走向了对立面。如果说，土耳其的伊斯坦布尔是亚洲和欧洲的十字路口。那么，毫无疑问，这将会两个当世雄主间的终极对决。1191年9月7日，狮心王理查在阿苏夫会战中击败萨拉丁，在十字军进军耶路撒冷的途中，萨拉丁不断派出穆斯林骑兵进行袭扰，直到1192年1月，十字军抵达贝特努巴城堡，此时，距离圣地耶路撒冷只剩下12英里，耶路撒冷唾手可得。历史更像是一种巧合，那一年萨拉丁的埃及援军从南部抵达战场，狮心王理查一世在英国的统治地位随时都有可能被颠覆，战争顿时陷入了焦灼状态。1192年8月，互相怀有敬意的双方，在雅法城签署停战协定，史称“雅法合约”，正是从那一刻起，声势浩大的第三次十字军东征悄然落下帷幕。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="P2307353790.jpg" alt="狮心王理查一世影视形象" referrerpolicy="no-referrer"></div><div class="image-caption">狮心王理查一世影视形象</div></figure><p>萨拉丁是否归还了真十字架，后世的我们已无从得知。我只知道，从那一刻开始，这对惺惺相惜、势均力敌的对手，再没有等来交手的机会，一年后萨拉丁去世，而理查一世则在回国途中被奥地利公爵扣押。直到1194年，经过英、奥双方多次谈判，理查一世终于获释。可这个拥有狮子般雄心壮志的传奇将领，永远都选择冲锋陷阵、选择身先士卒，获释后不久，他就再次陷入了英法战争的泥潭，于1199年战死沙场。以我狭隘的历史观，后世能匹敌理查一世这次东征运动的将领，也许，只有先后在莫斯科损兵折将的拿破仑和希特勒。在育碧的世界观中，马西亚夫最终没能挡住成吉思汗西征的步伐，原因是成吉思汗手中或许掌握着某种伊甸碎片。1222年，成吉思汗攻下花拉子模汗国首都撒马尔罕，丘处机远赴西域“止杀”，那一年阿泰尔57岁，他已经离开马西亚夫，开始长达20多年的“自我流放”。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Altaïr-1.png" alt="结束隐居生活的阿泰尔" referrerpolicy="no-referrer"></div><div class="image-caption">结束隐居生活的阿泰尔</div></figure><p>谁能想到，丘处机路过牛家村的那一年，他的父亲奥马尔正准备潜入萨拉丁的营地，结果在回来的时候不慎触发警报，不得不杀死一名贵族。那一年，萨拉丁大军围攻马西亚夫，在萨拉丁的逼迫之下，奥马尔以生命为代价，从萨拉丁手中换回俘虏艾哈迈德·索菲安以及萨拉丁的撤军。那一年，阿泰尔11岁，几乎在同一天，阿泰尔和阿巴斯同时失去了父亲。阿巴斯不愿意接受父亲叛变的事实，并把一切都归咎于阿泰尔的父亲，两个人内心的芥蒂自此种下。这份怨恨直到阿巴斯死去都没能放下，那一年，阿泰尔80岁，利用从金苹果中学到的知识，阿泰尔研制出了袖枪，而这段故事，我们曾在启示录中，以艾吉欧·奥迪托雷的身份亲眼见证过。对于整个第三次十字军东征而言，阿泰尔的故事更像是惊鸿一瞥，可正是这段难辨真伪的传奇故事，让刺客信条系列成为此后育碧旗下最广为人知的游戏IP，万物为虚，万事皆允，耕耘于黑暗，服侍光明，这就是刺客。</p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>育碧说，<strong>History Is Our Playground</strong>，电影里的故事真真假假，游戏里的故事更不必说，甚至是我这些未曾考据过的文过饰非，可这恰恰是历史最为迷人的地方，一个人的形象，其实是由无数个人的记忆拼凑出来的，你可以去肆意地想象你心目中的鲍德温四世、萨拉丁，亦或者是狮心王理查一世、传奇刺客阿泰尔，只要这一切都能自圆其说。所以，育碧选择用阴谋论、用自由与秩序来填补那些虚构的情节，听起来像一款游戏对不对？可玫瑰岛这个社会实验告诉我们，这一切还真的就是一款游戏，毕竟，意大利唯一一场打赢的战争，对手是一座面积只有400平米的小岛，试想，如果西泽尔·波奇亚泉下有知，怕是连胡子都要气得歪掉？当然，请记住一句话，<strong>我说的都是错的！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://qinyuanpei.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="游戏" scheme="https://qinyuanpei.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="历史" scheme="https://qinyuanpei.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="电影" scheme="https://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Envoy 集成 Jaeger 实现分布式链路跟踪</title>
    <link href="https://qinyuanpei.github.io/posts/768684858/"/>
    <id>https://qinyuanpei.github.io/posts/768684858/</id>
    <published>2022-01-14T16:46:23.000Z</published>
    <updated>2022-03-07T01:40:22.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>当我们的应用架构，从单体系统演变为微服务时，一个永远不可能回避的现实是，业务逻辑会被拆分到不同的服务中。因此，微服务实际就是不同服务间的互相请求和调用。更重要的是，随着容器/虚拟化技术的发展，传统的物理服务器开始淡出我们的视野，软件被大量地部署在云服务器或者虚拟资源上。在这种情况下，分布式环境中的运维和诊断变得越来越复杂。如果按照功能来划分，目前主要有 Logging、Metrics 和 Tracing 三个方向，如下图所示，可以注意到，这三个方向上彼此都有交叉、重叠的部分。在我过去的博客里，我分享过关于 <a href="/posts/3687594958">ELK</a> 和 <a href="/posts/1519021197">Prometheus</a> 的内容，可以粗略地认为，这是对 Logging 和 Metrics 这两个方向的涉猎。所以，这篇文章我想和大家分享是 Tracing，即分布式跟踪，本文会结合 Envoy、Jaeger 以及 .NET Core 来实现一个分布式链路跟踪的案例，希望能带给大家一点 Amazing 的东西。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Obserability_Metrics_Tracing_Logging.jpg" alt="可观测性：Metrics、Tracing & Logging" referrerpolicy="no-referrer"></div><div class="image-caption">可观测性：Metrics、Tracing & Logging</div></figure><h1 id="分布式跟踪"><a href="#分布式跟踪" class="headerlink" title="分布式跟踪"></a>分布式跟踪</h1><p>如果要追溯分布式跟踪的起源，我想，Google 的这篇名为 <a href="https://dirtysalt.github.io/html/dapper.html" target="_blank" rel="noopener">《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》</a> 的论文功不可没，因为后来主流的分布式跟踪系统，譬如 <a href="https://zipkin.io/" target="_blank" rel="noopener">Zipkin</a>、<a href="https://www.jaegertracing.io/" target="_blank" rel="noopener">Jeager</a>、<a href="https://skywalking.apache.org/" target="_blank" rel="noopener">Skywalking</a>、<a href="https://lightstep.com" target="_blank" rel="noopener">LightStep</a>……等等，均以这篇论文作为理论基础，它们在功能上或许存在差异，原理上则是一脉相承，一个典型的分布式跟踪系统，大体上可以分为代码埋点、数据存储和查询展示三个步骤，如下图所示，Tracing 系统可以展示出服务在时序上的调用层级，这对于我们分析微服务系统中的调用关系会非常有用。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Basic-Principles-Of-Distributed-Tracking-System.png" alt="分布式跟踪系统基本原理" referrerpolicy="no-referrer"></div><div class="image-caption">分布式跟踪系统基本原理</div></figure><p>一个非常容易想到的思路是，我们在前端发出的请求的时候，动态生成一个唯一的 <code>x-request-id</code>，并保证它可以传递到与之交互的所有服务中去，那么，此时系统产生的日志中就会携带这一信息，只要以此作为关键字，就可以检索到当前请求的所有日志。这的确是个不错的方案，但它无法告诉你每个调用完成的先后顺序，以及每个调用花费了多少时间。基于这样的想法，人们在这上面传递了更多的信息(<code>Tag</code>)，使得它可以表达层级关系、调用时长等等的特征。如图所示，这是一个由 <code>Jaeger</code> 产生的跟踪信息，我们从中甚至可以知道请求由哪台服务器处理，以及上/下游集群信息等等：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Jaeger-Works-On-gRPC.png" alt="通过 Jaeger 收集 gRPC 请求信息" referrerpolicy="no-referrer"></div><div class="image-caption">通过 Jaeger 收集 gRPC 请求信息</div></figure><p>目前，为了统一不同 Tracing 系统在 API、数据格式等方面上的差异，社区主导并产生了 <a href="https://opentracing.io/" target="_blank" rel="noopener">OpenTracing</a> 规范，在这个 <a href="https://github.com/opentracing/specification/blob/master/specification.md" target="_blank" rel="noopener">规范</a> 中，一个 Trace，即调用链，是由多个 <code>Span</code> 组成的有向无环图，而每个 <code>Span</code> 则可以含有多个键值对组成的 Tag。如图所示，下面是 <a href="https://opentracing.io/" target="_blank" rel="noopener">OpenTracing</a> 规范的一个简单示意图，此时，图中一共有 8 个 <code>Span</code>，其中 <code>Span A</code> 是根节点，<code>Span C</code> 是 <code>Span A</code> 的子节点， <code>Span G</code> 和 <code>Span F</code> 之间没有通过任何一个子节点连接，称为 <code>FollowsFrom</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">       <span class="selector-attr">[Span A]</span>  ←←←(the root span)</span><br><span class="line">           |</span><br><span class="line">    +<span class="selector-tag">------</span>+<span class="selector-tag">------</span>+</span><br><span class="line">    |             |</span><br><span class="line"><span class="selector-attr">[Span B]</span>      <span class="selector-attr">[Span C]</span> ←←←(Span C is a <span class="built_in">`ChildOf`</span> Span A)</span><br><span class="line">    |             |</span><br><span class="line"><span class="selector-attr">[Span D]</span>      +<span class="selector-tag">---</span>+<span class="selector-tag">-------</span>+</span><br><span class="line">              |           |</span><br><span class="line">          <span class="selector-attr">[Span E]</span>    <span class="selector-attr">[Span F]</span> &gt;&gt;&gt; <span class="selector-attr">[Span G]</span> &gt;&gt;&gt; <span class="selector-attr">[Span H]</span></span><br><span class="line">                                      ↑</span><br><span class="line">                                      ↑</span><br><span class="line">                                      ↑</span><br><span class="line">                        (Span G <span class="built_in">`FollowsFrom`</span> Span F)</span><br></pre></td></tr></table></figure><p>事实上，我们上面提到的 <a href="https://zipkin.io/" target="_blank" rel="noopener">Zipkin</a> 和 <a href="https://www.jaegertracing.io/" target="_blank" rel="noopener">Jeager</a> 都兼容这一规范，这使得我们可以更加灵活和自由地更换 Tracing 系统。除了 <a href="https://opentracing.io/" target="_blank" rel="noopener">OpenTracing</a> 规范，目前，<a href="https://opentelemetry.io/" target="_blank" rel="noopener">OpenTelemetry</a> 在考虑统一 Logging、Metrics 和 Tracing，即我们通常所说的 APM，如果大家对这个感兴趣，可以做更进一步的了解。</p><h1 id="Envoy-amp-Jaeger"><a href="#Envoy-amp-Jaeger" class="headerlink" title="Envoy &amp; Jaeger"></a>Envoy &amp; Jaeger</h1><p>目前，主流的服务网格平台如 <a href="https://istio.io/latest" target="_blank" rel="noopener">Istio</a>，选择 <a href="https://www.envoyproxy.io/" target="_blank" rel="noopener">Envoy</a> 作为其数据平面的核心组件。通俗地来讲，Envoy 主要是作为代理层来调节服务网格中所有服务的进/出站流量，它可以实现诸如负载均衡、服务发现、流量转移、速率限制、可观测性等等的功能。考虑到不同的服务都可以通过 <code>Gateway</code> 或者 <code>Sidecar</code> 来互相访问，我们更希望通过 Envoy 这个代理层来实现分布式跟踪，而不是在每个应用内都去集成 SDK，这正是服务网格区别于传统微服务的地方，即微服务治理需要的各种能力，逐步下沉到基础设施层。如果你接触过微软的 <a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/dapr-for-net-developers/getting-started" target="_blank" rel="noopener">Dapr</a>，大概就能体会到我这里描述的这种变化。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Manaing-Microservice-With-Istio.png" alt="Envoy 在 Istio 中扮演着重要角色" referrerpolicy="no-referrer"></div><div class="image-caption">Envoy 在 Istio 中扮演着重要角色</div></figure><p>事实上，Envoy 提供了入口来接入不同的 Tracing 系统，以 <a href="https://zipkin.io/" target="_blank" rel="noopener">Zipkin</a> 或者 <a href="https://www.jaegertracing.io/" target="_blank" rel="noopener">Jeager</a> 为例，除了前面提到的 <code>x-request-id</code>，它可以帮我们生成类似 <code>x-b3-traceid</code>、<code>x-b3-spanid</code> 等等的请求头。参照 <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/observability/tracing#arch-overview-tracing" target="_blank" rel="noopener">官方文档</a>，它大体上提供了下面 3 种策略来支撑系统范围内的跟踪：</p><ul><li>生成 <code>UUID</code> ：Envoy 会在需要的时候生成 <code>UUID</code>，并操作名为 <code>x-request-id</code> 的 HTTP 头部，应用可以转发这个 HTTP 头部用于统一的记录和跟踪。</li><li>集成外部跟踪服务：Envoy 支持可插拔的外部跟踪可视化服务，例如 LightStep、Zipkin 或者 Zipkin 兼容的后端（比如说 Jaeger）等等。</li><li>客户端跟踪 ID 连接：<code>x-client-trace-id</code> 这个 HTTP 头部可以用来把不信任的请求 ID 连接到受信的 <code>x-request-id</code> HTTP 头部上。</li></ul><p>这意味着，我们可以从客户端或者由 Envoy 来产生一个 <code>x-request-id</code>，只要应用转发这个 <code>x-request-id</code> 或者 外部跟踪系统需要的 HTTP 头部，Envoy 就可以帮我们完成把这些跟踪信息告诉这些外部跟踪系统，甚至在 <code>Sidecar</code> 模式下这一切都是自动完成的。我在写这篇博客时发现，官方还是比较推崇 <code>Sidecar</code> 模式，即一个服务就是一个 <code>Pod</code>，每个 <code>Pod</code> 里自带一个 Envoy 作为代理，对于 <code>Sidecar</code> 模式而言，它的分布式跟踪呈现出下面这样的结构，如果你认真阅读过官方的文档和示例，就会发现其 <a href="https://github.com/envoyproxy/envoy/tree/main/examples" target="_blank" rel="noopener">示例</a> 基本都是这种结构：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Envoy-Tracing-Sidecar.drawio.png" alt="Sidecar 模式下的分布式跟踪示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Sidecar 模式下的分布式跟踪示意图</div></figure><p>考虑到，2022 年还有没有用上 <code>K8S</code> 的人，以及 <a href="https://www.cnblogs.com/catcher1994/" target="_blank" rel="noopener">Catcher Wong</a> 大佬反映 <code>Sidecar</code> 模式比较浪费资源，这里我们还是用 <code>Gateway</code> 模式来实现，譬如我们有两个服务，订单服务(<code>OrderSevice</code>) 和 支付服务(<code>PaymentService</code>)，它们都由同一个 Envoy 来代理，当我们在订单服务中调用支付服务时，就会产生一条调用链。对于大多数的微服务而言，从它被拆分地那一刻起，就不可避免地走向了像蜘蛛网一般错综复杂的结局，此时，它的分布式跟踪呈现出下面的结构：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Envoy-Tracing-Gateway.drawio.png" alt="Gateway 模式下的分布式跟踪示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Gateway 模式下的分布式跟踪示意图</div></figure><p>如果从代码侵入角度来审视这个问题，<code>Sidecar</code> 模式，每个服务都由 Envoy 去生成或者是设置一系列相关的请求头；而如果采取 <code>Gateway</code> 模式，当你在订单服务里调用支付服务时，无论你使用 <code>HttpClient</code> 还是 <code>gRPC</code>，你都需要确保这一系列的请求头能传递下去，这意味着我们要写一点无关紧要的代码，这样看起来前者更好一点，不是吗？可惜，合适和正确，就像鱼和熊掌一样，永远不可兼得。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Jaeger-Span-Model.png" alt="Span 模型示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Span 模型示意图</div></figure><p>关于 Jeager，这是一个由 Uber 开发的、受 Dapper 和 Zipkin 启发的分布式跟踪系统，它主要适用于：分布式跟踪信息传递、分布式事务监控、问题分析、服务依赖性分析、性能优化这些场景，因为它兼容 OpenTracing 标准，所以 <code>Span</code> 这个术语对它来说依然使用，什么是 <code>Span</code> 呢？它是一个跟踪的最小逻辑单位，可以记录操作名，操作开始时间 和 操作耗时，下面是 Jaeger 的架构示意图，大家可以混个眼熟：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Jaeger-Architecture-v1.png" alt="Jaeger 的架构示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Jaeger 的架构示意图</div></figure><h1 id="第一个实例"><a href="#第一个实例" class="headerlink" title="第一个实例"></a>第一个实例</h1><p>OK，现在来分享本文的第一个示例，如前文所述，我们要实现的是一个 <code>Gateway</code> 模式下的请求跟踪。为此，我们准备了两个 ASP.NET Core 项目，分别来模拟订单服务(<code>OrderService</code>) 和 支付服务(<code>PaymentService</code>)，当我们通过 Envoy 访问 <code>OrderService</code> 的时候，会在其内部访问 <code>PaymentService</code>，以此来验证 Envoy 能否帮我们找到这条调用链。首先，我们来编写 <code>OrderService</code>，代码非常简单，从 HTTP 请求头中拿到 Jeager 需要的字段，并在调用 <code>OrderService</code> 的时候传递这些字段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Post</span>(<span class="params">[FromBody] OrderInfo orderInfo</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> paymentInfo = <span class="keyword">new</span> PaymentInfo()</span><br><span class="line">  &#123;</span><br><span class="line">    OrderId = orderInfo.OrderId,</span><br><span class="line">    PaymentId = Guid.NewGuid().ToString(<span class="string">"N"</span>),</span><br><span class="line">    Remark = orderInfo.Remark,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置请求头</span></span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">"x-request-id"</span>, Request.Headers[<span class="string">"x-request-id"</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">"x-b3-traceid"</span>, Request.Headers[<span class="string">"x-b3-traceid"</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">"x-b3-spanid"</span>, Request.Headers[<span class="string">"x-b3-spanid"</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">"x-b3-parentspanid"</span>, Request.Headers[<span class="string">"x-b3-parentspanid"</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">"x-b3-sampled"</span>, Request.Headers[<span class="string">"x-b3-sampled"</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">"x-b3-flags"</span>, Request.Headers[<span class="string">"x-b3-flags"</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">"x-ot-span-context"</span>, Request.Headers[<span class="string">"x-ot-span-context"</span>].ToString());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用/Payment接口</span></span><br><span class="line">  <span class="keyword">var</span> content = <span class="keyword">new</span> StringContent(JsonConvert.SerializeObject(paymentInfo), Encoding.UTF8, <span class="string">"application/json"</span>);</span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">"/Payment"</span>, content);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = response.IsSuccessStatusCode ? <span class="string">"成功"</span> : <span class="string">"失败"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="keyword">new</span> &#123; Msg = <span class="string">$"订单创建<span class="subst">&#123;result&#125;</span>"</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，<code>PaymentService</code> 就会变得非常简单，因为我们不会真的去对接一个支付系统，所以，就简单意思一下好啦！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> [<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Post</span>(<span class="params">[FromBody] PaymentInfo paymentInfo</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> requestId = Request.Headers[<span class="string">"x-request-id"</span>].ToString();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="keyword">new</span> &#123; Msg = <span class="string">$"支付成功, 流水号：<span class="subst">&#123;requestId&#125;</span>"</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务编写好以后，按照惯例，我们使用 <code>docker-compose.yaml</code> 文件来进行编排，除了 <code>OrderService</code> 和 <code>PaymentService</code>，我们还需要 <code>Envoy</code> 和 <code>Jeager</code>，即至少需要四个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoy_gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9090:9090"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9091:9091"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"./Envoy/envoy.yaml:/etc/envoy/envoy.yaml"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"./Envoy/logs/:/etc/envoy/logs/"</span></span><br><span class="line">  <span class="attr">order_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">OrderService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">  <span class="attr">payment_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">PaymentService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8082:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">  <span class="attr">jaeger:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jaegertracing/all-in-one</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">COLLECTOR_ZIPKIN_HOST_PORT=9411</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"9411:9411"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"16686:16686"</span></span><br></pre></td></tr></table></figure><p>此时，重头戏终于来了，Envoy 是如何连接外部跟踪系统的呢？我们可以设置 <code>HttpConnectionManager</code> 这个过滤器下的 <code>tracing</code> 字段，这里我们选择 <code>ZipkinConfig</code> 这个类型，因为 Jaeger 完全兼容 Zipkin，所以，我们可以直接使用这个 Provider。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filter_chains:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">    <span class="attr">typed_config:</span></span><br><span class="line">      <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">      <span class="attr">generate_request_id:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">tracing:</span></span><br><span class="line">        <span class="attr">provider:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">envoy.tracers.zipkin</span></span><br><span class="line">          <span class="attr">typed_config:</span></span><br><span class="line">            <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.config.trace.v3.ZipkinConfig</span></span><br><span class="line">            <span class="attr">collector_cluster:</span> <span class="string">jaeger</span></span><br><span class="line">            <span class="attr">collector_endpoint:</span> <span class="string">"/api/v2/spans"</span></span><br><span class="line">            <span class="attr">collector_endpoint_version:</span> <span class="string">HTTP_JSO</span></span><br></pre></td></tr></table></figure><p>基本上，只要是官方支持的 Provider，我们都可以照猫画虎接入进来，当然每一种 Provider 的配置项可能会不一样，这里我们唯一要注意的是 <code>collector_cluster</code>, 它表示的是指向 Jeager 服务器的一个 Cluster，这意味着我们要为它单独定义一个 Cluster :</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jaeger</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">  <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">  <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="attr">load_assignment:</span></span><br><span class="line">    <span class="attr">cluster_name:</span> <span class="string">jaeger</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">jaeger</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">9411</span></span><br></pre></td></tr></table></figure><p>还记得 Envoy 支撑系统内的分布式跟踪的三个支撑策略是什么吗？显然，我们可以通过 <code>generate_request_id</code> 字段来控制 Envoy 生成作用于 <code>x-request-id</code> 的 <code>UUID</code>，我们希望用户从 前端 或者 cURL 中发送的请求，都能自动地带上 <code>x-request-id</code> 请求头，所以，我们这里将其设为 <code>true</code>，这意味着，从现在开始，我们的请求有了这样一个 <code>x-request-id</code>， 其实，如果不考虑 Jeager 的话，我们请求已经可以实现跟踪了，只要后续的请求都像我这里一样传递 <code>x-request-id</code> 即可。原因我们已经在前面说过，此时，这些请求没有一个上下文的概念，更不要说要理清楚其中的调用层级，所以，接下来，我们还要做一点微不足道的工作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">virtual_hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">domains:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"*"</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">"/Payment"</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">prefix_rewrite:</span> <span class="string">/api/Payment</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">payment_service</span></span><br><span class="line">    <span class="attr">decorator:</span></span><br><span class="line">      <span class="attr">operation:</span> <span class="string">PaymentService</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">"/Order"</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">prefix_rewrite:</span> <span class="string">/api/Order</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">order_service</span></span><br><span class="line">    <span class="attr">decorator:</span></span><br><span class="line">      <span class="attr">operation:</span> <span class="string">OrderService</span></span><br></pre></td></tr></table></figure><p>如上所示，如果我们希望 Envoy 能记录我们的请求，那么，我们的请求必须要从它这里经过。这听起来像一句废话，可是在我调用 <code>PaymentService</code>已经确保我的请求是从 <code>/Payment</code> 这个路由上发起。默认情况下，在生成 <code>Span</code> 的时候，Envoy 会使用 <code>--service-cluster</code> 这个参数来作为 <code>Span</code> 的名称，这个参数通常写在 Envoy 的启动命令里，在这个示例中，它的取值是 <code>reverse-proxy</code>。仔细一想，会觉得哪里不太对，这样一来，所以的 <code>Span</code> 不就是同一个名字了吗？事实上，一开始我做实验的时候，确实是这个结果。解决方是设置一个 <code>operation</code>。此时，如果我们通过 <code>Postman</code> 访问订单接口 <code>/Order</code>，不出意外的话，我们会收到订单创建成功的结果，在浏览器里输入<code>http://localhost:16686</code>，我们来看看 Jeager 都收集到了哪些信息：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Envoy-JeagerUI-01.png" alt="JeagerUI 数据查询" referrerpolicy="no-referrer"></div><div class="image-caption">JeagerUI 数据查询</div></figure><p>从图中我们可以非常容易地识别出 Service 和 Operation 在 Envoy 中分别对应着什么，我们注意到这里检索到了三个 Span，因为博主后来又加了一个 <code>EchoService</code>，从这里我们能看到它整个过程从何时开始，经过多长时间以后结束。如果我们点击它，会看到更加详细的说明，如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Envoy-JeagerUI-02.png" alt="JeagerUI 数据展示" referrerpolicy="no-referrer"></div><div class="image-caption">JeagerUI 数据展示</div></figure><p>显然，这个调用关系是符合我们预期的，即客户端调用了<code>OrderService</code>，<code>OrderService</code>调用了<code>PaymentService</code>，对于每一次调用，我们均可以从 Span 的 Tag 中获得更多信息，文章中的第三张图，实际上就是出自这里，有了这些信息以后，我们排查或者分析微服务中的问题，是不是感觉容易了很多呢？结合 ELK，你可以知道要去找哪里的日志，而这些正是分布式跟踪的意义所在！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Jaeger-Works-On-gRPC.png" alt="通过 Jaeger 收集 gRPC 请求信息" referrerpolicy="no-referrer"></div><div class="image-caption">通过 Jaeger 收集 gRPC 请求信息</div></figure><p>好了，到这里为止，关于 Envoy 在分布式跟踪上的探索，终于可以告一段落，完整的项目文件我已经放在 <a href="https://github.com/Regularly-Archive/2022/tree/master/src/EnvoyTrace" target="_blank" rel="noopener">Github</a> 上供大家参考，谢谢大家！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>可观测性(Logging、Metrics &amp; Tracing) 是当下微服务中重要的一个组成部分，从 ELk 收集日志，到 Prometheus 监控指标， 再到 Jeager 跟踪调用链，我们看到了一种完全不同于单体系统中打断点、单步调试的诊断思路，这是否说明，微服务的治理永远是一个绕不过去的话题。在这篇文章里，我们简单介绍了分布式跟踪系统，比如最常见的 <a href="https://zipkin.io/" target="_blank" rel="noopener">Zipkin</a>、<a href="https://www.jaegertracing.io/" target="_blank" rel="noopener">Jeager</a>、<a href="https://skywalking.apache.org/" target="_blank" rel="noopener">Skywalking</a>、<a href="https://lightstep.com" target="_blank" rel="noopener">LightStep</a>…等等，其基本思想是生成一个 <code>x-request-id</code>，并在不同的服务或者应用中传递这个信息。在此基础上，我们介绍了 <a href="https://opentracing.io/" target="_blank" rel="noopener">OpenTracing</a> 规范，即 一个调用链(Trace)，是由多个 <code>Span</code> 组成的有向无环图，而每个 <code>Span</code> 则可以含有多个键值对组成的 Tag。目前，Envoy 官方主推的是 <code>Sidecar</code> 模式，即每个服务分配一个 Envoy 作为代理，考虑到博主目前使用 <code>Gateway</code> 模式更多一点，故结合 ASP.NET Core 和 Jeager 实现了一个简单的示例，这个示例唯一的不足在于，服务或者应用必须显式地传递这些请求头，如果直接集成 SDK，效果应该会比现在好很多，可这样的话，就显得不那么云原生了，如果大家有更好的做法，欢迎在评论区留言和交流。大家可以稍微注意一下 <a href="https://opentelemetry.io/" target="_blank" rel="noopener">OpenTelemetry</a> 这个项目，如果你需要更完备的可观测性信息收集。好了，以上就是这篇博客的全部内容，晚安，世界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Envoy" scheme="https://qinyuanpei.github.io/tags/Envoy/"/>
    
      <category term="Jaeger" scheme="https://qinyuanpei.github.io/tags/Jaeger/"/>
    
      <category term="Tracing" scheme="https://qinyuanpei.github.io/tags/Tracing/"/>
    
  </entry>
  
  <entry>
    <title>浅议非典型 Web 应用场景下的身份认证</title>
    <link href="https://qinyuanpei.github.io/posts/2478147871/"/>
    <id>https://qinyuanpei.github.io/posts/2478147871/</id>
    <published>2021-12-28T11:53:29.000Z</published>
    <updated>2022-03-07T01:40:22.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>据我所知，软件行业，向来是充满着鄙视链的，人们时常会因为语言、框架、范式、架构等等问题而争执不休。不必说 PHP 到底是不是世界上最好的语言，不必说原生与 Web 到底哪一个真正代表着未来，更不必说前端与后端到底哪一个更有技术含量，单单一个 C++ 的版本，1998 与 2011 之间仿佛隔了一个世纪。我真傻，我单知道人们会因为 GCC 和 VC++ 而分庭抗礼多年，却不知道人们还会因为大括号换行、Tab 还是空格、CRLF 还是 CR……诸如此类的问题而永不休战。也许，正如 <a href="http://www.yinwang.org/" target="_blank" rel="noopener">王垠</a> 前辈所说，编程这个领域总是充满着某种 <a href="http://www.yinwang.org/blog-cn/2015/04/03/paradigms" target="_blank" rel="noopener">宗教原旨</a> 的意味。回想起刚毕业那会儿，因为没有 Web 开发的经验而被人轻视，当年流行的 SSH 全家桶，对我鼓捣 Windows 桌面开发这件事情，投来无限鄙夷的目光，仿佛 Windows 是一种原罪。可时间久了以后，我渐渐意识到，对工程派而言，一切都是工具；而对于学术派而言，一切都是包容。这个世界并不是只有 Web，对吧？所以，这篇博客我想聊聊非典型 Web 应用场景下的身份认证。</p><h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>在讨论非典型 Web 应用场景前，我们不妨来回想一下，一个典型的 Web 应用是什么样子？打开浏览器、输入一个 URL、按下回车、输入用户名和密码、点击登录……，在这个过程中，Cookie/Session用来维持整个会话的状态。直到后来，前后端分离的大潮流下，无状态的服务开始流行，人们开始使用一个令牌(Token)来标识身份信息，无论是催生了 Web 2.0 的 <code>OAuth 2.0</code> 协议，还是在微服务里更为流行的 <code>JWT(JSON Web Token)</code>，其实，都在隐隐约约说明一件事情，那就是在后 Web 时代，特别是微信兴起以后，人们在线与离线的边界越来越模糊，疫情期间居家办公的这段时间，我最怕听到 Teams 会议邀请的声音，因为无论你是否在线，它都会不停地催促你，彻底模糊生活与工作的边界。那么，屏幕前聪明的你，你告诉我，什么是典型的 Web 应用？也许，我同样无法回答这个问题，可或许，下面这几种方式，即 gRPC、SignalR 和 Kafka，可以称之为：非典型的 Web 应用。</p><h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><p>相信经常阅读我博客的朋友，都知道这样一件事情，那就是，过去这半年多的时间，我一直在探索，如何去构建一个以 gRPC 为核心的微服务架构。想了解这方面内容的朋友，不妨抽空看看我前面写过的博客。从整体上来说，我们对于 gRPC 的使用上，基本可以分为对内和对外两个方面。对内，不同的服务间通过 gRPC 客户端互相通信，我们称之为：直连；对外，不同的服务通过 Envoy 代理为 JSON API 供前端/客户端消费，我们称之为：代理。一个简单的微服务示意图，如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="gRPC-MicroService.drawio.png" alt="gRPC 微服务中的内与外" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC 微服务中的内与外</div></figure><p>目前，这个方案最大的问题，不同的服务间通过 gRPC 客户端直连的时候，无法提供身份认证信息，因为如果是单纯的读，即从某一个服务查询数据，其实是可以接受这种“裸奔”的状态，可一旦涉及到了写，这种方案就显得不大严谨。譬如现在的做法，如果从 <code>HttpContext</code> 里提取不到用户信息，就默认当前用户是 Sys，表示这是一个系统级别的操作。那么，如何解决这个问题呢？我们一起来看一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(channel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> metadata = <span class="keyword">new</span> Metadata();</span><br><span class="line">metadata.Add(<span class="string">"Authorization"</span>, <span class="string">$"Bearer <span class="subst">&#123;token&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reply = client.SayHello(<span class="keyword">new</span> HelloRequest(), metadata);</span><br></pre></td></tr></table></figure><p>可以注意到，这里的关键是构造一个<code>Metadata</code>，并在其中传入<code>Authorization</code>头部。当然，这一切的前提是你遵循并且沿用了 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/identity?view=aspnetcore-3.0&tabs=visual-studio" target="_blank" rel="noopener">ASP.NET Core 身份验证</a>，这里以最常见的 JWT 认证为例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">services.AddAuthentication(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">   x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">&#125; ).AddJwtBearer(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   x.RequireHttpsMetadata = <span class="literal">false</span>;</span><br><span class="line">   x.SaveToken = <span class="literal">true</span>;</span><br><span class="line">   x.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters</span><br><span class="line">  &#123;</span><br><span class="line">     ValidateIssuerSigningKey = <span class="literal">true</span>,</span><br><span class="line">     IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOptions.Secret)),</span><br><span class="line">     ValidIssuer = jwtOptions.Issuer,</span><br><span class="line">     ValidAudience = jwtOptions.Audience,</span><br><span class="line">     ValidateIssuer = <span class="literal">true</span>,</span><br><span class="line">     ValidateAudience = <span class="literal">true</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通常情况下，这里的<code>IssuerSigningKey</code>由一个证书文件来提供，例如最常用的是<code>X509SecurityKey</code>类。为了方便演示，这里采用一组字符串进行签名。不管采用哪一种方式，我们都应该保证它与生成令牌时的参数一致。例如，下面是一个典型的生成 <code>JWT</code> 令牌的代码片段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> claims = <span class="keyword">new</span>[]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">new</span> Claim(ClaimTypes.Name, userInfo.UserName),</span><br><span class="line">   <span class="keyword">new</span> Claim(ClaimTypes.Role, userInfo.UserRole)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtOptions.Value.Secret));</span><br><span class="line"><span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(signKey, SecurityAlgorithms.HmacSha256);</span><br><span class="line"><span class="keyword">var</span> jwtToken = <span class="keyword">new</span> JwtSecurityToken(</span><br><span class="line">   _jwtOptions.Value.Issuer,</span><br><span class="line">   _jwtOptions.Value.Audience, </span><br><span class="line">   claims, </span><br><span class="line">   expires: DateTime.Now.AddMinutes(_jwtOptions.Value.AccessExpiration), </span><br><span class="line">   signingCredentials: credentials</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">token = <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(jwtToken);</span><br></pre></td></tr></table></figure><p>除了以上两点，请确保你的正确地配置了认证和授权两个中间件，注意它们的顺序和位置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    app.UseRouting();</span><br><span class="line">    <span class="comment">// 注意顺序</span></span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">    app.UseAuthorization();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       endpoints.MapGrpcService&lt;GreeterService&gt;();</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们就可以在 gRPC 中通过<code>IHttpContextAccessor</code>获取当前用户信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HelloReply&gt; <span class="title">SayHello</span>(<span class="params">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userName = _httpContextAccessor.HttpContext.User?.Identity.Name;</span><br><span class="line">    <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HelloReply &#123; Message = <span class="string">$"Hello <span class="subst">&#123;userName&#125;</span>"</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，考虑到我们使用 gRPC 客户端工厂的场景更多一点，我们更希望这个令牌可以在一开始就准备好，而不是每调用一个方法都需要传一次令牌。此时，我们可以使用下面的做法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(o =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    o.Address = <span class="keyword">new</span> Uri(<span class="string">"https://localhost:5001"</span>);</span><br><span class="line">&#125;).ConfigureChannel(o =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> credentials = CallCredentials.FromInterceptor((context, metadata) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(_token)</span><br><span class="line">        metadata.Add(<span class="string">"Authorization"</span>, <span class="string">$"Bearer <span class="subst">&#123;_token&#125;</span>"</span>);</span><br><span class="line">      <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    o.Credentials = ChannelCredentials.Create(<span class="keyword">new</span> SslCredentials(), credentials);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此，关于 gRPC 的身份认证问题终于得到了解决，无论是对内的直连还是对外的代理，我们都可以获得用户的身份信息。需要说明的是，默认情况下，gRPC 允许调用方在不携带令牌的情况下调用接口，所以，我们这里的认证方案更像是一种君子协定。如果希望做更严格的限制，可以考虑在具体的服务上添加 <code>[Authorize]</code>特性，就像我们在控制器上使用该特性一样。</p><h1 id="SignalR"><a href="#SignalR" class="headerlink" title="SignalR"></a>SignalR</h1><p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/introduction?view=aspnetcore-6.0" target="_blank" rel="noopener">SignalR</a> 是由微软提供的一面向实时 Web 应用的、开源的库，你可以认为，它是集 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-6.0" target="_blank" rel="noopener">WebSockets</a>、Server-Sent 事件 和 长轮询于一身的综合性的库。当你需要从服务端实时地推送消息到特定的客户端(组)的时候，SignalR 将会是一个不错的选择。譬如可视化的仪表盘或者监视系统，需要接收数据的变更通知以实时地刷新视图；即时通讯(IM)、社交网络、邮件、游戏、协作等方面地应用都需要及时地发出通知。ASP.NET Core 版本的 SIgnalR 在自动处理连接管理方面做出来不小的改善，可很多时候，SIgnalR 里面的 ConnectionId 对我们而言是没有意义的，我们更想知道连接到 Hub 的用户是谁，这样就催生出来 SignalR 身份认证的需求场景，下面，我们就来看看对应的 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/authn-and-authz?view=aspnetcore-6.0" target="_blank" rel="noopener">解决方案</a>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一、AccessTokenProvider </span></span><br><span class="line"><span class="keyword">var</span> hubConnection = <span class="keyword">new</span> HubConnectionBuilder()</span><br><span class="line">  .WithUrl(<span class="string">"http://localhost:5000/echohub"</span>,options =&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    options.AccessTokenProvider = () =&gt; Task.FromResult(<span class="string">"&lt;Your Token&gt;"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .WithAutomaticReconnect()</span><br><span class="line">  .Build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二、直接追加查询参数</span></span><br><span class="line"><span class="keyword">var</span> hubConnection = <span class="keyword">new</span> HubConnectionBuilder()</span><br><span class="line">  .WithUrl(<span class="string">"http://localhost:5000/echohub?access_token=&lt;Your Token&gt;"</span>)</span><br><span class="line">  .WithAutomaticReconnect()</span><br><span class="line">  .Build();</span><br></pre></td></tr></table></figure><p>首先，SignalR 的身份认证，整体上依然遵循 ASP.NET Core 里的这套认证/授权流程，所以，我们可以继续沿用 gRPC 这部分的代码。考虑到 SignalR 首次发起的是一个 GET 请求，通常的做法是在查询参数中追加令牌参数。当然，现在官方提供了<code>AccessTokenProvider</code>这个属性，允许你构造一个委托来提供令牌。接下来，为了让这个令牌更符合一般的场景，譬如，按照约定它应该出现在 HTTP 请求头的 <code>Authorization</code> 字段上，我们有下面两种方式来对它进行处理：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一、设置 JwtBearer 的 Events 属性</span></span><br><span class="line">services.AddAuthentication(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">.AddJwtBearer(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  x.Events = <span class="keyword">new</span> JwtBearerEvents()</span><br><span class="line">  &#123;</span><br><span class="line">    OnMessageReceived = context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> accessToken = context.Request.Query[<span class="string">"access_token"</span>];</span><br><span class="line">      <span class="keyword">var</span> path = context.HttpContext.Request.Path;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(accessToken) &amp;&amp; (path.StartsWithSegments(<span class="string">"/echohub"</span>)))</span><br><span class="line">        context.Token = accessToken;</span><br><span class="line">      <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二，编写中间件，注意顺序</span></span><br><span class="line">app.Use((context, next) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> accessToken = context.Request.Query[<span class="string">"access_token"</span>].ToString();</span><br><span class="line">  <span class="keyword">var</span> path = context.Request.Path;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(accessToken) &amp;&amp; (path.StartsWithSegments(<span class="string">"/echohub"</span>)))</span><br><span class="line">    context.Request.Headers.Add(<span class="string">"Authorization"</span>, <span class="keyword">new</span> StringValues(<span class="string">$"Bearer <span class="subst">&#123;accessToken&#125;</span>"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next.Invoke();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.UseAuthentication();</span><br><span class="line">app.UseAuthorization();</span><br></pre></td></tr></table></figure><p>可以注意到，不管是哪一种方式，核心目的都是为了让令牌能在 ASP.NET Core 的请求管道中出现在它期望出现的地方，这是什么地方呢？我想，应该是为执行认证/授权中间件以前，所以，为什么我说这两个中间件的顺序非常重要，原因正在于此，一旦我们做了这一点，剩下的事情就交给微软，我们只需要通过 <code>HttpContext</code> 的 <code>User</code> 属性获取用户信息即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">Echo</span>(<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userName = Context.User?.Identity?.Name;</span><br><span class="line">  Clients.Client(Context.ConnectionId).SendAsync(<span class="string">"OnEcho"</span>, <span class="string">$"<span class="subst">&#123;userName&#125;</span>:<span class="subst">&#123;message&#125;</span>"</span>);</span><br><span class="line">  <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 SignalR 而言，同一个用户会对应多个 ConnectionId，当然，我并不需要过度地去关注这个东西，除非我们真的要分清每一个 ConnectionId 具体代表什么。类似地，SignalR 一样可以用 <code>[Authorized]</code> 特性来限制 Hub 是否可以在未认证的情况下使用，甚至它可以配合不同的 Policy 来做更细致的划分：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserRoleRequirement</span> : </span><br><span class="line">  AuthorizationHandler&lt;UserRoleRequirement, HubInvocationContext&gt;, IAuthorizationRequirement</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task <span class="title">HandleRequirementAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    AuthorizationHandlerContext context, UserRoleRequirement requirement, HubInvocationContext resource</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> userRole = context.User.Claims.FirstOrDefault(x =&gt; x.Type == ClaimTypes.Role)?.Value;</span><br><span class="line">    <span class="keyword">if</span> (userRole == <span class="string">"Admin"</span> &amp;&amp; resource.HubMethodName == <span class="string">"Echo"</span>)</span><br><span class="line">      context.Succeed(requirement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们定义了一个<code>UserRoleRequirement</code>类，其作用是仅仅允许<code>Admin</code>角色访问<code>Echo()</code>方法。此时，为了让这个策略生效，我们还需要将其注册到容器中，如下面的代码片段所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services</span><br><span class="line">  .AddAuthorization(options =&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    options.AddPolicy(<span class="string">"UserRoleRestricted"</span>, policy =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      policy.Requirements.Add(<span class="keyword">new</span> UserRoleRequirement());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>现在，我们可以在集线器(Hub)上控制 <code>Echo()</code> 方法访问权限，考虑到 <code>gRPC</code> 和 <code>SignalR</code> 都可以使用这套身份认证方案，所以，这个做法同样适用于 <code>gRPC</code>，如果你希望实现方法级的权限控制：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EchoHub</span> : <span class="title">Hub</span></span><br><span class="line">&#123;</span><br><span class="line">  [<span class="meta">Authorize(<span class="meta-string">"UserRoleRestricted"</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Task <span class="title">Echo</span>(<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> userName = Context.User?.Identity?.Name;</span><br><span class="line">    Clients.Client(Context.ConnectionId).SendAsync(<span class="string">"OnEcho"</span>, <span class="string">$"<span class="subst">&#123;userName&#125;</span>:<span class="subst">&#123;message&#125;</span>"</span>);</span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>无独有偶，除了 SignalR ，我们还用到了消息中间件 Kafka，事实上，SignalR 会从 Kafka 拉取消息，并将其发布到订阅了该 Topic 的客户端上，所以，Kafka 在整个系统中，其实扮演着非常重要的角色。如果你只是需要让 Kafka 充当一个消息中介者，那么，你完全不需要考虑 Kafka 的身份认证问题。可一旦你考虑用 Kafka 来做具体的业务，这个问题就会立刻凸显出来。譬如，当我们用 Kafka 来实现一个分布式事务的时候，我们采用了 SAGA 模式，即让主事务负责事务的协调，每个子事务在收到主事务的消息后，执行相应的操作并回复主事务一条消息，再由主事务来决定整个事务应该提交还是回滚。如图所示，下面是一个针对 SAGA 模式的简单示意图：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Kafka-Distributed-Transaction.drawio.png" alt="分布式事务 SAGA 模式示意图" referrerpolicy="no-referrer"></div><div class="image-caption">分布式事务 SAGA 模式示意图</div></figure><p>关于这个模式的细节，感兴趣的朋友可以从 <a href="https://docs.microsoft.com/zh-cn/azure/architecture/reference-architectures/saga/saga" target="_blank" rel="noopener">这里</a> 获取。这里我想说的是，当我们尝试用 Kafka 来做具体的业务的时候，我们其实是无法获得对应的用户信息的，因为此时此刻，基于 ASP.NET Core 的管道式的洋葱模型，对我们而言是暂时失效的，所以，我一直在说的非典型 Web 应用，其实可以指脱离了洋葱模型、脱离了授权/认证流程的这类场景。和 gRPC 类似，当我们需要用户信息，而又无法获得用户信息的时候，该怎么办呢？答案是在 Kafka 的消息中传递一个令牌(Token)，下面是一个简单的实现思路：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> producerConfig = <span class="keyword">new</span> ProducerConfig &#123; BootstrapServers = <span class="string">"192.168.50.162:9092"</span> &#125;;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> p = <span class="keyword">new</span> ProducerBuilder&lt;Null, <span class="keyword">string</span>&gt;(producerConfig).Build())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> token = <span class="string">"&lt;Your Token&gt;"</span>;</span><br><span class="line">    <span class="keyword">var</span> topic = “&lt;Your Topic&gt;<span class="string">";</span></span><br><span class="line"><span class="string">    var document = new &#123; Id = "</span><span class="number">001</span><span class="string">", Name = "</span>张三<span class="string">", Address = "</span>北京市朝阳区<span class="string">", Event = "</span>喝水未遂<span class="string">" &#125;;</span></span><br><span class="line"><span class="string">    var message = new Message&lt;Null, string&gt; &#123; Value = JsonConvert.SerializeObject(document) &#125;;</span></span><br><span class="line"><span class="string">    // 在 Kafka 消息头里增加 Authorization 字段</span></span><br><span class="line"><span class="string">    message.Headers = new Headers();</span></span><br><span class="line"><span class="string">    message.Headers.Add("</span>Authorization<span class="string">", Encoding.UTF8.GetBytes($"</span>Bearer &#123;token&#125;<span class="string">"));</span></span><br><span class="line"><span class="string">    var result = await p.ProduceAsync(topic, message);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>显然，这是非常朴素的一个想法，发送 Kafka 消息的时候，在 Kafka 的消息头里增加 <code>Authorization</code>字段，完美借鉴<code>HTTP</code>协议里的做法。那么，相对应地，消费 Kafka 消息的时候需要做一点调整，因为 Kafka 完全独立于 ASP.NET Core 的请求管道，所以，校验令牌的工作此时需要我们来独立完成。不过，请放心，这一切不会特别难，因为<code>JwtSecurityTokenHandler</code>这个类我们已经在前面用过一次：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> consumerConfig = <span class="keyword">new</span> ConsumerConfig &#123; BootstrapServers = <span class="string">"127.0.0.1:9092"</span> &#125;;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> c = <span class="keyword">new</span> ConsumerBuilder&lt;Null, <span class="keyword">string</span>&gt;(consumerConfig).Build())</span><br><span class="line">&#123;</span><br><span class="line">    c.Subscribe(<span class="string">"&lt;Your Topic"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    <span class="keyword">var</span> jwtHandler = <span class="keyword">new</span> JwtSecurityTokenHandler();</span><br><span class="line">    <span class="keyword">var</span> tokenParameters = <span class="keyword">new</span> TokenValidationParameters()</span><br><span class="line">    &#123;</span><br><span class="line">      ValidateIssuerSigningKey = <span class="literal">true</span>,</span><br><span class="line">      IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(<span class="string">"&lt;Your Secret&gt;"</span>)),</span><br><span class="line">      ValidIssuer = <span class="string">"&lt;Your Issuer&gt;"</span>,</span><br><span class="line">      ValidAudience = <span class="string">"&lt;Your Audience&gt;"</span>,</span><br><span class="line">      ValidateIssuer = <span class="literal">true</span>,</span><br><span class="line">      ValidateAudience = <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> userName = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">var</span> consumeResult = c.Consume(cts.Token);</span><br><span class="line">        <span class="keyword">var</span> headers = consumeResult.Message.Headers;</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="literal">null</span> &amp;&amp; headers.TryGetLastBytes(<span class="string">"Authorization"</span>, <span class="keyword">out</span> <span class="keyword">byte</span>[] values))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 校验令牌</span></span><br><span class="line">            <span class="keyword">var</span> jwtToken = Encoding.UTF8.GetString(values).Replace(<span class="string">"Bearer"</span>, <span class="string">""</span>).Trim();</span><br><span class="line">            <span class="keyword">var</span> claimsPrincipal = jwtHandler.ValidateToken(jwtToken, tokenParameters, <span class="keyword">out</span> SecurityToken securityToken);</span><br><span class="line">            userName = claimsPrincipal.Identity.Name;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我个人感觉，这样会增加消息消费方的工作，更好的做法是采用 <code>CallContext</code> 或者 <code>AsyncLocal</code> 来做统一的处理，这样，消息订阅方只需要关心消息怎么处理即可，考虑到 Kafka 属于 Pull 模式的消息队列，这种思路不见得在性能上有多少提升，更多的是一种简化啦，算是少写一点重复代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Subscribe&lt;TKey, TValue&gt;(</span><br><span class="line">  <span class="keyword">this</span> IConsumer&lt;TKey, TValue&gt; consumer, <span class="keyword">string</span> topic, </span><br><span class="line">  CancellationToken cancellationToken, Action&lt;TValue&gt; callback)</span><br><span class="line">&#123;</span><br><span class="line">  consumer.Subscribe(topic);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> consumeResult = consumer.Consume(cancellationToken);</span><br><span class="line">      <span class="keyword">if</span> (consumeResult != <span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> headers = consumeResult.Message.Headers;</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="literal">null</span> &amp;&amp; headers.TryGetLastBytes(<span class="string">"Authorization"</span>, <span class="keyword">out</span> <span class="keyword">byte</span>[] values))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">var</span> jwtToken = Encoding.UTF8.GetString(values).Replace(<span class="string">"Bearer"</span>, <span class="string">""</span>).Trim();</span><br><span class="line">          <span class="keyword">var</span> userInfo = <span class="keyword">new</span> JwtTokenResloverService().ValidateToken(jwtToken);</span><br><span class="line">          UserContext.SetUserInfo(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">            callback(consumeResult.Message.Value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ConsumeException e)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>UserContext</code>内部利用<code>AsyncLocal</code>在不同线程间共享用户信息，这可以让我们在任意位置访问用户信息，因为该扩展方法中会调用一次<code>SetUserInfo()</code>方法，所以，只要在 Kafka 的消息头上维护了<code>Authorization</code>字段，就可以从中解析出常用的用户信息，譬如用户名、用户角色等等。当然，按照 <a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a> 的 <a href="https://datatracker.ietf.org/doc/html/rfc7519" target="_blank" rel="noopener">规范</a>，我们最好还是不要在载荷(Payload)中存放敏感信息，如果需要更详细的信息，比如部门、权限等等，建议通过调接口或者查数据的库方式来实现。下面是<code>UserContext</code>的实现细节：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UserContext</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AsyncLocal&lt;UserInfo&gt; _localUserInfo = <span class="keyword">new</span> AsyncLocal&lt;UserInfo&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetUserInfo</span>(<span class="params">UserInfo userInfo</span>)</span> =&gt; _localUserInfo.Value = userInfo;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title">GetUserInfo</span>(<span class="params"></span>)</span> =&gt; _localUserInfo.Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常的简单，对不对? 作为 <code>CallContext</code> 的继任者，<code>AsyncLocal</code>就是这样的优秀！也许，大家会好奇<code>JwtTokenResloverService</code>是什么？其实，它还是<code>JwtSecurityTokenHandler</code>那一堆东西，下面的代码片段展示了如何从<code>ClaimsPrincipal</code>中提取用户名和角色名称，再次说明，不要在这里放敏感信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> claimsPrincipal = _jwtHandler.ValidateToken(token, tokenParameters, <span class="keyword">out</span> SecurityToken securityToken);</span><br><span class="line"><span class="keyword">if</span> (claimsPrincipal != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">  userInfo.UserName = claimsPrincipal.Identity.Name;</span><br><span class="line">  userInfo.UserRole = claimsPrincipal.Claims.FirstOrDefault(x =&gt; x.Type == ClaimTypes.Role)?.Value;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们一开始的例子，可以简化成下面这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> consumerConfig = <span class="keyword">new</span> ConsumerConfig &#123; BootstrapServers = <span class="string">"127.0.0.1:9092"</span> &#125;;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> c = <span class="keyword">new</span> ConsumerBuilder&lt;Null, <span class="keyword">string</span>&gt;(consumerConfig).Build())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">  c.Subscribe(<span class="string">"&lt;Your Topic&gt;"</span>, cts.Token, message =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// 获取当前用户信息</span></span><br><span class="line">    <span class="keyword">var</span> userInfo = UserContext.GetUserInfo();</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kafka 的故事，讲述到这里本该结尾，可世界上哪里会有完美的方案呢？如果考虑到 Kafka 发生消息堆积的可能性，一旦消息没有被及时处理，那么，这个放在消息头上的令牌可能会出现过期的情况。这种事情就和你使用缓存一样，如果不考虑缓存的击穿、穿透、雪崩三大灾难，那你对缓存的认知简直是肤浅。同样的道理，你要考虑令牌的过期、刷新、撤销，整个认知网络才算是真正建立起来，这些就交给我聪明的读者啦，或者以后有机会单独写一写这些话题。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>2021年的最后一天，西安疫情可谓是涛声依旧，居家隔离、远程办公、买不到菜，注定要为这段时光写下注脚。也许，我们都习惯了饭来张口的外卖生活，可在这一刻，当一切线下互动被迫中止的时候，我们终于发现这些“典型”的生活场景变得不再“典型”；当人们开始在微信群里用接龙的方式来寻求生活物资的时候，微信这个社交工具的缺点就被不断地放大；当人们逐渐回归到一种“以物易物”的状态时，我不得不感慨这种从骨子里与生俱来的生存本能；当人们习以为常的“典型”被打破，其本身是否就是一种舒适圈？无论技术还是生活，你是否有做好随时面对“非典型”场景的准备？我想，在与新冠病毒长期对峙的后疫情时代，这是每一个人都应该去思考的问题，这篇博客断断续续地写了好几天，大概 2021 终究还是要这般潦草的过去罢。因为，我是一个长期悲观主义者，我确信这个世界依旧遵循熵增定律。如果你打算反驳，我会说：你说得对。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="SignalR" scheme="https://qinyuanpei.github.io/tags/SignalR/"/>
    
      <category term="Kafka" scheme="https://qinyuanpei.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 借助 Any 类型实现接口的泛化调用</title>
    <link href="https://qinyuanpei.github.io/posts/2617947988/"/>
    <id>https://qinyuanpei.github.io/posts/2617947988/</id>
    <published>2021-12-10T11:53:29.000Z</published>
    <updated>2022-03-07T01:40:22.302Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>我发现，人们非常喜欢在一件事情上反复横跳。譬如，以编程语言为例，人们喜欢静态的、强类型语言的严谨和安全，可难免会羡慕动态的、弱类型语言的自由和灵活。于是，在过去的这些年里，我们注意到，<code>.NET</code> 的世界里出现了 <code>dynamic</code> 类型，<code>JavaScript</code> 的世界里出现了 <code>TypeScript</code>，甚至连 <code>Python</code> 都开始支持类型标注。这种动与静、强与弱的角逐，隐隐然有种太极圆转、轮回不绝的感觉。果然，“城外的人想冲进去，城里的人想逃出来”，钱钟书先生说的固然是婚姻，可世上的事情，也许都差不多罢！人们反复横跳的样子，像极了「九品芝麻官」里的方唐镜。曾经有段时间，好多人吹捧 <a href="https://v3.cn.vuejs.org/" target="_blank" rel="noopener">Vue3</a> + <a href="https://www.tslang.cn/" target="_blank" rel="noopener">TypeScript</a> 的技术栈，有位前辈一针见血地戳破了这种叶公好龙式的喜欢，“你那么喜欢 TypeScript，不还是关掉了 ESLint 的规则，项目里全部都用 Any”。对于这个吐槽，我表示非常真实，因为我们对于动与静、强与弱的心理变化是非常微妙的。常言道，“动态类型一时爽，代码重构火葬场”，你是如何看待编程语言里的动与静静、强与弱的呢？在 gRPC 中我们通过 Protobuf 来描述接口的参数和返回值，由此对服务提供/消费方进行约束。此时，参数和返回值都是静态的、强类型的。如果我们希望提供某种“泛型”的接口，又该如何去做呢？所以，这篇文章我们来聊聊 gPRC 里的 Any 类型。</p><h1 id="Protobuf-里的-Any-类型"><a href="#Protobuf-里的-Any-类型" class="headerlink" title="Protobuf 里的 Any 类型"></a>Protobuf 里的 Any 类型</h1><p>在讲 Any 类型前，我想，我们应该想明白，为什么需要这样一个类型？现在，假设我们有下面的 <code>Protobuf</code> 定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vehicle</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> VehicleId = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> FleetNo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Officer</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Officer</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> OfficerId = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> Department = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，按照<code>Protobuf</code>的规范，我们必须像下面这样定义对应的集合：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VehicleList</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">VehicleList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Vehicle List = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OfficerList</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">OfficerList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Officer List = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到，在<code>C#</code> 中我们只需要使用 <code>List&lt;Vehicle&gt;</code> 和 <code>List&lt;Officer&gt;</code> 即可，这样难免就会形成一种割裂感，因为你几乎要为每一种类型建立对应的表示集合的类型，从语义化的角度考虑，我们更希望使用下面的 <code>Protobuf</code> 定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Any List = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>VehicleList</code> 和 <code>OfficerList</code> 就可以统一到 <code>Collection</code> 这个类型中，这样，不但减少了花在类型定义的时间，更能帮助我们打开一点思路。在过去，我们编写 API 的时候，通常会定义下面的类来返回结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ApiResult&lt;TData&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Msg &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> TData Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，当我们用 gPRC 来做微服务的时候，我们希望在 <code>Protobuf</code> 中沿用这个设计：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ApiResult</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> Code = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> Msg = <span class="number">2</span>;</span><br><span class="line">  Any Data = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，它可以和我们在 <code>C#</code> 中的认知联系起来，不会让你有太多心智上的负担。基于上述两种诉求，我们发现， <code>Protobuf</code> 中存在着需要泛化的场景，你可以理解为，我们需要用 <code>Protobuf</code> 来表示泛型或者模板类这样的东西。幸运的是，Google 为我们定义了 <code>Any</code> 类型，它到底是何方神圣呢？我们一起来看看：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Any</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> type_url = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">bytes</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，它就是这样的朴实无华，甚至比古天乐还要平平无奇，简单来说，<code>type_url</code>字段告诉你这是一个什么类型，<code>value</code>字段里则存放对应的二进制数据，而这就是 <code>Any</code> 类型的全部秘密！</p><h1 id="在-NET-中使用-Any-类型"><a href="#在-NET-中使用-Any-类型" class="headerlink" title="在 .NET 中使用 Any 类型"></a>在 .NET 中使用 Any 类型</h1><p>好了，下面我们来演示，如何在 .NET 中使用 <code>Any</code> 类型。通过前面我们已经知道， <code>Any</code> 类型和我们自定义的消息没有区别，所以，它同样实现了 <code>IMessage</code> 和 <code>IMessage&lt;Any&gt;</code>两个接口，唯一不同的地方在于，它拥有<code>Pack()</code>、<code>Unpack&lt;T&gt;()</code>、<code>TryUnpack&lt;T&gt;()</code>这样几个静态方法，这是实现任意 <code>IMessage</code> 到 <code>Any</code> 相互转换的关键。现在，假设我们现在有如下的 <code>Protobuf</code> 定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AnyRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Any Data = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AnyResponse</span> </span>&#123;</span><br><span class="line">  google.protobuf.Any Data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> Name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> Name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果我们希望在 <code>AnyRequest</code> 或者 <code>AnyResponse</code> 里传递 <code>Any</code> 类型，我们可以这样做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anyRequest = <span class="keyword">new</span> AnyRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo -&gt; Any，默认类型地址前缀</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.Name = <span class="string">"Foo"</span>;</span><br><span class="line">anyRequest.Data = Any.Pack(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bar -&gt; Any, 自定义类型地址前缀</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line">bar.Name = <span class="string">"Bar"</span>;</span><br><span class="line">anyRequest.Data = Any.Pack(bar, <span class="string">"type.company.com/bar"</span>);</span><br></pre></td></tr></table></figure><p>反过来，我们可以从 <code>Any</code> 中解析出 <code>IMessage</code> ：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.Data.Is(Foo.Descriptor))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Any -&gt; Foo</span></span><br><span class="line">  <span class="keyword">var</span> foo = request.Data.Unapck&lt;Foo&gt;();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (request.Data.Is(Bar.Descriptor))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Any -&gt; Bar</span></span><br><span class="line">  <span class="keyword">var</span> bar = request.Data.Unapck&lt;Bar&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的 <code>Any</code> 类型，只能对 <code>Protobuf</code> 生成的类型(即实现了 IMessage 接口)进行 <code>Pack</code> ，如果我们想做得更绝一点(最好还是不要)，那么，可以使用自定义的 <code>MyAny</code> 类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyAny</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> TypeUrl = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">bytes</span> Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地，我们为 <code>MyAny</code> 类型编写一点扩展方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyAnyExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyAny <span class="title">Pack</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">object</span> obj, <span class="keyword">string</span> typeUrlPrefix = <span class="string">""</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> any = <span class="keyword">new</span> MyAny();</span><br><span class="line">        any.TypeUrl = <span class="string">$"<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;obj.GetType().FullName&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(obj));</span><br><span class="line">        any.Value = Google.Protobuf.ByteString.CopyFrom(bytes);</span><br><span class="line">        <span class="keyword">return</span> any;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Unpack&lt;T&gt;(<span class="keyword">this</span> MyAny any, <span class="keyword">string</span> typeUrlPrefix = <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> typeUrl = <span class="string">$"<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;<span class="keyword">typeof</span>(T).FullName&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">if</span> (typeUrl == any.TypeUrl)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> json = Encoding.UTF8.GetString(any.Value.ToByteArray());</span><br><span class="line">            <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> Is&lt;T&gt;(<span class="keyword">this</span> MyAny any, <span class="keyword">string</span> typeUrlPrefix = <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> typeUrl = <span class="string">$"<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;<span class="keyword">typeof</span>(T).FullName&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">return</span> typeUrl == any.TypeUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们就可以对任意类型进行处理，虽然，此时此刻，从严格意义上来讲，它已不再属于 <code>Protobuf</code> 的范畴，因为序列化/反序列化都交给了 JSON ：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = serviceProvider.GetService&lt;ProtobufAny.Greeter.GreeterClient&gt;();</span><br><span class="line">client.Ping(<span class="keyword">new</span> Foo() &#123; Name = <span class="string">"Foo"</span> &#125;.Pack());</span><br><span class="line">client.Ping(<span class="keyword">new</span> Bar() &#123; Name = <span class="string">"Foo"</span> &#125;.Pack());</span><br><span class="line">client.Ping(<span class="keyword">new</span> &#123; X = <span class="number">0</span>, Y = <span class="number">1</span>, Z = <span class="number">0</span> &#125;.Pack());</span><br></pre></td></tr></table></figure><p>这样看起来是不是非常酷？我始终认为，这件事情是有意义的，一个系统中最多的接口显然是查询接口，此时，我们可以构建一个通用的 <a href="https://github.com/qinyuanpei/DynamicSearch" target="_blank" rel="noopener">查询</a> 来处理，使用者只需要传递一个实体、一个Proto，一组过滤条件，它就可以返回对应的数据，这样是不是比写一个又一个差不多的接口要好一点呢？过去我们开发 API，主张用数据传输对象(DTO)来隔离持久化层和业务层，从这个角度来看，Protobuf 本身就是 一种 DTO ，对于大多数相似的、模板化的、套路化的接口，我们完全可以考虑用这种方案来实现，只要双方约定好类型即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在业务层构建通用的查询</span></span><br><span class="line"><span class="keyword">public</span> QueryReply Query&lt;TInput, TOutput&gt;(SearchParameters searchParameters) <span class="keyword">where</span> TInput : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = _chinookContext.Set&lt;TInput&gt;().AsQueryable().Search(searchParameters).ToList();</span><br><span class="line">    <span class="keyword">var</span> output = result.Adapt&lt;List&lt;TOutput&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reply = <span class="keyword">new</span> QueryReply();</span><br><span class="line">    reply.List.AddRange(output.Select(x =&gt; x.Pack()));</span><br><span class="line">    <span class="keyword">return</span> reply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x =&gt; &#123; 1, 2, 3 &#125;.Contains(x.AlbumId)</span></span><br><span class="line"><span class="keyword">var</span> searchParameters = SearchParameters();</span><br><span class="line">searchParameters.QueryModel = <span class="keyword">new</span> QueryModel();</span><br><span class="line">searchParameters.QueryModel.Add(<span class="keyword">new</span> Condition() &#123; Field = <span class="string">"AlbumId"</span>, Op = Operation.StdIn, Value = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在服务层解析参数，完全可以由调用方提供 SearchParameters</span></span><br><span class="line"><span class="keyword">var</span> inputType = Type.GetType(request.InputType);</span><br><span class="line"><span class="keyword">var</span> outputType = Type.GetType(request.OutputType);</span><br><span class="line"><span class="keyword">if</span> (inputType != <span class="literal">null</span> &amp;&amp; outputType != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> queryMethod = _queryService.GetType().GetMethod(<span class="string">"Query"</span>).MakeGenericMethod(inputType, outputType);</span><br><span class="line">    QueryReply queryResult = (QueryReply)queryMethod.Invoke(_queryService, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; </span><br><span class="line">      <span class="keyword">new</span> DynamicSearch.Core.SearchParameters()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> Task.FromResult(queryResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>对于编程语言中的动与静、强与弱，我个人觉得还是要看场景，只要双方定义好契约，我相信，它都可以运作起来，当然，更多的时候，我们是在灵活与严谨间反复横跳。作为一门 DSL，Protobuf 虽然可以对服务提供/消费方产生一定约束，可当我们面对需要泛型或者模板类的场景的时候，这种做法就变成了一种负担，更不必说它缺乏对继承的支持。想象一下，你要写二十多个大同小异的接口，譬如为每一张数据表写一个 <code>GetXXXById()</code> 的接口。此时，我们可以借助 <code>Any</code> 类型来实现类似泛型、模板类的东西，它本质上还是 <code>IMessage</code> 接口的实现类，唯一的不同是增加了 Pack/Unpack 这组静态方法，可以帮助我们实现 <code>Any</code> 和 <code>IMessage</code> 的相互转换，关于本文中使用的的实例，可以参考：<a href="https://github.com/Regularly-Archive/2021/tree/master/src/ProtobufAny" target="_blank" rel="noopener">ProtobufAny</a>，好了，以上就是这篇博客的全部内容，如果有朋友对文章中的内容和观点存在疑问，欢迎在评论区积极留言，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="Protobuf" scheme="https://qinyuanpei.github.io/tags/Protobuf/"/>
    
      <category term="Any" scheme="https://qinyuanpei.github.io/tags/Any/"/>
    
  </entry>
  
  <entry>
    <title>分布式丛林探险系列之 Redis 集群模式</title>
    <link href="https://qinyuanpei.github.io/posts/1213387651/"/>
    <id>https://qinyuanpei.github.io/posts/1213387651/</id>
    <published>2021-12-01T09:58:59.000Z</published>
    <updated>2022-03-07T01:40:22.318Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>时间终于来到了十二月，据说，<a href="https://movie.douban.com/subject/34801038/" target="_blank" rel="noopener">《黑客帝国 4：矩阵重生》</a> 将于本月在北美上映，正如同它的片名一样，黑客帝国系列在沉寂了十八年后，终于等来了一次矩阵重生的机会，不可不谓“有生之年”、“爷青回”。提及黑客帝国系列，这是一部公认的、具有划时代意义的科幻电影，除了精彩绝伦的打斗特效，最为影迷所津津乐道的，当属对于人和机器的关系这种颇具哲学意味的问题的探讨。在第二部中，The One 的部分代码被融合到了 Smith 身上，而这使得 Smith 发生变异，成为了可以自我复制的病毒。于是，我们在这里看到了 Neo 和 100 个 Smith 打斗的桥段，类似的桥段还有第三部里的雨中决斗。这些桥段或多或少地影响到了后来的电影，譬如，星爷的 <a href="https://movie.douban.com/subject/1291543/" target="_blank" rel="noopener">《功夫》</a> 里，阿星与斧头帮、火云邪神打斗的片段；吴京的第一部电影 <a href="https://movie.douban.com/subject/3082452/" target="_blank" rel="noopener">《狼牙》</a> 里，阿布雨夜大战黑衣人的片段等等。虽然，病毒的自我复制和分布式系统中的复制，是两个完全不同的概念，可当我们试图将电影和现实联系起来的时候，我们还是会不免会心一笑，因为 100 个 Smith ，大概就相当于一个 Smith 的集群；而吞噬了先知能力的 Smith ，大概就相当于这个集群中的 Leader。我们注意到，强如超人般的 Neo，一样架不住越来越多的 Smith ，最后不得不飞走，所谓：“双拳难敌四手”，这足以说明集群的重要性。好了，既然这里聊到了集群，那么我们这次来聊聊 Redis 中的集群模式。</p><h1 id="Redis-集群概述"><a href="#Redis-集群概述" class="headerlink" title="Redis 集群概述"></a>Redis 集群概述</h1><p>通过上一篇<a href="/posts/1748863652/">文章</a>，我们了解到，主从复制的作用主要体现在数据冗余、故障恢复、负载均衡等方面。可很多时候，我们讲分布式，并不是说简单的复制就好啦！相信大家都听说过，水平扩展和垂直扩展这两个概念，特别是数据库的水平扩展，它天然地和分片(Sharding)联系在一起，这意味是我们希望在不同地数据库/表里存储不同地数据。此前，博主曾在 <a href="https://blog.yuanpei.me/posts/2151871792/" target="_blank" rel="noopener">《浅议 EF Core 分库分表及多租户架构的实现》</a> 一文里介绍过数据库的分库/表，作为类比，我们可以归纳出 Redis 集群模式的第一个特点，即：<strong>它本质上是一种服务器 Sharding 技术</strong>。因为纯粹的主从复制意味着，每台 Redis 服务器都存储相同的数据，显然这造成了资源的浪费，而让每台 Redis 服务器存储不同的数据，这就是 Redis 的集群模式。如下图所示，Redis 集群模式呈现出的一种网状结构，完全不同于主从复制间的单向流动：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-theory.drawio.png" alt="Redis 集群模式示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 集群模式示意图</div></figure><p>从图中可以看出，6 台服务器组成了一个网状结构，任意两台服务器间都可以相互通信。也许，大家会好奇一个问题，为什么这里博主就画了 6 台服务器？其实，这一切都是有迹可循的，因为 Redis 官方规定：一个集群中至少需要有 3 个主服务器(Master)。所以，一个 Redis 集群至少需要 6 台服务器。如果从这个角度来审视集群的定义的话，你可以认为 Redis 集群就是由多个主从复制一起对外提供服务。此时，集群中的节点都通过 TCP 连接和一个被称为 Cluster Bus 的二进制协议来建立通信，这里的 Cluster Bus 你可以将其理解为 <a href="https://kafka.apache.org/" target="_blank" rel="noopener">Kafka</a> 或者 <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a> 这样的支持“发布-订阅”(Pub-Sub)机制的东西，换句话说，集群中的每个节点都可以通过 Cluster Bus 与集群中的其它节点连接起来。节点们使用一种叫做 <a href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.2/gossip.html" target="_blank" rel="noopener">Gossip</a> 的消息协议，据说，这是一种从瘟疫和社交网站上获得灵感消息传播方式。“六度分割”理论告诉我们，<strong>最多通过 6 个人你就能认识任何一个陌生人</strong>，同样地，最多通过 6 个节点你就可以把消息传递给任何一个节点。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-1.drawio.png" alt="Redis 集群模式与主从模式的联系" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 集群模式与主从模式的联系</div></figure><p>目前，使用 Gossip 这一协议的项目有 Redis Cluster、<a href="https://www.consul.io/" target="_blank" rel="noopener">Consul</a>、<a href="https://cassandra.apache.org/_/index.html" target="_blank" rel="noopener">Apache Cassandra</a> 等等, 关于这个协议以及“六度分割”理论更进一步的细节，大家可以通过搜索引擎来获取，对我们而言，我们只需要知道，Redis 集群需要借助这个协议来实现诸如发现新节点、发送 <code>PING</code> 包、发送集群消息这些功能，因为每个节点除了存储自身的数据以外，还需要记录集群的状态，需要知道哪些节点不可用，需要合适的时机推选出主节点。我们在主从复制这一篇文章中提到过故障恢复，这个概念在这里同样适用，如图所示，S1 是 M1 的从节点，它本身并不是为了扩展请求的并发量而存在的，它需要在主节点宕机的情况下能被提拔为主节点，所以，它主要起一个数据备份的作用。因此，Redis 集群中的读和写，实际上都是在M1、M2 和 M3 上进行的。那么，我们不妨来想这样一个问题，如果 M1 和 S1 都宕机了，此时 Redis 集群还能不能正常工作呢？答案是否定的，因为此时显然不满足最少 3 个主节点的要求。</p><h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p>OK，我们知道，在面对数据库的水平拆分问题时，一个最为关键的问题是路由，换句话说，我怎么样可以找到到对应的库或者表。常见的思路有范围、哈希和配置等等，而在 Redis 的集群模式下，我们同样会面临这个问题，更一般地，任何需要负载均衡的场景都需要考虑这个问题，譬如，我们对多台服务器的 IP 地址求余，然后按照余数来进行路由，抑或者是按照不同的权重进行随机等等，这看起来像回到了熟悉的负载均衡算法，对吗？事实上，一般的负载均衡算法都会选择哈希算法，而哈希算法本质上就是一种散列函数，它可以把任意长度的输入转化为确定的、固定长度的输出，以最常见的求余为例，它具体是怎么工作的呢？我们来一起看下面的图：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Hash.drawio.png" alt="经典哈希算法" referrerpolicy="no-referrer"></div><div class="image-caption">经典哈希算法</div></figure><p>可以注意到，首先，我们需要对 Key 计算出一个 hash 值，你可以理解为编程语言里的<code>GetHashCode()</code>方法，主要目的是将字符串类型的 Key 转化为整数型方便计算。接下来，按照主节点的数量来进行求余运算(统称为<strong>散列运算</strong>)，例如，这里我们有 3 台主节点服务器，故而在上面的图示中 n 应该等于 3，而这就是经典的哈希算法啦！那么，Redis 的集群有没有采用这个算法呢？答案还是否定的，因为这个方案里最大的变数就是 n。具体来讲，如果你想要扩容，那么 n 会变大，此时 Key 与服务器间的映射关系会被打破，即使不扩容，一旦某台服务器宕机，Key 与服务器间的映射关系还是会被打破，如果出现散列“碰撞”，无疑会让问题变得更复杂。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Hash-Conflict.drawio.png" alt="经典哈希算法“碰撞”问题" referrerpolicy="no-referrer"></div><div class="image-caption">经典哈希算法“碰撞”问题</div></figure><p>可以注意到，当从对 3 取模变成对 2 取模以后，必然会出现两个 1，这就是所谓的散列“碰撞”。所以，对于经典的哈希算法而言，它无法抵消因为 n 的变化而带来的重新 hash 的问题。为了解决这个问题，业界普遍使用的是一致性哈希算法，相比经典的哈希算法，最大的变化在于它将 n 的取值固定下来，即按 <code>2^32</code> 取模，此时，结果会落在 0 到 <code>2^32 - 1</code> 这个区间内，一旦我们将这个区间抽象为一个圆环，利用 CRC16 算法计算出来的值就会落在圆环上的某个地方：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Hash-Advance.drawio.png" alt="改良后的哈希一致性算法" referrerpolicy="no-referrer"></div><div class="image-caption">改良后的哈希一致性算法</div></figure><p>如图所示，假设我们有 A、B、C 三个 Redis 节点，它们均按照顺时针方向排列在整个圆环上，当我们对每一个 Redis 节点进行 <code>hash()</code> 运算以后按 <code>2^32</code> 取模，此时，这个值依然会落在 0 到 <code>2^32 - 1</code> 这个区间内，以此类推，理论上对于任意一台服务器 X，我们总能找到对应的一个值，当该值介于区间<code>(m, n)</code>中，表示它分配在节点 n 上，你可以认为，每个服务器节点，它负责的并不是哈希环上的一个点，而是一个范围。基于这种特性，当某一台 Redis 服务器宕机时，对应的这个区间会变大，相当于流量从这个节点转移到了它的下一个节点，这意味着我们只需要移动一部分数据。同理，如果要增加节点，只需要把移动该节点到它上一个节点间的数据。由此可见，它对原来数据的影响非常小，而这就是一致性哈希算法。</p><h2 id="Redis-哈希槽"><a href="#Redis-哈希槽" class="headerlink" title="Redis 哈希槽"></a>Redis 哈希槽</h2><p>截止到现在，我们知道了，一致性哈希算法相对经典哈希算法的优势，可这个算法真的没有问题吗？我们应该会想到，节点在哈希环上的分布是不均匀的，这意味着，每个节点上对应的 Key 的数量各不相同，更进一步，我们可以说，每台 Redis 上存储的数据量不同，这样，原本期待着负载均衡的我们，此刻被光速地打脸。因此，在实际应用中，为了让哈希环分布更均匀一点，会设置所谓的“虚拟节点”。不过，就算你考虑到了这种地步，Redis 还是没有采用这种哈希一致性的方案，你说这是不是有点气人？事实上，它采用的是一种被称为哈希槽的方案：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Hash-Slots.drawio.png" alt="Redis 哈希槽示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 哈希槽示意图</div></figure><p>如图所示，Redis 集群中总共有 16384 个槽位，它是怎么算出来的呢？因为 CRC16 算法产生的 hash 值有 16 个 bit，因此，它可以产生 <code>2^16</code> 即 65536 个值，理论上我们完全可以分配 65536 个槽位，不过考虑到网络带宽、节点数目，作者觉得 16384 个槽位完全够用了，前提是你集群内的节点不超过 1000 个！是不是听起来觉得非常离谱？可有些时候，工程上的事情，还真不能按科学一板一眼的来，不然，你又怎么会见到各种各样的“敏捷开发”、”项目管理”呢？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Hash-Slots-Assign.png" alt="Redis 哈希槽槽位分配" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 哈希槽槽位分配</div></figure><p>OK，对于 Redis 中的每一个 Key，它经过计算以后会落到某个具体的槽位内，至于槽位会路由到哪个机器上，这完全取决于每台 Redis 服务器的配置，硬盘大就多分一点，硬盘小就少分一点，“能者多劳”，听起来就很科学，对吧！所以，从这个角度来看，相比哈希环，哈希槽可以更加灵活地控制槽位的分布。可世间万物，无一不是双刃剑，你选择了自由，那么需要操心的事情就变多了，至少 Redis 集群不会帮你转移和分配槽位；你选择了秩序，一切井井有条，那么你内心又会期盼自由。“小而美”，想要面面俱到；“大而全”，想要细致入微，难怪刺客组织要和圣殿骑士间的斗争永无止息啊，哈哈……因此，Redis 集群的高可用，实际上非常依赖主从节点的主从复制和故障切换，我承认，我点题了，你发现了吗？</p><h1 id="Redis-集群实战"><a href="#Redis-集群实战" class="headerlink" title="Redis 集群实战"></a>Redis 集群实战</h1><p>好了，和上一篇一样，我们先礼后兵，等所有的理论知识都讲完了，再来着眼实际的过程，因为在博主看来，这是一个互相印证的过程，写流水账、记下每一步的操作步骤，这固然可以让你快速上手，但你真的只愿意到此为止吗？博主以前学过 CAD，近来又开始学习 <a href="https://www.blender.org/" target="_blank" rel="noopener">Blender</a>，一个深刻的感受就是，这些软件都需要大量的重复练习，甚至于形成肌肉记忆。可是我们学习知识的过程，是一个反复提炼、内化的过程，我们并不是为了成为某种“熟练工”，我发现有很多朋友，特别喜欢问某软件/工具怎么安装/配置类似的问题，虽然说这是技术人员日常生活里的一部分，但我觉得这不应该成为你特别关注的问题，所以，如果你发现我越来越不像是在写教程，恭喜你，发现了我的改变，谢谢你啊！回到正题，我们还是准备一个最小的集群，即“<strong>三主三从</strong>”的一个集群，依然使用 <code>docker-compose</code> 进行服务编排。首先，准备下面的目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Clusters</span><br><span class="line">|-- docker-compose.yaml</span><br><span class="line">|-- redis-1</span><br><span class="line">|   |-- redis.conf</span><br><span class="line">|-- redis-2</span><br><span class="line">|   |-- redis.conf</span><br><span class="line">|-- redis-3</span><br><span class="line">|   |-- redis.conf</span><br><span class="line">|-- redis-4</span><br><span class="line">|   |-- redis.conf</span><br><span class="line">|-- redis-5</span><br><span class="line">|   |-- redis.conf</span><br><span class="line">|-- redis-6</span><br><span class="line">|   |-- redis.conf</span><br></pre></td></tr></table></figure><p>此时，针对集群模式的 Redis 配置文件，相比主从复制模式要精简许多，以其中一台服务器<code>7001</code>为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 端口号</span><br><span class="line">port 7001</span><br><span class="line"># 启用集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes_7001.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>照葫芦画瓢，我们准备好剩下的<code>7002</code>、<code>7003</code>、<code>7004</code>、<code>7005</code>、<code>7006</code> 这 5台服务器即可。接下来，我们准备服务编排文件<code>docker-compose.yaml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-1/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">redis2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-2/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">redis3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-3/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">redis4:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-4/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">redis5:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-5</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-5/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">redis6:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-6</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-6/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>接下来，我们运行 <code>docker-compose up</code>命令，就可以看到 6 台 Redis 服务器都运行起来，此时，我们需要选择任意一台 Redis 服务器对应的容器内，执行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create </span><br><span class="line">  127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 \</span><br><span class="line">  127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 \</span><br><span class="line">  --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>该命令表示创建一个由 6 台服务器组成的集群，其中，<code>--cluster-replicas</code> 参数表示每个主节点分配一个从节点。此时此刻，当我们按下回车后，就可以看到下面的画面：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Docker-01.png" alt="通过 redis-cli 创建 Redis 集群" referrerpolicy="no-referrer"></div><div class="image-caption">通过 redis-cli 创建 Redis 集群</div></figure><p>可以注意到，当前集群有 3 台主服务器节点：<code>7001</code>、<code>7002</code> 和 <code>7003</code>，有 3 台从服务器节点：<code>7004</code>、<code>7005</code> 和 <code>7006</code>，这符合我们一开始设想的“<strong>三主三从</strong>”，Redis 内部会为每个节点分配一个唯一的 Id，这个 Id 会和每个节点的 IP 地址、端口号一起保存下来。当我们没有显式地分配每台服务器对应多少个槽位时，它会按照主节点的数量平均地分割。在这里我们只有 3 台主节点服务器，无法被 16384 整除，所以，<code>7002</code> 这个服务器会多分配一个槽位。显然，Redis 需要我们来确定这个集群划分，此时，我们输入<code>yes</code>即可，这样我们就完成了 Redis 集群的搭建。接下来，我们通过 <code>redis-cli</code> 写入信息来看看集群实际的运行效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 Redis 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it df5cae3c6004 sh</span><br><span class="line"><span class="comment"># 连接 7001 服务器</span></span><br><span class="line">redis-cli -p 7001 -c</span><br><span class="line"><span class="comment"># 写入一个 key</span></span><br><span class="line">127.0.0.1:7001&gt; <span class="built_in">set</span> name yuanpei</span><br></pre></td></tr></table></figure><p>我们会发现一个现象，就是 Redis 会告诉你这里有一次重定向，如图所示，它从 <code>7001</code> 重定向到了 <code>7002</code>，这是因为按照 CRC16 算法计算出的结果，<code>name</code> 这个键应该被分配到 <code>7002</code> 上存储：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Docker-03.png" alt="通过 redis-cli 向 Redis 集群写入值" referrerpolicy="no-referrer"></div><div class="image-caption">通过 redis-cli 向 Redis 集群写入值</div></figure><p>同理，在我们已经知道 <code>name</code> 这个键存储在 <code>7002</code>上的情况下，我们依然可以从集群中的其它节点上读取到这个值：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Docker-02.png" alt="通过 redis-cli 向 Redis 集群读出值" referrerpolicy="no-referrer"></div><div class="image-caption">通过 redis-cli 向 Redis 集群读出值</div></figure><p>可以注意到，集群依然可以自动地从 <code>7004</code> 重定向到 <code>7002</code>，这表明，我们可以从集群中的任何一个节点上查询数据，并且每个节点上都存储着不同的数据，这可不就是数据分片吗？这恰恰印证了我一开始的观点，即：<strong>Redis 的集群模式，本质上是一种服务器 Sharding 技术</strong>。果然，博主诚不欺人也，哈哈！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Clusters-Vote.drawio.png" alt="Redis 集群投票示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 集群投票示意图</div></figure><p>到目前为止，我们已经搭建出了一个基本的 Redis 集群，你可能会问，如果集群中某个节点发生宕机该怎么办呢？此时，我们要注意区分，这是主观宕机还是客观宕机。什么是主观宕机呢？就是某个节点认为你挂了；什么是客观宕机呢？就是集群内超过半数的节点认为你挂了。事实上，只有客观宕机会触发故障转移，而所谓的故障转移，其实就是从故障节点的从节点中挑选一个出来继续提供服务，此时，需要有超过半数以上的主节点给这个从节点投票，这样，Redis 集群就会让它当选为新的主节点，谁能想到，在以绝对理性著称的技术世界里，居然会有如此民主而科学的做法呢？可少数服从多数，真的就是对的吗？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>坦白讲，这篇文章写起来非常费劲，因为它里面关联的知识点非常密集，从经典哈希算法到一致性哈希算法，再到 Redis 集群里的哈希槽，这是一个循序渐进的认知过程，我们由此认识到，Redis 的集群模式，本质上是由多个主从复制模式组成的服务器分片技术，它通过哈希槽来管理集群内的节点和数据，而节点间则是通过 TCP 协议互相通信，这使得我们可以从任意节点上查询数据，因为 Redis 集群会帮助我们实现连接的重定向。与此同时，Redis 集群内通过投票来实现故障转移，其触发机制是超过半数的节点认为该节点宕机，即客观宕机，此时，就需要从该节点的从节点中筛选一个继续提供服务，当然，这个筛选还是投票决定的，谁能说这不是一种现实世界的投影呢？好了，以上就是这篇博客的全部内容啦，关于 Gossip 协议等更细节的东西，留到以后有机会再写吧…..！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Redis" scheme="https://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="分布式" scheme="https://qinyuanpei.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="集群" scheme="https://qinyuanpei.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>写在冬阳升起以前</title>
    <link href="https://qinyuanpei.github.io/posts/2145169599/"/>
    <id>https://qinyuanpei.github.io/posts/2145169599/</id>
    <published>2021-11-26T08:48:41.000Z</published>
    <updated>2022-03-07T01:40:22.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="冬阳.jpg" alt="某个冬天的清晨" referrerpolicy="no-referrer"></div><div class="image-caption">某个冬天的清晨</div></figure><p>突然间想要写点什么，或许是我终于发觉，一个人内心的疲惫感，是会像水里泛起的涟漪一样，一圈圈地向远方散开去，直至在某个时刻产生了共振，这种感觉就仿佛是，冬天的清晨，于雾气中升起的太阳，虽然无法令你感受到炽热，可依然会令你感到刺目甚至眩晕，圣人有云，“劳心者治人，劳力者治于人”，而这种劳心又劳力的状态，属实是一个普通打工人，经常要去面对的一件事情，因此，我想要说的，本质上是一种薛定谔的状态，它代表着温暖，代表着光明，可以给你生存所需要的一切，可于此同时，它又代表着炽热，代表着煎熬，可以毫无顾忌地灼伤你裸露的心。</p><p>就像一下子击中内心似的，我渐渐意识到，这个世界上的工作，本质上只有两种，一种是问题本身特别难，需要更多的心智上的投入，譬如数学、计算机图形学、物理碰撞等等，一个有意思的事情是，国产单机游戏《古剑奇谭3》和《仙剑奇侠传7》，男主的剑都是直接“浮空”地背在人物身上的，甚至都没有剑鞘，而《巫师3》据说光是一个拔剑/收剑就借助了相当多的技术手段，这其中最大的问题在于穿模，尤其是国产游戏都喜欢给武器加各种发光特效，很多时候为了避免穿模的尴尬，不得不在刀/剑入鞘以后隐藏刀/剑刃这部分的模型，所以，这一类问题有时候属于“看起来简单，实现起来复杂”，联想到曾经有产品经理和程序员因为需求而大打出手的新闻，你就不难理解，人们对于难易程度的认知差异，其实是非常大的，原因就在于，人们无法确定这到底属于那一类问题，有人关注整体，就有人关注局部，就像人的眼睛，视锥体永远有一个范围，这无疑让人类永远只能看到一部分，这似乎会成为某种宿命，本身就很难的问题，大概就是无论从整体还是局部来看，难度都没有变化的问题。此前，有同事要计算客户的分层活跃度，我虽然知道这是一个关乎数学期望的问题，可因为我早就忘记了怎么去算概率密度函数，所以，这个问题我只知道方向而无从下手，换句话说，本身就很难的问题，并不会因为场景的转换而发生变化。</p><p>而相对地，第二种是问题本身不难，但因为流程、方案、组织等因素而变得复杂，不幸的是，我们在生活和工作中遇到的都是这种情况。我们总安慰自己说，买菜做饭用不到高等数学，其实，从某个角度来看，是因为作为普通人的你我，完全没有机会接触到这种“难题”。当然，我并不否认，这种因为复杂度提升而带来的挑战性。联想到最近网上报道的甘肃大爷花132万改造房子的新闻，我终于意识到，工程上的问题是无所谓科学与否的，因为无论装修工艺如何演进，技术与艺术的鸿沟始终存在。软件行业更是类似，不论我们使用多么先进的技术或是框架，多年来羁绊不前的其实是需求分析。我始终不明白，人可以靠着感觉去做一件事情，就好像设计师陶磊可以用傲慢和偏见去替老人做出选择一样，而我们这个行业可以在需求没落实的情况下仓促开发。如果说这两者间有什么本质上的不同，大概摸不着的软件和代码可以永无止境地修改吧！那么，当大爷的红砖毛坯房墙体开始反碱的时候，这是肉眼看得见的崩塌，可代码世界里的崩塌，又有谁会在乎呢？我们又太多太多的难度，完全是自己构建出来的，也许，这样能让大家看起来都在忙碌吧……</p><p>熟悉我的人，都知道我是一个怕麻烦的人，这种惰性，一旦体现在工作上，就表现为对繁琐、重复的厌倦，厌倦含糊不清的规则，厌倦似是而非的表达。每次工作上别人找我问问题，我更希望，对方可以用一句话说清楚他的疑虑，而不是每次都挥手示意我“过来”，我以为这是某种表达能力的欠缺，可很多时候，尤其是研发工作中的来来回回，这种沟通更像是一种“剧本杀”，每个人都利用手中的信息来拼凑出一个故事，然后互相从对方的故事中寻找破绽。这种感觉有时候会让我觉得麻烦，是不是隐隐约约有什么东西再让事情变得复杂起来，虽然我确信，熵增定律一定会让事物的复杂度变高，可假如这一切可以避免呢？我们都听过一个词——内耗，譬如，最典型的想太多、自我否定等等，一个人精神层面的自我内耗会让整个人都变得焦灼起来，而这种问题，如果反映到一个团队或者组织中，大概就是将错就错，“磨刀不误砍柴工”，可如果所有人都宁愿拿着一把生锈的刀去砍柴呢？有的人能忍受这样一把生锈的刀，有的人一定要用瑞士军刀才有生产力，而这就是分歧。</p><p>我一直觉得，我是那个站在技术与人文十字路口的那个人，甚至我能将这种东西完美融合在一起，毕竟，对于一个19岁前写诗的程序员来说，本质上都属于输入/输出的一个过程。可多年以后，我渐渐发现，我是一个重视实用性超过艺术性的人，也许，是技术给了我这种实用主义思维，当我发现我通过 Blender 建模无法调出甜甜圈的颜色的时候，我隐隐约约地从材质编辑器中找到了一点当年写 Shader 时的感觉，我终于理解了当初关于 CSS 不正交的说法，那就是，当一件事情有多种方式可以做到的时候，对于普通人而言，困难已不再是实现这件事情，而是做出选择，装修这项工程是这样，日常的研发工作还是这样，甚至人生都是这样，我们从来到这个世界的那一天起，无数种世界观、人生观、价值观开始交织和缠绕，我们清楚地知道人生的结局是什么，以至于这个真相都不在重要，毕竟，我们每天经历的事情，一直都在教你做出选择，以及不断合理化这个选择，人们常说，选择比努力更重要，那么，聪明的你，你说，哪一件事情更难？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://qinyuanpei.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="思考" scheme="https://qinyuanpei.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>分布式丛林探险系列之 Redis 主从复制模式</title>
    <link href="https://qinyuanpei.github.io/posts/1748863652/"/>
    <id>https://qinyuanpei.github.io/posts/1748863652/</id>
    <published>2021-11-16T11:48:41.000Z</published>
    <updated>2022-03-07T01:40:22.314Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>如果说，单体架构系统是坐在家里悠闲地喝着下午茶，那么，毫无疑问，分布式系统将会是一场永远充满惊喜的丛林冒险。从踏上这条旅程的那一刻起，此间种种都被打上分布式的烙印，譬如分布式锁、分布式事务、分布式存储、分布式配置等等，这些词汇拆开来看，“似曾相识燕归来”，每一个我都认识，而一旦放到分布式的场景中，一切就突然变得陌生起来，从过去的经典三层架构、到时下流行的微服务、再到更为前沿的服务网格，一路跌跌撞撞地走过来，大概只有眼花缭乱和目不暇接了。前段时间在做 <a href="https://github.com/qinyuanpei/FakeRpc" target="_blank" rel="noopener">FakeRpc</a>，这是一个基于 ASP.NET Core 的轻量级 RPC 框架，其间接触了 <a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">ZooKeeper</a>、<a href="https://nacos.io/zh-cn/" target="_blank" rel="noopener">Nacos</a>，后来工作中又接触到了 <a href="http://kafka.apache.org/" target="_blank" rel="noopener">Kafka</a>、<a href="https://docs.microsoft.com/zh-cn/azure/architecture/reference-architectures/saga/saga" target="_blank" rel="noopener">Saga</a>，虽然这些都是不同领域里的分布式解决方案，但是我隐隐觉得它们之间有某种内在的联系，就像所有的分布式系统都存在选举 Leader 的协调算法一样。于是，“喜新厌旧”的双子座，决定新开一个专栏，既然分布式系统是一场永远充满惊喜的丛林冒险，那么，这个专栏就叫做 「分布式丛林冒险系列」好了。一切该从哪里开始呢？我想，还是从 Redis 开始，今天这篇文章，我们来聊一聊 Redis 里的主从复制。</p><h1 id="主从复制概述"><a href="#主从复制概述" class="headerlink" title="主从复制概述"></a>主从复制概述</h1><p>从某种意义上来讲，主从复制并不是一个新的概念，因为此前博主介绍过数据库里的主从复制，在 <a href="https://blog.yuanpei.me/posts/1333693167/" target="_blank" rel="noopener">利用 MySQL 的 Binlog 实现数据同步与订阅(上)：基础篇</a> 这篇文章中，博主和大家分享过利用数据库 Binlog 实现数据同步的方案，而 Binlog 正是实现数据库主从复制的重要机制之一，甚至在更多的时候，我们更喜欢换一种说法，即 读写分离。和数据库类似，Redis 中的主从复制，其实，就是指将一台 Redis 服务器中的数据，复制到其它 Redis 服务器。其中，前者被称为主节点(Master)，后者被称为从节点(Slave)，通常情况下，每一台 Redis 服务器都是主节点，一个主节点可以有多个从节点，而一个从节点只能有一个主节点，并且数据只能从主节点单向流向从节点，如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication.png" alt="Redis 主从复制示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 主从复制示意图</div></figure><p>虽然 Redis 在缓存上的应用做到了家喻户晓的地步，可这并不代表我们能真正得用好 Redis，譬如，博主的上一家公司，基本上没有用到 Redis 的高可用，最多就是一主一从这样的搭配。所以，当时公司里很多人都知道哨兵、集群这些概念，而真正搭过环境的人则是寥寥无几，这正是博主要写这个系列的原因之一。那么，从实用性的角度来看，Redis 的主从复制有哪些实际的作用呢？个人认为，主要有以下几点：</p><ul><li>数据冗余：主从复制相当于实现了数据的热备份，是除了数据持久化以外的一种数据冗余方案。</li><li>故障恢复：主从复制相当于一种灾备措施，当主节点主线故障的时候，可以暂时由从节点来提供服务。</li><li>负载均衡：主从复制搭配读写分离，可以分担主节点的负载压力，在“读多于写”的场景中，可以显著提高并发量。</li><li>高可用：主从复制是高可用的基础，无论是集群模式还是哨兵模式，都建立在主从复制的基础上。</li></ul><p>相信大家都听过 CAP 定理，这是分布式系统中的重要理论之一，其基本思想是，一致性(<strong>Consistence</strong>)、可用性(<strong>Availability</strong>) 和 分区容忍性(<strong>Partition Tolerance</strong>)，最多只能同时实现两点，而无法做到三者兼顾，如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="CAP-Theory.png" alt="CAP 理论" referrerpolicy="no-referrer"></div><div class="image-caption">CAP 理论</div></figure><p>事实上，对分布式系统的设计而言，本质上就是“<strong>鱼和熊掌不可兼得</strong>”，关键看你想要做出一个怎么样的选择。例如，同样是注册中心，ZooKeeper、etcd 以及 Consul 都选择了 CP，而 Euraka 则选择了 AP。对于 Redis 而言，单机版的 Redis 可以看作是 CP，因为它牺牲了 A，即可用性。而集群化的 Redis，则可以看作是 AP，通过自动分片和数据冗余，来换取可用性。这其实印证了我们一开始的观点，为什么我们需要 Redis 的主从复制、集群、哨兵这些东西呢？本质上还是为了提高 Redis 的可用性。可能有朋友会问，难道一致性在 Redis 里就不重要了吗？我想，这要从 Redis 主从复制的原理说起。</p><h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><p>首先，我们要明确一点，Redis 里的主从复制是异步的，这样就回到了一个老生常谈的话题，即：实时一致性 和 最终一致性，显然，在 AP 的场景下，最终一致性这种“弱一致性”实现起来要更容易一点，因为实时一致性这种“强一致性”的方案，意味着所有人都要在这个时间点停下来，等实现一致性以后再继续进行下面的工作。我们甚至都不用钻研那些高深莫测的分布式理论，单单从日常生活的角度来切入，你一定会觉得这样子做事情效率低到爆炸，所以，追求实时一致性并不是说不可取，而是感觉这样有一点得不偿失，难道你要为了一致性而牺牲可用性吗？博主曾经接触过一个基于 <a href="http://ignite.apache.org/" target="_blank" rel="noopener">Ignite</a> 构建的缓存组件，对方声称数据的一致性比可用性更重要。所以，作为一个被很多项目依赖的基础设施，虽然隔三差五地出各种问题，可大家竟然能一直容忍下去，可能这就是爱吧。直到后来引进 <a href="https://docs.microsoft.com/zh-cn/azure/architecture/reference-architectures/saga/saga" target="_blank" rel="noopener">Saga</a> 做分布式事务，我意识到这是通过柔性事务来实现最终一致性，而如此前后矛盾的做法，只能成为此刻用来调侃的谈资，其实人更是如此，世间的一切你都可以去追逐，可你终将会失去它，这大概是人生的最终一致性。</p><p>好了，言归正传，事实上，Redis 的主从复制可以分为连接建立、数据同步、命令传播三个阶段，下面我们来分别讲解各个部分的相关细节。</p><h2 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h2><p>连接建立阶段，主要目的是主从双方建立 Socket 连接，此时，双方都需要知道对方的 IP 地址和端口号，其基本交互流程如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Phase-1.drawio.png" alt="Redis 主从复制：连接建立阶段" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 主从复制：连接建立阶段</div></figure><p>可以注意到，在连接建立阶段，首先，由从节点发出指令<code>slaveof &lt;IP&gt; &lt;Port&gt;</code>，这里的 IP 地址和端口号都是指主节点的 IP 地址和端口号。事实上，该指令还可以有下面两种形式，即：</p><ul><li>服务器启动参数：在<code>redis-server</code>命令后附加参数，即 <code>redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li><li>服务器配置文件：在 <code>redis.conf</code> 文件中配置主节点信息，即 <code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul><p>接下来，一旦主节点收到了该指令，就会对从节点做出响应，此时，从节点就可以获得主节点的 IP 地址和端口号，在 <code>redis-cli</code> 环境下，我们可以通过 <code>info Replication</code> 来验证这个观点。如图所示，是某个 Redis 从节点中存储的主节点信息：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Info-Slave.png" alt="Redis 从节点中存储的主节点信息" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 从节点中存储的主节点信息</div></figure><p>此时，从节点和主节点会打一场“乒乓球”，从节点会定期发送<code>PING</code>指令，此时，如果主节点返回了<code>PONG</code>指令，则表示连接到主节点的 Socket 可用，你可以将其理解为一种健康检查或者心跳机制，目的是确定主节点还“活”着，否则，作为客户端的从节点就会断开 Socket 连接并尝试重连。如果主节点要求提供密码，那么从节点还需要发送以下指令：<code>auth password</code>，这个时候主节点会对从节点提供的身份信息进行验证，一旦验证通过，从节点就会开始监听主节点的端口，与此同时，主节点会保存从节点的 IP 地址和端口号。同样地，我们可以在主节点中通过 <code>info Replication</code> 来验证这个观点：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Info-Master.png" alt="Redis 主节点中存储的从节点信息" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 主节点中存储的从节点信息</div></figure><p>至此，主从双方的互相“试探”结束，双方正式建立连接，是为连接建立阶段。</p><h2 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h2><p>如果我们把建立连接看作是两个人“握手”，也许，你的脑海中此刻会浮现出诺基亚的经典开机画面，毫无疑问，下面两个人的“会话”才是真正的重头戏。于是，我们来到了数据同步阶段，这一阶段的主要目的是，完成从节点的数据初始化。在连接建立阶段，从节点是主节点的客户端；而到了这一阶段以及命令传播阶段，双方互为彼此的客户端，因为，此时主节点需要主动向从节点发送命令。按照主从节点的状态不同，可以分为：<strong>全量复制</strong> 和 <strong>部分复制</strong>。</p><p>如果你接触过 Kafka，应该会有这样一种认知，即 Kafka 里面维护着一个始终追加的日志文件，而每一条消息则是这个日志文件中的一部分，Kafka 利用偏移量来定位某一条消息。在 Redis 的主从复制中，存在着类似的概念，它被称为：复制偏移量，事实上，参与复制的主从节点都会自身的复制偏移量，其中，主节点在处理完写入命令后，会将该命令的对应字节长度累加和记录，该信息可以在主节点的 <code>info Replication</code> 中的 <code>master_repl_offset</code> 字段上找到，我们还是用前面的图做例子来说明：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Info-Offset.png" alt="Redis 主节点中存储的复制偏移量信息" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 主节点中存储的复制偏移量信息</div></figure><p>实际上，在数据同步阶段，主节点内部会维护一个固定长度的、先进先出(<strong>FIFO</strong>)的队列作为复制积压缓冲区，其默认大小为 1 MB，主节点在响应写命令的时候，不但会把命令发送给从节点，还会写入到复制缓冲区，如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Buffer-Offset.png" alt="Redis 复制缓冲区 和 复制偏移量累积" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 复制缓冲区 和 复制偏移量累积</div></figure><p>这个复制缓存区的作用是保留主节点最近执行的写命令，因为它是一个先进先出的队列，所以，时间较早或者偏移量较大的命令会在一段时间后被挤出缓冲区，这样，我们就有了更进一步的结论，即：<strong>当主从节点 offset 的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制</strong>。所以，选择全量复制还是部分复制，还是要有实际的使用场景来决定。主从配置第一次启用的时候，因为从库没有对应的复制偏移量，所以，第一次复制一定是全量复制，对于全量复制而言，其基本流程如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Full.png" alt="Redis 主从复制：全量复制" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 主从复制：全量复制</div></figure><p>而对于部分复制而言，其得以实施的前提是，<strong>复制偏移量之后的数据依然存在于复制缓冲区</strong>，那么，如何判断复制偏移量在不在复制缓冲区里呢？在 Redis 中主要是通过 <code>PSYNC</code> 命令来实现，请注意，在 Redis 2.8 之前的版本中，只有 <code>SYNC</code> 命令，而 <code>PSYNC</code>则是 Redis 2.8 版本之后推出的替代命令，它提供了 <strong>完整重同步</strong> 和 <strong>部分重同步</strong> 的功能，主要解决了老版本中断线以后重新复制带来的低效率问题。这里，我们以 <code>PSYNC</code> 命令为例来进行说明。事实上，无论主从节点，都会被分配一个唯一的 runid，所以，对于部分复制而言，实际上是从节点告诉主节点，它的 runid 和 offset，然后由主节点来判断这个 offset 是否在它的复制缓冲区里，如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Phase-2-PSYNC.png" alt="Redis 主从复制：部分复制" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 主从复制：部分复制</div></figure><p>因为复制缓冲区中持久化了写入命令，所以此时我们只需要从复制缓冲区中找到对应区间的数据，发给从节点即可，在这种情况下，主节点不需要生成 RDB 快照，所以，部分复制的效率会比全量复制要高很多。以上就是 Redis 数据同步阶段的基本流程，其实在这这个过程中，我们还有很多问题没有说到，譬如 <strong>Redis 的两种持久化方案 RDB 和 AOF 应该如何去选择，全量复制过程中主要的性能损耗点，以及 从节点如何利用 RDB 快照更新数据</strong>等等，考虑到篇幅，这些话题等以后有机会了再专门来说吧！</p><h2 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h2><p>前面提到过，主节点内部会维护一个复制缓冲区，其主要作用是持久化最近执行的写命令，可是你把命令都放到这个复制缓冲区里了，那些从节点又怎么知道这个具体动作呢？实际上，这一工作是由命令传播程序来完成的，所以，命令传播阶段实际上就是指主节点在写入复制缓冲区以后，通知从节点的这个过程。下面是一个简单的示意图：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Phase-3.png" alt="Redis 主从复制：命令传播阶段" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 主从复制：命令传播阶段</div></figure><p>我承认，这些偏理论的内容，不单单看起来挺费劲，我写起来更费劲，所以，我只能尽可能地去画这些流程图，这样能更好地帮助大家理解这些内容。其实，有很多的东西，你对它的理解，是一种潜移默化、层层递进的过程，就像这里的复制缓冲区，你压根说不上来，到底是 Kafka 帮助你理解了 Redis，还是 Redis 帮助你理解了 Kafka。<strong>有时候，我挺不理解人类变幻莫测的情感，那东西对我来说有时像一门玄学，显然，科学对我而言会更容易一点，那么，我不妨选择去相信科学、相信唯物主义</strong>。也许，屏幕前的你，会不置可否地批评我说“光说不练假把式”，好了，下面我们来看一个全量复制的简单实例。</p><h1 id="主从复制实战"><a href="#主从复制实战" class="headerlink" title="主从复制实战"></a>主从复制实战</h1><p>这里，我们按照“<strong>一主两从</strong>”的方案来实施 Redis 的主从复制，前面提到过，我们有三种方式来配置主从复制。在这里，博主是使用第三种方式来进行配置的，如下图所示，准备三个文件夹及一个 <code>docker-compose.yaml</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MasterSlave</span><br><span class="line">|-- docker-compose.yaml</span><br><span class="line">|-- redis-1</span><br><span class="line">|   |-- redis.conf</span><br><span class="line">|-- redis-2</span><br><span class="line">|   |-- redis.conf</span><br><span class="line">|-- redis-3</span><br><span class="line">|   |-- redis.conf</span><br></pre></td></tr></table></figure><p>其中，<code>redis-1</code>为主节点，对应端口号为：7001；<code>redis-2</code> 和 <code>redis-3</code>为从节点，对应端口号分别为：7002 和 7003。首先，主节点的配置项定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode no</span><br><span class="line">port 7001</span><br><span class="line">timeout 5000</span><br><span class="line"># 900 秒内 1 个更改</span><br><span class="line">save 900 1</span><br><span class="line"># 300 秒内 10 个更改</span><br><span class="line">save 300 10</span><br><span class="line"># 60 秒内 10000 个更改</span><br><span class="line">save 60 10000</span><br><span class="line">rdbcompression yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir &#x2F;data</span><br><span class="line"># 开启 AOF 模式</span><br><span class="line">appendonly yes</span><br><span class="line"># 每秒一次 fsync</span><br><span class="line">appendfsync everysec</span><br><span class="line">requirepass 12345678</span><br></pre></td></tr></table></figure><p>接下来，对于<code>redis-2</code> 和 <code>redis-3</code> 这两个从节点而言，主要多了 <code>slaveof</code> 和 <code>masterauth</code> 这两行配置，这是因为我们在主节点中配置了密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode no</span><br><span class="line">port 7002</span><br><span class="line">timeout 5000</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">rdbcompression yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir &#x2F;data</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br><span class="line">requirepass 12345678</span><br><span class="line"></span><br><span class="line">slaveof 127.0.0.1 7001</span><br><span class="line">masterauth 12345678</span><br></pre></td></tr></table></figure><p>同理，可以对 <code>redis-3</code> 进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode no</span><br><span class="line">port 7003</span><br><span class="line">timeout 5000</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">rdbcompression yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir &#x2F;data</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br><span class="line">requirepass 12345678</span><br><span class="line"></span><br><span class="line">slaveof 127.0.0.1 7001</span><br><span class="line">masterauth 12345678</span><br></pre></td></tr></table></figure><p>以上配置文件，均可以在 <a href="https://github.com/Regularly-Archive/2021/tree/master/src/RedisClusters/MasterSlave" target="_blank" rel="noopener">Github</a> 获取。接下来，我们会使用 Docker-Compose 进行服务编排：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-master</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-1/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">redis2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-slave-1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-2/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="attr">redis3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-slave-2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-3/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>此时，当我们执行<code>docker-compose up</code>命令，如下图所示，它就会自动建立主从关系，这意味着我们在主节点写入的值，均可以通过从节点来进行读取：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Docker-Compose.png" alt="通过 Docker-Compose 建立主从关系" referrerpolicy="no-referrer"></div><div class="image-caption">通过 Docker-Compose 建立主从关系</div></figure><p>为了印证我们的想法，下面我们通过 Redis 的命令行工具<code>redis-cli</code> 来向主节点写入值，为此我们需要进入到容器内部并执行相应的命令。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Docker-Compose-List.png" alt="一主两从及对应的容器 ID" referrerpolicy="no-referrer"></div><div class="image-caption">一主两从及对应的容器 ID</div></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入主 Redis 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 8574d93eeaf4 sh</span><br><span class="line"><span class="comment"># 通过 redis-cli 连接 master</span></span><br><span class="line">redis-cli -p 7001 -c</span><br><span class="line"><span class="comment"># 身份认证</span></span><br><span class="line">127.0.0.1:7001&gt; auth 12345678</span><br><span class="line"><span class="comment"># 写入一个 key：name</span></span><br><span class="line">127.0.0.1:7001&gt; <span class="built_in">set</span> name yuanpei</span><br></pre></td></tr></table></figure><p>同样地，我们进入从节点，从 <code>7002</code> 和 <code>7003</code> 中任选一个即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入从 Redis 容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 0b19237b7e58 sh</span><br><span class="line"><span class="comment"># 通过 redis-cli 连接从节点</span></span><br><span class="line">redis-cli -p 7002 -c</span><br><span class="line"><span class="comment"># 身份认证</span></span><br><span class="line">127.0.0.1:7002&gt; auth 12345678</span><br><span class="line"><span class="comment"># 读取一个 key：name</span></span><br><span class="line">127.0.0.1:7002&gt; get name</span><br></pre></td></tr></table></figure><p>可以注意到，我们从 <code>7002</code> 中读取出了 <code>7001</code> 中写入的值，这表明我们搭建的 Redis 主从复制起作用了，这样，如果主节点某一天遭遇不幸，这个时候从节点可以临时提供服务，而这恰好印证了我们一开始的观点，为什么需要主从复制呢？我们肉眼可见的效果就是数据冗余和故障恢复，而负载均衡和高可用更多的是一种战略上的考量，它完全取决于你所处的高度。截至到此刻，Redis 的主从复制，你学会了吗？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="Redis-Replication-Docker-Compose-Sync.png" alt="Redis 主从复制效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">Redis 主从复制效果展示</div></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文是 #分布式丛林探险系列# 的第一篇文章，主要分享了 Redis 主从复制模式的相关内容。首先，主从复制可以为 Redis 带来数据冗余、故障恢复、负载均衡以及高可用等方面的收益，单机版的 Redis 是一个符合 CP 的系统，而集群化的 Redis 则是一个符合 AP 的系统，其一致性正是由这篇文章中描述的复制来保证。根据主从节点状态的不同，Redis 中的主从复制，可以分为 <strong>全量复制</strong> 和 <strong>部分复制</strong> 两种，全量复制是主节点生成一个快照然后发送给从节点，而部分复制则是从复制缓冲区中筛选出命令然后发给从节点，在此基础上，我们用 Docker-Compose 构建了一个“<strong>一主两从</strong>”的主从复制方案。这个世界上没有 100% 完美的方案，Redis 的主从复制在实际使用中可能会遇到，诸如延迟与不一致、数据过期、故障切换等等的问题，特别是故障切换，虽然从节点可以在主节点挂了的时候临时顶上去，但这依赖于研发人员去切换项目中使用的连接字符串，如果希望更好的实现主从切换，可能还是需要大家去做进一步的工作，常言道，“实践出真知”，这篇文章充其量只能作为一个引子，更深入的话题、玩法，需要大家在实践中不断总结。好了，以上就是这篇文章的全部内容啦，如果大家对文章中的内容和观点有什么意见或者建议，欢迎大家在评论区留言，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Redis" scheme="https://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="分布式" scheme="https://qinyuanpei.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="主从复制" scheme="https://qinyuanpei.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>通过 Python 预测 2021 年双十一交易额</title>
    <link href="https://qinyuanpei.github.io/posts/735074641/"/>
    <id>https://qinyuanpei.github.io/posts/735074641/</id>
    <published>2021-10-26T16:10:47.000Z</published>
    <updated>2022-03-07T01:40:22.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>突然间，十月以某种始料未及的方式结束了，也许是因为今年雨水变多的缘故，总觉得这个秋天过去得平平无奇，仿佛只有观音禅寺的满地银杏叶儿，真正地宣布着秋天的到来，直到看见朋友在朋友圈里借景抒怀，『 霜叶红于二月花 』，秋天终于没能迁就我的一厢情愿，我确信她真的来了。当然，秋天不单单会带来这些诗情画意的东西，更多的时候我们听到的是双十一、双十二，这些曾经由光棍节而催生出的营销活动，在过去的十多年间渐渐成为了一种文化现象，虽然我们的法定节日永远都只有那么几天，可这并不妨碍我们自己创造出无数的节日，从那一刻开始，每个节日都可以和购物产生联系，这种社会氛围让我们有了某种仪式感，比如，零点时为了抢购商品恨不得戳破屏幕。再比如，在复杂的满减、红包、优惠券算法中复习数学知识。可当时间节点来到 1202 年，你是否依然对剁手这件事情乐此不疲呢，在新一轮剁手行动开始前，让我们来试试通过 Python 预测一下今年的交易额，因为在这场狂欢过后，没有人会关心你买了什么，而那个朴实无华的数字，看起来总比真实的人类要生动得多。</p><h1 id="思路说明"><a href="#思路说明" class="headerlink" title="思路说明"></a>思路说明</h1><p>其实，我一直觉得这个东西，完全不需要特意写一篇文章，因为用毕导的话说，这个东西我们在小学二年级就学过。相信只要我说出 <a href="https://ws.wiki.gaogevip.com/wiki/最小二乘法" target="_blank" rel="noopener">最小二乘法</a> 和 <a href="https://zh.wikipedia.ryancray.com/zh-hans/線性回歸" target="_blank" rel="noopener">线性回归</a> 这样两个关键词，各位就知道我在说什么了！博主从网上收集了从 2009 年至今历年双十一的交易额数据，如果我们将其绘制在二维坐标系内，就会得到一张散点图，而我们要做的事情，就是找到一条曲线或者方程，来对这些散点进行拟合，一旦我们确定了这样一条曲线或者方程，我们就可以预测某一年双十一的交易额。如图所示，是 2009 年至今历年双十一的交易额数据，在 Excel 中我们可以非常容易地得到对应的散点图：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/10/27/mf3h4oXLiswzPOq.png" alt="在 Excel 中绘制散点图" referrerpolicy="no-referrer"></div><div class="image-caption">在 Excel 中绘制散点图</div></figure><p>如果有朋友做过化学或者生物实验，对接下来的事情应该不会感到陌生，通常我们会在这类图表中添加趋势线，由此得到一个公式，实际上这就是一个回归或者说拟合的过程，因为 Excel 内置了线性、指数型、对数型等多种曲线模型，所以，我们可以非常容易地切换到不同的曲线，而评估一个方程好坏与否的指标为 $R^2$，该值越接近 1 表示拟合效果越好，如图是博主在 Excel 中得到的一条拟合方程：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/10/27/D5xHLIfrJsZNi1B.png" alt="在 Excel 中添加趋势线" referrerpolicy="no-referrer"></div><div class="image-caption">在 Excel 中添加趋势线</div></figure><p>那么，在 Python 中我们如何实现类似的效果呢？答案是 <a href="https://scikit-learn.org.cn/" target="_blank" rel="noopener">scikit-learn</a>，这是 Python 中一个常用的机器学习算法库，主要覆盖了以下功能：<strong>分类</strong>、<strong>回归</strong>、<strong>聚类</strong>、<strong>数据降维</strong>、<strong>模型选择</strong> 和 <strong>数据预处理</strong>，我们这里主要利用了回归这部分的 <a href="https://scikit-learn.org.cn/view/394.html" target="_blank" rel="noopener">LinearRegression</a> 类，顾名思义，它就是我们通常说的线性回归。事实上，这个线性并不是单指一元一次方程，因为我们还可以使用二次或者三次多项式，因为上面的 Excel 图表早已告诉我们，一元一次方程误差太大。</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>OK，具体是如何实现的呢？首先，我们从 CSV 文件中加载数据，这个非常简单，利用 <a href="https://pandas.pydata.org/" target="_blank" rel="noopener">Pandas</a> 库中的 read_csv() 方法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">'./历年双十一交易额.csv'</span>, index_col = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>接下来，我们使用下面的方法来获取 年份 和 交易额 这两列数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">year = np.array(df.index.tolist())</span><br><span class="line">sales = np.array(df.Sales.tolist())</span><br></pre></td></tr></table></figure><p>此时，我们可以非常容易地用 <a href="https://matplotlib.org" target="_blank" rel="noopener">matplotlib</a> 库绘制出对应的图表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(year, sales, marker=<span class="string">'o'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'年份'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'交易额(亿)'</span>)</span><br><span class="line">plt.title(<span class="string">'历年双十一交易额变化趋势'</span>)</span><br></pre></td></tr></table></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/10/27/wD2b8lhjmIsETeP.png" alt="通过 matplotlib 绘制散点图" referrerpolicy="no-referrer"></div><div class="image-caption">通过 matplotlib 绘制散点图</div></figure><p>接下来，我们来看看如何对这组数据做线性回归，以一元一次方程为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X = (year - <span class="number">2008</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">X = np.concatenate([X], axis= <span class="number">-1</span>)</span><br><span class="line">Y = sales</span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X, Y)</span><br><span class="line">print(<span class="string">'方程系数：'</span>, lr.coef_)</span><br><span class="line">print(<span class="string">'方程截距：'</span>,lr.intercept_)</span><br></pre></td></tr></table></figure><p>这里，首先我们需要把 2009 到 2020 这个范围内的年份转化为更方便计算的 1、2、3 …，所以，每一个数都减去了 2008，这样我们就得到了横坐标 <code>X</code> 以及 纵坐标 <code>Y</code>。接下来，我们只需要将其传入 <code>fit()</code> 方法即可。有时候，你可能会看到下面这样的代码，即用于划分 <strong>训练集</strong> 和 <strong>测试集</strong> 的的代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>考虑到我们这里的样本数据本来就不多，毕竟，这股消费主义的风潮在中国刚刚流行了十二年，所以，我们要珍惜这份福报，就不划分 <strong>训练集</strong> 和 <strong>测试集</strong> 了(逃。此时，我们会得到两个重要的参数，即方程系数 <code>lr.coef_</code> 和 方程截取 <code>lr.intercept_</code>，而一旦有了这两个参数，我们就能确定一个线性方程，即传说中的 $y=ax+b$ :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: lr.coef_[<span class="number">0</span>] * x + lr.intercept_</span><br><span class="line">print(<span class="string">'2021年交易额预测：'</span>, f(<span class="number">13</span>))</span><br></pre></td></tr></table></figure><p>此时，f(13) 就是 2021 年双十一的交易额，显然，这是一个预测值，大概是 3592 亿，这属实是有点离谱啦，都没能超过 2020 年的 4982 亿，我们前面提到过 $R^2$，在 <a href="https://scikit-learn.org.cn/" target="_blank" rel="noopener">scikit-learn</a> 中我们使用下面的方法来计算它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'R^2：'</span>, lr.score(X_test, Y_test))</span><br></pre></td></tr></table></figure><p>没错，<code>score()</code> 函数需要这样一组测试数据，我们利用前面划分 <strong>训练集</strong> 和 <strong>测试集</strong> 的方法就可以得到它。我们发现，这个值大概是 0.73，这要不离谱都说不过去，这一点我们从图上就可以看出来：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/10/27/UerVa9mZ5NSPwTC.png" alt="历年双十一交易额变化趋势预测：一次方程" referrerpolicy="no-referrer"></div><div class="image-caption">历年双十一交易额变化趋势预测：一次方程</div></figure><p>这样显然不行啊，那怎么办呢？遥想古人利用“割圆术”无限逼近圆形进而计算出圆周率的这种执着，我们是不是可以通过提高“次数”来解决欠拟合的问题呢？换句话说，我们来试试一元二次方程，此时，我们只需要调整下横坐标 <code>X</code> 的构造过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = (year - <span class="number">2008</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">X = np.concatenate([X**<span class="number">2</span>, X], axis= <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>简单来说，如果你需要构造一个 N 次多项式，那么，只需要由高到底依次写出来即可，所以，你可以想象得到，对于三次多项式，我们可以这样构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = (year - <span class="number">2008</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">X = np.concatenate([X**<span class="number">3</span>, X**<span class="number">2</span>, X], axis= <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>对于二次多项式，我们可以得到下面的结果，其 $R^2$ 为 0.92，预测 2021 年双十一交易额为 5218 亿：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/10/27/1RF3LtQr4pTidb6.png" alt="历年双十一交易额变化趋势预测：二次方程" referrerpolicy="no-referrer"></div><div class="image-caption">历年双十一交易额变化趋势预测：二次方程</div></figure><p>同理，对于三次多项式，我们可以得到下面的结果，其 $R^2$ 为 0.96，预测 2021 年双十一交易额为 6213 亿：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/10/27/DlHcQUIXf1pORob.png" alt="历年双十一交易额变化趋势预测：三次方程" referrerpolicy="no-referrer"></div><div class="image-caption">历年双十一交易额变化趋势预测：三次方程</div></figure><p>整体上看，三次方程的拟合效果更好一点，达到了 0.96，但这个和大学时候做实验追求的 0.99 相比，多少有一点尴尬，屏幕前的你，是否想到了更好的曲线模型呢，我们常常说某某行业取得了指数级的增长，难道说指数模型更适合这个问题？关于这一点博主没能去亲自验证，因为看起来在 <a href="https://scikit-learn.org.cn/" target="_blank" rel="noopener">scikit-learn</a> 中没有指数型函数的计算模型，可当博主在 Excel 中添加了指数型的趋势线以后，发现结果有点出人意料，因为它的 $R^2$ 只有 0.8314，而按这个方程计算出的交易额则约为2万多亿，好家伙，这都赶上恒大目前拖欠的债务了，想想就觉得离谱，指数型函数对应的曲线如下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/10/27/ZBN5RgXiqUDLym3.png" alt="历年双十一交易额变化趋势预测：指数函数" referrerpolicy="no-referrer"></div><div class="image-caption">历年双十一交易额变化趋势预测：指数函数</div></figure><p>此时此刻，坐在屏幕前的你，更倾向于选择那种计算模型呢，个人觉得三次方程更好一点，因为它的 $R^2$ 是目前最好的，当然，<a href="https://scikit-learn.org.cn/" target="_blank" rel="noopener">scikit-learn</a> 还有类似可解释的方差分数、最大误差、平均绝对误差、均方误差、均方误差对数等等不同的指标，大家可以参考 <a href="http://scikit-learn.org.cn/view/93.html#3.3.4%20%E5%9B%9E%E5%BD%92%E6%8C%87%E6%A0%87" target="_blank" rel="noopener">官方文档</a> 来做更进一步的探索，一切都只有等到下个月双十一过后方能揭晓，就让我们拭目以待！本文中使用的源代码，已更新至 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/11.11" target="_blank" rel="noopener">Github</a> 供大家参考，如果大家对博客中的内容有什么意见或者建议，欢迎大家在评论区积极留言，谢谢大家！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>恍惚中惊觉，十月份就这样结束了，这意味是 2021 年只剩下 60 多天。上了年纪的人总不免开始怀念，那些偷偷从树叶间隙里溜走的时光，去年的这个时候我在做些什么呢？大概刚刚追完「半泽直树」第二部吧！在疫情愈发常态化的日子里，人对于未来总有种难以言说的失控感，某君有言道，『不知道明天和意外哪一个先来』，虽然机器学习可以通过“训练”过去达到“预测”未来的目的，可人生并没有哪一个方程可以完美拟合，虽然这个世界早已为你规划好一条叫做“随大流”的路，一个人的过去、当下就像无数个离散的点，这些点构成了我们人生的轨迹，某种我们通常称之为回忆的东西，可这些点是否会向着预期的方向延伸，也许，永远没有人会知道答案，这个世界上有相当多的数字，譬如自然对数、圆周率、黄金分割比等等，都是前辈先哲从自然世界中寻找到的，可对于我们的人生而言，并没有这样明显的答案，所以，每次做数据分析的时候，我都有种奇怪的感觉，因为我不明白这些数字背后，到底和我们本身有着什么样的关联，可这个世界偶尔会感应到你的失落，当你听着「明年今日」，而心里想的是去年今日，我想，这一页可以翻过去，这篇文章可以结尾，这样就可以了吧…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="Sklearn" scheme="https://qinyuanpei.github.io/tags/Sklearn/"/>
    
      <category term="双十一" scheme="https://qinyuanpei.github.io/tags/%E5%8F%8C%E5%8D%81%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>从「失控玩家」中得到的启示</title>
    <link href="https://qinyuanpei.github.io/posts/1005876321/"/>
    <id>https://qinyuanpei.github.io/posts/1005876321/</id>
    <published>2021-10-18T20:42:47.000Z</published>
    <updated>2022-03-07T01:40:22.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>也许，在某一个不寻常的清晨，突然从睡梦中惊醒的你，开始重新审视周围的一切，这个习以为常的世界，是否是真实的呢？而这种疑问，「黑客帝国」里的 Neo 有过，「西部世界」里的 Dolores 有过，甚至，连庄周梦蝶这个故事，都在探讨同一个哲学命题，即：人应该如何认识真实。从某种意义上来讲，游戏世界是现实世界的一种映射，这种对人类文明进行解构，并尝试进行重新演绎的做法，其本身就有种浓厚的哲学意味，正如古希腊人刻在阿波罗神殿里的那句名言，『人啊，认识你自己』。关于真实，这是人从诞生那一刻起，就在不断思考着的终究问题：我是谁？我从哪里来？要到哪里去？</p><p>「失控玩家」的切入点，源于一名自我意识觉醒的 NPC——盖，他每天过着一成不变的生活：起床、喝咖啡、到银行上班、等待劫匪上门、和黑人保安趴在地上配合演出……事实上，这可以视为早期的 AI —— 有限状态机，我想，接触过游戏开发的朋友们，看到这里都不免要会心一笑啦！可惜，这是一部以 NPC 作为主角的电影，在电影的设定中，盖是一个具备深度学习能力的 AI，当他偶然从玩家手中夺过墨镜以后，终于从玩家视角看见不一样的世界。和「头号玩家」中被游戏入侵真实生活的设定不同，「失控玩家」更像是游戏版的「楚门的世界」，如果用一句话来概括，『海的尽头是天空，天空的尽头是荧幕』，在某个时刻，当你发现周围的一切变得不再真实，甚至身边的所有人都是演员，而更为讽刺的是，你的人生其实是一场被现场直播着的真人秀，而这便是「楚门」所面对着的世界。暂且不论这种设定，是否隐隐约约预言了当下流行的真人秀节目。当不经意间发现生活在不断重复的时候，你是否会愿意男主盖一样跳出这个循环呢？从我们出生的那一刻起，姓名、身份、知识、道德、文化…等等，无一不是我们的「出厂设定」，更不必说上学、工作、结婚、生子这种类似 RPG 游戏里打怪升级的任务系统。</p><p>导演小策有一期<a href="https://www.bilibili.com/video/BV1vy4y187rR?spm_id_from=333.999.0.0" target="_blank" rel="noopener">视频</a>，大意是说，我们这个世界，其实是高维度文明设计出的一个游戏，这个游戏制定了非常精细的规则，与此同时，它具备高度的自由性，这一切的一切，都让我们误以为我们可以自己来做决定。其实，这些高维度文明，早已设定好了基本的规则，他们唯一想做的事情，就是看我们能不能通过进化发现自己只是一个戏中人。正如电影中的美女咖啡师，难道她真的喜欢做「两份奶一份糖」的咖啡吗？还是冥冥中有某种接近命运的东西让她成为了这样一个咖啡师？也许，这样的理论是细思极恐的，可笛卡尔同样说过，『我思故我在』。既然，我们都解释不了，我们为何会在这里，我们又如何能相信，周围的一切就一定是真实的呢？如果说，盖因为爱情的鼓舞而快速升级进化，这多少沾点喜剧的色彩，那么，接下来，当整个世界即将不复存在的时候，整个故事就变成了彻头彻尾的悲剧，因为在那一刻，无论你等级有多高，装备有多好，全部都失去了意义，一如人死灯灭，名与利，转瞬化为烟云，假如真有高维度文明存在，对方的维度只比你多0.0000001，连一粒尘埃的质量都达不到，你拼命想要抓住、想要证明的人生，可能就只是一场游戏，一个实验，就像最近大火的韩国电视剧「鱿鱼游戏」，穷人的放手一搏，富人的博君一笑，荒诞而又真实。可以说，终其一生，我们都在追求意义和仪式感，可人生恰恰是没有意义的，就像盖每天都重复着同一句话醒来，在永无止境的循环中，意义始终逃不出这个作用域，你可以定义它，但你终将失去它。</p><p>而这种感觉，在我玩「风之旅人」这款游戏时更为强烈，在广袤无垠的沙漠中，当我开始漫无目的地行走的时候，我突然意识到，有可以称之为起点的地方，便一定会有可以称之为终点的地方，我会在某个时刻消逝，而这个世界则不会结束，就好像这个世界从来没有过我一样。其实，在「风之旅人」这个游戏中，陈星汉老师通过壁画的形式，隐晦地讲述了白袍人文明从诞生到被黄沙掩埋的整个故事。主角拼尽全力穿过雪地，如同预言一般死在圣山脚下，然后化成一道光变成玩家一开始身着红袍的样子。你不能不说这是一种轮回，故事还是那个故事，红袍人还是红袍人，而你注定再难变回你自己。不管是游戏还是人生，我们都会碰见不止一个同伴，而它们永远只能陪伴我们走完一段旅程，接下来的人生还是需要自己去完成。所以，这是一种难以言说的感觉，虽然听起来像是某种虚无主义的观点，可其实你仔细一想，如果上帝真的会掷骰子，女娲真的会造人，这个世界本身又何尝不能是一款游戏，一个人从出生的那一刻起，就开始扮演各种角色，这是一个角色扮演游戏；从小到大，从分数到薪资再到地位，这是一个跑酷竞技游戏……而游戏规则永远掌握在少数人手中，而这个时代，成功或者是优秀的标准，早已令人高不可攀，甚至没有人会想到，证明你是一个真实的人要比想象中还要难。在人工智能的加持下，游戏里的 NPC 有了独立的意识，可如果你无法分辨出什么是真实，你就无法证明这个世界是真实存在的。正因为如此，「模仿游戏」中的警官，只有不无遗憾地对图灵说，I can’t judge you.</p><p>回到电影本身的话，我想，它更能激发骨灰级电影爱好者发掘彩蛋的兴趣。因为，这部电影里的梗简直多得像一部百科全书。从主角盖的冒险经历来看，你能找到「楚门的世界」、「西部世界」、「黑客帝国」等多部电影的影子，而如果从『自由城』的氛围来看，你会发现这无非就是一个升级、高配版本的「侠盗猎车手」游戏，甚至于盖在对抗 Dude 这个游戏中的 Boss 的时候，更是接连使用美队盾牌、绿巨人、光剑这种颇具代表性的意象。当然，你还可以从研发人员的视角来调侃这部电影，无论是盖背后无与伦比的人工智能算法，还是尚未完成设计就仓促上线的 Dude，抑或者是模型岛屿下面的天空盒，即使你并不确定，游戏公司老板选择用斧头来砸游戏服务器，其中是否有致敬「闪灵」的嫌疑？这个世界的神奇之处在于，无论你试图用文学、戏剧、游戏、电影中的哪一种方式来进行描摹，你都能得到一个令你自己确信的故事，唯独在确定自身的真实性上不止一次地迟疑过。对于普通人而言，我们真的有那么多的选择吗？是我们在玩一款游戏，还是躲在游戏背后的人在愚弄我们？当讨论一个群体的时候，个体的独特性就会被忽略，可或许我们本就没有什么不同，完全是 AGCT 四种碱基的排列组合让我们相信自己与众不同，在这款被称为「人生」的游戏里，99.9999999 的玩家注定要成为 NPC，人人都笑工具人，可在这款游戏里，谁又不是工具人呢？人们步履不停、反反复复地跌入生老病死的无限循环，为了只在这次循环中被定义和声明的作用域而奔波一生，这是否可以算作某种献祭？</p><p>如果这个世界是假的，你应该如何面对？对于这个问题，我想，我没有答案，因为它就像我一直都看不清、抓不着的未来一样，无论我有没有机会去做出这个选择，它始终就像写好的结局一样被放在哪里，而我步履蹒跚的每一个当下，从某种意义上来讲，它或许只是我走向未来的一个工具，就像「风之旅人」里漫无边际的沙漠一样，你追着风的足迹前往某个叫做远方的地点，没有人知道远方的远方到底是什么。可你生命中遇见的每一个闪光点是何其的珍贵，即使它只在这一次循环内存在，即使它终会在你走向某座雪山的时候失去，而这正是生命的意义所在，不妨去假设这个世界是一款虚拟的游戏，你我都是这个游戏里最普通不过的 NPC，我们来到这个世界的唯一目的，也许是为了在这个宇宙中传递某种讯息，正如屏幕前的你，曾经无意间捕获到这点微弱的信号。罗曼罗兰曾经说过，『世上只有一种英雄主义，就是在认清生活真相之后依然热爱生活』，而这款游戏的目的，或许正是要我们在窥破这个世界的真实面目的时候，依然能够勇敢地面对人类孤独的永恒本质，依然能够用热爱和虔诚去面对由别人定义的意义，依然能够让生命中的每个当下都变得不舍和难忘，无论快乐还是悲伤，我们总不愿意永远活在别人的期待里，成为一个被信息茧房和消费主义麻醉的人，而这，正是我想要的冒险。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="游戏" scheme="https://qinyuanpei.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="影评" scheme="https://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="哲学" scheme="https://qinyuanpei.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 搭配 Swagger 实现微服务文档化</title>
    <link href="https://qinyuanpei.github.io/posts/4056800047/"/>
    <id>https://qinyuanpei.github.io/posts/4056800047/</id>
    <published>2021-09-28T14:13:32.000Z</published>
    <updated>2022-03-07T01:40:22.302Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>有人说，程序员最讨厌两件事情，一件是写文档，一件是别人不写文档，这充分展现了人类双标的本质，所谓的“严于律人”、“宽于律己”就是在说这件事情。虽然这种听来有点自私的想法，是生物自然选择的结果，可一旦人类的大脑皮层在进化过程中产生了“理性”，就会试图去纠正这种来自动物世界的阴暗面。所以，人类双标的本质，大概还是因为这个行为本身就有种超越规则、凌驾于众人之上的感觉，毕竟每个人生来就习惯这种使用特权的感觉。回到写文档这个话题，时下流行的微服务架构，最为显著的一个特点是：仓库多、服务多、接口多，此时，接口文档的重要性就凸显出来，因为接口本质上是一种契约，特别在前后端分离的场景中，只要前、后端约定好接口的参数、返回值，就可以独立进行开发，提供一份清晰的接口文档就显得很有必要。在 RESTful 风格的 API 设计中，<a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 是最为常见的接口文档方案，那么，当我们开始构建以 gRPC 为核心的微服务的时候，我们又该如何考虑接口文档这件事情呢？今天我们就来一起探讨下这个话题。</p><h1 id="protoc-gen-doc-方案"><a href="#protoc-gen-doc-方案" class="headerlink" title="protoc-gen-doc 方案"></a>protoc-gen-doc 方案</h1><p>当视角从 RESTful 转向 gRPC 的时候，本质上是接口的描述语言发生了变化，前者是 JSON 而后者则是 Protobuf，因此，gRPC 服务的文档化自然而然地就落在 Protobuf 上。事实上，官方提供了 <a href="https://github.com/pseudomuto/protoc-gen-doc" target="_blank" rel="noopener">protoc-gen-doc</a> 这个方案，如果大家阅读过我以前的博客，就会意识到这是 Protobuf 编译器，即 <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">protoc</a> 的插件，因为我们曾经通过这个编译器来生成代码、服务描述文件等等。protoc-gen-doc 这个插件的基本用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protoc \</span><br><span class="line">  --plugin=protoc-gen-doc=./protoc-gen-doc \</span><br><span class="line">  --doc_out=./doc \</span><br><span class="line">  --doc_opt=html,index.html \</span><br><span class="line">  proto/*.proto</span><br></pre></td></tr></table></figure><p>其中，官方更推荐使用 Docker 来进行部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">  -v $(pwd)/examples/doc:/out \</span><br><span class="line">  -v $(pwd)/examples/proto:/protos \</span><br><span class="line">  pseudomuto/protoc-gen-doc</span><br></pre></td></tr></table></figure><p>默认情况下，它会生成 HTML 格式的接口文档，看一眼就会发现，就是那种传统的 Word 文档的感觉：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/28/h756tJjApsGgcDW.png" alt="通过 protoc-gen-doc 生成的接口文档" referrerpolicy="no-referrer"></div><div class="image-caption">通过 protoc-gen-doc 生成的接口文档</div></figure><p>除此以外，这个插件还可以生成 Markdown 格式的接口文档，这个就挺符合程序员的审美，因为此时此刻，你眼前看到的这篇文章，就是通过 Markdown 写成的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">  -v $(pwd)/examples/doc:/out \</span><br><span class="line">  -v $(pwd)/examples/proto:/protos \</span><br><span class="line">  pseudomuto/protoc-gen-doc --doc_opt=markdown,docs.md</span><br></pre></td></tr></table></figure><p>这个方案如果整合到 CI/CD 中还是挺不错的，传统的 Word 文档形式的接口文档，最主要的缺点是没有版本控制、无法实时更新，因此，对于团队间的协作是非常不利的，我本身挺讨厌这种 Word 文档发来发去的。有时候，只有接口文档是不完美的，因为懒惰的人类希望你能提供个调用示例，最好是直接<code>Ctrl+C</code>、<code>Ctrl+V</code>这种程度的，对此，博主只有仰天长叹：悠悠苍天，此何人哉……</p><h1 id="Swagger-方案"><a href="#Swagger-方案" class="headerlink" title="Swagger 方案"></a>Swagger 方案</h1><p>考虑到，第一种方案没有办法对接口进行调试，所以，下面我们来尝试第二种方案，即整合 Swagger 的方案，可能有小伙伴会好奇，Swagger 还能和 Protobuf 这样混搭起来玩？目前，Swagger 是事实上的 <a href="https://swagger.io/specification/" target="_blank" rel="noopener">OpenAPI</a> 标准，我们只需要在 Protobuf 和 OpenAPI 规范间做一个适配层即可。还记得博主曾经为 ASP.NET MVC 编写的 Swagger <a href="http://localhost:2333/posts/4116164325/" target="_blank" rel="noopener">扩展</a>吗？没错，我们要再次“整活”了，首先，这里给出的是 OpenAPI 规范的定义：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"openapi"</span>: <span class="string">"3.0.1"</span>,</span><br><span class="line">  <span class="attr">"info"</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">"servers"</span>: [ ],</span><br><span class="line">  <span class="attr">"paths"</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">"components"</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>info</code> 节点里存放的是接口文档的基本信息，例如标题、作者、许可证等。<code>servers</code> 节点里存放的是接口所属服务的主机名、端口号等。<code>paths</code> 节点里存放的是每个 API 端点的信息，例如路由、请求参数、返回值等。<code>components</code> 节点里存放的是类型信息，例如请求参数、返回值中每个属性或者字段的具体类型等。一旦搞清楚了这些内容，我们发现这个里面最关键的两个信息是：<code>paths</code> 和 <code>components</code>，如果我们回过头来看 Protobuf 的声明文件，就会发现这两个东西，分别对应的是 <code>rpc</code> 和 <code>message</code>，如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/28/nPN5QgY2MWrGJBK.png" alt="Swagger 与 Protobuf 的对应关系" referrerpolicy="no-referrer"></div><div class="image-caption">Swagger 与 Protobuf 的对应关系</div></figure><p>通常情况下，我们使用 <code>Swashbuckle.AspNetCore.Swagger</code> 这个库来为 ASP.NET Core 项目提供 Swagger 支持，其中最为关键的是<code>ISwaggerProvider</code>接口，这里我们来尝试为 Protobuf 提供一个具体的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GrpcSwaggerProvider</span> : <span class="title">ISwaggerProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ISchemaGenerator _schemaGenerator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SwaggerGeneratorOptions _options;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IApiDescriptionGroupCollectionProvider _apiDescriptionsProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> GrpcSwaggerSchemaGenerator _swaggerSchemaGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrpcSwaggerProvider</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        SwaggerGeneratorOptions options, </span></span></span><br><span class="line"><span class="function"><span class="params">        ISchemaGenerator schemaGenerator, </span></span></span><br><span class="line"><span class="function"><span class="params">        IApiDescriptionGroupCollectionProvider apiDescriptionsProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">        GrpcSwaggerSchemaGenerator swaggerSchemaGenerator</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _options = options;</span><br><span class="line">        _schemaGenerator = schemaGenerator;</span><br><span class="line">        _apiDescriptionsProvider = apiDescriptionsProvider;</span><br><span class="line">        _swaggerSchemaGenerator = swaggerSchemaGenerator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OpenApiDocument <span class="title">GetSwagger</span>(<span class="params"><span class="keyword">string</span> documentName, <span class="keyword">string</span> host = <span class="literal">null</span>, <span class="keyword">string</span> basePath = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_options.SwaggerDocs.TryGetValue(documentName, <span class="keyword">out</span> OpenApiInfo info))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownSwaggerDocument(documentName, _options.SwaggerDocs.Select(d =&gt; d.Key));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> schemaRepository = <span class="keyword">new</span> SchemaRepository(documentName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swagger Document</span></span><br><span class="line">        <span class="keyword">var</span> swaggerDoc = <span class="keyword">new</span> OpenApiDocument</span><br><span class="line">        &#123;</span><br><span class="line">            Info = info,</span><br><span class="line">            Servers = BuildOpenApiServers(host, basePath),</span><br><span class="line">            Paths = <span class="keyword">new</span> OpenApiPaths() &#123; &#125;,</span><br><span class="line">            Components = <span class="keyword">new</span> OpenApiComponents</span><br><span class="line">            &#123;</span><br><span class="line">                Schemas = schemaRepository.Schemas,</span><br><span class="line">                SecuritySchemes = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, OpenApiSecurityScheme&gt;(_options.SecuritySchemes)</span><br><span class="line">            &#125;,</span><br><span class="line">            SecurityRequirements = <span class="keyword">new</span> List&lt;OpenApiSecurityRequirement&gt;(_options.SecurityRequirements)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swagger Filters</span></span><br><span class="line">        <span class="keyword">var</span> apiDescriptions = _apiDescriptionsProvider.GetApiDescriptions().Where(x =&gt; x.Properties[<span class="string">"ServiceAssembly"</span>]?.ToString() == documentName);</span><br><span class="line">        <span class="keyword">var</span> filterContext = <span class="keyword">new</span> DocumentFilterContext(apiDescriptions, _schemaGenerator, schemaRepository);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> filter <span class="keyword">in</span> _options.DocumentFilters)</span><br><span class="line">        &#123;</span><br><span class="line">            filter.Apply(swaggerDoc, filterContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swagger Schemas</span></span><br><span class="line">        swaggerDoc.Components.Schemas = _swaggerSchemaGenerator.GenerateSchemas(apiDescriptions);</span><br><span class="line">        <span class="keyword">var</span> apiDescriptionsGroups = _apiDescriptionsProvider.ApiDescriptionGroups.Items.Where(x =&gt; x.Items.Any(y =&gt; y.Properties[<span class="string">"ServiceAssembly"</span>]?.ToString() == documentName));</span><br><span class="line">        swaggerDoc.Paths = _swaggerSchemaGenerator.BuildOpenApiPaths(apiDescriptionsGroups);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> swaggerDoc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>OpenApiDocument</code>对应着 OpenAPI 规范中的定义的结构，我们需要返回一个<code>OpenApiDocument</code>，并对其<code>Components</code>和<code>Paths</code>属性进行填充，这部分工作由<code>GrpcSwaggerSchemaGenerator</code>类来完成。我们这里不会直接去解析 Protobuf 文件，而是利用<code>Google.Protobuf.Reflection</code>这个包来反射 Protobuf 生成的类，然后将其转化为 OpenAPI 规范中定义的结构，更多的细节，大家可以参考<a href="https://github.com/qinyuanpei/FluentGrpc.Gateway/blob/master/src/FluentGrpc.Gateway/Swagger/GrpcSwaggerSchemaGenerator.cs" target="_blank" rel="noopener">这里</a>。</p><p>接下来，在实现了<code>ISwaggerProvider</code>以后，我们还需要替换掉默认的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGrpcGateway</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">this</span> IServiceCollection services, </span></span></span><br><span class="line"><span class="function"><span class="params">  IConfiguration configuration, </span></span></span><br><span class="line"><span class="function"><span class="params">  Action&lt;Microsoft.OpenApi.Models.OpenApiInfo&gt; setupAction = <span class="literal">null</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">string</span> sectionName = <span class="string">"GrpcGateway"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> configSection = configuration.GetSection(sectionName);</span><br><span class="line">    services.Configure&lt;GrpcGatewayOptions&gt;(configSection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> swaggerGenOptions = <span class="keyword">new</span> GrpcGatewayOptions();</span><br><span class="line">    configSection.Bind(swaggerGenOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> swaggerGenSetupAction = BuildDefaultSwaggerGenSetupAction(swaggerGenOptions, setupAction);</span><br><span class="line">    services.AddSwaggerGen(swaggerGenSetupAction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace ISwaggerProvider</span></span><br><span class="line">    services.Replace(<span class="keyword">new</span> ServiceDescriptor(</span><br><span class="line">        <span class="keyword">typeof</span>(ISwaggerProvider),</span><br><span class="line">        <span class="keyword">typeof</span>(GrpcSwaggerProvider),</span><br><span class="line">        ServiceLifetime.Transient</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace IApiDescriptionGroupCollectionProvider</span></span><br><span class="line">    services.Replace(<span class="keyword">new</span> ServiceDescriptor(</span><br><span class="line">        <span class="keyword">typeof</span>(IApiDescriptionGroupCollectionProvider),</span><br><span class="line">        <span class="keyword">typeof</span>(GrpcApiDescriptionsProvider),</span><br><span class="line">        ServiceLifetime.Transient</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GrpcDataContractResolver</span></span><br><span class="line">    services.AddTransient&lt;GrpcDataContractResolver&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GrpcSwaggerSchemaGenerator</span></span><br><span class="line">    services.AddTransient&lt;GrpcSwaggerSchemaGenerator&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure GrpcClients</span></span><br><span class="line">    services.ConfigureGrpcClients(swaggerGenOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AllowSynchronousIO</span></span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是见证奇迹的时刻，gRPC 和 Swagger 牵手成功。从此，查阅和调试 gRPC 接口，我们有了更时尚的做法：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/28/Uj9Z3EcbQmdhriD.png" alt="gRPC 成功牵手 Swagger" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC 成功牵手 Swagger</div></figure><p>调一下接口看看效果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/28/z9Umj6t5hcSQeTv.png" alt="通过 Swagger 调试 gRPC 接口" referrerpolicy="no-referrer"></div><div class="image-caption">通过 Swagger 调试 gRPC 接口</div></figure><p>可以注意到，此时，Swagger 中返回了我们期望的结果，事实上，只有 Swagger 还不足以令它运作起来，其中的诀窍是，博主利用终结点(<strong>Endpoints</strong>)动态创建了路由。关于这一点，博主曾在 <a href="https://blog.yuanpei.me/posts/2167892202/" target="_blank" rel="noopener">ASP.NET Core gRPC 打通前端世界的尝试</a> 这篇文章中提到过。最终，博主编写了一个更为完整的项目：<a href="https://github.com/qinyuanpei/FluentGrpc.Gateway" target="_blank" rel="noopener">FluentGrpc.Gateway</a>，而关于 Swagger 的这部分内容则成为了这篇博客的内容，如果大家对这个项目感兴趣的话，欢迎大家去做进一步的探索，欢迎大家 Star 和 PR，而到这里，这篇博客差不多就可以结尾啦！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>有时候，博主会不由地感慨，整个微服务架构的落地过程中，服务治理是花费时间和精力最多的环节，除了保证接口的稳定性，更多的时候，其实是不同的服务间相互打交道。那么，除了口头传达外，最好的管理接口的方式是什么呢？显然是接口文档。本文分享了两种针对 gRPC 的服务文档化的方案，第一种是由官方提供的 <a href="https://github.com/pseudomuto/protoc-gen-doc" target="_blank" rel="noopener">protoc-gen-doc</a>，它可以从 Protobuf 生成 HTML 或者 Markdown 格式的接口文档。第二种是由博主实现的 <a href="https://github.com/qinyuanpei/FluentGrpc.Gateway" target="_blank" rel="noopener">FluentGrpc.Gateway</a>，它实现了从 Protobuf 到 Swagger 的转换，只需要在项目中引入这个中间件，就可以把 gRPC 带进 Swagger 的世界，不管是查阅接口还是调试接口，都多了一种玩法，如果你还需要给非开发人员提供接口文档，那么，我觉得你还可以试试 <a href="http://yapi.smart-xwork.cn/" target="_blank" rel="noopener">YAPI</a>，只需要导入 Swagger 格式的服务描述信息即可，而这一步，我们已经实现了。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Swagger" scheme="https://qinyuanpei.github.io/tags/Swagger/"/>
    
      <category term="文档" scheme="https://qinyuanpei.github.io/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>SSL/TLS 加密传输与数字证书的前世今生</title>
    <link href="https://qinyuanpei.github.io/posts/3163397596/"/>
    <id>https://qinyuanpei.github.io/posts/3163397596/</id>
    <published>2021-09-05T14:13:32.000Z</published>
    <updated>2022-03-07T01:40:22.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>Hi，大家好，我是飞鸿踏雪，欢迎大家关注我的博客。近来，博主经历了一次服务器迁移，本以为有 Docker-Compose 加持，一切应该会非常顺利，没想到最终还是在证书上栽了跟头，因为它的证书是和 IP 地址绑定的。对，你没听错，这个世界上还真就有这么别扭的设定，尤其是你折腾了一整天，发现你需要到一个 CA 服务器上去申请证书的时候，那种绝望你晓得吧？数字证书、HTTPS、SSL/TLS、加密……无数的词汇在脑海中席卷而来，这都是些啥啊？为了解答这些困惑，经历了写字、画图、查资料的无数次轮回，终于在周末两天淅淅沥沥的雨声中，有了今天这篇文章，我将借此带大家走进 SSL/TLS 加密传输与数字证书的前世今生，希望从此刻开始，令人眼花缭乱的证书格式不会再成为你的困扰。</p><h1 id="证书与加密"><a href="#证书与加密" class="headerlink" title="证书与加密"></a>证书与加密</h1><p>对于数字证书的第一印象，通常来自于 HTTPS 协议。因为地球人都知道，HTTP 协议是不需要数字证书的。对于 HTTPS 协议的理解，可以简单粗暴的认为它约等于 HTTP + SSL，所以，从这个协议诞生的那一刻起，加密算法与数字证书就密不可分，因为从本质上来讲，HTTPS 协议就是为了解决如何在不安全的网络上、安全地传输数据的问题。事实上，HTTPS 协议的实现，背后依托 SSL/TLS、数字签名、对称/非对称加密等一系列的知识。也许，在读到这篇文章以前，你就像博主一样，对于 HTTPS 的理解，永远止步于 HTTP + SSL。那么，我希望下面的解释可以帮助到你，通常，HTTPS 认证可以分为 单向认证 和 双向认证 两种，这里我们以为以单向认证为例，来说明数字证书与加密算法两者间的联系：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/nkJFiPNdVc4ShAw.png" alt="HTTPS 数字证书与加密传输间的关系" referrerpolicy="no-referrer"></div><div class="image-caption">HTTPS 数字证书与加密传输间的关系</div></figure><p>如图所示，HTTPS 单向认证流程主要经历了下面 7 个步骤，它们分别是：</p><ul><li>客户端发起 HTTPS 请求</li><li>服务器返回证书信息，本质上是公钥</li><li>客户端/浏览器通过 CA 根证书验证公钥，如果验证失败，将会收到警告信息</li><li>客户端随机生成一个对称密钥 Key，并利用公钥对 Key 进行加密</li><li>服务器使用私钥解密获得对称密钥 Key</li><li>通过对称密钥 Key 对确认报文进行加密</li><li>双方开始通信</li></ul><p>由此，我们可以看出，整个 HTTPS 单向认证流程，实际上是结合了 对称加密 和 非对称加密 两种加密方式。其中，非对称加密主要用于客户端、服务器双方的“试探”环节，即证书验证部分；对称加密主要用于客户端、服务器双方的“正式会话”阶段，即数据传输部分。关于 对称加密 和 非对称加密 两者的区别，我们可以从下面的图中找到答案：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/08/lBNLu4t9VxkOewn.png" alt="对称加密 与 非对称加密" referrerpolicy="no-referrer"></div><div class="image-caption">对称加密 与 非对称加密</div></figure><p>因为客户端持有服务器端返回的公钥，所以，两者可以使用 非对称加密 对随机密钥 Key 进行加/解密。同理，因为客户/服务器端使用相同的随机密钥，所以，两者可以使用 对称加密 对数据进行加/解密。有朋友可能会问，那照你这样说，任何一个客户端都可以向服务器端发起请求嘛，你这样感觉一点都不安全呢？我承认，大家的担心是有道理的。所以，在此基础上，我们还可以使用双向认证，就是不单单客户端要验证服务器端返回的证书，同样，服务器端要对客户端的证书进行验证。那么，客户端是如何验证服务器端返回的证书的呢？服务器返回的证书里都含有哪些信息呢？带着这些问题，我们来看看知乎这个网站：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/5vcDPmT14WyCOqE.png" alt="知乎的证书信息" referrerpolicy="no-referrer"></div><div class="image-caption">知乎的证书信息</div></figure><p>事实上，浏览器在对服务器端返回的证书进行校验时，主要关心下面这些信息：</p><ul><li>判断域名、有效期等信息是否正确：这些信息在证书中是公开的，可以非常容易地获得。</li><li>判断证书是否被篡改：需要由 CA 服务器进行校验。</li><li>判断证书来源是否合法：每一份签发的证书都可以按照证书链找到对应的根证书，所以，可以通过操作系统中安装的根证书对证书的来源进行验证。</li><li>判断证书是否被吊销：需要由 CRL（Certificate Revocation List，即 证书注销列表）和 OCSP（Online Certificate Status Protocol, 即 在线证书状态协议） 来实现。</li></ul><p>这里引入了一个新的概念，即 CA（Certification Authority）。那么，什么是 CA 呢？ 通俗来讲，CA 就是一个负责签发、认证和管理证书的机构。可能有朋友会想，客户端和服务器端通过非对称加密相互校验证书就好了啊，为什么还需要这样一个第三方的机构呢？事实上，这相当于一种担保/信用体系，因为服务器端的公钥对任何人来说都是可见的，我们来考虑这样一种情形。假设客户端从服务器端获得了某个公钥，并且它认为这个公钥是可信的，此时，有一个不怀好意的中间人截获了这个公钥，它如法炮制伪造了一个相同的公钥并返回，那么，此时客户端会如何看待这个公钥呢？虽然这个中间人不可能伪造出与服务端相同的私钥，可这无疑会让客户端感到困惑，因为它没有办法判断这个证书的真假。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/renZkROKljmYuoE.png" alt="证书的签发与认证" referrerpolicy="no-referrer"></div><div class="image-caption">证书的签发与认证</div></figure><p>其实，写到这里的时候，博主隐隐约约意识到，当下流行的比特币/数字人民币均与数字签名息息相关，因为 CA 使用私钥对证书进行了签名，这样就杜绝了证书被篡改的可能，从而可以为证书的真实性背书，这种基于信任制、拥有权威性的体系，就像现实生活中银行为货币的真实性、价值背书一样。因此，我们会注意到，在现实生活中，想要获得一份权威机构的数字证书，就需要向 CA 进行申请，例如，知乎的证书是从 DigiCert Inc 这个机构中购买的，不同的机构对于证书申请者的审核要求不同，这样就形成了不同价格甚至免费的数字证书。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/szYK63b2y4XhNr7.png" alt="CA 组织树形结构" referrerpolicy="no-referrer"></div><div class="image-caption">CA 组织树形结构</div></figure><p>当然，这个世界上有超过 1 亿个网站，如果每个网站都去向 CA 申请数字证书，那么，CA 一定会忙到崩溃。所以，实际的运行过程是，一个根 CA 会分成多个中间 CA，然后中间 CA 可以继续拆分为更小的中间 CA，这样做的好处是效率更高，同时保证了根 CA 中私钥的安全性。此时，我们会发现一个新的问题，就是当整个数字证书体系中突然多出来这么多“中介”以后，我们如何保证证书的权威性和真实性呢？类似地，数字证书世界里里有证书链的概念。所谓证书链，就是指证书可以追本溯源、在整个链路上都是可信任的，听起来是不是有区块链的味道了？事实上区块链正是利用了数字签名的不可伪造、不可抵赖、不可复制等一系列特性。说回到证书链，由根 CA 签发的证书称为根证书、由中间 CA 签发的证书称为中间证书，其关系如下图所示，假设 A 完全信任 B，B 完全信任 C，则 A 可以完全信任 C:</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/07/WilIrjBSwTft2hL.png" alt="证书链示意图" referrerpolicy="no-referrer"></div><div class="image-caption">证书链示意图</div></figure><h1 id="证书创建"><a href="#证书创建" class="headerlink" title="证书创建"></a>证书创建</h1><p>OK，现在我们已然理清了证书与加密两者间的联系，那么，在实际生活中，我们该如何获得一个证书呢？由上文可知，证书理论上应该由 CA 机构来签发。目前，全球主流的 CA 机构有<a href="https://ssl.idcspy.net/comodo/" target="_blank" rel="noopener">Comodo</a>、<a href="https://ssl.idcspy.net/symantec/" target="_blank" rel="noopener">Symantec</a>、<a href="https://ssl.idcspy.net/geotrust/" target="_blank" rel="noopener">GeoTrust</a>、<a href="https://www.anxinssl.com/digicert/" target="_blank" rel="noopener">DigiCert</a>、<a href="https://ssl.idcspy.net/thawte/" target="_blank" rel="noopener">Thawte</a>、<a href="https://www.anxinssl.com/globalsign/" target="_blank" rel="noopener">GlobalSign</a>、<a href="https://ssl.idcspy.net/rapidssl/" target="_blank" rel="noopener">RapidSSL</a> 等，其中 <a href="https://www.anxinssl.com/symantec/" target="_blank" rel="noopener">Symantec</a>、<a href="https://www.anxinssl.com/geotrust/" target="_blank" rel="noopener">GeoTrust</a> 都是 <a href="https://www.anxinssl.com/digicert/" target="_blank" rel="noopener">DigiCert</a> 机构的子公司，占据数字证书体系中的垄断地位，就连国内的互联网厂商都需要向这些机构来购买证书，所以，推广 HTTPS 并不是完全出于安全的考虑，实际上还有某种利益关系在里面，可以想象得到，假如你的证书信任度不高，不在浏览器的可信任机构列表中，那么，你的网站就会被浏览器认为是不安全的，随之而来的就是用户对网站的信任度的下降。当然，购买数字证书是需要花钱的，所以，实际操作中，通常有自签名证书 和 CA 证书 两种，两者唯一的差别就在于权威性不同，大概相当于一种互联网行业的“保护费”。</p><h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>所谓自签名证书，其实就是自建一个 CA，然后利用这个 CA 对证书进行签名。为什么说它没有权威性呢？大概这就像小时候试卷上要签署大人的名字一样，如果你照着大人的笔迹伪造了签名，那么，此时没有人能保证这份签名的真实性。更深层次的原因在于，由你自建的这个 CA 没有在互联网上备案，它产生的证书无法通过证书链追溯，这是自签名证书没有权威性的原因。我们通常说的创建/生成证书，其实都是指这种自签名证书，创建自签名证书最常见的方式是 <a href="https://www.openssl.org" target="_blank" rel="noopener">OpenSSL</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建根证书</span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line">openssl req -new -key ca.key -out ca.csr</span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure><p>在这个过程中，OpenSSL 会要求我们提供下列信息：国家、省份、城市、组织 以及 全域名(FQDN)。在此之前，关于知乎的那个例子，实际上证书上的那些信息就是从这里来的。当我们有了这样一个自建的 CA 以后，我们就可以用这个自建的 CA 去签发证书，这就是自签名 CA 证书，如何生成这个证书呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 环境准备，下列路径在 openssl.conf 文件中定义</span><br><span class="line">mkdir -p ./demoCA/newcerts</span><br><span class="line"><span class="built_in">cd</span> ./demoCA/</span><br><span class="line">touch index.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'01'</span> &gt; serial</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">// 签发证书</span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line">openssl req -new -key ca.key -out server.csr</span><br><span class="line">openssl ca -<span class="keyword">in</span> server.csr -out server.crt -cert ca.crt -keyfile ca.key</span><br></pre></td></tr></table></figure><p>同样的，我们需要再输入一次下列信息：国家、省份、城市、组织 以及 全域名(FQDN)，然后利用自建的 CA 进行签名。在 OpenSSL 中，它定义了证书申请方需要满足的“门槛”，这决定了你能不能向某个 CA 申请证书，其定义位于<code>openssl.conf</code>文件中：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/08/ldIigFrJ8LvYZfP.png" alt="OpenSSL 策略配置" referrerpolicy="no-referrer"></div><div class="image-caption">OpenSSL 策略配置</div></figure><p>例如，这里的策略表示，只有当证书申请方的国家、省份、组织相同的时候，CA 才会接受你的证书申请。所以，至此你明白证书为什么收费了吧？因为主流的 CA 机构都在国外，理论上 CA 机构可以去调整这个策略，可如果对方不愿意调整策略，那么你只能找别人帮你来申请，通过不断的调用<code>openssl ca</code>命令， 产生新的中间 CA，这样就形成了树状的 CA 组织。是不是觉得看人脸色非常地不舒服？除了这种方式以外，我们还可以按下面这种方式生成证书，这种方式像极了我们小时候模仿大人签字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 签发证书</span><br><span class="line">openssl genrsa -out server.key 4096</span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure><p>如果是在 Windows 系统下，我们还可以搭建 CA 服务器，此时，证书申请者需要远程登陆到这台服务器进行操作，请参考：<a href="https://docs.microsoft.com/zh-cn/windows-server/networking/core-network-guide/cncg/server-certs/server-certificate-deployment" target="_blank" rel="noopener">服务器证书部署</a>。</p><h2 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h2><p>一旦理解了自签名证书，理解 CA 证书 就变得特别容易，这就是交了“保护费”的证书，过去总以为互联网世界里没有政治，后来发现互联网并不是“法外之地”，一切的自媒体、流量，最终都会转化为某种商品出售，只要人与人形成了某种圈子或者团体，这种政治就一定会存在。所以，你到腾讯云或者阿里云去购买证书，而腾讯和阿里则是某个 CA 机构的代理商，因为数字证书通常会和域名产生联系，所以，在供应商那里，两者往往是捆绑在一起销售，再加上网站备案、虚拟主机这些东西，在由资本绘制的商业版图里，你的钱包被安排得明明白白。或是为了打破这种垄断，或是为了某种利害关系，慢慢地出现了像 <a href="https://letsencrypt.org/zh-cn/" target="_blank" rel="noopener">Let’s Encrypt</a> 这样的提供免费证书的机构。所以，下面，我们以此为例来展示如何申请一个 CA 证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/acmesh-official/acme.sh.git</span><br><span class="line"><span class="built_in">cd</span> ./acme.sh</span><br><span class="line">./acme.sh --install</span><br><span class="line"></span><br><span class="line">acme.sh --register-account -m &lt;Your E-Mail&gt;</span><br><span class="line">acme.sh --issue -d &lt;Your-Domain&gt; --standalone</span><br></pre></td></tr></table></figure><p>目前，<a href="https://letsencrypt.org/zh-cn/" target="_blank" rel="noopener">Let’s Encrypt</a> 的使用是通过 acme.sh 这个脚本来驱动的，其基本用法如上面脚本所示。不同于自签名证书，Let’s Encrypt 目前不支持使用公网 IP 来申请证书，所以，如果在开发阶段，可以使用自签名的证书；在生产阶段，则最好使用 CA 签发的证书。通过阅读 <a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">文档</a> 可知，它支持 HTTP 和 DNS 两种验证方式，可以使用 Apache 、Nginx 和 Standalone 三种模式，个人推荐使用 Docker 来进行部署，因为前两种模式要求你安装对应的软件，第三种模式要求你的 80 端口是空闲的，这对于一名开发人员来说，简直是痴心妄想。如果你有一个域名，而恰好这个域名提供商在其支持的 <a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi" target="_blank" rel="noopener">列表</a> 内，那么，你就可以使用下面的方式来申请证书。首先，准备一个<code>docker-compose.yml</code>文件，博主的域名是从 <a href="https://www.godaddy.com" target="_blank" rel="noopener">GoDaddy</a> 申请的，大家可以结合实际情况进行调整：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"2.1"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  acme.sh:</span><br><span class="line">    image: neilpang/acme.sh</span><br><span class="line">    container_name: <span class="string">"acme.sh"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /docker/ssl:/acme.sh</span><br><span class="line">    environment:</span><br><span class="line">      - GD_Key=&lt;GoDaddy Key&gt;</span><br><span class="line">      - GD_Secret=&lt;GoDaddy Secret&gt;</span><br><span class="line">    <span class="built_in">command</span>: daemon</span><br></pre></td></tr></table></figure><p>接下来，我们只需要启动容器，然后在容器内部执行命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;ContainerId&gt; sh</span><br><span class="line">acme.sh --register-account -m &lt;Your E-Mail&gt;</span><br><span class="line">acme.sh --issue --dns dns_gd -d &lt;Your-Domain&gt;</span><br></pre></td></tr></table></figure><p>可以注意到，下面即为博主从 Let’s Encrypt 申请到的证书文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/08/FZLKdQ1cBRtjS4y.png" alt="从 Let‘s Encrypt 申请证书" referrerpolicy="no-referrer"></div><div class="image-caption">从 Let‘s Encrypt 申请证书</div></figure><p>如果你的域名提供商在这个 <a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi" target="_blank" rel="noopener">列表</a> 内，此时，你可以手动将其生成的值添加到域名记录中，这些在文档中均有提及，不再赘述。总而言之，你向 CA 机构申请证书需要一个有效的域名，像腾讯云、阿里云这种云服务提供商，早已提供好了完整的一条龙服务，只要你愿意花钱去买对方的产品。</p><h1 id="证书使用"><a href="#证书使用" class="headerlink" title="证书使用"></a>证书使用</h1><p>一旦生成了证书，我们就可以在应用程序中使用这些证书啦，我注意到公司的每个项目都配置了证书文件，其实我一直不明白，为什么不能直接把证书安装到宿主机上？这样只需要折腾一次就好了啊，简直是一劳永逸。如果有小伙伴们知道这个问题的答案，欢迎大家在评论区留言。下面我们来看看，生成的证书如何在不同的环境中配置，这里以 ASP.NET Core 、Envoy 和 Nginx 为例来说明。</p><h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><p>在 ASP.NET Core 中配置 HTTPS 证书，最直接的方案是在通过 Kestrel 中间件来指定证书路径和密码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webBuilder.ConfigureKestrel(options =&gt; &#123;</span><br><span class="line">    <span class="comment">// 方式 1</span></span><br><span class="line">    options.ConfigureHttpsDefaults(kestrel =&gt; &#123;</span><br><span class="line">        kestrel.ServerCertificate = <span class="keyword">new</span> X509Certificate2(<span class="string">"./path/to/your/example.com.pfx"</span>,<span class="string">"&lt;证书密码&gt;"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 2</span></span><br><span class="line">    options.Listen(IPAddress.Loopback, <span class="number">5001</span>, kestrel =&gt; &#123;</span><br><span class="line">      kestrel.UseHttps(<span class="keyword">new</span> X509Certificate2(<span class="string">"./path/to/your/example.com.pfx"</span>,<span class="string">"&lt;证书密码&gt;"</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果整个 ASP.NET Core 应用以容器方式运行，则还可以按下面这样的方式来配置证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -p 8000:80 -p 8001:443 \</span><br><span class="line">  -e ASPNETCORE_URLS=<span class="string">"https://+;http://+"</span> \</span><br><span class="line">  -e ASPNETCORE_HTTPS_PORT=8001 \</span><br><span class="line">  -e ASPNETCORE_ENVIRONMENT=Development \</span><br><span class="line">  -e ASPNETCORE_Kestrel__Certificates__Default__Password=<span class="string">"&lt;证书密码&gt;"</span> \</span><br><span class="line">  -e ASPNETCORE_Kestrel__Certificates__Default__Path=/path/to/your/example.com.pfx</span><br><span class="line">  -v /c/path/to/certs/:/https/ </span><br><span class="line">  &lt;镜像Id&gt;</span><br></pre></td></tr></table></figure><p>不得不说，这里的双下划线，总是让我不由地想起 Python 里的魔法方法：<code>__init__</code>。可能大家会疑惑，为什么博主这里要强调证书的扩展名，因为这实际上是数字证书里最让人迷惑的地方：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/09/08/tadr5bEHxR1Cs2y.png" alt="数字证书编码格式与扩展名" referrerpolicy="no-referrer"></div><div class="image-caption">数字证书编码格式与扩展名</div></figure><p>在整个数字证书体系中，X.509 是作为数字证书标准而存在的，按照编码格式的不同，可以分为 PEM 证书 和 DER 证书两类，前者是文本格式，而后者是二进制格式。不同的操作系统、开发语言，产生了不同的证书文件格式，但这些扩展名本身并不能说明什么，特别是像 .crt 或者 .cre 这种薛定谔的证书，唯一的判断标准，就是用记事本打开它，如果可读，说明它是 PEM 编码的证书，如果不可读，说明它是 DER 编码的证书。如果大家和 Java 系的技术或者产品做过对接，应该会对这种微妙的差别深有体会，此时，我们就需要通过 OpenSSL 来实现不同证书格式间的转换，ASP.NET Core 需要的 .pfx 证书是如何产生的呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// x.509 -&gt; .pfx</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> server.crt -inkey server.key -out server.pfx</span><br></pre></td></tr></table></figure><p>同理，常见的 OpenSSL 转换命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// .pem -&gt; .pfx</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> cert.pem -out cert.pfx -inkey key.pem </span><br><span class="line">// .pfx -&gt; .cer</span><br><span class="line">openssl pkcs12 -<span class="keyword">in</span> server.pfx -out server.cer -nodes</span><br><span class="line">// .cer -&gt; .pem</span><br><span class="line">openssl x509 -inform der -<span class="keyword">in</span> server.cer -out server.pem</span><br><span class="line">// PEM -&gt; DER</span><br><span class="line">openssl x509 -<span class="keyword">in</span> server.pem -outform der -out server.der</span><br><span class="line">// DER -&gt; PEM</span><br><span class="line">openssl x509 -<span class="keyword">in</span> server.der -inform der -outform pem -out server.pem</span><br></pre></td></tr></table></figure><h2 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h2><p>Envoy 中可以直接使用 .crt 文件 以及 .key 文件，这里出现了一个 TLS 协议，这个协议一直没机会来说，这里可以简单说一下，它可以视为 SSL 3.1，因为早期的 SSL 协议是由网景公司(Netscape)提出的，一共经历了 1.0、2.0 和 3.0 三个版本，后来标准化组织 IETE 在此基础上提出了增强版的 TLS 协议，一直沿用至今，所以，TLS 可以看做是 SSL 3.1，换句话讲，HTTPS = HTTP + SSL/TLS。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">transport_socket:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">envoy.transport_sockets.tls</span></span><br><span class="line">  <span class="attr">typed_config:</span></span><br><span class="line">    <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext</span></span><br><span class="line">    <span class="attr">common_tls_context:</span></span><br><span class="line">      <span class="attr">alpn_protocols:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"h2"</span></span><br><span class="line">      <span class="attr">tls_certificates:</span></span><br><span class="line">        <span class="attr">certificate_chain:</span></span><br><span class="line">          <span class="attr">filename:</span> <span class="string">"/path/to/your/example.com.crt"</span></span><br><span class="line">        <span class="attr">private_key:</span></span><br><span class="line">          <span class="attr">filename:</span> <span class="string">"/path/to/your/example.com.key"</span></span><br></pre></td></tr></table></figure><p>相信到了现在这个地步，大家终于能想明白 通过 HttpClient 调用第三方接口时，为什么要这这样一段堪称魔法的代码了吧？因为在推进 HTTPS 的过程中，大家使用的 SSL/TLS 协议版本都不一样，有时候客户端还提供不了可以通过验证的证书，所以，大家干脆无视协议的版本、证书的验证错误这些问题啦！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.Net.ServicePointManager.SecurityProtocol =</span><br><span class="line">    SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12 | SecurityProtocolType.Tls13;</span><br><span class="line">System.Net.ServicePointManager.ServerCertificateValidationCallback += (a, b, c, d) =&gt; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RestSharp</span></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> RestClient();</span><br><span class="line">client.RemoteCertificateValidationCallback += (a, b, c, d) =&gt; <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx 就更不必说啦，不过我个人现在更喜欢 Envoy 一点，Nginx 可以用 .crt 证书 或者 .pem 证书，我们只需要简单配置一下就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;path&#x2F;to&#x2F;example.com.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;path&#x2F;to&#x2F;example.com.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>因为一次服务器迁移时被证书苦虐的经历，决定花点时间研究了一下数字证书，本文从 HTTPS 协议入手，引出了对称加密、非对称加密等加密相关的内容，然后讨论了什么是证书，什么是 CA，以及 为什么需要 CA 等内容，现实世界中需要一个为证书权威性、真实性提供担保的组织，这种组织可以签发证书、验证证书、管理证书，利用数字签名的不可篡改、不可抵赖、不可复制、不可伪造等特性，根 CA 可以授权中间 CA 去签发证书，因为整个证书链都是可以追溯的。有了这些知识作为背景，我们分享了如何获得一份自签名证书和 CA 证书，两者本质上没有什么不同，唯一的区别在于其信任度不同。故事的最后，博主分享了如何为 ASP.NET Core 、Envoy、Nginx 配置 证书，对于数字证书的理解，从道的层面到术的层面，我们全部都串联起来啦，好了，以上就是这篇博客的全部内容，欢迎大家在评论区积极留言、参与讨论，原创不易，写技术博客更不易，大家点个赞吧！</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://kangzubin.com/certificate-format/" target="_blank" rel="noopener">SSL 数字证书的标准、编码以及文件扩展名</a></li><li><a href="https://www.moeelf.com/archives/281.html" target="_blank" rel="noopener">Docker 使用 acme.sh 申请 SSL 证书</a></li><li><a href="https://ws.wiki.gaogevip.com/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输安全协议</a></li><li><a href="https://zhuanlan.zhihu.com/p/100389013" target="_blank" rel="noopener">RingCentral Tech 丨证书，证书链，CA 的那些事</a></li><li><a href="https://zhuanlan.zhihu.com/p/96494976" target="_blank" rel="noopener">你知道，HTTPS 用的是对称加密还是非对称加密</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="证书" scheme="https://qinyuanpei.github.io/tags/%E8%AF%81%E4%B9%A6/"/>
    
      <category term="加密" scheme="https://qinyuanpei.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="签名" scheme="https://qinyuanpei.github.io/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="HTTPS" scheme="https://qinyuanpei.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>夕雾花园：从建筑中读出的爱情和美学</title>
    <link href="https://qinyuanpei.github.io/posts/3623891261/"/>
    <id>https://qinyuanpei.github.io/posts/3623891261/</id>
    <published>2021-08-26T09:13:32.000Z</published>
    <updated>2022-03-07T01:40:22.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>“古巴比伦王颁布了汉谟拉比法典，刻在黑色的玄武岩，距今已经三千七百多年”。多年以前，周杰伦在 <a href="https://www.bilibili.com/video/BV1Vx411G7Aj/" target="_blank" rel="noopener">《爱在西元前》</a> 里这样喃喃道，古巴比伦、楔形文字、玄武岩石板、底格里斯河、汉谟拉比法典……千年以后，一切已无法考据，这些如图腾符号一般神秘的意象，留给后人的只有无限的遐想。据传，公元前 6 世纪，新巴比伦国王尼布甲尼撒二世，迎娶了米底的公主安美依迪丝为王后。公主美丽可人，深受国王宠爱，可没过多久，公主就因为思念家乡而满怀愁绪。为此，国王召集工匠依照米底山区的景致修建了空中花园。最终，这座被誉为“古代七大奇迹”之一的神秘建筑，凭借它巧夺天工的园林景色俘获了公主的欢心。当空中花园渐渐淹没在滚滚黄沙里，这段无人知晓的爱，大概会被永远淹没在史书文卷，直到一个叫做方文山的词人发现它，然后写出来。在几乎同时代的周朝，周幽王烽火戏诸侯，只为博褒姒一笑。故事总是相似的，只是我们更愿意相信，那就是爱。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/vL3PmCX9TUfuqN1.jpg" alt="巴比伦“空中花园”" referrerpolicy="no-referrer"></div><div class="image-caption">巴比伦“空中花园”</div></figure><p>在更为久远的公元前 4 世纪，彼时庞贝城刚刚开始兴建。这个背靠地中海的小渔村，依托着天然的港口优势，在短短几十年里，逐渐成为仅次于意大利古罗马城的第二大城市。它北距罗马 300 千米，西接著名的西西里岛，南通希腊与北非，有着丝毫不亚于古罗马的斗兽场、太阳神神庙、大剧院、巫师堂、蒸汽浴室、商铺以及娱乐场所，吸引了无数来自周中海周边城邦的贵族和富商。庞贝城以北，有一座维苏威火山，这座活火山千年来一直在不断喷发，甚至庞贝古城本身就是建筑在硬化的火山熔岩上面。公元 62 年 2 月 8 日，一次强烈的地震令庞贝古城中的大量建筑塌毁，人们重建了庞贝古城，比以前更加追求奢侈豪华。历史定格在公元 79 年 8 月 24 日这一天，维苏威火山突然爆发，厚约 6 米的火山灰完全将这座城市从地球上抹去。<a href="https://music.163.com/#/song?id=1842802205" target="_blank" rel="noopener">许嵩</a> 对此发问，“如果火山喷发，是灾难还是壮美？”。也许，在那一瞬间，真的有人攥着新鲜的玫瑰，准备向喜欢的人求爱。火山喷发的刹那，庞贝是一颗千年的琥珀，时间自此被凝固和封印。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/bte7TPhu15aErHv.jpg" alt="重见天日的庞贝古城" referrerpolicy="no-referrer"></div><div class="image-caption">重见天日的庞贝古城</div></figure><p>不管是神秘莫测的空中花园，还是重见天日的庞贝古城，某种程度上，我们更愿意相信，那些亦真亦假的美丽传说。也许，这是因为它比建筑本身更具有说服力。因此，巴黎圣母院有过卡西莫多与艾丝梅拉达的故事，沧浪亭有过<a href="https://book.douban.com/subject/1088581/" target="_blank" rel="noopener">《浮生六记》</a>里的伉俪情深，泰姬陵有过沙·贾汗的一夜白头，布达拉宫有过松赞干布和文成公主的相敬如宾，埃菲尔铁塔有过古斯塔夫·埃菲尔的望眼欲穿……世上以爱为名的建筑不在少数，或为古堡、或为陵墓、或为高塔、或为教堂……即使随着时间的流逝，建筑会褪去自身的光芒，而透过这些故事所折射出的爱情的光华，则永远不会褪去，还有什么比历经风雨洗礼的建筑更能表达爱的深沉呢？电影 <a href="https://movie.douban.com/subject/30238379/" target="_blank" rel="noopener">《夕雾花园》</a> 同样讲述了一个关于建筑的故事，假如园林艺术可以当做一种建筑的话。于是，爱情、战争、艺术、救赎、悬疑……种种元素交织在一起，像极了这座园林里一草一木、一砖一瓦。透过石头和木头，去打量某段扑朔迷离的历史，这本身就是一种『借景』，谁还能记得起，在兴庆宫的花萼相辉楼，李白曾经写过某一首诗呢？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/D2mPAnxp3Zlo6hv.jpg" alt="从一方天地中借景" referrerpolicy="no-referrer"></div><div class="image-caption">从一方天地中借景</div></figure><p>妹妹云红，年轻时曾和姐姐云林一起前往日本旅行，并在那里见到了日式庭院，自此在心里埋下了一份庭院情结。后来，日本发动对马来西亚的侵略战争，姐妹俩被抓到同一个集中营里。姐姐云林，白天目睹日军对妹妹的暴行，夜晚聆听妹妹对日本园林的畅想。此时此刻，人生的苦难与艺术的理想，像极了一幅太极图，互不相溶而又紧紧相依。再后来，姐姐死里逃生，而妹妹却命丧矿井。带着这份深深的内疚感，云林决心替妹妹建造一座日式园林。就这样，女主结识了日本皇家园艺师中村有朋。中村并没有接受女主的园艺委托，而是让女主参与夕雾花园的修建工作，正是在这个过程中，中村教给了云林『借景』的智慧，所谓『借景』，是指在一个视觉范围内，借由远方的山，眼前的树，天上的云与雾，呼应人工打造的花园，创造出浑然天成的自然框景。所以，对于这个电影而言，云林是从过往的美好回忆、未来的无限期许中借景；中村是从和云林的相处中借景；导演是从时间、氛围、景致、阅历中借景。由此，云林和中村互相实现了自我救赎，云林能放下过去的执念努力生活下去，中村能够放下国家战争的罪恶感潜心钻研园艺，而我们能有幸看到这样一个故事。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/Fv8x1ObSHcuiX2w.jpg" alt="回忆中可爱的妹妹" referrerpolicy="no-referrer"></div><div class="image-caption">回忆中可爱的妹妹</div></figure><p>如果单纯用爱情来定义这部电影，显然是狭隘而片面的，因为我认为它表达了某种关乎艺术、心灵的东西。从无印良品到优衣库，日式的美学，始终让人联想到侘寂或者无用这样的字眼，甚至连同今年的东京奥运会开幕式，都被人们吐槽充满了阴间的味道。对于云林而言，中村是一个侵略者的身份，不管他是不是日军的间谍，不管他是不是知道集中营的位置，因为他们国家的铁蹄踏入自己的家园，亲人因此而走向毁灭，这是不折不扣的事实。可天使和魔鬼谁又真正分得清楚呢？云林曾经这样问妹妹云红，“日本人这样对待我们，为何你还喜欢他们的庭园”，云红说，“我爱的是花园，而不是建造它的人”。所以，对我而言，这部电影的基调是残酷而又不乏温柔的，战争带给人们的伤痛是真实而残酷的，而实现一种心灵层面上的宁静、尊重自然、尊重生命则是平静而温柔的。日式庭院，在战争时期对人们而言是毫无用处的，甚至修建这样一座庭院并不能让妹妹活过来，可正是这样一份来自侵略者国度的艺术理想，支撑着姐妹俩熬过那些人生中至暗的时刻。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/jl9D7bTKYJGMXIH.jpg" alt="我们活在疯狂的世界" referrerpolicy="no-referrer"></div><div class="image-caption">我们活在疯狂的世界</div></figure><p>透过云林被汗水浸透的衣服，中村第一次看见她背上的鞭痕，中村说，从那一刻开始，他就想为眼前的这个女人负责。刺青、折纸、浮世绘，这些非常日系的意象，仿佛故事里纠缠的线索一般，无一不在告诉观众，这是个谜一般的男人。正因为如此，他只能在隐秘的森林深处消失不见，恰如这个故事本身充满冲突和对立，只能选择戛然而止。有时候我会问自己，不能在当下验证和确认的爱，是否就要因此而阻断，甚至遥遥无期直至搁浅。我只知道，电影里是这样处理的，中村以一种私密而残忍的方式，将他对云林的爱，一针一针地钉在她的身上，那片由鞭痕演变而来的刺青。多年以后，经历过时间濯洗的云林，战争带给她的伤痛早已烟消云散，她终于能读懂那个男人的良苦用心。可正如那些被她扯下的折纸一般，当她像从前一样站在门口，凝视着这框架里嵌入的一方天地、一草一木、一花一叶，完成一次『借景』，可那个人此刻又在哪里呢？如果爱上一个来自侵略者国家的人，这样的爱算不算对妹妹、对战争带来的伤痛的背叛？而如果向殖民地的女人吐露国家的秘密，这样的爱又是否是对国家的背叛？年轻时，我们总以为爱情是奋不顾身，可爱与不爱，一个人说了不算啊……</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/Ygl9JcErsHGD3SF.jpg" alt="林深不见“中村”" referrerpolicy="no-referrer"></div><div class="image-caption">林深不见“中村”</div></figure><p>回过头看历史的时候，我们总以为“奋六世之余烈”的大秦帝国，理应是正义的一方，因为历史常常由赢家来书写，一旦你赢了，你怎么说都行，因为后人并不关心真相。一如历史上古罗马帝国横跨亚、欧、非三块大陆，蒙古帝国全盛时期版图甚至辐射到波兰，英国皇家海军一度在海上建立起“日不落”帝国……再后来，人们只记住了联合国五常，我们本以为这个世界不会再有战争，可塔利班还是在阿富汗打了起来。我不认为，战争与伤痛，就只能带来仇恨，就像朝鲜与韩国、印度和巴基斯坦，可能在我们有生之年都不会迎来和解，如果战争不能让人意识到爱与和平的珍贵，相反，它深化了人们内心的仇恨与愤怒，我以为，这才是对那些因为战争而死去的人的辜负和背叛。所以，身处乱世，一座庭院或者建筑，其本身是一种侘寂之美、无用之美，却能在痛苦与艰难中为内心寻得一处安宁，而这正是我看完 <a href="https://movie.douban.com/subject/30238379/" target="_blank" rel="noopener">《夕雾花园》</a> 后想表达的一种观点。无论爱在西元前还是西元后，站在庞贝古城前的你我，是否可以从此刻启程，回到人物饱满、情节充沛的某个瞬间，那一年，汉谟拉比用楔形文字刻下第一部法典，我静静地看着你，完全没想过防卫，拥抱的刹那，庞贝古城仿佛从未消失过一样……</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/27/IpXbBhykijmU1t2.jpg" alt="彼岸浮灯" referrerpolicy="no-referrer"></div><div class="image-caption">彼岸浮灯</div></figure><p>这世间的有些废墟相当壮观，而我对它们曾经的丰功伟绩知之甚少；这世间的有些故居格外亲切，而它们的主人对于历史进程的影响微乎其微。中国传统文学中的抒情主题，占比最多的怀古之情、兴亡之叹，所以，陈子昂登幽州台，发出前无古人、后无来者的慷慨悲歌；苏东坡赤壁遨游，感慨人生如梦，一樽还酹江月；辛弃疾登京口北固亭，梦回金戈铁马，气吞万里如虎……可能，从废墟中寻找某种感同身受的历史幻想，这才是中国文人群体如同着魔一般的集体症候，而将这一现象延伸到更大的世界，也许，全人类都是这样。谁能说刺客信条系列游戏，不是将人类几千年的历史，放在 Animus 这样一个沉浸式的 VR 设备中重新演绎呢？当艾吉欧·奥迪托雷漫步在古罗马的街道，人们总会不由自主地想到，凯撒在长老院遇刺身死、古罗马斗兽场里的三千斯巴达勇士……罗马不是一天建成的，而条条大路通罗马，这种由废墟而产生的莫名的情结，始终萦绕在人们的心头，帕特农神庙、圆明园、庞贝古城、乞力马扎罗雪山……世间有太多的风景，还未来得及亲眼去看就已经消失不见，无论是天然的景致，还是人造的景观，其实和人类本身一样，都要面临消逝的结局，唯一的不同的是，在时间尺度上它们显得更为永恒一点，相比六十年产权的现代化住宅，我还是更喜欢，这些废墟里慢悠悠地流淌着的故事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="历史" scheme="https://qinyuanpei.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="影评" scheme="https://qinyuanpei.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="夕雾花园" scheme="https://qinyuanpei.github.io/tags/%E5%A4%95%E9%9B%BE%E8%8A%B1%E5%9B%AD/"/>
    
      <category term="建筑" scheme="https://qinyuanpei.github.io/tags/%E5%BB%BA%E7%AD%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 自动识别防疫健康码</title>
    <link href="https://qinyuanpei.github.io/posts/1509692610/"/>
    <id>https://qinyuanpei.github.io/posts/1509692610/</id>
    <published>2021-08-19T14:13:32.000Z</published>
    <updated>2022-03-07T01:40:22.306Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>这个月月初的时候，朋友兴奋地和我描述着他的计划——准备带孩子到宁夏自驾游。朋友感慨道，“小孩只在书本上见过黄河、见过沙漠，这样的人生多少有一点遗憾”，可正如新冠病毒会变异为德尔塔一样，生活里唯一不变的变化本身，局部地区疫情卷土重来，朋友为了孩子的健康着想，不得不取消这次计划，因为他原本就想去宁夏看看的。回想过去这一年多，口罩和二维码，是每天打交道最多的东西。也许，这会成为未来几年里的常态。在西安，不管是坐公交还是地铁，都会有人去检查防疫二维码，甚至由此而创造了不少的工作岗位。每次看到那些年轻人，我都有种失落感，因为二十九岁高龄的我，已然不那么年轻了，而这些比我更努力读书、学历更高的年轻人，看起来在做着和学历/知识并不相称的工作。也许，自卑的应该是我，因为国家刚刚给程序员群体定性——<a href="http://www.mohrss.gov.cn/SYrlzyhshbzb/jiuye/gzdt/202108/t20210816_420736.html" target="_blank" rel="noopener">新生代农民工</a>。可是，我这个农民工，今天想做一点和学历/知识相称的事情，利用 Python 来自动识别防疫二维码。</p><h1 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h1><p>对于防疫二维码而言，靠肉眼去看的话，其实主要关注两个颜色，即标识健康状态的颜色和标识疫苗注射状态的颜色。与此同时，为了追踪人的地理位置变化，防疫/安检人员还会关注地理位置信息，因此，如果要自动识别防疫二维码，核心就是读出其中的颜色以及文字信息。对于颜色的识别，我们可以利用 <a href="https://opencv.org" target="_blank" rel="noopener">OpenCV</a> 中的 <a href="https://docs.opencv.org/3.4/da/d97/tutorial_threshold_inRange.html" target="_blank" rel="noopener">inRange()</a> 函数来实现，只要我们定义好对应颜色的 <a href="">HSV</a> 区间即可；对于文字的识别，我们可以利用 <a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a> 库来进行提取。基于以上原理，我们会通过 <a href="https://opencv.org" target="_blank" rel="noopener">OpenCV</a> 来处理摄像头的图像，只要我们将手机二维码对准摄像头，即可以完成防疫二维码的自动识别功能。考虑到检测不到二维码或者颜色识别不到这类问题，程序中增加了蜂鸣报警的功能。写作本文的原因，单纯是我觉得这样好玩，我无意借此来让人们失业。可生而为人，说到底不能像机器一样活着，大家不都追求有趣的灵魂吗？下面是本文中使用到的第三方 Python 库的清单：</p><ul><li>pyzbar == 0.1.8</li><li>opencv-contrib-python == 4.4.0.46</li><li>opencv-python == 4.5.3.56</li><li>paddleocr == 2.2.0.2</li><li>paddlepaddle == 2.0.0</li></ul><h1 id="图块检测"><a href="#图块检测" class="headerlink" title="图块检测"></a>图块检测</h1><p>下面是一张从手机上截取的防疫二维码图片，从这张图片中我们看出，整个防疫二维码，可以分为三个部分，即：上方的定位信息图块，中间的二维码信息图块，以及下方的核酸检验信息图块。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/eqzajLoMHEidy5t.jpg" alt="“西安一码通” 防疫二维码" referrerpolicy="no-referrer"></div><div class="image-caption">“西安一码通” 防疫二维码</div></figure><p>对于二维码的检测，我们可以直接使用 <a href="https://github.com/NaturalHistoryMuseum/pyzbar/" target="_blank" rel="noopener">pyzbar</a> 这个库来解析，可如果直接对整张图进行解析，因为其中的干扰项实在太多，偶尔会出现明明有二维码，结果无法进行解析的情况。所以，我们可以考虑对图片进行切分，而切分的依据就是图中的这三个图块。这里，我们利用二值化函数 <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/threshold/threshold.html" target="_blank" rel="noopener">threshold()</a> 和 轮廓提取函数 <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/shapedescriptors/find_contours/find_contours.html?highlight=findcontours" target="_blank" rel="noopener">findContours()</a> 来实现图块的检测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 灰度化 &amp; 二值化</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, binary = cv2.threshold(gray, <span class="number">135</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 检测轮廓，获得对应的矩形</span></span><br><span class="line">contours = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[<span class="number">-2</span>] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(contours)):</span><br><span class="line">    block_rect = cv2.boundingRect(contours[i])</span><br></pre></td></tr></table></figure><p>这里有一个感触颇深的地方，在检测图块的过程中，博主发现中间和底部这两个图块，其检测要更为简单一点，因为它有明显的边界、属于规则的矩形，而上方的图块，因为带有装饰性的纹理，以及灰色的过渡区，二值化并不能检测到其边缘，如下图所示，地铁上使用的二维码，相比商场里使用的二维码，轮廓线要更为清晰一点。所以，这里选择一个什么样的阈值来做二值化，个人感觉是需要反复去尝试的。考虑到要兼容这种轮廓不规则的图块，实际上我使用了一点小技巧，即：在得到下面两个图块以后，利用高度的换算关系，人为地生成上方图块的矩形范围。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/6gdQlwoDncJAvLV.jpg" alt="“西安一码通” 灰度化 & 二值化" referrerpolicy="no-referrer"></div><div class="image-caption">“西安一码通” 灰度化 & 二值化</div></figure><p>那么，这是否说明，代表美的设计，在代表绝对理性的算法面前，其实更像是一种噪音。也许，它们各自的领域不同、观点不同，可都一样在为这个世界发光发热，生活不止一种真相，世界不止一种回声，有微小的差异，同样有宏大的统一。</p><h1 id="二维码检测"><a href="#二维码检测" class="headerlink" title="二维码检测"></a>二维码检测</h1><p>好了，我们可以注意到，一旦完成图块的切分，此时，二维码位于中间这个图块，检测二维码在这里并不是重点，因为检测这个二维码是第一步，按照这个二维码所在的矩形去检测中心的的色彩，这是这里的重点，因为这个二维码解析以后就是一个 URL 地址，本身并没有包含任何信息，我们想要知道一个人是否健康，唯一的办法就是检测中间的色彩。其实，理论上剩余两个图块同样需要检测色彩，可考虑到三者在含义的表达上是一致的，即三者拥有相同的颜色，我们只需要处理其中一个即可。下面是利用 <a href="https://github.com/NaturalHistoryMuseum/pyzbar/" target="_blank" rel="noopener">pyzbar</a> 库对二维码区块进行解析，获取二维码信息、二维码所在的矩形等信息的代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测二维码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_qrcode</span><span class="params">(image, block)</span>:</span></span><br><span class="line">    block_image, block_rect, _ = block</span><br><span class="line">    block_x, block_y, _, _ = block_rect</span><br><span class="line">    gray = cv2.cvtColor(block_image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    qrcodes = decode(gray, [ZBarSymbol.QRCODE])</span><br><span class="line">    <span class="keyword">if</span> len(qrcodes) &gt; <span class="number">0</span>:</span><br><span class="line">        qrcode = qrcodes[<span class="number">0</span>]</span><br><span class="line">        qrcodeData = qrcode.data.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">        x, y, w, h = qrcode.rect</span><br><span class="line">        abs_x = block_x + x</span><br><span class="line">        abs_y = block_y + y</span><br><span class="line">        cv2.rectangle(image, (abs_x, abs_y), (abs_x + w, abs_y + h), color_marker, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, qrcodeData, (abs_x, abs_y, w, h)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>可以注意到，通过 <a href="https://github.com/NaturalHistoryMuseum/pyzbar/" target="_blank" rel="noopener">pyzbar</a> 这个库，我们不单单可以获取到二维码的信息，同时还可以获得二维码在图块中的矩形范围，由此我们可以推算出，二维码在整张图片中的矩形范围，我们会绘制一个矩形来标识二维码的位置，这样使用者就可以清楚的知道，我们的的确确检测到了二维码。</p><h1 id="色彩检测"><a href="#色彩检测" class="headerlink" title="色彩检测"></a>色彩检测</h1><p>一旦我们确定了二维码的矩形范围，接下来的工作，就是在这个矩形范围里检测颜色啦！譬如一个人如果健康状态，二维码的中间部分会显示为绿色。如果一个人完成了疫苗的注射，二维码边上的区域会显示为金色。所以，基于这样的原理，我们只需要检测对应区域是否有对应的颜色即可，这里主要利用了<code>HSV</code>颜色模型，不同于<code>RGB</code>颜色模型，<code>HSV</code>颜色模型利用色相、饱和度和亮度三个指标来描述颜色，是一种把<code>RGB</code>色彩空间中的点放在倒圆锥体上的表示方法。其中：</p><ul><li>H，即 Hue，表示色相，它通过角度来度量，因此，它的取值范围是0 到 360 度，如下图所示，红色对应 0 度，绿色对应 120 度，蓝色对应 240 度：</li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/jGVkTzscKUabeDf.jpg" alt="HSV 颜色模型：色相" referrerpolicy="no-referrer"></div><div class="image-caption">HSV 颜色模型：色相</div></figure><ul><li>S，即 Saturation，表示饱和度，用 0 到 100% 之间的数值表示，如果用下面的倒圆锥体来表示，则 S 表示的是色彩点到所在圆形切面圆心的距离与该圆半径的比值：</li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/UoSRreKhx2Af39d.jpg" alt="HSV 颜色模型：倒圆锥体" referrerpolicy="no-referrer"></div><div class="image-caption">HSV 颜色模型：倒圆锥体</div></figure><ul><li>V，即 Value，表示亮度，同样用 0 到 100% 之间的数值表示，参考上面的倒圆锥体，可以了解到，V 表示的是色彩点所在圆形切面圆心与该圆圆心在垂直距离上的比值：</li></ul><p>此时此刻，你有没有回想起小时候调电视机画面时的经历呢？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/vHSp6CmZQWnjBVk.jpg" alt="找不到合适的图，简单怀旧一下？" referrerpolicy="no-referrer"></div><div class="image-caption">找不到合适的图，简单怀旧一下？</div></figure><p>对于<code>HSV</code>颜色模型，我们可以参考下面的取值范围：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/FfocQAgdOzrhpjm.png" alt="HSV 颜色模型：参考范围" referrerpolicy="no-referrer"></div><div class="image-caption">HSV 颜色模型：参考范围</div></figure><p>以红色为例，其 H 分量取值范围为：0 到 10；S 分量取值范围为：43 到 255；V 分量取值范围为：46 到 255。<a href="https://opencv.org" target="_blank" rel="noopener">OpenCV</a> 中的 <a href="https://docs.opencv.org/3.4/da/d97/tutorial_threshold_inRange.html" target="_blank" rel="noopener">inRange()</a> 函数，可以判断某个 HSV 数组（此时图片使用一个数组来表示）是否在某个给定的区间范围内。于是，我们的思路就是：定义好目标颜色的 HSV 区间，同时提供一份 HSV 格式的图片数据。此时，其实现逻辑如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 颜色范围定义</span></span><br><span class="line">color_dist = &#123;</span><br><span class="line">    <span class="string">'red'</span>: &#123;<span class="string">'Lower'</span>: np.array([<span class="number">0</span>, <span class="number">60</span>, <span class="number">60</span>]), <span class="string">'Upper'</span>: np.array([<span class="number">6</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">'blue'</span>: &#123;<span class="string">'Lower'</span>: np.array([<span class="number">100</span>, <span class="number">80</span>, <span class="number">46</span>]), <span class="string">'Upper'</span>: np.array([<span class="number">124</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">'green'</span>: &#123;<span class="string">'Lower'</span>: np.array([<span class="number">35</span>, <span class="number">43</span>, <span class="number">35</span>]), <span class="string">'Upper'</span>: np.array([<span class="number">90</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">'golden'</span>: &#123;<span class="string">'Lower'</span>: np.array([<span class="number">26</span>, <span class="number">43</span>, <span class="number">46</span>]), <span class="string">'Upper'</span>: np.array([<span class="number">34</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测颜色</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_color</span><span class="params">(image, color)</span>:</span></span><br><span class="line">    <span class="comment"># gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 灰度</span></span><br><span class="line">    gs = cv2.GaussianBlur(image, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)  <span class="comment"># 高斯模糊</span></span><br><span class="line">    hsv = cv2.cvtColor(gs, cv2.COLOR_BGR2HSV)  <span class="comment"># HSV</span></span><br><span class="line">    erode_hsv = cv2.erode(hsv, <span class="literal">None</span>, iterations=<span class="number">2</span>) <span class="comment"># 腐蚀</span></span><br><span class="line">    inRange_hsv = cv2.inRange(erode_hsv, color_dist[color][<span class="string">'Lower'</span>], color_dist[color][<span class="string">'Upper'</span>])</span><br><span class="line">    contours = cv2.findContours(inRange_hsv.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">if</span> len(contours) &gt; <span class="number">0</span>:</span><br><span class="line">        draw_color_area(image, contours)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        winsound.Beep(<span class="number">440</span>, <span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这里，我们先对图片做了一次高斯模糊、然后将其转换为 HSV 格式，经过侵蚀以后传给 <code>inRange()</code>函数，这样我们就得到了所有符合这个区间范围的点。接下来，单单找到颜色还不行，我们还需要根据这些点得到一个轮廓，此时，<code>findContours()</code>函数再次登场，为了让使用者更直观地找到对应的颜色区域，我们这里使用下面的方法将其“画”出来：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标记颜色区域</span></span><br><span class="line">def draw_color_area(image, contours):</span><br><span class="line">    max, index = 0, -1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(contours)):</span><br><span class="line">       <span class="built_in"> area </span>= cv2.contourArea(contours[i])</span><br><span class="line">        <span class="keyword">if</span><span class="built_in"> area </span>&gt; max:</span><br><span class="line">            max = area</span><br><span class="line">            index = i</span><br><span class="line">    <span class="keyword">if</span> index &gt;= 0:</span><br><span class="line">        rect = cv2.minAreaRect(contours[index])</span><br><span class="line">        cv2.ellipse(image, rect, color_marker, 2, 8)</span><br><span class="line">        cv2.circle(image, (np.int32(rect[0][0]), np.int32(rect[0][1])), 2, color_marker, 2, 8, 0)</span><br></pre></td></tr></table></figure><p>以中间部分的二维码图块为例，此时，我们可以得到下面的结果，这是做了两次颜色检测得到的，第一次检测绿色，第二次检测金色：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/19/wt6y4gEocnhkM5K.png" alt="“西安一码通” 防疫二维码：颜色检测" referrerpolicy="no-referrer"></div><div class="image-caption">“西安一码通” 防疫二维码：颜色检测</div></figure><h1 id="OCR-识别"><a href="#OCR-识别" class="headerlink" title="OCR 识别"></a>OCR 识别</h1><p><code>OCR</code>识别没有太多悬念，因为我们直接使用 <a href="https://github.com/PaddlePaddle/PaddleOCR" target="_blank" rel="noopener">PaddleOCR</a> 即可，因为我们已经完成对图块的切分，只需要依次对图片进行检验即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install paddlepaddle==2.0.0 -i https://mirror.baidu.com/pypi/simple</span><br><span class="line">python -m pip install paddleocr</span><br></pre></td></tr></table></figure><p>在安装的过程中，可能会得到这样的错误信息：<code>Microsoft Visual C++ 14.0 is required</code>。如果你安装了 Visual Studio 依然提示错误，解决方案就是找到 Visual Studio 安装包，然后勾选那些和 Microsoft Visual C++ 14.0 相关的可选的安装项，再安装了这些必要组件以后，重新使用<code>pip</code>安装即可。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/Iqms8YS6G7l4zrC.png" alt="“Microsoft Visual C++ 14.0 is required” 错误信息" referrerpolicy="no-referrer"></div><div class="image-caption">“Microsoft Visual C++ 14.0 is required” 错误信息</div></figure><p>因为 <a href="https://github.com/PaddlePaddle/PaddleOCR" target="_blank" rel="noopener">PaddleOCR</a> 接受的是<code>PIL</code>库中的<code>Image</code>类型，所以，在拆分图块的时候，实际上是为每个图块生成了一个对应的文件。此时，OCR 识别部分的代码实现如下。首先，我们需要初始化 PaddleOCR ，首次运行会自动下载训练好的模型文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PaddleOCR</span></span><br><span class="line">ocr = PaddleOCR()</span><br></pre></td></tr></table></figure><p>这里，我们通过<code>detect_text</code>来检测每个图块的文字，并在原始图片中标记出文字位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测文字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_text</span><span class="params">(image, block)</span>:</span></span><br><span class="line">    _, block_rect, block_file = block</span><br><span class="line">    block_x, block_y, _, _ = block_rect</span><br><span class="line">    result = ocr.ocr(block_file)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> result:</span><br><span class="line">        boxes = line[<span class="number">0</span>]</span><br><span class="line">        texts = line[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        x = int(boxes[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        y = int(boxes[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        w = int(boxes[<span class="number">2</span>][<span class="number">0</span>]) - x</span><br><span class="line">        h = int(boxes[<span class="number">2</span>][<span class="number">1</span>]) - y</span><br><span class="line">        abs_x = block_x + x</span><br><span class="line">        abs_y = block_y + y</span><br><span class="line">        cv2.rectangle(image, (abs_x, abs_y), (abs_x + w, abs_y + h), color_marker, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">yield</span> texts</span><br></pre></td></tr></table></figure><p>以底部图块的检测结果为例，其文字位置标记及文字识别结果如下图所示：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/XSTfimvkc2yPOAR.png" alt="通过 OCR 识别出来的文字位置" referrerpolicy="no-referrer"></div><div class="image-caption">通过 OCR 识别出来的文字位置</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/VP2YouclhKLX58j.png" alt="通过 OCR 识别出来的文字信息" referrerpolicy="no-referrer"></div><div class="image-caption">通过 OCR 识别出来的文字信息</div></figure><h1 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h1><p>到现在为止，主要的部分我们已经编写完成，接下来，我们只需要接入摄像头，从摄像头捕捉图像即可。这里，请允许在下推荐一个非常好用的软件：<a href="https://ivcam.en.softonic.com/" target="_blank" rel="noopener">iVCam</a>，它可以让手机摇身一变成为摄像头，从而可以让我们模拟扫描二维码的场景。使用 OpenCV 捕捉来自摄像头的图片非常简单，大家可以参考我曾经的博客：<a href="https://blog.yuanpei.me/posts/2997581895/" target="_blank" rel="noopener">视频是不能P的系列：OpenCV人脸检测</a>，这里我们直接给出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_video</span><span class="params">()</span>:</span></span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, image = cap.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">           <span class="comment"># 检测画面中的图块</span></span><br><span class="line">            blocks = list(detect_blocks(image))</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 处理每个图块</span></span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">                image = handle_block(image, block)</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 展示处理结果</span></span><br><span class="line">            cv2.imshow(<span class="string">'QRCode Detecting'</span>, image)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 按 Q 退出</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    cap.release() </span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>此时，我们就可以看到下面的结果。可以注意到，在实际应用中，通过视频采集的图像会受到环境光照、拍摄角度等因素的影响，受此影响，我们的图块检测在这个环节表现不佳，它甚至把整张图片当成了一个图块，这直接导致最重要的二维码没有检测出来。百度的 <a href="https://github.com/PaddlePaddle/PaddleOCR" target="_blank" rel="noopener">PaddleOCR</a> 表现倒是可圈可点，识别速度和准确性还是非常出色的。对于视频这种级别的输入，特别是在人流量较大的商场、车站等场所，对于识别准确性、可靠性都有着非比寻常的要求，如果要考虑这个思路的落地，应该在图像采集的预处理、图像检测的算法上去下功夫，特别是在拆分图块这个环节，识别的准确性还会受到二维码样式的影响，而这些显然是这篇博客背后的故事啦！正所谓，”路漫漫其修远兮，吾将上下而求索”，如果大家对这个项目感兴趣的话，可以到 <a href="https://github.com/Regularly-Archive/2021/tree/master/src/GreenQRCode" target="_blank" rel="noopener">Github</a> 上做进一步的了解。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/20/dxtOhKCr8YFLmoW.jpg" alt="通过摄像头检测防疫二维码" referrerpolicy="no-referrer"></div><div class="image-caption">通过摄像头检测防疫二维码</div></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>写完这篇博客的时候，我不由地会想，也许，屏幕前的某个人会在看完这篇博客以后，一脸鄙夷地说道，就这？可这的确就是基础性研究的现状，即：投入了时间和精力，并不一定能得到满意的结果。我们从小到大接受的关于成功的理念，无非都是“只要功夫深，铁杵磨成针”、“吃得苦中苦，方为人上人”……可不知道为什么，这种理念在被一点一点的打破，某种意义上来讲，国家和个人在这个时代面对的选择是相似的，在选择挣快钱还是挣慢钱这个问题上。多年以前，在实验室里捣腾化学试剂的我，曾经一度认为做实验、分析数据、写报告这些事情是枯燥而无用的，因为在当时看来，这些东西距离实际应用都挺遥远的。可是，此刻我大概不得不承认，这些基础工作的重要性。的确，写算法、做模型，这些事情都是科学家去做的事情，我们普通人只要奉行“拿来主义”就好，可当 OpenCV 就放在你手里，而你依然做不好这件事情的时候，大概还是我输了罢，说“认真你就输了”的人，真的真的真的认真过吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="OpenCV" scheme="https://qinyuanpei.github.io/tags/OpenCV/"/>
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="健康码" scheme="https://qinyuanpei.github.io/tags/%E5%81%A5%E5%BA%B7%E7%A0%81/"/>
    
      <category term="防疫" scheme="https://qinyuanpei.github.io/tags/%E9%98%B2%E7%96%AB/"/>
    
  </entry>
  
  <entry>
    <title>你不可不知的容器编排进阶技巧</title>
    <link href="https://qinyuanpei.github.io/posts/172025911/"/>
    <id>https://qinyuanpei.github.io/posts/172025911/</id>
    <published>2021-08-14T22:13:32.000Z</published>
    <updated>2022-03-07T01:40:22.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>在团队内推广<code>Docker Compose</code>有段时间啦，值得庆幸的是，最终落地效果还不错，因为说到底，大家都不大喜欢，那一长串复杂而枯燥的命令行参数。对我而言，最为重要的一点，团队内使用的技术变得更加透明化、标准化，因为每个微服务的配置信息都写在<code>docker-compose.yml</code>文件中，任何人都可以快速地构建出一套可用的服务，而不是每次都要去找具体的某一个人。我想说，这其实是一个信息流如何在团队内流动的问题。也许，我们有文档或者<code>Wiki</code>，可新人能不能快速融入其中，这才是检验信息流是否流动的唯一标准。就这样，团队从刀耕火种的<code>Docker</code>时代，进入到使用服务编排的<code>Docker Compose</code>时代。接下来，能否进入<code>K8S</code>甚至是云原生的时代，我终究不得而知。今天我想聊聊，在使用<code>Docker Compose</code>的过程中，我们遇到的诸如容器的<strong>启动顺序</strong>、<strong>网络模式</strong>、<strong>健康检查</strong>这类问题，我有一点<code>Docker Compose</code>的进阶使用技巧想和大家分享。</p><h1 id="容器的启动顺序"><a href="#容器的启动顺序" class="headerlink" title="容器的启动顺序"></a>容器的启动顺序</h1><p>使用服务编排以后，大家最关心的问题是，如果服务间存在依赖关系，那么如何保证容器的启动顺序？我承认，这是一个真实存在的问题，譬如，你的应用依赖某个数据库，理论上数据库要先启动，抑或者是像<code>Redis</code>、<code>Kafka</code>、<code>Envoy</code>这样的基础设施，总是要优先于应用服务本身启动。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/LnAh6GSdMJ2NkVx.png" alt="假如章鱼的这些脚互相影响会怎么样？" referrerpolicy="no-referrer"></div><div class="image-caption">假如章鱼的这些脚互相影响会怎么样？</div></figure><p>熟悉<code>Docker Compose</code>的同学，也许会想到<code>depends_on</code>这个选项，可如果大家亲自去尝试过就会知道，这终究只是我们的一厢情愿。为什么呢？因为这个<code>depends_on</code>主要是看目标容器是不是处于<code>running</code>的状态，所以，在大多数情况下，我们会注意到<code>Docker Compose</code>并不是按我们期望的顺序去启动的，因为目标容器在某一瞬间的确已经是<code>running</code>的状态了，那这样简直太尴尬了有木有啊！我们从一个简单的例子开始：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&gt;</span></span><br><span class="line">      <span class="string">/bin/bash</span> <span class="string">-c</span> <span class="string">'</span></span><br><span class="line"><span class="string">      sleep 5;</span></span><br><span class="line"><span class="string">      echo "sleep over";'</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure><p>可以注意到，为了证明<code>city_service</code>服务不会等待<code>redis_server</code>服务，我故意让子弹飞了一会儿，结果如何呢？我们一起来看看：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/BqDRtbJkpVcno3s.png" alt="Docker Compose 启动顺序：一厢情愿" referrerpolicy="no-referrer"></div><div class="image-caption">Docker Compose 启动顺序：一厢情愿</div></figure><p>果然，我没有骗各位，<code>city_service</code>服务不会等待<code>redis_server</code>服务。我们知道，<code>Redis</code>提供的命令行接口中，有一个<code>PING</code>命令，当<code>Redis</code>可以正常连接的时候，它会返回一个<code>PONG</code>，也许，这就是乒乓球的魅力所在。基于这个想法，我们继续修改<code>docker-compose.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&gt;</span></span><br><span class="line">      <span class="string">/bin/bash</span> <span class="string">-c</span> <span class="string">'</span></span><br><span class="line"><span class="string">      while ! nc -z redis_server 6379;</span></span><br><span class="line"><span class="string">      do</span></span><br><span class="line"><span class="string">        echo "wait for redis_server";</span></span><br><span class="line"><span class="string">        sleep 1;</span></span><br><span class="line"><span class="string">      done;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      echo "redis_server is ready!";</span></span><br><span class="line"><span class="string">      echo "start city_service here";</span></span><br><span class="line"><span class="string">      '</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure><p>这里，我们用了一种取巧的方法，<code>Ubuntu</code>中的<code>nc</code>命令可以对指定主机、指定端口进行检测，换言之，我们简单粗暴的认为，只要<code>6379</code>这个端口可以访问，就认为<code>Redis</code>准备就绪啦，因为我们没有办法在<code>city_service</code>这个容器中调用<code>redis-cli</code>，这个做法本身并不严谨，我们这里更多的是验证想法：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/Hhx4R7obZL5FBrv.png" alt="Docker Compose 启动顺序：检测 Redis" referrerpolicy="no-referrer"></div><div class="image-caption">Docker Compose 启动顺序：检测 Redis</div></figure><p>可以注意到，此时，<code>city_service</code>服务会等待<code>redis_server</code>服务，直到<code>redis_server</code>服务就绪。所以，要解决服务编排时，容器的启动顺序的问题，本质上就是把需要等待的服务、端口以及当前服务的启动命令，统一到容器的入口中。为此，官方提供了 <a href="https://github.com/vishnubob/wait-for-it" target="_blank" rel="noopener">wait-for-it</a> 这个方案，官方关于容器启动顺序的文档，可以参考：<a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">Startup Order</a>。对于上面的例子，我们可以这样改写<code>docker-compose.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/wait-for-it.sh",</span> <span class="string">"redis_server:6379"</span><span class="string">,</span> <span class="string">"--"</span><span class="string">,</span> <span class="string">"dotnet"</span><span class="string">,</span> <span class="string">"CityService.dll"</span><span class="string">]</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure><p>此时，启动容器时的效果如下，因为这个方案依赖 <a href="http://netcat.sourceforge.net/" target="_blank" rel="noopener">Netcat</a> 这样一个工具，所以，我们的容器中还需要加入这个工具，此时，可以使用下面的脚本片段：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:buster-slim as wait-for-it</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y <span class="string">"wait-for-it"</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=<span class="built_in">wait</span>-for-it /usr/bin/<span class="built_in">wait</span>-for-it .</span></span><br></pre></td></tr></table></figure><p>不过，不太明白为什么这里一直提示路径不对：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/16/jgbwuVHeJNvG5BY.png" alt="Docker Compose 启动顺序：wait-for-it.sh" referrerpolicy="no-referrer"></div><div class="image-caption">Docker Compose 启动顺序：wait-for-it.sh</div></figure><p>个人建议，最好将这个语句写在<code>Dockerfile</code>，或者试提供一个类似于<code>entrypoint.sh</code>的脚本文件。关于这个方案的更多细节，大家可以参考<a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">官方文档</a>，写这篇文章的时候，我不由得感慨：<code>Shell</code>脚本真的是太难学了(逃……。所以，点到为止。刚刚提到过，我个人觉得这种主机 + 端口号的检测方式不够严谨，因为一个端口可以<code>PING</code>通，并不代表服务一定是可用的，所以，在接下来的内容里，我会介绍基于健康检查的思路。</p><h1 id="容器的健康检查"><a href="#容器的健康检查" class="headerlink" title="容器的健康检查"></a>容器的健康检查</h1><p>不知道大家有没有这样的经历，就是你明明看到一个容器的状态变成<code>Up</code> ，可对应的微服务就是死活调不通。面对来自前端同事的戏谑与嘲讽，你不禁仰天长叹一声，开始在容器里翻箱倒柜，一通操作如虎。过了许久，你终于发现是容器内部出现了始料不及的错误。看来，容器状态显示为<code>Up</code>，并不代表容器内的服务就是可用的啊！果然，还是需要一种机制来判断容器内的服务是否可用啊！等等，这不就是传说中的健康检查？恭喜你，答对了！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/fplPBvICiEOYsKR.jpg" alt="Docker 经典集装箱形象" referrerpolicy="no-referrer"></div><div class="image-caption">Docker 经典集装箱形象</div></figure><p>在<code>Docker</code>及<code>Docker Compse</code>中，均原生支持 <a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="noopener">健康检查</a> 机制，一旦一个容器指定了<code>HEALTHCHECK</code>选项，<code>Docker</code>会定时检查容器内的服务是否可用。我们都知道，一个普通的 Docker 容器，无非是开始、运行中、停止这样三种状态，而提供了<code>HEALTHCHECK</code>选项的<code>Docker</code>容器，会在这个基础上增加健康(<strong>healthy</strong>)和非健康(<strong>unhealthy</strong>)两种状态，所以，我们应该用这两个状态来判断容器内的服务是否可用。下面是一个指定了<code>HEALTHCHECK</code>选项的容器示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="number">3.1</span>-buster-slim</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /app/publish .</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"dotnet"</span>, <span class="string">"CityService.dll"</span>]</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5s --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD curl -fs http://localhost:80/city || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>可以注意到，<code>Docker</code>原生的健康机制，需要通过<code>CMD</code>的方式来执行一个命令行，如果该命令行返回 0 ，则表示成功；返回 1，则表示失败。</p><p>此处，我们还可以配置以下三个参数，<code>--interval=&lt;间隔&gt;</code>表示健康检查的间隔，默认为 30 秒；<code>--timeout=&lt;时长&gt;</code>表示健康检查命令超时时间，超过该时间即表示<code>unhealthy</code>，默认为 30 秒；<code>--retries=&lt;次数&gt;</code>表示连续失败的次数，超过该次数即表示<code>unhealthy</code>。对于我们这里的<code>ASP.NET Core</code>应用而言，如果程序正常启动，显然这个地址是可以调通的，我们可以用这个来作为一个“探针”。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/14/QnuPZ8vsCYKbVHm.png" alt="Docker 健康检查：healthy" referrerpolicy="no-referrer"></div><div class="image-caption">Docker 健康检查：healthy</div></figure><p>我们可以注意到，在容器启动的第 14 秒，其状态为：<code>health：starting</code>。而等到容器启动的第 16 秒，其状态则为：<code>healthy</code>，这表明我们的服务是健康的。此时此刻，如果我们耍点小心思，让<code>curl</code>去访问一个不存在的地址会怎么样呢？可以注意到，此时状态变成了：<code>unhealthy</code>:</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/14/oNtX8G7UAqEDIzS.png" alt="Docker 健康检查：unhealthy" referrerpolicy="no-referrer"></div><div class="image-caption">Docker 健康检查：unhealthy</div></figure><p><code>HEALTHCHECK</code>指令除了可以直接写在<code>Dockerfile</code>中以外，还可以直接附加到<code>docker run</code>命令上，还是以上面的项目作为示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run  --name city_service -d -p 8081:80  city_service \</span><br><span class="line">--health-cmd="curl -fs http://localhost:80/city || exit 1" \</span><br><span class="line">--health-interval=3s \</span><br><span class="line">--health-timeout=5s \</span><br><span class="line">--health-retries=3</span><br></pre></td></tr></table></figure><p>甚至，我们还可以使用下面的命令来查询容器的健康状态：<code>docker inspect --format=&#39;&#39; &lt;ContainerID&gt;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Status"</span>: <span class="string">"unhealthy"</span>,</span><br><span class="line">  <span class="attr">"FailingStreak"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"Log"</span>: [&#123;</span><br><span class="line"><span class="attr">"Start"</span>: <span class="string">"2021-08-14T15:27:50.3325424Z"</span>,</span><br><span class="line"><span class="attr">"End"</span>: <span class="string">"2021-08-14T15:27:50.3813102Z"</span>,</span><br><span class="line"><span class="attr">"ExitCode"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"Output"</span>: <span class="string">""</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我个人感觉这个<code>curl</code>的写法非常别扭，尤其是当我试图在<code>docker-compose</code>中写类似命令的时候，我觉得稍微复杂一点的健康检查，还是交给脚本语言来实现吧！例如，下面是官方提供的针对<code>MongoDB</code>的健康检查的脚本<code>docker-healthcheck.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -eo pipefail </span><br><span class="line">host="$(hostname --ip-address || echo '127.0.0.1')" </span><br><span class="line">if mongo --quiet "$host/test" --eval 'quit(db.runCommand(&#123; ping: 1 &#125;).ok ? 0 : 2)'; then </span><br><span class="line">   exit 0</span><br><span class="line">fi </span><br><span class="line">   exit 1</span><br></pre></td></tr></table></figure><p>此时，<code>HEALTHCHECK</code>可以简化为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5s --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD bin/bash docker-healthcheck.sh</span></span><br></pre></td></tr></table></figure><p>更多的示例，请参考：<a href="https://github.com/docker-library/healthcheck/" target="_blank" rel="noopener">docker-library/healthcheck/</a> 以及 <a href="https://github.com/rodrigobdz/docker-compose-healthchecks" target="_blank" rel="noopener">rodrigobdz/docker-compose-healthchecks</a>。</p><p>其实，对于容器的启动顺序问题，我们还可以借助检查检查的思路来解决，因为<code>depends_on</code>并不会等待目标容器进入<code>ready</code>状态，而是等目标容器进入<code>running</code>状态。这样，就回到了我们一开始描述的现象：一个容器明明都变为<code>Up</code>状态了，可为什么接口就是死活调不通呢？因为我们无法界定这样一个<code>ready</code>状态。考虑到<code>depends_on</code>可以指定<code>condition</code>，此时，我们可以这样编写<code>docker-compose.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="string">["CMD",</span> <span class="string">"redis-cli"</span><span class="string">,</span> <span class="string">"ping"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">redis_server:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure><p>简单来说，我们使用了<code>Redis</code>内置的命令对<code>redis_server</code>服务进行健康检查，而<code>city_service</code>服务则依赖于<code>redis_server</code>服务的健康状态，只有当<code>Redis</code>准备就绪了以后，<code>city_service</code>才会开始启动。下面是实际启动过程的截图，看看是不是和我们想的一样：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/15/HKvjmoCdznlW6FV.png" alt="Docker 健康检查：容器启动顺序" referrerpolicy="no-referrer"></div><div class="image-caption">Docker 健康检查：容器启动顺序</div></figure><p>果然，奇怪的知识有增加了呢，我们唯一需要解决的问题，就是怎么给某一个服务做健康检查，以上！</p><h1 id="容器的网络模式"><a href="#容器的网络模式" class="headerlink" title="容器的网络模式"></a>容器的网络模式</h1><p>接下来，我们来说说<code>Docker</code>里的网络模式，特别是当我们使用<code>docker-compose</code>来编排一组服务的时候，假设我们有一个目录<code>app</code>，在这个牡蛎里我们放置了服务编排文件<code>docker-compose.yml</code>，默认情况下，<code>Docker-Compose</code>会创建一个一个名为<code>app_default</code>的网络，并且这个网络是<code>bridge</code>，即网桥模式的一个网络。什么是网桥模式呢？你可能会感到困惑，而这要从<code>Docker</code>中的网络模式开始说起，这里简单下常用的几种：</p><ul><li>host 模式，或叫做主机模式，可以认为容器和主机使用相同的端口进行访问，因为容器和主机在同一个网络下，此模式下，意味着通过<code>-p</code>绑定的端口失效，因为所有容器都使用主机的网络，所以容器间可以相互通信，此模式通过<code>--network=host</code>指定。</li><li>bridge 模式，或叫做网桥模式，这是<code>Docker</code>中默认的网络设置，此模式下，容器和主机有各自的 IP/端口号，两者之间通过一个虚拟网桥进行通信，虚拟网桥的作用类似于物理交换机。因此，不同容器间的网络是相互隔离的，此模式通过<code>--network=bridge</code>指定。</li><li>none 模式，通俗讲就是无网络模式，意味着容器是一个封闭的环境，无法通过主机访问外部的网络，这种模式在那种讲究保密性质、封闭式开发的场合应该会有一点用，可这都 2021 年了，难道你还能把互联网上的软件全部下载下来吗？此模式通过<code>--network=none</code>指定。</li><li>container 模式，或叫做共享模式，通俗来讲，就是指一个容器共享某个已经存在的容器的<code>Network Namespace</code>，此时，该容器将不会拥有属于自己的 IP/端口号等资源，因为这种模式可以节约一定的网络资源，此模式通过<code>--network=&lt;Container_ID&gt;/&lt;Container_Name&gt;</code>指定。</li></ul><p>为了帮助大家理解和区分这四种模式，博主绘制了下面的图示来补充说明：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/16/DJq3CBrmktaRNex.png" alt="容器的网络模式(主机、容器、网桥)示意图" referrerpolicy="no-referrer"></div><div class="image-caption">容器的网络模式(主机、容器、网桥)示意图</div></figure><p>通过以上的图文信息反复加深印象，相信大家可以找出点规律：</p><ul><li>如果你的容器网络与主机网络不需要隔离，那么选择主机模式(<strong>host</strong>)</li><li>如果你的应用运行在不同的容器里，并且这些容器间需要相互通信，那么选择网桥模式(<strong>bridge</strong>)</li><li>如果你的应用需要运行在一个隔绝外界网络的环境中，那么选择无网络模式(<strong>none</strong>)</li><li>如果你希望在节省网络资源的同时，实现不同容器间的通信，那么选择容器模式(<strong>container</strong>)</li></ul><p>以上四种网络模式，除了可以在<code>docker run</code>的时候指定以外，我们还可以在<code>docker-compose.yml</code>文件中指定。例如，下面表示的是一个主机模式的容器：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.8'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">cache_server:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cache_server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure><p>大多数情况下，我们只需要连接到<code>docker0</code>这个虚拟网卡即可，而如果你想为某个容器或者一组容器单独建立这样一张网卡，此时，就不得不提到<code>Docker</code>中的自定义网络功能，我们一起来看下面的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个网络：test-network</span><br><span class="line">docker network create test-network</span><br><span class="line">// 创建一个Nginx的容器：nginx_8087，使用网络：test-network</span><br><span class="line">docker run -d --name nginx_8087 --network test-network -p 8087:80 nginx:latest</span><br><span class="line">// 创建一个Nginx的容器：nginx_8088</span><br><span class="line">docker run -d --name nginx_8088 -p 8088:80 nginx:latest</span><br><span class="line">// 连接容器：nginx_8088 至网络：test-network</span><br><span class="line">docker network connect test-network nginx_8088</span><br></pre></td></tr></table></figure><p>接下来，通过下面的命令，我们可以拿到两个容器的 ID，在此基础上我们看一下两个容器各自分配的 IP 是多少：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' &lt;ContainerID&gt;</span><br></pre></td></tr></table></figure><p>此时，我们会发现一个有趣的现象，<code>nginx_8087</code>这个容器，可以获得 IP 地址<code>172.17.0.2</code>，而<code>nginx_8088</code>则无法获得 IP 地址，这是为什么呢？这其实就是我们前面提到过的容器模式(<strong>container</strong>)，此时，<code>nginx_8088</code>这个容器实际上是和<code>nginx_8087</code>共享一个<code>Network Namespace</code>，即使它们有各自的文件系统。同样地，我们可以使用下面的命令来让容器从某个网络中断开：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 断开容器：nginx_8088 至网络：test-network</span><br><span class="line">docker network disconnect test-network nginx_8088</span><br><span class="line">// 删除网络</span><br><span class="line">docker network rm test-network</span><br></pre></td></tr></table></figure><p>是否觉得手动维护容器的网络非常痛苦？幸好，我们还有<code>Docker-Compose</code>可以用，上面两个<code>Nginx</code>的容器我们可以这样维护：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx_8087:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8087</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8087</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">  <span class="attr">nginx_8088:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8088</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8088</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">test-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>此时，我们可以注意到，<code>Docker Compose</code>会创建两个网络，即<code>network_mode_default</code>和<code>network_mode_test-network</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/16/Sgsbpt1huUlmTQM.png" alt="Docker Compose 中使用自定义网络" referrerpolicy="no-referrer"></div><div class="image-caption">Docker Compose 中使用自定义网络</div></figure><p>这说明默认网络依然存在，如果我们希望完全地使用自定义网络，此时，我们可以这样修改服务编排文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure><p>这表示默认网络会采用主机模式，相应地，你需要修改<code>nginx_8087</code>和<code>nginx_8088</code>两个容器的<code>network</code>选项，使其指向<code>default</code>。</p><p>除此之外，你还可以使用<code>external</code>指向一个已经存在的网络：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">a-existing-network</span></span><br></pre></td></tr></table></figure><p>在<code>Docker</code>中，每个容器都会分配<code>IP</code>，因为这个<code>IP</code>总是不固定的，所以，如果我们希望像虚拟机那样使用一个静态<code>IP</code>的话，可以考虑下面的做法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx_8087:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8087</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8087</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">          <span class="attr">ipv4_address:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line">  <span class="attr">nginx_8088:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8088</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8088</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">          <span class="attr">ipv4_address:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">test-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure><p>关于<code>Docker</code>及<code>Docker Compose</code>中的网络驱动，如 <a href="https://docs.docker.com/network/macvlan/" target="_blank" rel="noopener">macvlan</a>、<a href="https://docs.docker.com/network/overlay/" target="_blank" rel="noopener">overlay</a> 等等，这些显然是更加深入的话题，考虑到篇幅，不在这里做进一步的展开，对此感兴趣的朋友可以参考官方文档：<a href="https://docs.docker.com/network/" target="_blank" rel="noopener">Networking Overview</a> 以及 <a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">Networking in Compose</a>。博主写这篇文章的想法，主要是源于团队内落地<code>Docker-Compose</code>时的一次经历，当时有台虚拟机偶尔会出现<code>IP</code>被篡改的情况，而罪魁祸首居然是<code>Docker-Compose</code>，虽然最终用主机模式勉强解决了这个问题，可终究留下了难以言说的疑问，此刻，大概能稍微对<code>Docker</code>的网络有点了解。果然，越靠近底层，就是越是抽象、越是难以理解。</p><h1 id="文本小结"><a href="#文本小结" class="headerlink" title="文本小结"></a>文本小结</h1><p>本文分享了<code>Docker</code>及<code>Docker-Compose</code>中的进阶使用技巧，主要探索了服务编排场景下容器的启动顺序、健康检查、网络模式三类问题。默认情况下，<code>Docker-Compose</code>的<code>depends_on</code>选项，取决于容器是否处于<code>running</code>状态，因此，当我们有多个服务需要启动时，实际上启动顺序并不会受到<code>depends_on</code>选项的影响，因为此时容器都是<code>running</code>的状态。为了解决这个问题，官方提供了 <a href="https://github.com/vishnubob/wait-for-it" target="_blank" rel="noopener">wait-for-it</a> 的方案，这是一种利用 <a href="http://netcat.sourceforge.net/" target="_blank" rel="noopener">Netcat</a> 对<code>TCP</code>和<code>UDP</code>进行检测的机制，当检测条件被满足的时候，它会执行由用户指定的启动脚本。从这里看，其实已经有了一点健康检查的影子，而官方的健康检查，则允许用户使用更加自由的命令或者脚本去实现检测逻辑，所以，从这个角度上来讲，<code>HEALTHCHECK</code>结合<code>depends_on</code>，这才是实现容器启动顺序控制的终极方案。<code>Docker</code>的网络是一个相对复杂的概念，所以，这里就是简单的介绍了下常见的四种网络模式，更深入的话题比如网络驱动等，还需要花时间去做进一步的探索。本文示例以上传至<a href="https://github.com/Regularly-Archive/2021/tree/master/src/DockerTips" target="_blank" rel="noopener">Github</a>，供大家参考。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Docker" scheme="https://qinyuanpei.github.io/tags/Docker/"/>
    
      <category term="容器" scheme="https://qinyuanpei.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="服务编排" scheme="https://qinyuanpei.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/"/>
    
      <category term="云原生" scheme="https://qinyuanpei.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core 搭载 Envoy 实现 gRPC 服务代理</title>
    <link href="https://qinyuanpei.github.io/posts/3942175942/"/>
    <id>https://qinyuanpei.github.io/posts/3942175942/</id>
    <published>2021-08-08T22:49:47.000Z</published>
    <updated>2022-03-07T01:40:22.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>在构建以 gRPC 为核心的微服务架构的过程中，博主曾经写过一篇名为 <a href="https://blog.yuanpei.me/posts/2167892202/" target="_blank" rel="noopener">ASP.NET Core gRPC 打通前端世界的尝试</a> 的文章，主要是希望打通 gRPC 和 前端这样两个异次元世界，因为无论我们构建出怎样高大上的微服务架构，最终落地的时候，我们还是要面对当下前后端分离的浪潮。所以，在那篇文章中，博主向大家介绍过 gRPC-Web 、gRPC-Gateway 、封装 API 、<a href="https://github.com/qinyuanpei/Grpc.Gateway" target="_blank" rel="noopener">编写中间件</a> 这样四种方案。我个人当时更喜欢编写中间件这种方案，甚至后来博主进一步实现了 gRPC 的 “扫描” 功能。</p><p>当时，博主曾模糊地提到过，Envoy 可以提供容器级别的某种实现，这主要是指 Envoy 独有的 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">gRPC-JSON Transcoder</a> 功能。考虑到 Envoy 是一个同时支持 HTTP/1.1 和 HTTP/2 的代理软件，所以，它天然地支持基于 HTTP/2 实现的 gRPC。所谓 gRPC-JSON Transcoder，其实指 Envoy 充当了 JSON 到 Protobuf 间互相转换的角色，而它利用的正是 Envoy 中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">过滤器</a> 这一重要组件。好了，在今天这篇文章中，博主就为大家介绍一下这种基于 Envoy 的方案，如果大家困惑于如何把 gRPC 提供给前端同事使用，不妨稍事休息、冲一杯卡布奇诺，一起来探索这广阔无垠的技术世界。</p><h1 id="从-Envoy-说起"><a href="#从-Envoy-说起" class="headerlink" title="从 Envoy 说起"></a>从 Envoy 说起</h1><p>开辟鸿蒙，始有天地。上帝说，要有光，于是，就有了光。而故事的起源，则要追溯到我们最早提出的那个问题：假设我们有下面的 gRPC 服务，我们能否让它像一个 JSON API 一样被调用？ 通过查阅 Protobuf 的 <a href="https://developers.google.cn/protocol-buffers/docs/proto3#json" target="_blank" rel="noopener">官方文档</a>，我们可以发现 Protobuf 与 JSON间存在着对应关系，这是两者可以相互转化的前提。博主在编写 <a href="https://hub.fastgit.org/qinyuanpei/Grpc.Gateway/blob/master/src/Grpc.Gateway/GrpcExtensions.cs" target="_blank" rel="noopener">中间件</a> 时，同样借助了 Protobuf 暴露出来的接口 <a href="https://developers.google.cn/protocol-buffers/docs/reference/csharp/class/google/protobuf/message-parser?hl=zh-cn" target="_blank" rel="noopener">MessageParser</a>：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> csharp_namespace = <span class="string">"GrpcService"</span>;</span><br><span class="line"><span class="keyword">package</span> greet;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来，这个 gPRC 服务如何和 Envoy 这个代理服务器产生关联呢？首当其冲的自然是一个路由啦：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">"/greet"</span></span><br><span class="line">  <span class="attr">route:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">grpc_service</span></span><br><span class="line">    <span class="attr">timeout:</span> </span><br><span class="line">      <span class="attr">seconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><p>这表示以 <code>/greet</code> 开头的请求会被路由到 <code>grpc_service</code> 这个集群，如果按照一般的 Envoy 使用流程，接下来，我们只需要配置对应的集群节点即可。我们前面提到过，Envoy 的这个 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">gRPC-JSON Transcoder</a> 功能，是通过过滤器来实现的，更确切地说，它是一个 HTTP 级别的过滤器，所以，我们继续耐心往下看：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http_filters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.grpc_json_transcoder</span></span><br><span class="line">  <span class="attr">typed_config:</span></span><br><span class="line">    <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder</span></span><br><span class="line">    <span class="attr">proto_descriptor:</span> <span class="string">"/etc/descriptor/greet.pb"</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"greet.Greeter"</span></span><br><span class="line">    <span class="attr">print_options:</span></span><br><span class="line">      <span class="attr">add_whitespace:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">always_print_primitive_fields:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">always_print_enums_as_ints:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">preserve_proto_field_names:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">auto_mapping:</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure><p>可以注意到，这里使用了一个叫做 <code>envoy.filters.http.grpc_json_transcoder</code> 的过滤器。对于这个过滤器而言，核心的、需要注意的地方有两个：</p><ul><li><code>proto_descriptor</code> 指向一个 Protobuf 的描述文件，这是一个二进制文件，可以由<code>protoc</code>编译器生成。</li><li><code>services</code> 表示一组服务，必须按照 <code>包名.服务名</code> 的格式进行填写，这里的示例为：<code>greet.Greeter</code>。</li></ul><p>关于如何生成二进制的 Protobuf 描述文件，我们专门放在下一节来讲，在此基础上，我们只要增加集群即可完成 Envoy 的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc_service</span></span><br><span class="line">  <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LOGICAL_DNS</span></span><br><span class="line">  <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="attr">dns_lookup_family:</span> <span class="string">V4_ONLY</span></span><br><span class="line">  <span class="attr">http2_protocol_options:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">upstream_connection_options:</span></span><br><span class="line">    <span class="attr">tcp_keepalive:</span></span><br><span class="line">      <span class="attr">keepalive_time:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">load_assignment:</span></span><br><span class="line">    <span class="attr">cluster_name:</span> <span class="string">grpc_service</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">grpc_service</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>完整的 Envoy 配置文件，请参考 <a href="https://github.com/Regularly-Archive/2021/tree/master/src/EnvoyGrpc" target="_blank" rel="noopener">这里</a>，不再占用篇幅进行说明。</p><h1 id="准备描述文件"><a href="#准备描述文件" class="headerlink" title="准备描述文件"></a>准备描述文件</h1><p>生成 Protobuf 的二进制描述文件，需要借助 <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">protoc</a> 这个命令行工具，此前我们介绍 gRPC 生态中的 gRPC-Web、gRPC-Gateway 时曾经接触过它。Envoy 正是通过这个描述文件来处理 <code>JSON</code> 和 <code>Protobuf</code> 的相互转换，博主猜测这里可能用到了类似 <a href="https://developers.google.cn/protocol-buffers/docs/reference/csharp/class/google/protobuf/message-parser?hl=zh-cn" target="_blank" rel="noopener">MessageParser</a> 的东西，Envoy 从这个二进制的描述文件中获取 gRPC 的元数据信息，并由此从 <code>JSON</code> 构建出 <code>Protobuf</code>。这里，我们还是以本文开始的 <code>.proto</code>文件为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --descriptor_set_out=./Protos/descriptor/greet.pb --include_imports Protos\greet.proto</span><br></pre></td></tr></table></figure><p>这条命令行的含义是，为 <code>Protos\greet.proto</code> 生成对应的服务描述文件 <code>/Protos/descriptor/greet.pb</code>。下图即为博主生成的服务描述文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/08/lhPofJFKytHGWja.png" alt="通过命令行生成 Protobuf 描述文件" referrerpolicy="no-referrer"></div><div class="image-caption">通过命令行生成 Protobuf 描述文件</div></figure><p>此时，我们只需要将其放到 Envoy 的目录中即可，本文中的示例位于以下路径：<code>/etc/descriptor/greet.pb</code>。好了，现在 Envoy 和 gRPC 均已就绪，我们通过 <code>docker-compose</code> 对服务进行编排：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoygateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9090:9090"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9091:9091"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">grpcservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">GrpcService/GrpcService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8082:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br></pre></td></tr></table></figure><p>启动服务后，如果我们像调用 gRPC 服务中的 <code>SayHello()</code>方法，此时，对应的路由为：<code>/greet.Greeter/SayHello</code>，即：<code>包名.服务名/方法名</code>。好了，我们用 Postman 或者 Apifox 对接口进行测试：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/08/RZpux1nwWDh6eJK.png" alt="像调用一个 JSON API 一样调用 gRPC" referrerpolicy="no-referrer"></div><div class="image-caption">像调用一个 JSON API 一样调用 gRPC</div></figure><p>至此，我们实现一开始的目的，通过 Envoy 代理 gRPC 服务以后，对于前端而言，它已不再关心，这个服务背后的服务提供者到底是什么？因为对它而言，JSON API 还是 Protobuf 已经完全没有差别。博主曾经评价它是容器级别的方案，因为它可以将多个 gRPC 服务统一到一个入口中，非常适合充当整个微服务的网关，如果你正在使用 gRPC，相信我，这会是一条必由之路。</p><p>目前，博主所在的公司，已经全面采用了这种方案，而博主则进一步在团队中推广了<code>Docker-Compose</code>，换言之，我们将多个微服务通过<code>Docker-Compose</code>进行编排，并通过 Envoy 为所有微服务提供统一入口，唯一的遗憾是，通过<code>protoc</code>生成服务描述文件这个过程没有纳入到 CI/CD 环节，靠手动生成、复制服务描述文件，到底还是会有点失落呢？如果结合前面分享过的 <a href="https://blog.yuanpei.me/posts/731808750/" target="_blank" rel="noopener">Envoy 身份认证</a>，整个微服务架构终于看起来形成闭环啦！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分享了 Envoy 中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter" target="_blank" rel="noopener">gRPC-JSON Transcoder</a> 功能，它可以将一个 gRPC 服务代理成一个 JSON API，从而方便前端或者是客户端去消费一个 gRPC 服务。其原理是，Envoy 中可以通过配置过滤器来实现 JSON 和 Protobuf 的相互转换，这一过程依赖 Protobuf 的元数据，故而，我们需要通过命令行工具<code>protoc</code>生成服务描述文件，我们只需要在 Envoy 中添加相关配置，就可以像调用一个 JSON API 一样调用 gRPC。至此， gRPC 与 Web 世界彻底打通，我们可以用我们熟悉的技术去消费一个 gRPC 服务。博主的 <a href="https://github.com/qinyuanpei/Grpc.Gateway" target="_blank" rel="noopener">Grpc.Gateway</a> 实现了类似的功能，如果大家感兴趣，欢迎大家前去体验一番。好了，以上就是这篇博客的全部内容啦，谢谢大家，祝各位晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Envoy" scheme="https://qinyuanpei.github.io/tags/Envoy/"/>
    
      <category term="RESTful" scheme="https://qinyuanpei.github.io/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>再话 AOP，从简化缓存操作说起</title>
    <link href="https://qinyuanpei.github.io/posts/2126762870/"/>
    <id>https://qinyuanpei.github.io/posts/2126762870/</id>
    <published>2021-08-04T20:49:47.000Z</published>
    <updated>2022-03-07T01:40:22.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>AOP，即：<strong>面向切面编程</strong>，关于这个概念，博主其实写过好几篇<a href="https://blog.yuanpei.me/tags/AOP/" target="_blank" rel="noopener">博客</a>啦！从这个概念，我们可以引申出诸如代理模式、动态代理、装饰器模式、过滤器、拦截器等等相互关联的概念。从实现方式上而言，微软官方的 <a href="https://docs.microsoft.com/zh-cn/previous-versions/dotnet/articles/ms973857(v=msdn.10)?redirectedfrom=MSDN" target="_blank" rel="noopener">.NET Remoting</a> 提供了真实代理和透明代理的支持，我们熟悉的 <code>WebService</code> 和 <code>WCF</code> 均和这项技术息息相关，作为最早的分布式 RPC 解决方案，其本身更是与客户端的动态代理密不可分。或许，各位曾经接触过 <code>Unity</code>、<code>Castle</code>、<code>AspectCore</code>、<a href="https://www.postsharp.net" target="_blank" rel="noopener">PostSharp</a> 等等这些支持 AOP 特性的库，那么，我们是否已经抵达了 AOP 的边界呢？事实上，如果你仔细研究过 <code>Stub</code> 和 <code>Mock</code> 这样两个术语，你就发现 AOP 的应用范围远比我们想象的宽广。今天这篇文章，我不打算再介绍一遍这些第三方库的“<strong>奇技淫巧</strong>”，我更想聊聊，如何通过 AOP 来简化一个缓存操作。</p><p>缓存，一个面试时命中率 100%的话题，曾记否？来自面试官的灵魂发问三连：<strong>缓存击穿</strong>、<strong>缓存穿透</strong>、<strong>缓存雪崩</strong>。与此同时，缓存是一个令人爱恨交加的东西，其一致性、持久化、高可用等等，均是实际应用中需要去考虑的东西。狭义的缓存主要指 <a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>、<a href="https://www.memcached.org" target="_blank" rel="noopener">Memcached</a> 等分布式缓存系统，而广义的缓存则可以是 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/response?view=aspnetcore-5.0" target="_blank" rel="noopener">HTTP 响应缓存</a>、EF/EF Core 查询缓存、二级缓存等等。我们都知道，使用缓存可以显著地提升软件性能，而究其本质，则是因为减少了和数据库交互的频次。于是，我们注意到，大多数的缓存代码，都是下面这样的风格：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheKey = <span class="string">"GetAllStudents"</span>;</span><br><span class="line"><span class="keyword">var</span> students = <span class="keyword">new</span> List&lt;Student&gt;();</span><br><span class="line"><span class="keyword">var</span> cacheValue = distributedCache.GetString(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(cacheValue))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 未命中缓存：从数据库查询数据 + 写缓存</span></span><br><span class="line">    students = repository.GetAll().ToList();</span><br><span class="line">    <span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(students));</span><br><span class="line">    distributedCache.Set(cacheKey, bytes);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 命中缓存：读缓存</span></span><br><span class="line">    students = JsonConvert.DeserializeObject&lt;List&lt;Student&gt;&gt;(cacheValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> students;</span><br></pre></td></tr></table></figure><p>正所谓：大道至简，“<strong>高端的食材，往往只需要最朴素的烹饪方式</strong>”。故而，最朴素的思想就是，首先从缓存中查询数据，如果数据存在则直接返回，否则从数据库中查询数据，并执行一次写缓存操作。这的确是个朴实无华的方案，因为我们每一次都要写这样的代码，其程度丝毫不亚于永远不会缺席的 <code>xxx != null</code>。写到这里，博主不由得陷入了沉思：难道真的没有更简单点的方案了吗？后来的故事大家都知道了，我们可以在方法的参数上附加 <code>[NotNull]</code> 特性。所以，接下来，我们会用类似的方案来解决缓存的问题，换言之，我们可以把我们经常写、写到不愿意再写的代码交给代理类来做，既然缓存本质上是为了查询数据，那我们就只需要关心查询数据这个行为本身。具体怎么实现的呢？我们一起来看下面的代码。</p><p>此时此刻，假设我们有这样一个接口：<code>IFakeService</code>，它通过<code>GetColors()</code>方法返回一组颜色：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFakeService</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Cacheable(CacheKeyPrefix = <span class="meta-string">"Fake"</span>, Expiration = 180)</span>]</span><br><span class="line">    <span class="function">List&lt;<span class="keyword">string</span>&gt; <span class="title">GetColors</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望，在调用这个方法的时候，可以对其返回值进行缓存，所以，可以注意到，这里添加了一个<code>[Cacheable]</code>的特性。其定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CacheableAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> CacheKeyPrefix &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Expiration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>CacheKeyPrefix</code>用于指定缓存键名前缀，<code>Expiration</code>用于指定缓存过期时间，单位为秒。接下来，博主通过<code>DispatchProxy</code>来实现动态代理，它可以视为<code>RealProxy</code>在后.NET 时代的替代品：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class CacheInterceptor&lt;TCacheService&gt; : DispatchProxy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> TCacheService _realObject =&gt; ServiceProvider.GetRequiredService&lt;TCacheService&gt;();</span><br><span class="line">    <span class="keyword">private</span> ICacheSerializer _cacheSerializer =&gt; ServiceProvider.GetRequiredService&lt;ICacheSerializer&gt;();</span><br><span class="line">    <span class="keyword">private</span> IDistributedCache _distributedCache =&gt; ServiceProvider.GetRequiredService&lt;IDistributedCache&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IServiceProvider ServiceProvider &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">object</span> <span class="title">Invoke</span>(<span class="params">MethodInfo targetMethod, <span class="keyword">object</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] cacheValue;</span><br><span class="line">        <span class="keyword">var</span> returnType = targetMethod.ReturnType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// void &amp;&amp; Task</span></span><br><span class="line">        <span class="keyword">if</span> (returnType == <span class="keyword">typeof</span>(<span class="keyword">void</span>) || returnType == <span class="keyword">typeof</span>(Task))</span><br><span class="line">            <span class="keyword">return</span> targetMethod.Invoke(_realObject, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">            returnType = targetMethod.ReturnType.GetGenericArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cacheableAttribute = targetMethod.GetCustomAttribute&lt;CacheableAttribute&gt;();</span><br><span class="line">        <span class="keyword">if</span> (cacheableAttribute != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> cacheKey = GetCacheKey(cacheableAttribute, targetMethod);</span><br><span class="line">            cacheValue = _distributedCache.Get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Task&lt;T&gt;</span></span><br><span class="line">                <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">                    <span class="keyword">return</span> Task.FromResult(_cacheSerializer.Deserialize(cacheValue, returnType));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _cacheSerializer.Deserialize(cacheValue, returnType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">dynamic</span> returnValue = targetMethod.Invoke(_realObject, args);</span><br><span class="line">            cacheValue = _cacheSerializer.Serialize(returnValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Task&lt;T&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">                cacheValue = _cacheSerializer.Serialize(returnValue.Result);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> cacheOptions = <span class="keyword">new</span> DistributedCacheEntryOptions() &#123; </span><br><span class="line">              AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(cacheableAttribute.Expiration) </span><br><span class="line">            &#125;;</span><br><span class="line">            _distributedCache.Set(cacheKey, cacheValue, cacheOptions);</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targetMethod.Invoke(_realObject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，最为关键的地方是<code>Invoke()</code>方法，它负责对被代理对象的方法进行拦截，这里的被代理对象，其实就是<code>_realObject</code>，即真实对象，因为，我们最终调用的，实际上是真实对象上对应的方法。因为<code>DispatchProxy</code>在创建代理对象时，要求这个代理基类，即这里的拦截器，必须要有一个无参的构造函数。所以，我们这里用属性注入的方式来注入<code>IServiceProvider</code>。说回这个方法，首先，我们会判断它的返回值类型是不是<code>void</code>或者<code>Task</code>，因为无返回值的方法本身就不需要缓存。接下来，我们会检查当前方法上是否附加了<code>[Cacheable]</code>特性，因为我们只需要处理有这个特性的方法。接下来，通过<code>GetCacheKey()</code>方法来生成一个唯一的键名，通过这个键名我们就可以在缓存中查询数据啦，该方法的实现细节如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">GetCacheKey</span>(<span class="params">CacheableAttribute cacheableAttribute, MethodInfo methodInfo</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> segments = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(cacheableAttribute.CacheKeyPrefix))</span><br><span class="line">        segments.Add(cacheableAttribute.CacheKeyPrefix);</span><br><span class="line"></span><br><span class="line">    segments.Add(methodInfo.DeclaringType.FullName.Replace(<span class="string">"."</span>, <span class="string">"_"</span>));</span><br><span class="line"></span><br><span class="line">    segments.Add(methodInfo.Name);</span><br><span class="line"></span><br><span class="line">    methodInfo.GetParameters().ToList().ForEach(x =&gt; segments.Add(x.Name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>.Join(<span class="string">"_"</span>, segments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于分布式缓存，博主这里使用的是微软提供的<code>IDistributedCache</code>这个接口，接下来的事情就变得朴实无华起来，因为它和我们一开始写的代码一脉相承，唯一的不同是，这里考虑了<code>Task&lt;T&gt;</code>这种异步的返回值类型，同时对序列化/反序列化进行了抽象，即这里注入的<code>ICacheSerializer</code>接口，注意到<code>IDistributedCache</code>接口的<code>Set()</code>方法需要传入一个<code>byte[]</code>，显然二进制的序列化方案如 <a href="https://developers.google.cn/protocol-buffers?hl=zh-cn" target="_blank" rel="noopener">Protobuf</a> 、<a href="https://msgpack.org/" target="_blank" rel="noopener">MessagePack</a> 会更加得心应手一点。所以，我们将这一层单独抽象出来。至此，我们已经完成了最核心的部分。</p><p>对于一开始的<code>IFakeService</code>，我们提供一个简单的实现，并通过让线程阻塞的方式来模拟一个耗时操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeService</span> : <span class="title">IFakeService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">string</span>&gt; <span class="title">GetColors</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Green"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入IFakeService、ICacheSerializer、IDistributedCache</span></span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddTransient&lt;IFakeService, FakeService&gt;();</span><br><span class="line">services.AddTransient&lt;ICacheSerializer, JsonCacheSerializer&gt;();</span><br><span class="line">services.AddStackExchangeRedisCache(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Configuration = <span class="string">"localhost:6379"</span>;</span><br><span class="line">    options.InstanceName = <span class="string">"Caching.AOP.Test"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成代理对象</span></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> fakeServiceProxy = DispatchProxy.Create&lt;IFakeService, CacheInterceptor&lt;IFakeService&gt;&gt;();</span><br><span class="line">(fakeServiceProxy <span class="keyword">as</span> CacheInterceptor&lt;IFakeService&gt;).ServiceProvider = serviceProvider;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代理对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> stopWatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">    stopWatch.Start();</span><br><span class="line">    <span class="keyword">var</span> colors = fakeServiceProxy.GetColors();</span><br><span class="line">    stopWatch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">$" <span class="subst">&#123;i&#125;</span> - Invoke GetColors used <span class="subst">&#123;stopWatch.Elapsed.TotalMilliseconds&#125;</span> ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果，可以注意到，第一次调用的时候，因为缓存不存在，调用的时间相对更长一点，而当缓存存在的时候，调用的时间会明显缩短。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/04/FdafGyS7zrl53W1.png" alt="有无缓存对调用时长的影响" referrerpolicy="no-referrer"></div><div class="image-caption">有无缓存对调用时长的影响</div></figure><p>虽然这个性能提升与缓存不无关系，可对于调用者来说，它完全不用关心缓存里有没有数据这件事情，它只需要像往常一样调用接口方法即可，这就是 AOP 之于缓存的意义所在，为了证明我没有说谎，我们可以看到 Redis 中对应的数据：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/08/04/wkAQGMRKr8xuol3.png" alt="Redis中对应的缓存数据" referrerpolicy="no-referrer"></div><div class="image-caption">Redis中对应的缓存数据</div></figure><p>需要说明的是，这个思路同样可以扩展到<code>Unity</code>、<code>Castle</code>、<code>AspectCore</code>、<a href="https://www.postsharp.net" target="_blank" rel="noopener">PostSharp</a> 这些第三方库，实现方式上大同小异，大家可以结合自己的业务场景做相应的调整。其实，从业务上抽离出通用组件、功能作为公共库或者下沉到框架中，是及其自然而然的一件事情。这里面最关键的问题是，基础组件或者框架相对于业务方的职责范围，因为如果基础组件或者框架做得太多，业务上往往难以定制或者扩展；而如果基础组件或者框架做得太少，业务上就要写大量的辅助代码。写这篇文章的原因是，我对于一个缓存方案设计上的疑问，业务上想要缓存一张表中的数据，至少需要写 20 行代码，在下觉得这简直太离谱了，更不用说，业务方还要关心这个缓存是否可用。有人说，一个合格的前任就应该像死了一样，那么，我是不是可以说，一个合格的中间件，就应该像它从来没有来过一样，你甚至都感觉不到它的存在，可事实上它总是无所不在。也许，这听起来有点科幻的色彩，可这的确是我期待的某种自洽的、优雅的设计思路。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分享了通过 AOP 来简化缓存操作的一种思路，考虑到常规的缓存代码写法，读/写缓存与业务代码严重耦合在一起，而博主心目中的缓存应该像水、电、煤气一样普普通通，你只需要告诉我哪些数据需要缓存，而无需关心这些数据怎么缓存。基于这样一种考虑，博主基于<code>DispatchProxy</code>实现了一个针对缓存的 AOP 方案，我们只需要在接口上打上<code>[Cachable]</code>标签，它会自动对方法的返回值进行缓存，从而简化我们平时使用缓存的流程。<a href="https://www.cnblogs.com/catcher1994" target="_blank" rel="noopener">Catcher Wong</a> 大佬在其缓存框架 <a href="https://www.cnblogs.com/catcher1994/p/10806607.html" target="_blank" rel="noopener">EasyCaching</a> 同样集成了这一特性，如果大家有类似的使用场景，可以直接使用这个<a href="https://github.com/dotnetcore/EasyCaching" target="_blank" rel="noopener">框架</a>。如果大家对此有更好的想法或者思路，欢迎大家在评论区留言，本文示例已上传至 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/Caching.AOP" target="_blank" rel="noopener">Github</a>，供大家学习或者参考。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="AOP" scheme="https://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="Redis" scheme="https://qinyuanpei.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="https://qinyuanpei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="动态代理" scheme="https://qinyuanpei.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>洗衣随想曲</title>
    <link href="https://qinyuanpei.github.io/posts/3938682696/"/>
    <id>https://qinyuanpei.github.io/posts/3938682696/</id>
    <published>2021-08-02T00:13:48.000Z</published>
    <updated>2022-03-07T01:40:22.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>对我而言，洗衣服是周末的例行活动，尤其是在炎热的夏天。也许，你会自顾自地说，衣服不必攒到周末去洗，如果你愿意下班后腾出一点时间。可人的惰性，正如在太阳底下会流汗一般寻常，如果我愿意，你也许会早一点看到，这些只在周末显得安静的文字。</p><p>换这部手机时，店家附赠了一只蓝牙音响，带着物尽其用的想法，先后用它来听网易云、听微信读书、听 TED。于是，在一刹那间，水龙头里的流水声、拧干衣服时的水花声、我脑海里的闪念的低吟声，都成为这只麦克风的伴奏。我开始黯然失色，这听来听去，大概是在听寂寞在唱歌。果然，微信听书的效果并不好，那机械而平静的合成音，甚至还不如地铁上的播报充满感情。最为致命的问题，微信听书像极了听老师讲课：书读完了吗？读完了！还记得讲了什么吗？完全不记得！</p><p>现实生活可不像武侠世界，没有那么多无招胜有招的奇遇。所以，有一段时间，我总觉得用听书这种方式来读书，像极了姜太公钓鱼——愿者上钩。五柳先生，好读书而不求甚解，因为观其大略，而这连看都不愿意看一眼，简直就是自欺欺人。如此反复折磨自我，发现听演讲居然是最适合打发时间的方式，特别是洗衣服的这段时间。仔细一想，大概是演讲更能做到声情并茂，古人一桌、一椅、一扇、一抚尺，就能讲一个沉浸感十足的故事。而我们从文字到图片再到视频，仿佛都不足以表达自我。在百家争鸣的战国时代，不管是合纵/连横的策略，还是法、儒、墨、兵各家，我们能听见不同的声音，虽然表达方式不过是竹简。</p><p>可今天，我们好像陷入了一个信息黑洞，网络上的信息越来越嘈杂，原本代表着开放与连接的互联网，在一个又一个的小圈子里，正在走向越来越封闭的局面。譬如，喝茶与喝咖啡，从生物学上来讲这两个行为间并无差异，可人与人之间就是会形成所谓的鄙视链，甚至连咖啡本身都会形成这种鄙视链，手冲和速溶，本质上有什么不一样吗？圈子文化的盛行，让圈子本身更加封闭，隐形门槛的提高，让圈子外的人更加不能理解圈内人的行为，比如汉服与 JK，本质上不就是一件衣服吗？可人定要分出个山(寨)与正(品)的差别。人与人的关系，大致可以理解为相互炫耀、相互鄙视，而不同群体间的互相鄙视，其实加速了整个互联网的割裂，男女对立、饭圈文化……，无一不是这种割裂感的具体产物。</p><p>鲁迅先生写道，“<strong>人类的悲欢并不相通，我只是觉得他们吵闹</strong>”。人类想要互相理解彼此，除了感同身受以外，大概只有放下强烈的个人意识这一条路。可做一个精致的利己主义者，又有什么不好吗？只要我们不因为远方的声音让这个世界频频陷入大火，自私一点又有什么关系呢？罗曼蒂克不会消亡，只是我们对罗曼蒂克的要求变得越来越高。翻开历史，人类几千年的文明，一样是在这种割裂和封闭的状态下延续着，梁武帝从信佛到灭佛，汉武帝罢黜百家独尊儒术，商鞅因法而兴由法而灭……儒家与道家尚不能共治，巴基斯坦和印度更是势如水火……人们推倒了篱墙，再重新筑起篱墙，周而复始，反反复复。我由衷地想念那个百家争鸣的时代，人们有耻食周栗的觉悟、有伯牙绝弦的深情、有横槊赋诗的豪情……古人寿命不及我们、生活不如我们，可这几千年的精神世界，都是他们留给我们的。</p><p>不同于被生活磨去棱角的年轻人，一开口就是房子、车子和孩子。要知道，子在过去可是一种敬词，孔孟不必多说，老庄无须多言，前有张子连横六国，后有苏子遨游赤壁，这是否意味着，古人的精神世界远比我们丰富，毕竟我们都太枯燥了。有时候，我在地铁上看到别人面无表情地刷着抖音，如果说圈子本身让我们变得狭隘，那么信息茧房无疑会让我们变得愚蠢。你说，这个地球是不是变得越来越小，可明明我们还没有走过所有地方，不曾见过亚马逊的热带雨林，不曾见过极地的奇幻光影，不曾见过东非的荒漠草原……我们实在太容易相信那就是全部了，因为别人都这样过每一天，因为随大流不需要花时间思考什么，因为只此一次的生命实在过于短暂……越来越觉得，结婚就是用高昂的沉没成本，来阻止人们试错，每一步都走得小心翼翼的人，步步生莲，莲是三寸金莲的莲，虽然我们有耐克、有鸿星尔克、有美特斯邦威。</p><p>我喜欢逛西安这座城市的书店，因为传统书店愈发没落的今天，它需要找到一种物质和精神上的平衡，可人何尝又不是这样？每当我漫步在不同的商场，我忽然觉得，我们只是以为自己有那么多的选择，越来越多的餐饮像是流水线一般，我们寻找的那份属于自己的独特，早已在机器的转动声中消失殆尽。于是，人们开始复兴手工制作，越来越多的商家，开始在招牌上加上手工的字样。也许，现代和传统就是这样两个相互鄙视的圈子，它们互相鄙视，而又反复横跳。其实，单以甜点而论，我更喜欢中式的点心，大概是因为那些西式点心的名称，说起来要更绕口一点。泡芙、圣代、提拉米苏……像极了你学英语时的样子，每一个单词都认识，放到一起简直不知所云。以前，我在挑选饮料方面选择困难，因为总是记不住那些眼花缭乱的名字，后来手机里装了大众点评，忽然发现，每家商场里的店铺都差不多呢，这大概是一种进步，因为你没有选择。</p><p>当年我有一位高中同学，特别喜欢郭德纲的相声，报菜名、说绕口令的技艺相当纯熟，毕业后留在苏州的学而思，据说是变成了一名老师。近来教育培训行业政策有变动，不知道他是否还有心情饶舌一番。说回听书这件小事，那时，听一位作家讲金庸先生的越女剑，联想到武侠的没落，大概有几分道理可言。为什么漫威的超级英雄在这个时代更受欢迎，因为超级英雄们获得能的方式更现代化一点，无论是神话、科技、变异，这都是我们这个时代可以理解的东西，所以，我们能接受通过蛛丝发射器飞檐走壁的蜘蛛侠，唯独接受不了同样靠轻功飞檐走壁的大侠们。因为，没有人能说得清武功的来源。在一个武术成为观赏性项目的时代，我们对武功的理解，不会比神话时代好多少，我们都听过卧薪尝胆的故事，听过博浪飞锥的故事，听过图穷匕首的故事……如果世上真的有武功，大概就像我们认为的战争，对于没有亲身经历的人而言，永远都只能活在想象里，那么，武侠的起源到底从哪里开始呢？</p><p>在 B 站看到 30 多年前的西安，隐隐约约可以认出永宁门、大雁塔和钟楼，弹幕里有人打出无人机的字眼，原来，航拍这个词的含义已经等同于无人机，不管那个时候有没有无人机。同样地，现在的小孩会问，怎么通过座机打电话，我会不由得想起初/高中住校那几年，和家里联络基本都是靠座机。后来，我们有了直板手机、智能手机，再不必担心两百条短信会用完，再不必掐着时间给家里打电话，可再没有那样愿意陪你发短信的人，一个月下来甚至都打不了几个电话，流量从 5 块钱 30 兆一直涨到几十块钱，可对我来说，无非还是写写字、读读书，和过去相比并没有什么不同。人啊，总有些东西，在默默提醒着你：你在一天天地老去，永远都 18 岁，那比科幻电影还要科幻，除非你能从卷福手里拿到时间宝石。如果回到过去，你会如何和过去的自己谈判呢？我只知道，金庸先生穿越回吴越争霸的时代，他让阿青从白猿身上学到了武功。越王勾践卧薪尝胆、三千越甲吞吴的故事，父亲从小就同我讲过，可他也许不知道金庸先生的这个版本。</p><p>阿青被范蠡带入宫中，传授越国剑士精妙剑法，自此帮助越王勾践打败吴国、洗雪前耻，范蠡得以与情人西施重逢，可偏偏阿青喜欢上来了范蠡，没有人能阻挡阿青手中的竹棒，除了西施绝世的容貌，原来她比范蠡描述的还要美。虽然阿青放弃了寻仇，可棒头的内劲儿还是伤到了西施，自此西施落下来心口疼痛的毛病。这大概就是金庸先生心目中武功的缘起，范蠡西施放舟太湖、悠游终生，自此世上有了江湖，果然，这个说法像雷神之锤一样相当有说服力，“那些都是很好很好的，可是我偏偏不喜欢”，某种意义上来讲，功成身退的范蠡比张仪、韩信、商鞅要幸运得多，而这正是历史的迷人之处。什么？你问我衣服洗完了没有？当然洗完了！因为这些闪念，对于一个双子座而言，就像穿衣吃饭一般寻常，唯一的困难在于，我要将它写出来、同时让你看懂，以上！果然是标准的日式结尾呢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://qinyuanpei.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="https://qinyuanpei.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core 搭载 Envoy 实现微服务身份认证(JWT)</title>
    <link href="https://qinyuanpei.github.io/posts/731808750/"/>
    <id>https://qinyuanpei.github.io/posts/731808750/</id>
    <published>2021-07-25T09:41:24.000Z</published>
    <updated>2022-03-07T01:40:22.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>在构建以 gRPC 为核心的微服务架构的过程中，得益于 Envoy 对 gRPC 的“<strong>一等公民</strong>”支持，我们可以在过滤器中对 gRPC 服务进行转码，进而可以像调用 Web API 一样去调用一个 gRPC 服务。通常情况下， RPC 会作为微服务间内部通信的信使，例如，Dubbo、Thrift、gRPC、WCF 等等更多是应用在对内通信上。所以，一旦我们通过 Envoy 将这些 gRPC 服务暴露出来，其性质就会从对内通信变为对外通信。我们知道，对内和对外的接口，无论是安全性还是规范性，都有着相当大的区别。博主从前的公司，对内的 WCF 接口，长年处于一种”<strong>裸奔</strong>“的状态，属于没有授权、没有认证、没有文档的“<strong>三无产品</strong>”。那么，当一个 gRPC 服务通过 Envoy 暴露出来以后，我们如何保证接口的安全性呢？这就是今天这篇博客的主题，即 Envoy 作为网关如何提供身份认证功能，在这里，我们特指通过JWT，即 Json Web Token 来对接口调用方进行身份认证。</p><h1 id="搭建-Keycloak"><a href="#搭建-Keycloak" class="headerlink" title="搭建 Keycloak"></a>搭建 Keycloak</h1><p>对于 <a href="https://jwt.io" target="_blank" rel="noopener">JWT</a> ，即 Json Web Token ，我想大家应该都非常熟悉了，它是目前最流行的跨域认证解决方案。考虑到，传统的 Session 机制，在面对集群环境时，扩展性方面表现不佳。在日益服务化、集群化的今天，这种无状态的、轻量级的认证方案，自然越来越受到人们的青睐。在 ASP.NET Core 中整合JWT非常简单，因为有各种第三方库可以帮助你生成令牌，你唯一需要做的就是配置授权/认证中间件，它可以帮你完成令牌校验这个环节的工作。除此以外，你还可以选择更重量级的 <a href="https://identityserver4.readthedocs.io/en/latest/" target="_blank" rel="noopener">Identity Server 4</a>，它提供了更加完整的身份认证解决方案。在今天这篇博客里，我们使用的 <a href="https://www.keycloak.org" target="_blank" rel="noopener">Keycloak</a>，一个类似 Identity Server 4 的产品，它提供了一个更加友好的用户界面，可以更加方便的管理诸如客户端、用户、角色等等信息。其实，如果从头开始写不是不可以，可惜博主一时间无法实现 <a href="https://auth0.com/docs/tokens/json-web-tokens/json-web-key-sets" target="_blank" rel="noopener">JWKS</a>，所以，就请大家原谅在下拾人牙慧，关于 JWKS ，我们会在下一节进行揭晓。接触微服务以来，在做技术选型时，博主的一个关注点是，这个方案是否支持容器化。所以，在这一点上，显然是 Keycloak 略胜一筹，为了安装 Ketcloak ，我们准备了如下的服务编排文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">keycloak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/keycloak/keycloak:14.0.0</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KEYCLOAK_USER:</span> <span class="string">$&#123;KEYCLOAK_USER&#125;</span></span><br><span class="line">      <span class="attr">KEYCLOAK_PASSWORD:</span> <span class="string">$&#123;KEYCLOAK_PASS&#125;</span></span><br><span class="line">      <span class="attr">DB_VENDOR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_ADDR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_DATABASE:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">DB_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"7070:8080"</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br></pre></td></tr></table></figure><p>其中，<code>.env</code>文件放置了服务编排文件中使用到的环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># KEYCLOAK</span><br><span class="line">KEYCLOAK_USER&#x3D;admin</span><br><span class="line">KEYCLOAK_PASS&#x3D;admin</span><br><span class="line"># POSTGRESQL</span><br><span class="line">POSTGRESQL_DB&#x3D;keycloak</span><br><span class="line">POSTGRESQL_USER&#x3D;keycloak</span><br><span class="line">POSTGRESQL_PASS&#x3D;keycloak</span><br></pre></td></tr></table></figure><p>此时，我们运行<code>docker compose up</code>命令就可以得到一个 Keycloak 环境，它将作为我们整个微服务里的认证中心，负责对用户、角色、权限、客户端等进行管理。于此同时，接口消费方可以通过 Keycloak 获取令牌、JWKS，而 Envoy 正是利用 JWKS 来对令牌进行校验的。这个 JWKS 到底是何方神圣，我们暂且按下不表。在正式使用 Keycloak 前，我们需要做一点简单的配置工作，具体来说，就是指创建用户、角色和客户端，我们一起来看一下。</p><p>首先，是创建一个用户，这里以《天龙八部》中壮志未酬的“<strong>慕容龙城</strong>”为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/U9Pm3HFLn1y6dYB.png" alt="Keycloak 创建用户" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 创建用户</div></figure><p>《天龙八部》中提到，“<strong>慕容龙城</strong>”一心想光复大燕，可惜时不我与，正好遇上宋太祖建立宋朝，即使他创造出“<strong>斗转星移</strong>”的武功绝学，依然免不了郁郁而终的结局。慕容龙城算是第一代创业者，我们准备一个<code>Developer</code>的角色：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/H8xy3BYDz1XmWf9.png" alt="Keycloak 创建角色" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 创建角色</div></figure><p>在权限系统的设计中，角色总是需要和用户关联在一起。同样地，在 Keycloak 中，我们需要给“<strong>慕容龙城</strong>”分配一个<code>Developer</code>的角色：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/ZDui9X3weq5NMs8.png" alt="Keycloak 分配角色" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 分配角色</div></figure><p>到了“<strong>慕容复</strong>”这一代，“<strong>慕容垂</strong>”假借死亡之名秘密活动，而活跃在台前的“<strong>慕容复</strong>”，实际上是作为慕容家族的“<strong>代理人</strong>”出现。在今天这篇文章中，Envoy 会充当认证服务的代理，因为我们希望 Envoy 可以对所有进站的 API 请求进行统一的认证。所以，这里，我们还需要创建一个客户端：<code>envoy-client</code>，并为其分配客户端角色：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/MJC3dVkE7UxopyO.png" alt="Keycloak 创建客户端" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 创建客户端</div></figure><p>OK，我们都知道，<a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0</a> 有这样四种认证方式：密码模式、客户端模式、简化模式、授权码模式。这四种认证方式如何在 Keycloak 中实现呢？目前，博主基本搞清楚了前面两种。我们在创建完客户端以后，可以通过设置访问类型来决定客户端使用哪种认证方式，目前已知，当访问类型的取值为<code>public</code>时，表示密码模式。当访问类型的取值为<code>confidential</code>时，表示客户端模式。这里，我们以客户端模式为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/le5rstobVOh91m3.png" alt="Keycloak 客户端模式" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 客户端模式</div></figure><p>此时，我们就可以拿到一个重要的信息：<code>client_secret</code>，如果大家使用过客户端模式，就会知道它是获取令牌的重要参数之一。好了，当我们有了这些信息以后，该怎么样去获取令牌呢？我们只需要用 POST 的方式，将<code>grant_type</code>、<code>client_id</code>、<code>client_secret</code>、<code>username</code>、<code>password</code>、<code>scope</code>传过去即可：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/S5rgmZaGEqQkHUK.png" alt="从 Keycloak 获取令牌" referrerpolicy="no-referrer"></div><div class="image-caption">从 Keycloak 获取令牌</div></figure><p>如果需要刷新令牌，则只需要再追加一个<code>refresh_token</code>参数即可，它是我们第一次获取到的令牌：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/ukdNami5yMERWDc.png" alt="从 Keycloak 刷新令牌" referrerpolicy="no-referrer"></div><div class="image-caption">从 Keycloak 刷新令牌</div></figure><p>可能大家会疑惑，博主是从哪里知道这些 API 的端点地址的呢？其实，和 Identity Server 4 类似， Keycloak 提供了一个用于服务发现的接口地址：<code>/auth/realms/master/.well-known/openid-configuration</code>，通过这个接口地址，我们可以获得一份 API 列表：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/bDYNASUw23qLyml.png" alt="Keycloak 提供的 “服务发现” 能力" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 提供的 “服务发现” 能力</div></figure><p>可以注意到，图中有我们需要的换取令牌的接口，以及提供 JWKS 的接口：<code>/auth/realms/master/protocol/openid-connect/certs&quot;</code>，尤其第二点，它对于对我们进行下一个步骤意义重大，Envoy 能不能承担起微服务认证的重担，就看它的啦，至此， Keycloak 的搭建工作已经完成。</p><h1 id="配置-Envoy"><a href="#配置-Envoy" class="headerlink" title="配置 Envoy"></a>配置 Envoy</h1><p>在上一节内容中，博主卖了一个关子，说要等到这一节再说 JWKS 是何方神圣？不过，博主以为，“<strong>饭要一口一口吃，步子迈太大，咔，容易扯着蛋</strong>”，我们还是先来说说 JWT ，因为只要你了解了它的结构，你才能了解如何去检验一个令牌。我们说，JWT，是 JSON Web Token 的简称，那这个 JSON 到底体现在哪里呢？而这要从 JWT 的结构开始说起。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/Tdag82VsSGJxD9u.png" alt="JSON Web Token 结构说明图" referrerpolicy="no-referrer"></div><div class="image-caption">JSON Web Token 结构说明图</div></figure><p>这是一张来自 <a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a> 官网的截图，博主认为，这张图非常清晰地展示出了 JWT 的加密过程，我们熟悉的这个令牌，其实是由<code>header</code>、<code>payload</code>和<code>signature</code>三个部分组成，其基本格式为：<code>header.payload.signature</code>，细心的朋友会发现，图中生成的令牌中含有两个<code>.</code>。其中，<code>header</code>部分是一个 JSON 对象，表示类型(<strong>typ</strong>)及加密算法(<strong>alg</strong>)，常见的加密算法主要有 HMAC、RSA、ECDSA 三个系列。<code>payload</code>部分同样是一个 JSON 对象，主要用来存放实际需要传递的数据。目前，JWT 官方规定了以下7个备选字段：</p><ul><li>iss，即 issuer，表示：令牌签发人</li><li>exp，即 expiration time，表示：令牌过期时间</li><li>sub，即 subject，表示：令牌主题</li><li>aud，即 audience，表示：令牌受众</li><li>nbf，即 Not Before，表示：令牌生效时间</li><li>iat，即 Issued At，表示：令牌签发时间</li><li>jti，即 JWT ID，表示：令牌编号</li></ul><p>需要注意的是，<code>header</code>和<code>payload</code>这两部分，默认是不加密的，这意味着任何人都可以读到这里的信息，所以，一个重要的原则是，不要在<code>payload</code>中存放重要的、敏感的信息。无论是<code>header</code>还是<code>payload</code>，最终都需要通过 <a href="https://www.base64url.com/" target="_blank" rel="noopener">Base64URL</a> 算法将其转化为普通的字符串，该算法和 <a href="https://www.sojson.com/base64.html" target="_blank" rel="noopener">Base64</a> 算法类似，唯一的不同点在于它会对<code>+</code>、<code>/</code> 和 <code>=</code> 这三个符号进行替换，因为这三个符号在网址中有着特殊的含义。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/zDx765FpRMaP8mK.png" alt="Base64 & Base64URL 算法对比" referrerpolicy="no-referrer"></div><div class="image-caption">Base64 & Base64URL 算法对比</div></figure><p>第三部分，<code>signature</code>，即通常意义上的签名，主要是防止数据篡改。对于 HMAC 系列的加密算法，需要指定一个密钥，以 HMACSHA256 算法为例，其签名函数为：<code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code>。对于 RSA 和 ECDSA 这两个系列的加密算法，需要指定公钥和私钥，以 ECDSASHA512 算法为例，其签名函数为：<code>ECDSASHA512(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), PublicKey, PrivateKey)</code>。一旦计算出签名，就可以将这三部分合成一个令牌，而这就是 JWT 的产生原理，而如果我们对第一节中获得的令牌进行解密，我们就会得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/mpVo8vasYWL4gPN.png" alt="解密 Keycloak 生成的令牌" referrerpolicy="no-referrer"></div><div class="image-caption">解密 Keycloak 生成的令牌</div></figure><p>所以，JSON Web Token 中的 JSON，其实是指 <code>header</code> 和 <code>payload</code> 这两个 JSON 对象，并且我们可以注意到，Keycloak 中生成的令牌实际上携带了更多的信息，例如，客户端、IP 地址、<code>realm_access</code> 以及 <code>resource_access</code>等等，所以。 JWT 其实是一个相对宽松的规范，在实现<code>payload</code>这部分时，可以结合实际场景做更多的扩展，唯一的要求还是那句话，不要在<code>payload</code>中存放重要的、敏感的信息。至此，我们讲清楚了 JWT 的底层原理。</p><p>OK，解释清楚了 JWT，我们再来说 JWKS，这位又是何方神圣呢？我们提到，JWT 至少需要一个密钥或者一对公/私钥来进行签名的校验，因为对于<code>header</code>和<code>payload</code>这两个部分而言，它的加密算法始终都是 Base64URL，所以，我们总是可以反推出原始的 JSON 字符串。接下来，我们只需要按签名函数计算签名即可，对于 HMAC 系列的加密算法，需要指定一个密钥；对于 RSA 和 ECDSA 这两个系列的加密算法，需要指定公钥和私钥。由此，我们就可以计算出一个签名，此时，我们只需要比较两个签名是否一致即可。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/23/N6ybGazKBUSfE2H.png" alt="JWT 校验过程示意图" referrerpolicy="no-referrer"></div><div class="image-caption">JWT 校验过程示意图</div></figure><p>通过 JWKS 的 <a href="https://auth0.com/docs/tokens/json-web-tokens/json-web-key-sets" target="_blank" rel="noopener">官网</a>，我们可以了解到一件事情，那就是 JWKS 本质上是 Json Web Key Set 的简称，顾名思义，这是一组可以校验任意 JWT 的公钥，并且这些 JWT 必须是通过 RS256 算法进行签名的，RS256 则是我们上面这张图里的 RSA 非对唱加密算法，它需要一个公钥和一个私钥，通常强况下，私钥用来生成签名，公钥用来校验签名。这个 JWKS 呢？同样是一个 JSON 对象，它只有一个属性<code>keys</code>，以 Keycloak 中获得的 JWKS 为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/24/lQrXThYCvk9RPLm.png" alt="Keycloak 产生的 JWKS" referrerpolicy="no-referrer"></div><div class="image-caption">Keycloak 产生的 JWKS</div></figure><p>关于 JWKS 的规范，大家可以通过 <a href="https://datatracker.ietf.org/doc/html/rfc7517" target="_blank" rel="noopener">RFC7515</a> 来了解，作为一种通用的规范，Identity Server 4 和 Keycloak 都实现了这一规范，所以，就今天这篇博客而言，不管是哪一种方案，它都可以和 Envoy 配合得天衣无缝。为什么这样说呢？因为我们在 Envoy 中实现 JWT 认证，其核心还是 JWKS 这一套规范。博主没有选择从头开始实现这一切，就在于这个 JWKS 有特别多的细节。总之，我们只需要知道，通过 JWKS 可以对一个令牌进行验证，而 Envoy 刚好有这样一个过滤器，下面是 Envoy 中对应的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http_filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.jwt_authn</span></span><br><span class="line">    <span class="attr">typed_config:</span></span><br><span class="line">      <span class="string">"@type"</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication</span></span><br><span class="line">      <span class="attr">providers:</span></span><br><span class="line">        <span class="attr">jwt_provider:</span></span><br><span class="line">          <span class="attr">issuer:</span> <span class="string">"http://192.168.50.162:7070/auth/realms/master"</span></span><br><span class="line">          <span class="attr">audiences:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"account"</span></span><br><span class="line">          <span class="attr">forward:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">remote_jwks:</span></span><br><span class="line">            <span class="attr">http_uri:</span></span><br><span class="line">              <span class="attr">uri:</span> <span class="string">"http://192.168.50.162:7070/auth/realms/master/protocol/openid-connect/certs"</span></span><br><span class="line">              <span class="attr">cluster:</span> <span class="string">keycloak</span></span><br><span class="line">              <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">prefix:</span> <span class="string">"/api/w"</span></span><br><span class="line">          <span class="attr">requires:</span></span><br><span class="line">            <span class="attr">provider_name:</span> <span class="string">jwt_provider</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">prefix:</span> <span class="string">"/api/c"</span></span><br><span class="line">          <span class="attr">requires:</span></span><br><span class="line">            <span class="attr">provider_name:</span> <span class="string">jwt_provider</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure><p>可以注意到，我们这里配置了一个叫做<code>envoy.filters.http.jwt_authn</code>的过滤器，并为这个过滤器指定了一个叫做<code>jwt_provider</code>的认证提供者，其中的<code>issuer</code>和<code>audiences</code>，我们在讲解 JWT 结构的时候提到过，最为关键的是<code>remote_jwks</code>，我们通过 Keycloak 的服务发现功能，可以获得这个地址，我们将其配置到 Envoy 中即可，Envoy 可以通过它来验证一个 JWT 的令牌，而下面的规则，表示哪些路由需要认证，这里我们假设需要对<code>/api/w</code>和<code>/api/c</code>这两个端点进行认证。所以，可以预见的是，我们可以为整个网关配置统一的认证流程，无论我们有多少个微服务。以往我们都是通过 ASP.NET Core 里的过滤器来实现应用级的认证服务，而此时此刻，我们有了容器级别的认证服务，基础设施从框架提升到了容器层面。除此以外，我们还需要为 Envoy 定义一个集群，这样读取远程 JWKS 的请求才会被正确地转发过去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">keycloak</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">keycloak</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.50</span><span class="number">.162</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">7070</span></span><br></pre></td></tr></table></figure><p>如此，整个认证服务相关的基础设施均已准备就绪，所谓“万事俱备，只欠东风”，我们还需要定义资源 API 供调用者消费，所以，接下来，我们来看看 API 如何编写。</p><h1 id="编写-API"><a href="#编写-API" class="headerlink" title="编写 API"></a>编写 API</h1><p>编写 API 非常简单，我们直接用 ASP.NET Core 创建两个项目即可，这里是两个服务：<code>CityService</code> 和 <code>WeatherService</code>。</p><p>首先，是 <code>CityService</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CityController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] Cities = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"中卫"</span>, <span class="string">"西安"</span>, <span class="string">"苏州"</span>, <span class="string">"安庆"</span>, <span class="string">"洛阳"</span>, <span class="string">"银川"</span>, <span class="string">"兰州"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;CityController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CityController</span>(<span class="params">ILogger&lt;CityController&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">dynamic</span> <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">var</span> rnd = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">var</span> city =  Cities[rnd.Next(Cities.Length)];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> &#123; City = city, Now = DateTime.Now &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，是 <code>WeatherService</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"Freezing"</span>, <span class="string">"Bracing"</span>, <span class="string">"Chilly"</span>, <span class="string">"Cool"</span>, <span class="string">"Mild"</span>, <span class="string">"Warm"</span>, <span class="string">"Balmy"</span>, <span class="string">"Hot"</span>, <span class="string">"Sweltering"</span>, <span class="string">"Scorching"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WeatherController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherController</span>(<span class="params">ILogger&lt;WeatherController&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">var</span> rng = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">      &#123;</span><br><span class="line">        Date = DateTime.Now.AddDays(index),</span><br><span class="line">        TemperatureC = rng.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">        Summary = Summaries[rng.Next(Summaries.Length)]</span><br><span class="line">      &#125;)</span><br><span class="line">      .ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这两个服务如何实现容器化、反向代理等等的细节，大家可以参考博主前面几篇文章，本文示例已托管到 <a href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyJwt" target="_blank" rel="noopener">Github</a>，供大家做进一步的参考。</p><h1 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h1><p>这段时间最大的收获便是，学会了通过<code>docker-compose</code>对服务进行编排，虽然目前还有点悬而未决的东西，可一旦接触了这种略显“<strong>高端</strong>”的技巧，便再不愿回到刀耕火种、敲命令行维护<code>docker</code>环境的时代。等有时间了，博主会考虑写一点<code>docker</code>或者<code>docker-compose</code>使用技巧的文章，当然这些都是以后的事情啦！我们要活在当下啊，还是看看这个<code>docker-compose.yaml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoy_gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"6060:9090"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"6061:9091"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:80"</span><span class="string">![Envoy-Jwt-Keycloak-16.png](https://i.loli.net/2021/07/24/rCcUBWDyJVtOxkd.png)</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br><span class="line">  <span class="attr">weather_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8082:80"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">"http://+"</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">"Development"</span></span><br><span class="line">  <span class="attr">keycloak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/keycloak/keycloak:14.0.0</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KEYCLOAK_USER:</span> <span class="string">$&#123;KEYCLOAK_USER&#125;</span></span><br><span class="line">      <span class="attr">KEYCLOAK_PASSWORD:</span> <span class="string">$&#123;KEYCLOAK_PASS&#125;</span></span><br><span class="line">      <span class="attr">DB_VENDOR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_ADDR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_DATABASE:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">DB_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"7070:8080"</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br></pre></td></tr></table></figure><p>等所有的服务都启动起来以后，我们来验证下这个网关，是不是真的像我们期待的那样。注意到，Envoy 对外暴露出来的端口是<code>6060</code>，这里我们以<code>CItyService</code>为例：</p><p>首先，是不带令牌直接访问接口，我们发现接口返回了<code>401</code>状态码，并提示：<strong>Jwt is missing</strong>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/24/Bg5r8dAIbEp4eFy.png" alt="不携带令牌，Envoy 认证失败" referrerpolicy="no-referrer"></div><div class="image-caption">不携带令牌，Envoy 认证失败</div></figure><p>我们带上令牌会怎么样呢？可以注意到，接口成功地返回了数据，这表示我们的目的达到了，这些经由 Envoy 代理的 API 接口，今后都必须携带令牌进行访问：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/24/rCcUBWDyJVtOxkd.png" alt="携带令牌，Envoy 返回数据" referrerpolicy="no-referrer"></div><div class="image-caption">携带令牌，Envoy 返回数据</div></figure><p>因为 Keycloak 这个认证中心是独立于我们的应用单独存在的，所以，我们可以直接在 Keycloak 中设置令牌的过期时间、为用户分配角色、为不同的资源设置范围等等，而这一切都不需要应用程序或者 Envoy 做任何调整，开发者只需要认真地写好每一个后端服务即可，这是否就是传说中的基础设施即服务呢？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要分享了如何利用 Envoy 实现容器级别的 JWT 认证服务，在实现过程中，我们分别了解了 JWT 和 JWKS 这两个概念。其中，JWT 即JSON Web Token，是目前最为流行的跨域认证方案，一个 JWT 通常由 <code>header</code>、<code>payload</code> 和 <code>signature</code> 三个部分组成，JWT 的 JSON 主要体现在<code>header</code>和<code>payload</code>这两个 JSON 对象上，通过 Base64Url 算法实现串化，而 <code>signature</code> 部分则是由<code>header</code>和<code>payload</code>按照签名函数进行生成，主要目的是防止数据篡改。JWKS 可以利用密钥或者公/私钥对令牌进行验证，利用这一原理，Envoy 中集成了 JWKS ，它表示一组可以校验任意 JWT 的公钥，同样是一个 JSON 对象。为了获得可用的 JWKS，我们可以通过 Identity Server 4 或者 Keycloak 中提供的地址来获得这一信息，方便起见，本文选择了更为便捷的 Keycloak。最终，我们实现了一个通用的、容器级别的认证网关，调用方在消费这些 API 资源时都必须带上从认证中心获得的令牌，进而达到保护 API 资源的目的，更好地保障系统和软件安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Envoy" scheme="https://qinyuanpei.github.io/tags/Envoy/"/>
    
      <category term="JWT" scheme="https://qinyuanpei.github.io/tags/JWT/"/>
    
      <category term="Keycloak" scheme="https://qinyuanpei.github.io/tags/Keycloak/"/>
    
      <category term="认证" scheme="https://qinyuanpei.github.io/tags/%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>浪客剑心：一曲幕末时代的挽歌</title>
    <link href="https://qinyuanpei.github.io/posts/673523131/"/>
    <id>https://qinyuanpei.github.io/posts/673523131/</id>
    <published>2021-07-12T08:53:48.000Z</published>
    <updated>2022-03-07T01:40:22.330Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><p>近日，Netflix 官方宣布，浪客剑心·最终章：追忆篇 将于 7 月 30 日上线，这意味着这部横跨十年时间、被誉为漫改巅峰的系列电影，终于要迎来它的落幕。人对于时间的感觉，难免会相对迟钝一点。如果将思绪拉回到 2011 年，对我来说，人生中无数闪光的时刻，无一不是从这一刻开始：第一次拥有互相喜欢的人、第一次拥有属于我的电脑、第一次在图书馆里借满 100 本书……每次听别人说到漫威十年，我总觉得一切无比陌生。回想起来，第一次到电影院看电影，始于 Lemon 同学请我吃石锅拌饭，对于漫威英雄们的了解，更多的是事后诸葛亮，而唯有浪客剑心系列，一直陪伴着我走过这兵荒马乱的十年。所以，当这个系列走向终点的时候，我果然还是想说点自以为是的话，因为在时代的波涛里，每一个小人物的命运，都不过是艰难挣扎着活下去。</p><p>也许，不光是此刻屏幕前的你，就连我自己完全想象不出，有一天我会对日本的影视作品产生兴趣。过去的我，是一个被人称为“不适合在现代社会”的“怪人”。彼时，我喜欢苏轼烟雨任平生的豁达，喜欢稼轩气吞万里如虎的豪迈，喜欢纳兰容若秋风画扇的悲凉……更多的时候，我是一个偏理想化、偏浪漫主义的文艺青年。在我越来越模糊的时光回忆里，全然没有火影忍者、海贼王这些日漫作品的身影，因为在喜欢安静的我看来，这些动漫人物总是在互相“攻伐”，或许是因为日/韩的语言听起来更像是“吵架”，我一度认为这些东西是聒噪而喧嚣的。直到后来，接触到半泽直树、Legal High、白色巨塔这类影视作品，终于对日本人那种听起来像是“吵架”的表演风格有所了解，而像宫崎骏、新海诚、米林宏昌等动画导演的作品，则是后来一点点接触到的，甚至连鬼灭系列完全都是一个偶然，单纯是因为，我想找一个类似无皇刃谭的作品。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/17/h4q9frIXGyATeZS.jpg" alt="绯村剑心与雪代缘战斗" referrerpolicy="no-referrer"></div><div class="image-caption">绯村剑心与雪代缘战斗</div></figure><p>第一次看浪客剑心的时候，我全然不知它是一部漫改作品。当时，除了感觉人物造型有点 cosplay 以外，更多的时候，我喜欢把当作日式古装片/武侠片。庆幸的是，浪客剑心对于幕末/明治时期的社会氛围一直刻画地不错，即使后来浪客剑心更为人所称道的，是 垣谷健治 从中国功夫电影中借鉴到的动作设计。动画版的浪客剑心，或被称之为：明治剑客浪漫谭。也许，是因为 100 多年的历史不远不近，更适合人们去肆意想象。所以，当我们提起明治亦或者民国，我们总是期待，那是一个浪漫的时代。浪客剑心的开场，是鸟羽伏见之战，电影中我们记住的，或许是剑心傲娇地将刀插在地上，因为最终赢得这场战争的，是剑心背后的新政府军。可历史永远比想象更残酷，末代幕府将军德川庆喜，在苍茫夜色中逃往大阪城的时候，是否会不时想起，在大坂夏之阵中独自对抗德川大军的真田幸村。历史是何其地相似，可当你恍然间惊觉，原来泛黄的书页已翻过三百余年。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/hMPNtmfHd8FKOrn.jpg" alt="鸟羽伏见战场" referrerpolicy="no-referrer"></div><div class="image-caption">鸟羽伏见战场</div></figure><p>有人说，日本幕府的毁灭始于黑船事件，自此以后便是让日本快速崛起的明治维新。如果把黑船(枪炮)看作西方工业革命的象征，明治维新无疑就是一场西洋枪炮与东瀛武士刀的角逐。所以，在这样一种背景下，浪客剑心里的矛盾冲突，其实都是新时代与旧时代的一次碰撞。禁刀令下，一个曾经双手沾满鲜血的刽子手——绯村拔刀斋，手握一柄逆刃刀，试图斩断一切囿于过去的亡魂，等到他终于放下心中的罪孽感，不再执着于过去发生的一切，脸上的十字刀疤终于消失不见。你告诉我，还有比听起来比这个更浪漫的故事吗？绯村剑心，本名心太，幼年时父母因混乱而死，在被人贩子运送途中遭山贼袭击，幸得飞天御剑流第十三代传人比古清十郎搭救并收为弟子，传授其飞天御剑流剑术。比古清十郎认为心太这个名字太过柔弱，不适合一名剑客，故将其改名为剑心。多年后，剑心与师父的意见向左，师父认为，<strong>剑是凶器，剑术就是杀人伎俩，无论是用多么华丽的词藻去粉饰终究是事实</strong>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/dFegZqaQ23J8VCP.jpg" alt="剑心与师傅比古清十郎" referrerpolicy="no-referrer"></div><div class="image-caption">剑心与师傅比古清十郎</div></figure><p>而在一个动荡的乱世，剑术固然可以锄强扶弱，可更多的或许是成为政客手里的杀人工具。一心想亲手拯救人民于水火的剑心，在下山后遇到了桂小五郎、高杉晋作等维新志士组成的奇兵队，自此成为专门暗杀幕府政要的刽子手，其出众的剑术令幕府闻风丧胆，人称刽子手拔刀斋。其实，在时代的洪流里，不管是作为刽子手的拔刀斋，还是作为浪人的剑心，其实都是一个时代的牺牲品。志志雄真实和剑心，本质上都属于同一类人，不同的是，志志雄是在新时代建立后被抛弃的人，因为身体被大面积烧伤而无法正常排汗，内心燥热的火焰终于要随无限刃而喷薄欲出，他从国外购买了铁甲舰、手下集结了十本刀，决心将这个新时代变成炼狱。明治维新，是两个新旧时代的碰撞，在这样一个大背景下，传统的武士、刽子手大量被抛弃。不管是鹈堂刃卫，还是志志雄真实，都失去了存在下去的意义，他们被鲜血和执念吞噬，试图用最极端的方式来证明自己的存在，在武侠的世界里，追求武功天下第一，是每一个习武之人的毕生追求，可禁刀令一出，大家都生活在充满法制、文明的时代，曾经的一切都仿佛不复存在。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/VtUchpjIKZeBrWL.jpg" alt="武士刀 & 警棍" referrerpolicy="no-referrer"></div><div class="image-caption">武士刀 & 警棍</div></figure><p>这种失落感相当真实，多年以前，徐克拍摄《黄飞鸿》时，曾用“铁布衫”严振东的死，表达过这种在坚船利炮面前的无力感。纵观整个浪客剑心系列，除了第一部的反派武田观柳以外，几乎没有绝对的反派。有一个人，和这些囿于过去、不愿放过自己的人形成强烈对比，那就是斋藤一，这个被称为“壬生狼”的前新选组成员，永远奉行着“恶即斩”的主观标准。在每个被人潮推着向前走的时代，没有人能独善其身，可毫无疑问，斋藤一会是适应能力最强的那一类人。显然，剑心是那种愿意向前看，可依然对过去无法释怀的那一类人。有时候，我们会在文学作品中遇到隐形主角，譬如袁崇焕之于碧血剑，而浪客剑心的隐形主角，我以为应该是替剑心打造逆刃刀的新井赤空，一个铸剑师以匠人的心态打造神兵利器，结果这些刀剑都被用作凶器去杀人。同样地，一名剑客以济世救人的心态加入维新志士这一方，结果在迎接新时代到来的过程中夺去了别人的生命。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/vHI38FRoG9MOVWf.png" alt="新井赤空 & 剑心" referrerpolicy="no-referrer"></div><div class="image-caption">新井赤空 & 剑心</div></figure><p>可以说，剑心手上的逆刃刀，其实就是新井赤空的化身，两个人在赎罪这一心理上是高度一致的，甚至剑心内心的挣扎，早已和这把逆刃刀融为一体，逆刃刀固然会伤到自己，而一个人敢于直视自己的内心，未尝不会被这份鲜血淋漓灼伤，当剑心面对一个又一个的敌人，当剑心身上的秘密一点点被揭开，剑心面对的其实一条自我灵魂的救赎之路。电影中的逆刃刀一共有两把，第一把被称之为“影打”，属于试验品。在和“天剑”宗次郎对决的过程中被名刀虎彻斩断。第二把被称之为“真打”，属于千锤百炼的真品。在关键时刻让剑心打败十本刀之一的“刀狩”泽下条张。在京都大火篇中，当剑心准备从泽下条张手中救下伊织时，剑心有过一段阐述个人理念的独白，大意是说在新时代降生的孩子，都是真正的天选之子，值得他用生命去守护。从这里可以看出，即使曾经作为一个血债累累的刽子手，剑心灵魂深处的仁慈从未丢失过，多年后，他依然还是那个选择埋葬山贼和人贩子尸体的少年心太。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/toA6xTNQyYqGIZK.png" alt="剑心对战 “天剑” 宗次郎" referrerpolicy="no-referrer"></div><div class="image-caption">剑心对战 “天剑” 宗次郎</div></figure><p>可这个角色让人着迷的地方就在于，剑心身上有着难以融合的关于救赎、杀念和仁慈的混合气质：手执逆刃刀，是为不杀之誓，是为自我救赎；在新时代拒绝传授飞天御剑流剑术，认为神谷活心流的“活人剑”更值得传承下去，是为武者之仁。在我的印象中，剑心只有两次真正动了杀心，一次是从鹈堂刃卫手中救下被“心之一方”麻痹肺部的神谷薰，一次是从“刀狩”下泽条张手中救下新井青空的孩子伊织。有时候，我会想，那个一直让剑心不要再杀人的女人可真狠心。直到后来，我终于明白，雪代巴和神谷薰，都是剑心的剑鞘，一个真正爱你的人，怎么会忍心看着你堕入修罗呢？历史的扑朔迷离，往往来自那些不经意间文过饰非的春秋笔法，浪客剑心的第三部，即传说的完结篇，在这一篇里，伊藤博文宣布，绯村拔刀斋已死，绯村剑心重生。后人已无法知晓，伊藤博文下令向铁甲站舰开炮时的心境，也许在某一瞬间，伊藤博文真的想让剑心，连同这些幕末的亡灵一起葬送于火海。如果是这样，每一个想成为时代弄潮儿的英雄，是否最后都变成了政治家的牺牲品呢？虽然我不得不承认，海滩上明治政府向武士们致敬的这一幕，一旦搭配上飞天的背景音乐，就会成为比少年热血漫还要沸腾的东西。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/09/R2XldmgBs47wauW.jpg" alt="明治政府向武士们致敬" referrerpolicy="no-referrer"></div><div class="image-caption">明治政府向武士们致敬</div></figure><p>美国人曾经拍过一部电影《最后的武士》，描写社会变更时期的武士精神如何走向没落。历史的车轮呼啸而过，传统在飞扬的尘土中转瞬湮没。坂本龙马、大久保利通、西乡隆盛等维新志士，在历史的长河里惊鸿一瞥，人类面对滚滚历史长河时的渺小，大概就像大海中浮沉着的一叶孤舟，无论自身多么想要划向远方，最终亦不得不面对历史的进程。在这部电影结尾，明治天皇被阿汤哥的精神感动，从他手中接过胜元的武士刀，这大概是一种艺术加工。因为真实的历史是往往要更加残酷，此后的许多年里，武士道精神被偷换为军国主义，战争给这个世界带来的伤害可谓历历在目。我们说民国浪漫，是一种“为往圣继绝学，为万世开太平”的浪漫，是那种为了一个民族的未来，而甘愿做孺子牛、上下求索的浪漫。假如剥离这层浪漫的滤镜，将历史放大到一个普通人的生活。或许啊，我们看到的会是 《觉醒年代》 里的饿殍遍野、民生多艰。同样地，我们说明治浪漫，是那如夕阳一般绝美的最后的高光时刻。因为，在每一个时代，都有这样一群人，他们在新与旧，改革与保守，东方与西方的冲突中不断地挣扎。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/17/yDOkYUMW2i8qanN.jpg" alt="绯村剑心经典红白造型" referrerpolicy="no-referrer"></div><div class="image-caption">绯村剑心经典红白造型</div></figure><p>时至今日，年轻人对国家的未来充满希望，对个人的未来充满绝望，也许是因为，在时代的潮流中，普通人甚至比不上一朵小浪花，一如被剑心斩杀的雪代巴的未婚夫清里，本质上并无对错可言，无非是阵营不同。在浪客剑心里，年幼的心太对比古清十郎说，“人死了不过都是一具尸体”。多年后，我在日剧《Unnatural》 里找到了对应的答案，中堂医生在庭审时说过的话，“人这种生物，无论是谁，切开来剥开皮都只不过是一团肉，等你死了就知道了”。说到底，我们不过是碰巧活着啦，比古清十郎和高荷惠，都曾劝诫剑心，在救人前要先学会自保。或许，爱情更是如此，我们常说，“自爱沉稳而后爱人”，《仁医》 里穿越到幕末时代的医生南方仁，怀着对生命和历史的温情与敬意，不自觉地参与到幕末的各种历史事件中，并由此领悟到，“世间的一切都是先人赐予我们的，是历史中的每个人战斗、挣扎和牺牲所赢得的，更是由无数的生命奇迹编织而成，所以，我们必须用我们的双手，给予后人更加光明的未来”。剧中南方仁的仁是医者之仁，而坂本龙马的仁是以公义超越私爱，这两者共同构成这部电视剧的主题：仁，而剑心的仁在于止杀(戈)，这是真正的武者之仁。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/07/17/gFtbwBVfTsU1oql.jpg" alt="守护世界上最萌的剑心" referrerpolicy="no-referrer"></div><div class="image-caption">守护世界上最萌的剑心</div></figure><p>兔死狐悲的历史总在不断重复上演，历史上的白起、韩信、伍子胥，莫不如是。所以，对于志志雄真实这样一个悲情人物，总是会让人不由心生感慨。原著中的志志雄，不单单有蓄意谋国的野心，甚至开始探索“石油”这种属于未来的科技，在被明治政府抛弃以后，强忍着身心双重折磨，如丧尸一般存活下来。他建立起一套“弱肉强食”的社会达尔文主义理论，在手下十本刀的帮助下，意图颠覆刚建立不久的明治政府。每一个时代都有想成为“弄潮儿”的人，可更多的时候，不过是让这个世界频频陷入“大火”，时代的车轮呼啸着碾过的时候，牺牲的是无数细小的浪花、尘埃，每一个人都想成为英雄，可成为英雄的代价是什么呢？一将功成万骨枯，太阳从树叶的缝隙中穿过的时候，每一片叶子都合成了叶绿素，可难免会刺痛某个躺在树下乘凉的人的眼睛。不管是人诛篇的雪代缘，还是完结篇的志志雄，时代是需要英雄，可你不必非要成为那样的人，我还是想做一个普通人，因为，活着便能创造新的回忆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="电影" scheme="https://qinyuanpei.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="浪客剑心" scheme="https://qinyuanpei.github.io/tags/%E6%B5%AA%E5%AE%A2%E5%89%91%E5%BF%83/"/>
    
      <category term="日本" scheme="https://qinyuanpei.github.io/tags/%E6%97%A5%E6%9C%AC/"/>
    
      <category term="佐藤健" scheme="https://qinyuanpei.github.io/tags/%E4%BD%90%E8%97%A4%E5%81%A5/"/>
    
  </entry>
  
</feed>
