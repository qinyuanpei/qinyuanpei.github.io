<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一个人的孤落时辰</title>
  
  <subtitle>纵有疾风起，人生不言弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinyuanpei.github.io/"/>
  <updated>2021-06-22T07:04:41.534Z</updated>
  <id>https://qinyuanpei.github.io/</id>
  
  <author>
    <name>飞鸿踏雪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ASP.NET Core gRPC 打通前端世界的尝试</title>
    <link href="https://qinyuanpei.github.io/posts/2167892202/"/>
    <id>https://qinyuanpei.github.io/posts/2167892202/</id>
    <published>2021-06-20T21:37:36.000Z</published>
    <updated>2021-06-22T07:04:41.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在构建以 gRPC 为核心的微服务架构的过程中，我们逐渐接触到了 gRPC 的过滤器、健康检查、重试等方面的内容。虽然， Protocol Buffers 搭配 HTTP/2 ，在整个传输层上带来了显著的性能提升，可当这套微服务方案面对前后端分离的浪潮时，我们能明显地有点“<strong>水土不服</strong>”。其实，如果单单是以 Protocol Buffers 来作为 HTTP 通信的载体，通过 <a href="https://github.com/dcodeIO/protobuf.js" target="_blank" rel="noopener">protobuf.js</a> 就可以实现前端的二进制化。考虑到 gRPC 实际的通信过程远比这个复杂，同时还要考虑<code>.proto</code>文件在前/后端共享的问题，所以，我们面对的其实是一个相当复杂的问题。现代的前端世界，是一个<code>React</code>、<code>Angular</code>和<code>Vue</code>三足鼎立的世界，如果这个世界不能和微服务的世界打通，我们面对的或许并不是一个真实的世界。因为博主注意到，项目中有一部分 gRPC 服务被封装为<code>Web API</code>并提供给前端，这说明大家都意识到了这个问题。所以，这篇博客想和大家分享的是，如何打通 gRPC 和 前端 两个不同的世界，这里介绍四种方式：<strong>gRPC-Web</strong>、<strong>gRpc-Gateway</strong>、<strong>封装Web API</strong>、<strong>编写中间件</strong>，希望能给大家带来一点启发。</p><h1 id="gRPC-Web"><a href="#gRPC-Web" class="headerlink" title="gRPC-Web"></a>gRPC-Web</h1><p><a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Web</a> 是官方提供的一个方案，它的原理是利用命令行工具<code>ptotoc</code>及其插件<code>protoc-gen-grpc-web</code>来生成<code>.proto</code>对应的客户端代码，这些代码经过<code>webpack</code>这类打包工具处理以后，就可以在前端使用。所以，对于 gRPC-Web ，你可以从两个方面来考虑它：第一，它支持生成强类型的客户端代码；第二，它支持在非 HTTP/2 环境下使用 gRPC 。下面是一个基本的使用流程：</p><p>首先，我们需要下载命令行工具：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">protoc</a> 及其插件：<a href="https://github.com/grpc/grpc-web/releases" target="_blank" rel="noopener">protoc-gen-grpc-web</a>。</p><p>此时，我们可以使用下面的命令来生成<code>JavaScript</code>版本的 gRPC 代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc greetjs.proto \</span><br><span class="line">  --js_out=import_style=commonjs:. \</span><br><span class="line">  --grpc-web_out=import_style=commonjs,mode=grpcwebtext:. \</span><br><span class="line">  --plugin=protoc-gen-grpc-web=C:\Users\Payne\go\bin\protoc-gen-grpc-web.exe</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>--js_out</code> 和 <code>--grpc-web_out</code> 分别指定了我们要生成的<code>JavaScript</code>代码的模块化标准，这里使用的是 <a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS</a> 规范。</li><li><code>mode=grpcwebtext</code> 指定 gRPC-Web 的数据传输方式。目前：支持两种方式，application/grpc-web-text(Base64编码，文本格式) 和 application/grpc-web+proto(二进制格式)，前者支持 Unary Calls 和 Server Streaming Calls，后者只支持 Unary Calls。</li></ul><p>在这个例子中，会生成下面两个文件，它们分别定义了<code>客户端</code>和<code>消息</code>这两个部分：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/22/Yd9A5CEONkZgBjU.png" alt="利用 protoc 生成 JavaScript 代码" referrerpolicy="no-referrer"></div><div class="image-caption">利用 protoc 生成 JavaScript 代码</div></figure><p>此时，我们可以这样编写我们的逻辑代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> proto.greet.GreeterClient(<span class="string">'http://localhost:8000'</span>);</span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> proto.greet.HelloRequest();</span><br><span class="line"><span class="keyword">var</span> metadata = &#123; &#125;</span><br><span class="line">request.setName(<span class="string">'长安书小妆'</span>);</span><br><span class="line">client.sayHello(request, metadata, <span class="function"><span class="keyword">function</span>(<span class="params">error, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你更倾向于使用类型安全的 TypeScript，你还可以按下面的方式来生成代码：</p><ul><li>import_style=commonjs+dts: CommonJS &amp; .d.ts typings</li><li>import_style=typescript: 100% TypeScript</li></ul><p>更多的细节请参考官方文档：<a href="https://hub.fastgit.org/grpc/grpc-web#typescript-support" target="_blank" rel="noopener">https://hub.fastgit.org/grpc/grpc-web#typescript-support</a></p><p>接下来，对于 .NET 开发者而言， gRPC-Web 意味着我们只需要简单地配置下 ASP.NET Core 的中间件管道，就可以享受到上面提供的这些便利。因为 Visual Studio 会在编译<code>.proto</code>文件时，自动帮你生成这个客户端代码，我们可以将这一技术应用到单页面应用(<strong>SPA</strong>) 和 WebAssembly 中，最典型的例子莫过于微软的 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-5.0" target="_blank" rel="noopener">Blazor</a>，它使得 gRPC 可以充当客户端与服务端间的信使。同样地，这里准备了相关的示例代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddGrpc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    app.UseGrpcWeb();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;().EnableGrpcWeb();</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大家留意一下微软官方的 <a href="https://hub.fastgit.org/grpc/grpc-dotnet/blob/master/examples/Browser/Server/wwwroot/Scripts/index.js" target="_blank" rel="noopener">示例项目</a>，就会发现和这里类似的东西，因为原理上一脉相承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; HelloRequest, HelloReply &#125; = <span class="built_in">require</span>(<span class="string">'./greet_pb.js'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; GreeterClient &#125; = <span class="built_in">require</span>(<span class="string">'./greet_grpc_web_pb.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> GreeterClient(<span class="built_in">window</span>.location.origin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nameInput = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">var</span> sendInput = <span class="built_in">document</span>.getElementById(<span class="string">'send'</span>);</span><br><span class="line"><span class="keyword">var</span> streamInput = <span class="built_in">document</span>.getElementById(<span class="string">'stream'</span>);</span><br><span class="line"><span class="keyword">var</span> resultText = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unary call</span></span><br><span class="line">sendInput.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> HelloRequest();</span><br><span class="line">    request.setName(nameInput.value);</span><br><span class="line"></span><br><span class="line">    client.sayHello(request, &#123;&#125;, (err, response) =&gt; &#123;</span><br><span class="line">        resultText.innerHTML = htmlEscape(response.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>gRPC-Web 在将 gRPC 带入前端世界的过程中，其实是牺牲了一部分重要特性的，譬如浏览器中无法实现 HTTP/2，相对应地，gRPC-Web不再支持客户端流和双向流，依然支持服务端流，博主猜测可能是利用了服务端发送事件(<strong>Server Sent Event</strong>)。不过，这并不影响我们对这个项目的敬意，感谢它将 gRPC 带入了前端的世界。</p><h1 id="gRPC-Gateway"><a href="#gRPC-Gateway" class="headerlink" title="gRPC-Gateway"></a>gRPC-Gateway</h1><p><a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Gateway</a> 同样是命令行工具<code>protoc</code>的一个插件，其原理是，读取 gRPC 服务定义，并生成一个反向代理服务器，将 RESTful JSON API 转换为 gRPC 。而两者间的对应关系，则是通过<code>.proto</code>文件中的自定义选项来维护的。简单来说，就是在我们定义 gRPC 服务的同时，增加一组选项来表明这是一个 RESTful JSON API 。目前，这个插件只支持<code>Go</code>语言的代码生成。所以，如果想玩一玩这个插件，需要大家安装好<code>Go</code>的环境。</p><p>首先，我们从 <a href="https://hub.fastgit.org/protocolbuffers/protobuf/releases/tag/v3.6.1" target="_blank" rel="noopener">Github</a> 下载 Protocol Buffers 的编译器，它负责从从<code>.proto</code>文件生成代码。</p><p>这里我们选择 Windows 版本，直接将其解压到一个非中文的路径下即可。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/21/eTfGF9hI6cPSlwR.png" alt="Protocol Buffers 的编译器" referrerpolicy="no-referrer"></div><div class="image-caption">Protocol Buffers 的编译器</div></figure><p>这里，我们需要配置下面两个环境变量：</p><ul><li>PATH：C:\Program Files\Protobuf\bin</li><li>PROTOC_INCLUDE：C:\Program Files\Protobuf\include</li></ul><p>接下来，在<code>Go</code>环境中进行以下设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway </span><br><span class="line">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger </span><br><span class="line">go install github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p>这样，我们就通过<code>Go</code>完成了<code>protoc</code>的插件的安装。此时，我们可以通过下面的命令来生成<code>Go</code>代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成Go的客户端代码</span></span><br><span class="line">protoc --proto_path=. \</span><br><span class="line">  --go_out=. \</span><br><span class="line">  --plugin=protoc-gen-go=C:\Users\Payne\go\bin\protoc-gen-go.exe \</span><br><span class="line">  ./greet.proto </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成Go的反向代理服务器端代码</span></span><br><span class="line">protoc \</span><br><span class="line">  -I C:\Users\Payne\go\pkg\mod\github.com\grpc-ecosystem\grpc-gateway@v1.9.0\third_party\googleapis\ \</span><br><span class="line">  --proto_path=. \</span><br><span class="line">  --grpc-gateway_out=. \</span><br><span class="line">  --plugin=protoc-gen-grpc-gateway=C:\Users\Payne\go\bin\protoc-gen-grpc-gateway.exe \</span><br><span class="line">  ./greet.proto</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面两个<code>.go</code>格式的文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/22/wHvUzr5OybAtfkS.png" alt="通过 grpc-gateway 生成 Go 代码" referrerpolicy="no-referrer"></div><div class="image-caption">通过 grpc-gateway 生成 Go 代码</div></figure><p>关于反向代理服务器的观点的验证，大家可以从生成的第二个文件中去发现。</p><p>而关于 <a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Gateway</a> 这个插件的使用，最直观的用法，其实应该来自<code>.proto</code>文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">syntax</span> = <span class="string">"proto3";</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//</span> <span class="string">Go里面的包名，必选</span></span><br><span class="line"><span class="attr">option</span> <span class="string">go_package = "grpc-gateway/hello-word";</span></span><br><span class="line"></span><br><span class="line"><span class="attr">package</span> <span class="string">greet;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//</span> <span class="string">Google的API注解相关的.proto文件，必选</span></span><br><span class="line"><span class="attr">import</span> <span class="string">"Protos/google/api/annotations.proto";</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service</span> <span class="string">Greeter &#123;</span></span><br><span class="line">  <span class="attr">rpc</span> <span class="string">SayHello (HelloRequest) returns (HelloReply) &#123;</span></span><br><span class="line">      <span class="attr">option</span> <span class="string">(google.api.http) = &#123; </span></span><br><span class="line">          <span class="attr">post</span>: <span class="string">"/v1/greet/sayHello"</span></span><br><span class="line">          <span class="attr">body</span>: <span class="string">"*" </span></span><br><span class="line">      <span class="attr">&#125;;</span></span><br><span class="line">  <span class="attr">&#125;;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">message</span> <span class="string">HelloRequest &#123;</span></span><br><span class="line">  <span class="attr">string</span> <span class="string">name = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">message</span> <span class="string">HelloReply &#123;</span></span><br><span class="line">  <span class="attr">string</span> <span class="string">message = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>考虑到博主并不擅长<code>Go</code>这门语言，这里我们就不再对它做进一步的探索啦！事实上，我觉得这个方案非常糟糕，因为只要修改了<code>.proto</code>文件，这个代理服务器就要重新生成，更不用说只支持<code>Go</code>这一显著的缺点啦！</p><h1 id="封装-Web-API"><a href="#封装-Web-API" class="headerlink" title="封装 Web API"></a>封装 Web API</h1><p>封装Web API，这是一个非常朴实无华的方案，博主目前的公司就是采用这种方案，所以，你能想象得到，基本就是在控制器中调用客户端。唯一的弊病在于，这是一个非常低效的工作。当年，博主的前公司，就是风风火火地要这样替换掉WCF，结果最终还是不了了之。所以说，世间没有银弹，历史不过是一次次地重复上演。下面是一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">SayHello</span>(<span class="params">HelloRequestDTO requestDTO</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = requestDTO.Adapt&lt;HelloRequest&gt;();</span><br><span class="line">    <span class="keyword">var</span> client = _serviceProvider.GetService&lt;Greeter.GreeterClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> replay = <span class="keyword">await</span> client.SayHelloAsync(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(replay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而一旦做到这一层，其实我们是把一个未知的问题转化成一个已知的问题，这是数学家最常用的思路。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">   method: <span class="string">'POST'</span>,</span><br><span class="line">   headers: headers,</span><br><span class="line">   body: <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'长安书小妆'</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">"https://localhost:44372/Greet/SayHello"</span>, options)</span><br><span class="line">   .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">   .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">   .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure><p>那么，下一个问题，你打算用 Fetch API 还是 Axios 呢？这个问题就交给前端的朋友啦！因为，我是一个伪全栈工程师(逃。</p><h1 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h1><p>其实，读到这里，你就会明白，这才是我真正要分享的内容，而此前种种，不过是我为了丰富这个话题而抛出的它山之石。既然觉得手写 Web API 太麻烦，那么我们能不能用一种新的思路来解决这个问题呢？这里说一下博主的思路，用户传入JSON，经过中间件反序列化为<code>.proto</code>对应的类型，我们将这个类型传递给 gRPC 的客户端作为请求参数，等拿到结果以后，我们再将它序列化为 JSON 即可。这样，我们就实现了将一个 gRPC 服务转化为 Web API 的想法。下面是具体的代码，其实这个代码并不复杂，我最初打算用反射来解决，可惜 gRPC 生成的这个客户端方法重载实在太多啦，所以，我最后决定用下面的这种方式。当然啦，缺点就和 gRPC-Gateway 一样，每一个接口都要单独写，好处大概是代码量减少了好多。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义扩展方法：AddGrpcGateway</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> AddGrpcGateway&lt;TClient,TRequest,TResponse&gt;(</span><br><span class="line">  <span class="keyword">this</span> IApplicationBuilder app, </span><br><span class="line">  <span class="keyword">string</span> route, </span><br><span class="line">  Func&lt;<span class="keyword">string</span>, TRequest&gt; requestBuilder, </span><br><span class="line">  Func&lt;TClient,TRequest,TResponse&gt; responseBuilder</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt; endpoints.MapPost(route, <span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> streamReader = <span class="keyword">new</span> StreamReader(context.Request.Body))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> client = (TClient)app.ApplicationServices.GetService(<span class="keyword">typeof</span>(TClient));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> payload = <span class="keyword">await</span> streamReader.ReadToEndAsync();</span><br><span class="line">            <span class="keyword">var</span> request = requestBuilder(payload);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> reply = responseBuilder(client, request);</span><br><span class="line">            <span class="keyword">var</span> response = JsonConvert.SerializeObject(reply);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> context.Response.Body.WriteAsync(Encoding.UTF8.GetBytes(response));</span><br><span class="line">            context.Response.StatusCode = <span class="number">200</span>;</span><br><span class="line">            context.Response.ContentType = <span class="string">"application/json"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，这个方案依赖 gRPC 的客户端代码，同时需要读取 HTTP 的请求体，所以，我们还需要下面的代码作为辅助：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(opt =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        opt.Address = <span class="keyword">new</span> Uri(<span class="string">"https://localhost:8001"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们通过中间件配置一个路由即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议放在 UseEndpoints() 方法下面</span></span><br><span class="line">app.AddGrpcGateway&lt;Greeter.GreeterClient, HelloRequest, HelloReply&gt;(</span><br><span class="line">    route: <span class="string">"greet/SayHello"</span>,</span><br><span class="line">    requestBuilder: json =&gt; <span class="keyword">new</span> MessageParser&lt;HelloRequest&gt;(() =&gt; <span class="keyword">new</span> HelloRequest()).ParseJson(json),</span><br><span class="line">    responseBuilder: (client, request) =&gt; client.SayHelloAsync(request).ResponseAsync.Result</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>为了证明这个中间件真的有用，我们用 <a href="https://www.apifox.cn/" target="_blank" rel="noopener">Apifox</a> 或者 <a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">Postman</a> 测试一下看看。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/21/hEmSVqOCy9tBbdv.png" alt="自定义中间件实现 gRPC 转 API 效果" referrerpolicy="no-referrer"></div><div class="image-caption">自定义中间件实现 gRPC 转 API 效果</div></figure><p>此时，可以看到，这就真的和调用一个 Web API 一样，我们完全意识不到，这是一个 gRPC 服务。你觉得，这样子算是达到目的了吗？</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>其实，本文完全是临时想起来决定要写的一篇文章，起因就是看到了项目中有人在手动地封装 gRPC 服务为 RESTful 服务，当时就在想有没有一种方案，可以让这个过程稍微好一点点。所以，你可以认为，我写这篇博客的初衷，原来就是为了炫耀我写的那几行代码。不过，人到了一定的阶段以后，不管是写作还是思考，都似乎越来越喜欢某种框架结构，这种体验就有点像是上学时候写论文一样，虽然你明确地知道自己在做什么，可当你真正要把你的思路或者过程复述出来的时候，你还是需要有一个“文献综述”的环节。我个人以为，这是一种由外及内的认知方法，通过内外世界的对比来寻找自我提升的突破口。对于本文而言，不管是 <a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Web</a> 还是 <a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">gRPC-Gateway</a>，从本质上来讲，它们都是 Protocol Buffers 工具链中的插件，在这个过程中发现了平时使用 gRPC 过程中被隐藏了的一部分细节，这些细节如果能和开发工具完美结合的话，就可以极大地提升我们在 gRPC 方面的开发效率，譬如 gRPC-Web 在 .NET 中的实现就利用了 MSBuild 的自定义编译任务，这就让底层的Protocol Buffers 工具链、前端构建工具等对使用者来说是无感知的，从开发体验上就给人心旷神怡的感觉。我个人还是倾向于结合 ASP.NET Core 或者容器级别的 Envoy 来解决这个问题，我觉得应该还有更好的方案，希望大家可以在评论区写下你的想法。好啦，这篇博客就先写到这里，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="前端" scheme="https://qinyuanpei.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Web" scheme="https://qinyuanpei.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>EFCore 实体命名约定库：EFCore.NamingConventions</title>
    <link href="https://qinyuanpei.github.io/posts/3219639636/"/>
    <id>https://qinyuanpei.github.io/posts/3219639636/</id>
    <published>2021-06-17T16:37:11.000Z</published>
    <updated>2021-06-22T07:04:41.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在软件开发过程中，数据库永远都是绕不开的一个话题。有时候，我们甚至会因此而获得一个名字——“<strong>CURD Boy</strong>”。虽然不过是朴实无华的“<strong>增删查改</strong>”，可隐隐然早已分出了无数的流派。在这些不同的流派中，有的人坚持“<strong>我手写我心</strong>”，认为手写<code>SQL</code>才是真正的王道，没有读过/写过成百上千行的存储过程，便不足以谈论程序员的人生。而有的人喜欢<code>ORM</code>的清晰、整洁，认为数据库和面向对象存在着天然抗阻，<code>ORM</code>更有利于推进<code>DDD</code>和微服务的落地。相信大家都听说过<code>Java</code>里的<code>SSH</code>框架，从<code>Hibernate</code>到<code>Mybatis</code>再到<code>Spring Data JPA</code>，可以说这种争论一直没有停止过。这里我们不打算讨论这个问题，我们平时使用<code>EF</code>或者<code>EFCore</code>的过程中，作为连接数据库和面向对象两个异世界的桥梁，<code>ORM</code>需要我们来告诉它，实体数据与数据库表字段的映射关系，所以，经常需要通过<code>数据注解</code>或者<code>Fulent API</code>来写各种配置。那么，有没有什么方案可以让我们偷这个懒呢？下面隆重请出本文的主角：<a href="https://github.com/efcore/EFCore.NamingConventions" target="_blank" rel="noopener">EFCore.NamingConventions</a>。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p><a href="https://github.com/efcore/EFCore.NamingConventions" target="_blank" rel="noopener">EFCore. NamingConventions</a>，目前由一个非官方的组织进行维护，代码托管在 Github 上，100％的开源项目。</p><p>如果你希望直接使用它的话，可以直接通过<code>NuGet</code>进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package EFCore.NamingConventions</span><br></pre></td></tr></table></figure><p>接下来，我们只需要在<code>DbContext</code>的 <code>OnConfiguring()</code>方法中，调用它提供的扩展方法即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)  </span></span><br><span class="line"><span class="function"></span>=&gt; optionsBuilder  </span><br><span class="line">.UseSqlite(<span class="string">"Data Source=Chinook.db"</span>)</span><br><span class="line">.UseSnakeCaseNamingConvention();</span><br></pre></td></tr></table></figure><p>或者，你可以使用依赖注入的方式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddDbContext&lt;ChinookContext&gt;(options =&gt; </span><br><span class="line">    options.UseSqlite(<span class="string">"Data Source=Chinook.db"</span>)</span><br><span class="line">          .UseSnakeCaseNamingConvention()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里我以<code>SQLite</code>数据库为例，来展示它的具体使用细节。事实上，它提供了 4 种命名约定的策略：</p><ul><li>UseSnakeCaseNamingConvention: <code>FullName</code> -&gt; <code>full_name</code></li><li>UseLowerCaseNamingConvention: <code>FullName</code> -&gt; <code>fullname</code></li><li>UseCamelCaseNamingConvention: <code>FullName</code> -&gt; <code>fullName</code></li><li>UseUpperCaseNamingConvention: <code>FullName</code> -&gt; <code>FULLNAME</code></li></ul><p>简单来说，就是当我们的实体中存在一个属性<code>FullName</code>时，它会告诉<code>EF</code>或者<code>EFCore</code>，这个属性<code>FullName</code>对应的表字段是什么。</p><p>虽然，在大多数的场景中，我们都希望属性名称和表字段一致，可你要知道，像<code>Oracle</code>这种对大小写敏感的数据库，特别喜欢自作聪明地帮你全部改成大写。</p><p>所以，在上家公司工作的时候，为了兼容<code>Oracle</code>这病态的癖好，公司里有个不成文的规定，那就是：所有实体的属性名称最好都大写。</p><p>本来大家用驼峰命名就是为了好认单词，好家伙！这下全部大写了，一眼望过去简直就是灾难，因为没有办法做到“<strong>望文生义</strong>”，如果那个时候知道这个库的存在，是不是就能解决这个问题了呢？</p><h1 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h1><p>下面我们以<code>UseSnakeCaseNamingConvention</code>为例，结合<code>SQLite</code>来做一个简单的例子。</p><p>首先，我们定义必要的实体，并为<code>DbContext</code>配置实体命名约束规则：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Album</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Album</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> AlbumId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Artist</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Artist</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，通过迁移命令来生成数据库架构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration "Init-Database" -Context ChinookContext</span><br><span class="line">Update-Database</span><br></pre></td></tr></table></figure><p>可以注意到，生成的数据库表字段会以小写+下划线的方式命名。这就是所谓的实体命名约束。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/18/cSVRWrDTbnv29Ze.png" alt="通过实体命名约束生成的 Album 表" referrerpolicy="no-referrer"></div><div class="image-caption">通过实体命名约束生成的 Album 表</div></figure><p>只要大家都看着这个约定来写实体的属性，这套机制就可以完美工作。它和<code>MVC</code>里的默认路由一样，都是属于一种“<strong>约定大于配置</strong>”的方案。</p><p>在我看来，不管是配置还是约定。当以团队为单位进行协作时，最好还是以文档的形式记录下来，否则会出现两种结局，<strong>其一是没人知道怎么配置，其二是新人不知道有这个约定</strong>。</p><p>以上就是<code>EFCore.NamingConventions</code>的基本用法，更多的细节大家可以去阅读它的<code>README</code>，因为这个库需要结合迁移功能来使用，所以，如果要在已存在的表上应用这套约束规则时，建议大家还是小心谨慎一点。</p><p>我个人觉得，它可以方便团队去制定一套数据库规范，进而去约束开发人员写出更规范的命名。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要介绍了可用于<code>EFCore</code>的实体命名约束库：<code>EFCore.NamingConventions</code>。这是一个由社区维护的、开源的项目，它可以在创建<code>DbContext</code>的时候，指定一个实体命名约束规则，即实体属性如何与数据库表字段进行对应，这是一种约定大于配置的方案，一旦团队形成了属于自己的数据库命名风格，那么，研发人员只需要按照规范为实体属性命名，例如开发人员可以使用驼峰风格的命名，而数据库管理员则可以使用下划线风格的命名。这样，就可以省略一部分字段映射的配置代码，从而提高团队研发的效率。值得说明的一点是，不管是配置还是约定。当以团队为单位进行协作时，最好还是以文档的形式记录下来，否则会出现两种结局，<strong>其一是没人知道怎么配置，其二是新人不知道有这个约定</strong>。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据存储" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="实体" scheme="https://qinyuanpei.github.io/tags/%E5%AE%9E%E4%BD%93/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="数据库" scheme="https://qinyuanpei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="EF" scheme="https://qinyuanpei.github.io/tags/EF/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core gRPC 集成 Polly 实现优雅重试</title>
    <link href="https://qinyuanpei.github.io/posts/2742255459/"/>
    <id>https://qinyuanpei.github.io/posts/2742255459/</id>
    <published>2021-06-07T15:19:11.000Z</published>
    <updated>2021-06-22T07:04:41.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在上一篇 <a href="https://blog.yuanpei.me/posts/1657075397/" target="_blank" rel="noopener">博客</a> 中，我们一起探索和实现了<code>gRPC</code>的健康检查。从服务治理的角度来看，健康检查保证的是被调用的服务“健康”或者“可用”。可即使如此，我们依然会遇到，因为网络不稳定等原因而造成的服务调用失败的情形，就如同我们赖以生存的这个真实世界，本身就充满了各种不确定的因素一样，“<strong>世间唯一不变的只有变化本身</strong>”。不管是面对不稳定的服务，还是面对不确定的人生，任何时候我们都需要有一个 B 计划，甚至我们人生中的一切努力，本质上都是为了多一份自由，一份选择的自由。在微服务的世界里，我们将这种选择称之为“<strong>降级(Fallback)</strong>”，如果大家有接触过 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Hystrix</a> 或者 <a href="https://github.com/App-vNext/Polly" target="_blank" rel="noopener">Polly</a> 这类框架，就会明白我这里的所说的“<strong>降级</strong>”具体是什么。在众多的“<strong>降级</strong>”策略中，<strong>重试</strong>是一种非常朴素的策略，尤其是当你调用一个不稳定的服务的时候。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/GIBVj3sKb5zMeE1.jpg" alt="重试" referrerpolicy="no-referrer"></div><div class="image-caption">重试</div></figure><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在此之前，博主曾经介绍过 <a href="https://blog.yuanpei.me/posts/2070070822/" target="_blank" rel="noopener">HttpClient</a> 的重试。所以，今天这篇博客我们来聊聊<code>gRPC</code>的客户端重试，因为要构建一个高可用的微服务架构，除了需要高可用的服务提供者，同样还需要高可用的服务消费者。下面，博主将由浅入深地为大家分享 4 种重试方案的实现，除了 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/retries?view=aspnetcore-3.1" target="_blank" rel="noopener">官方</a> 内置的方案，基本上都需要搭配 Polly 来使用，所以，到这里你可以理解这篇博客的标题，为什么博主会 <a href="https://music.163.com/#/song?id=167720" target="_blank" rel="noopener">毁人不倦</a> 地尝试不同的重试方案，因为每一种方案都有它自身的局限性，博主想要的是一种更优雅的方案。具体来讲，主要有：<strong>基于 gRPC RetryPolicy</strong>、<strong>基于 HttpClientFactory</strong>、<strong>基于 gRPC 拦截器</strong> 以及 <strong>基于CallInvoker</strong> 4 种方案。如果大家还有更好的思路，欢迎大家在博客评论区积极留言、参与讨论。</p><h1 id="基于-gRPC-RetryPolicy"><a href="#基于-gRPC-RetryPolicy" class="headerlink" title="基于 gRPC RetryPolicy"></a>基于 gRPC RetryPolicy</h1><p>所谓的 gRPC RetryPolicy，其实是指 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/retries?view=aspnetcore-3.1" target="_blank" rel="noopener">官方</a> 提供的暂时性故障处理方案，它允许我们在创建<code>GrpcChannel</code>的时候，去指定一个重试策略：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultMethodConfig = <span class="keyword">new</span> MethodConfig &#123;</span><br><span class="line">    Names = &#123; MethodName.Default &#125;,</span><br><span class="line">    RetryPolicy = <span class="keyword">new</span> RetryPolicy &#123;</span><br><span class="line">        MaxAttempts = <span class="number">5</span>,</span><br><span class="line">        InitialBackoff = TimeSpan.FromSeconds(<span class="number">1</span>),</span><br><span class="line">        MaxBackoff = TimeSpan.FromSeconds(<span class="number">5</span>),</span><br><span class="line">        BackoffMultiplier = <span class="number">1.5</span>,</span><br><span class="line">        RetryableStatusCodes = &#123; StatusCode.Unavailable &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>, <span class="keyword">new</span> GrpcChannelOptions &#123;</span><br><span class="line">    ServiceConfig = <span class="keyword">new</span> ServiceConfig &#123; MethodConfigs = &#123; defaultMethodConfig &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>MethodConfig</code>可以为指定的方法配置一个重试策略，当传入的方法名为<code>MethodName.Default</code>时，它将应用于该通道下的所有gRPC方法。如你所见，在重试策略中我们可以指定重试次数、重试间隔等参数。<strong>这个方案本身没有太多心智上的负担，唯一的缺点是，它没有预留出可扩展的接口</strong>，以至于我们想要验证它到底有没有重试的时候，居然要通过<code>Fiddler</code>抓包这种方式，换句话讲，我们没有办法自定义整个重试行为，譬如你想在重试过程中记录日志，这种方案就会鸡肋起来，<strong>对使用者来说，这完全就是一个黑盒子</strong>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/QzjaH4VqWMnEFcb.png" alt="官方自带的 “黑盒子” 重试机制" referrerpolicy="no-referrer"></div><div class="image-caption">官方自带的 “黑盒子” 重试机制</div></figure><p>除此之外，官方还提供了一种成为 <code>Hedging</code> 重试策略作为备选方案。类似地，它通过 <code>HedgingPolicy</code> 属性来指定重试策略。对比 <code>RetryPolicy</code>，它可以同时发送单个gRPC请求的多个副本，并使用第一个成功的结果作为返回值，所以，<strong>一个显而易见的约束是，它要求这个gRPC方法是无副作用的、幂等的函数</strong>。其实，这是所有重试方案都应该考虑的一个问题，而不单单是 <code>HedgingPolicy</code>。由于这两种策略有着本质上的不同，请记住：<strong>RetryPolicy不能与HedgingPolicy一起使用。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultMethodConfig = <span class="keyword">new</span> MethodConfig &#123;</span><br><span class="line">    Names = &#123; MethodName.Default &#125;,</span><br><span class="line">    HedgingPolicy = <span class="keyword">new</span> HedgingPolicy &#123;</span><br><span class="line">        MaxAttempts = <span class="number">5</span>,</span><br><span class="line">        NonFatalStatusCodes = &#123; StatusCode.Unavailable &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>, <span class="keyword">new</span> GrpcChannelOptions &#123;</span><br><span class="line">    ServiceConfig = <span class="keyword">new</span> ServiceConfig &#123; MethodConfigs = &#123; defaultMethodConfig &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>世间的一切都是双刃剑， <code>HedgingPolicy</code> 同样打不破这铁笼一般的人间真实，虽然它可以一次发送多个<code>gRPC</code>请求，可毫无疑问的是，<strong>这是一种相当浪费的策略，因为不管有多少个请求，它始终都取第一个结果作为返回值，而剩余的结果都将会被直接抛弃</strong>。想想每一年的高考状元，大家是不是都只记住了第一名。也许，人生正是如此呢，程序世界固然是由 0 和 1 构成的虚幻世界，可何尝就不是真实世界的某种投影呢？这里请允许博主安利一部动漫<a href="https://movie.douban.com/subject/30401194/" target="_blank" rel="noopener">《你好世界》</a>，它用视觉化的方式表达了真实世界与程序世界的某种特殊联系。</p><h1 id="基于-HttpClientFactory"><a href="#基于-HttpClientFactory" class="headerlink" title="基于 HttpClientFactory"></a>基于 HttpClientFactory</h1><p>接下来，我们要介绍的是基于 <code>HttpClentFactory</code> 的重试方案。也许，大家会感到困惑，明明这篇博客说的是 <code>gRPC</code> ，为什么 <code>HttpClientFactory</code> 会出现在这里呢？其实，很多时候，我们看到的只有表面，而出奇制胜的招式往往出自你对于本质的理解。如果大家阅读过 <code>gRPC</code> 客户端部分的源代码，就会意识到这样一件事情，即，<code>gRPC</code> 底层依然用到了 <code>HttpClient</code> 这套所谓“管道式”的体系，你可以理解为，最终传输层还是要交给 <code>HttpClient</code> 来处理，而 <code>HttpClientFactory</code> 本来就支持结合 <code>Polly</code> 进行重试，所以，我们其实是针对同一个问题的不同阶段进行了切入处理。一旦想清楚这一点，下面的代码理解起来就没有难度啦：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(opt =&gt; &#123;</span><br><span class="line">    opt.Address = <span class="keyword">new</span> Uri(<span class="string">"https://localhost:8001"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.ConfigurePrimaryHttpMessageHandler(() =&gt; <span class="keyword">new</span> HttpClientHandler &#123;</span><br><span class="line">    ClientCertificateOptions = ClientCertificateOption.Manual,</span><br><span class="line">    ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) =&gt; <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">.AddPolicyHandler(</span><br><span class="line">    HttpPolicyExtensions.HandleTransientHttpError()</span><br><span class="line">    .OrResult(res =&gt; res.StatusCode != System.Net.HttpStatusCode.OK)</span><br><span class="line">    .WaitAndRetryAsync(</span><br><span class="line">      <span class="number">6</span>, </span><br><span class="line">      retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="number">2</span>, retryAttempt)) + TimeSpan.FromMilliseconds(<span class="keyword">new</span> Random().Next(<span class="number">0</span>, <span class="number">100</span>)), </span><br><span class="line">      (result, timeSpan, current, context)=&gt; &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">$"StatusCode=<span class="subst">&#123;result.Result?.StatusCode&#125;</span>"</span>);</span><br><span class="line">          Console.WriteLine(<span class="string">$"Exception=<span class="subst">&#123;result.Exception?.Message&#125;</span>"</span>);</span><br><span class="line">          Console.WriteLine(<span class="string">$"正在进行第<span class="subst">&#123;current&#125;</span>次重试，间隔<span class="subst">&#123;timeSpan.TotalMilliseconds&#125;</span>秒"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">await</span> serviceProvider.GetService&lt;Greeter.GreeterClient&gt;().SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">"长安书小妆"</span> &#125;);</span><br></pre></td></tr></table></figure><p>在这里，为了模拟网络不畅的这种场景，我们故意指定了一个错误的终结点信息。此时，我们会得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/5yamSqIzbH3heXF.png" alt="基于 HttpClientFactory 的重试方案" referrerpolicy="no-referrer"></div><div class="image-caption">基于 HttpClientFactory 的重试方案</div></figure><p>不过话又说回来，因为我们选择切入的阶段是“<strong>传输层</strong>”，所以，相对于整个 <code>RpcException</code> 而言，我们其实是找到了一个问题的子集，这意味着这个方案并不能覆盖到所有的场景，如果是在非“<strong>传输层</strong>”引发了某种异常，我们就没有办法通过这种方式去做重试处理。所以，我在一开始就说过，没有 100% 完美的解决方案，每一种方案都有它自身的局限性，这句话在这里得到了第一次印证。如果大家再回过头去看第一种方案，是不是就会发现，它里面还是使用了<code>HTTP</code>状态码作为是否重试的判断依据。所以，大家觉得呢？欢迎大家在评论区留下你的想法。</p><h1 id="基于-gRPC-拦截器"><a href="#基于-gRPC-拦截器" class="headerlink" title="基于 gRPC 拦截器"></a>基于 gRPC 拦截器</h1><p>关于 <code>gRPC</code> 的拦截器，博主专门写过一篇 <a href="https://blog.yuanpei.me/posts/1679688265/" target="_blank" rel="noopener">博客</a> 来介绍它，所以，在一开始考虑重试方案的时候，拦截器其实是最容易想到的一种方案，主要思路是利用 <code>Polly</code> 中<code>Policy</code>的<code>Execute()</code>方法，对拦截器中获取<code>gRPC</code>调用结果的过程进行包装，我们一起来看下面的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">    TRequest request,</span><br><span class="line">    ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span><br><span class="line">    AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> retryPolicy =</span><br><span class="line">        Policy&lt;AsyncUnaryCall&lt;TResponse&gt;&gt;</span><br><span class="line">        .Handle&lt;RpcException&gt;(s =&gt; s.StatusCode == StatusCode.Internal)</span><br><span class="line">        .Or&lt;WebException&gt;()</span><br><span class="line">        .OrResult(r =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> awaiter = r.GetAwaiter();</span><br><span class="line">            <span class="keyword">if</span> (awaiter.IsCompleted)</span><br><span class="line">                <span class="keyword">return</span> r.GetStatus().StatusCode == StatusCode.OK;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.ResponseAsync.Wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AggregateException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .WaitAndRetryAsync(<span class="number">3</span>, x =&gt; TimeSpan.FromSeconds(<span class="number">5</span>), (result, timeSpan, current, context) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"正在进行第<span class="subst">&#123;current&#125;</span>次重试..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retryPolicy.ExecuteAsync(() =&gt; Task.FromResult(continuation(request, context))).Result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 <code>gRPC</code> 拦截器的这种方案，它最大的问题在于异常的颗粒度太大，这句话是什么意思呢？简单来讲就是在拦截器这个层面上，你能捕捉到的只有<code>RpcException</code>，这样就使得我们难以捕获更小粒度的异常，譬如网络异常、超时异常等等。其次，<code>gPRC</code> 拦截器中大量使用了，类似<code>AsyncUnaryCall&lt;TResponse&gt;</code>这样的异步的返回值类型，这让我们在编写 Policy 的时候，多多少少会有一点不自在。综上所述，这个最容易想到的方案，本身是没有太大的问题的，最关键的问题是我们能接受什么样的异常颗粒度。而像异步返回值这种问题，只要写过一次以后，博主以为，它并不会成为我们继续探索的阻碍，这一点大家可以自己去体会。</p><p>在尝试基于拦截器的重试方案的过程中，博主发现，指定一个错误的终结点信息，<code>gRPC</code>会在进入拦截器前就引发异常。这意味着这种基于拦截器的重试方案，在面对“<strong>传输层</strong>”的异常时略显乏力，所以，从某种程度上来讲，这个方案同样是一个不完美的方案。可这世上人来人往、本无完人，我们实在没有必要耽于技术方案的绝对完美而不可自拔，当求真、莫求执，所谓“<strong>大成若缺</strong>”，可以欣赏得来缺憾之美，同样是一种幸福。</p><h1 id="基于-CallInvoker"><a href="#基于-CallInvoker" class="headerlink" title="基于 CallInvoker"></a>基于 CallInvoker</h1><p>如果说，前面的3种方案都属于“<strong>见招拆招</strong>”的外家功夫。那么，接下来我要分享的思路，绝对可以称得上是“<strong>打通任督二脉</strong>”的玄门内功。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/IOwrYtdLXGxMeHf.png" alt="gRPC客户端底层原理说明" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC客户端底层原理说明</div></figure><p>首先，博主想用一张图来讲解 <code>gRPC</code> 客户端的工作原理。从这张图中，我们可以看出，初始化一个<code>gRPC</code>的客户端，主要有<code>GrpcChannel</code>和<code>CallInvoker</code>两种构造形式，而<code>GrpcChannel</code>中的<code>CreateCallInvoker()</code>方法会返回<code>HttpClientCallInvoker</code>的一个实例。此时，我们就会发现，<code>HttpClientCallInvoker</code>是<code>CallInvoker</code>的一个子类。所以，我们基本可以判定<code>CallInvoker</code>是一个扮演着重要角色的类。继续探索，我们就会发现，<code>GrpcCallInvokerFactory</code>内部通过构造<code>GrpcChannel</code>，进而实现了<code>CreateCallInvoker()</code>方法，换句话说，本质上依然是调用了<code>GrpcChannel</code>中的<code>CreateCallInvoker()</code>方法。最终，这个<code>CallInvoker</code>实例会作为参数，传递给<code>DefaultClientActivator</code>的<code>CreateClient()</code>方法，至此我们就完成了整个<code>gRPC</code>客户端的创建工作。</p><p>好了，相信现在大家都有一个疑问，这个<code>CallInvoke</code>到底是个什么东西呢？为什么它在整个<code>gRPC</code>的底层中是如此的重要呢？其实，它就是一个平平无奇的抽象类啦，可是一旦配合着<code>gRPC</code>中的<code>Calls</code>类来使用，这个<code>CallInvoker</code>简直就是扩展<code>gRPC</code>的一个重要的桥梁，因为我们不用关心底层是如何处理<code>gRPC</code>请求/响应的，而这丝毫不影响我们对这个过程进行自定义重写。因此，按照这样的思路，我们有了下面的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GrpcCallInvoker</span> : <span class="title">CallInvoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Channel _channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> GrpcPollyPolicyOptions _pollyOptions;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrpcCallInvoker</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        GrpcPollyPolicyOptions pollyOptions</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _channel = channel;</span><br><span class="line">        _pollyOptions = pollyOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncClientStreamingCall&lt;TRequest, TResponse&gt; AsyncClientStreamingCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, </span><br><span class="line">      CallOptions options</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncClientStreamingCall&lt;TRequest, TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncClientStreamingCall(CreateCall(method, host, options)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt; AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, </span><br><span class="line">      CallOptions options</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncDuplexStreamingCall(CreateCall(method, host, options)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncServerStreamingCall&lt;TResponse&gt; AsyncServerStreamingCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, CallOptions options, </span><br><span class="line">      TRequest request</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncServerStreamingCall&lt;TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncServerStreamingCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, </span><br><span class="line">      CallOptions options, </span><br><span class="line">      TRequest request</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncUnaryCall&lt;TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncUnaryCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> TResponse BlockingUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">      Method&lt;TRequest, TResponse&gt; method, </span><br><span class="line">      <span class="keyword">string</span> host, </span><br><span class="line">      CallOptions options, </span><br><span class="line">      TRequest request</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;TResponse&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.BlockingUnaryCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想，经过连续三篇文章的洗礼，大家对这些方法应该都不陌生了吧！下面我们来着重讲解下<code>CreateCall()</code>和<code>CreatePollyPolicy()</code>这两个方法。其中，<code>CreateCall()</code>这个方法会相对简单一点，因为它完全就是返回<code>gRPC</code>的内置类型<code>CallInvocationDetails</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> CallInvocationDetails&lt;TRequest, TResponse&gt; CreateCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">    Method&lt;TRequest, TResponse&gt; method,</span><br><span class="line">    <span class="keyword">string</span> host,</span><br><span class="line">    CallOptions options</span><br><span class="line">)</span><br><span class="line">    <span class="keyword">where</span> TRequest : <span class="keyword">class</span></span><br><span class="line">    <span class="title">where</span> <span class="title">TResponse</span> : <span class="title">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallInvocationDetails&lt;TRequest, TResponse&gt;(_channel, method, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，<code>CreatePollyPolicy()</code>这个方法就非常的明确啦，通过注入的<code>GrpcPollyPolicyOptions</code>来构造一个Policy。考虑到我们要做的是一个通用的方案，这里预留了<strong>断路器</strong>、<strong>重试</strong>、<strong>超时</strong>三种不同策略的参数。如果希望对构建Policy的过程进行自定义，则可以通过重写该方法来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Policy&lt;TResult&gt; CreatePollyPolicy&lt;TResult&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    Policy&lt;TResult&gt; policy = <span class="literal">null</span>; ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造断路器策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.CircuitBreakerCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policyBreaker = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Exception&gt;()</span><br><span class="line">            .CircuitBreaker(_pollyOptions.CircuitBreakerCount, _pollyOptions.CircuitBreakerTime);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? policyBreaker :</span><br><span class="line">                    policy.Wrap(policyBreaker) <span class="keyword">as</span> Policy&lt;TResult&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断路器降级</span></span><br><span class="line">        <span class="keyword">var</span> policyFallBack = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Polly.CircuitBreaker.BrokenCircuitException&gt;()</span><br><span class="line">            .Fallback(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">default</span>(TResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        policy = policyFallBack.Wrap(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造超时策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.Timeout &gt; TimeSpan.Zero)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policyTimeout = Policy.Timeout(() =&gt; _pollyOptions.Timeout, Polly.Timeout.TimeoutStrategy.Pessimistic);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? (Policy&lt;TResult&gt;)policyTimeout.AsPolicy&lt;TResult&gt;() :</span><br><span class="line">        policy.Wrap(policyTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时降级</span></span><br><span class="line">        <span class="keyword">var</span> policyFallBack = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Polly.Timeout.TimeoutRejectedException&gt;()</span><br><span class="line">            .Fallback(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">default</span>(TResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        policy = policyFallBack.Wrap(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造重试策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.RetryCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> retryPolicy = Policy&lt;TResult&gt;.Handle&lt;Exception&gt;().WaitAndRetry(</span><br><span class="line">          _pollyOptions.RetryCount, </span><br><span class="line">          x =&gt; _pollyOptions.RetryInterval, </span><br><span class="line">          (result, timeSpan, current, context) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"正在进行第<span class="subst">&#123;current&#125;</span>次重试，间隔<span class="subst">&#123;timeSpan.TotalSeconds&#125;</span>秒"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? retryPolicy :</span><br><span class="line">            policy.Wrap(retryPolicy) <span class="keyword">as</span> Policy&lt;TResult&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们无法修改<code>DefaultGrpcClientFactory</code>中关于<code>CallInvoker</code>这部分的逻辑，所以，我们采取了下面的“<strong>迂回战术</strong>”：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc();</span><br><span class="line">services.AddTransient&lt;GrpcCallInvoker&gt;();</span><br><span class="line">services.AddTransient&lt;Channel&gt;(sp =&gt; <span class="keyword">new</span> Channel(<span class="string">"localhost"</span>, <span class="number">5001</span>, ChannelCredentials.Insecure));</span><br><span class="line">services.AddTransient&lt;GrpcPollyPolicyOptions&gt;(sp =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GrpcPollyPolicyOptions()</span><br><span class="line">    &#123;</span><br><span class="line">        RetryCount = <span class="number">10</span>,</span><br><span class="line">        RetryInterval = TimeSpan.FromSeconds(<span class="number">1</span>),</span><br><span class="line">        CircuitBreakerCount = <span class="number">5</span>,</span><br><span class="line">        CircuitBreakerTime = TimeSpan.FromSeconds(<span class="number">6</span>),</span><br><span class="line">        Timeout = TimeSpan.FromSeconds(<span class="number">10</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callInvoker = services.BuildServiceProvider().GetService&lt;GrpcCallInvoker&gt;();</span><br><span class="line"><span class="keyword">var</span> client = (Greeter.GreeterClient)Activator.CreateInstance(<span class="keyword">typeof</span>(Greeter.GreeterClient), callInvoker);</span><br><span class="line">client.SayHello(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">"长安书小妆"</span> &#125;);</span><br></pre></td></tr></table></figure><p>此时，如果我们故意写一个错误的终结点地址，我们将会得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/09/m67kG1hDfgyPJKs.png" alt="基于 CallInvoker 的重试方案" referrerpolicy="no-referrer"></div><div class="image-caption">基于 CallInvoker 的重试方案</div></figure><p>因为重试 5 次后就会启动断路器，所以，这个接口在重试 5 次后就立即停止了调用，这证明我们设想的这个方案是可以完美工作的！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>写完以后，突然发现这一篇的信息量有点爆炸，尤其是<code>CallInvoker</code>这一部分，需要花点时间去阅读 <a href="https://github.com/grpc/grpc-dotnet" target="_blank" rel="noopener">gRPC</a> 的源代码。可对于博主而言，其实更加享受的是，探索 <code>gRPC</code> 重试方案的这个过程。起初，因为对拦截器更熟悉一点，所以，我最先想到的是基于拦截器的重试方案。经过博主一番验证以后，发现这是一个有缺陷的方案。这时候，我意外发现，官方提供了重试策略，可这个重试策略对于使用者来说是一个黑盒子。再后来，发现可以在 HttpClient 上做一点文章，虽然它针对的是“<strong>传输层</strong>”这个阶段。直到从网上查资料，意识到可以重写<code>CallInvoker</code>这个抽象类，这个时候终于找到了最完美的方案。所以，通过这个过程，大家可以发现，我这篇博客的写作过程，其实与我思考过程有着明显的不同。思考的过程中带入“<strong>先入为主</strong>”的意识，这让我的思考过程走了不少的弯路，而写作过程则是一个由浅入深、由表及里的顺序。也许，下一次遇到类似的问题，我会先了解一下官方有没有提供标准方案，这是我在写完这篇博客以后最大的一个感悟。好了，这篇博客就先写到这里啦，如果大家对文中的内容由意见或者建议，欢迎大家在评论区给我留言，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="Polly" scheme="https://qinyuanpei.github.io/tags/Polly/"/>
    
      <category term="重试" scheme="https://qinyuanpei.github.io/tags/%E9%87%8D%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core gRPC 健康检查的探索与实现</title>
    <link href="https://qinyuanpei.github.io/posts/1657075397/"/>
    <id>https://qinyuanpei.github.io/posts/1657075397/</id>
    <published>2021-06-01T11:37:36.000Z</published>
    <updated>2021-06-22T07:04:41.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>各位朋友，大家好，欢迎大家关注我的博客。在上一篇 <a href="https://blog.yuanpei.me/posts/1679688265/" target="_blank" rel="noopener">博客</a> 中，博主和大家分享了<code>gRPC</code>的拦截器在日志记录方面的简单应用，今天我们继续来探索<code>gRPC</code>在构建微服务架构方面的可能性。其实，从博主个人的理解而言，不管我们的微服务架构是采用<code>RPC</code>方式还是采用<code>RESTful</code>方式，我们最终要面对的问题本质上都是一样的，博主这里将其归纳为：服务划分、服务编写 和 服务治理。首先，服务划分决定了每一个服务的上下文边界以及服务颗粒度大小，如果按照领域驱动设计(<strong>DDD</strong>)的思想来描述微服务，我认为它更接近于限界上下文(<strong>BoundedContext</strong>)的概念。其次，服务编写决定了每一个服务的具体实现方式，譬如是采用无状态的<code>RESTful</code>风格的<code>API</code>，还是采用强类型的、基于代理的<code>RPC</code>风格的<code>API</code>。最后，服务治理是微服务架构中永远避不开的话题，服务注册、服务发现、健康检查、日志监控等等一切的话题，其实都是在围绕着<strong>服务治理</strong>而展开，尤其是当我们编写了一个又一个的服务以后，此时该如何管理这些浩如“<strong>星</strong>”海的服务呢？所以，在今天这篇博客中，博主想和大家一起探索下<code>gRPC</code>的健康检查，希望能给大家带来一点启发。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/02/oVS3YkPIncr2xM9.jpg" alt="健康检查-服务注册-服务发现示意图" referrerpolicy="no-referrer"></div><div class="image-caption">健康检查-服务注册-服务发现示意图</div></figure><p>关于“健康检查”，大家都知道的一点是，它起到一种“防微杜渐”的作用。不知道大家还记不记得，语文课本里的经典故事《扁鹊见蔡桓公》，扁鹊一直在告知蔡桓公其病情如何，而蔡桓公讳疾忌医，直至病入骨髓、不治而亡。其实，对应到我们的领域知识，后端依赖的各种服务譬如数据库、消息队列、Redis、API等等，都需要这样一个“<strong>扁鹊</strong>”来实时地“<strong>望闻问切</strong>”，当发现问题的时候及时地采取相应措施，不要像“<strong>蔡桓公</strong>”一样病入骨髓，等到整个系统都瘫痪了，这时候火急火燎地去“救火”，难免会和蔡桓公一样，发出“悔之晚矣”的喟叹。当我们决定使用<code>gRPC</code>来构建微服务架构的时候，我们如何确保这些服务一直是可用的呢？所以，提供一种针对<code>gRPC</code>服务的健康检查方案就会显得非常迫切。这里，博主主要为大家介绍两种实现方式，它们分别是：基于<code>IHostedService</code>的实现方式 以及 基于<code>Consul</code>的实现方式。</p><h1 id="基于-IHostedService-的实现方式"><a href="#基于-IHostedService-的实现方式" class="headerlink" title="基于 IHostedService 的实现方式"></a>基于 IHostedService 的实现方式</h1><p>第一种方式，主要是利用<code>IHostedService</code>可以在程序后台执行的特点，搭配<code>Timer</code>就可以实现定时轮询。在 <a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">gRPC</a> 的 <a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">官方规范</a> 中，提供了一份<code>Protocol Buffers</code>的声明文件，它规定了一个健康检查服务必须实现<code>Check()</code>和<code>Watch()</code>两个方法。既然是官方定义好的规范，建议大家不要修改这份声明文件，我们直接沿用即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">package grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  string service = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    SERVING = 1;</span><br><span class="line">    NOT_SERVING = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line">  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要实现对应的<code>HealthCheckService</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class HealthCheckService : Health.HealthBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HealthCheckResponse&gt; <span class="title">Check</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerCallContext context</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HealthCheckResponse() &#123; </span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">Watch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      IServerStreamWriter&lt;HealthCheckResponse&gt; responseStream, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerCallContext context</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> HealthCheckResponse()&#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要实现<code>HostedHealthCheckService</code>，它实现了<code>IHostedService</code>接口，并在其中调用<code>HealthCheckService</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HostedHealthCheckService</span> : <span class="title">IHostedService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Timer _timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HostedHealthCheckService&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostedHealthCheckService</span>(<span class="params">ILogger&lt;HostedHealthCheckService&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(HostedHealthCheckService)&#125;</span> start running...."</span>);</span><br><span class="line">        _timer = <span class="keyword">new</span> Timer(DoCheck, <span class="literal">null</span>, TimeSpan.Zero, TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(HostedHealthCheckService)&#125;</span> stop running...."</span>);</span><br><span class="line">        _timer?.Change(Timeout.Infinite, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoCheck</span>(<span class="params"><span class="keyword">object</span> state</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>); ;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> Health.HealthClient(channel);</span><br><span class="line">        client.Check(<span class="keyword">new</span> HealthCheckRequest() &#123; Service = <span class="string">"https://localhost:5001"</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，是大家非常熟悉的<strong>依赖注入</strong>环节：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigureServices</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GrpcServerLoggingInterceptor&gt;());</span><br><span class="line">    services.AddHostedService&lt;HostedHealthCheckService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;HealthCheckService&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大家对上一篇博客中的拦截器还有印象，对于下面的结果应该会感到非常亲切：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/02/vx2QLUoMzXaWpZY.png" alt="基于 IHostedService 的 gRPC 健康检查" referrerpolicy="no-referrer"></div><div class="image-caption">基于 IHostedService 的 gRPC 健康检查</div></figure><p>除此以外，我们还可以直接安装第三方库：<code>Grpc.HealthCheck</code>。此时，我们需要继承<code>HealthServiceImpl</code>类并重写其中的<code>Check()</code>和<code>Watch()</code>方法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthCheckService</span> : <span class="title">HealthServiceImpl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HealthCheckResponse&gt; <span class="title">Check</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerCallContext context</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HealthCheckResponse()</span><br><span class="line">        &#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">Watch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      IServerStreamWriter&lt;HealthCheckResponse&gt; responseStream, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerCallContext context</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> HealthCheckResponse()</span><br><span class="line">        &#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们只需要在<code>HostedHealthCheckService</code>调用它即可，这个非常简单。</p><p>故，无需博主多言，相信屏幕前的你都能写得出来，如果写不出来，参考博主给出得实现即可(逃！</p><h1 id="基于-Consul-的实现方式"><a href="#基于-Consul-的实现方式" class="headerlink" title="基于 Consul 的实现方式"></a>基于 Consul 的实现方式</h1><p><a href="https://www.consul.io/" target="_blank" rel="noopener">Consul</a> 是一个由 <a href="https://www.hashicorp.com/about" target="_blank" rel="noopener">HashiCorp</a> 提供的产品，它提供了服务注册、服务发现、健康检查、键值存储等等的特性。这里，我们通过集成它的<code>SDK</code>来实现<code>gRPC</code>服务的服务注册、服务发现、健康检查，从某种程度上来讲，它无形中帮助我们实现了客户端的负载均衡，因为我们可以将每一个服务的终结点都注册到<code>Consul</code>中，而<code>Consul</code>的健康检查则可以定时移除那些不可用的服务。所以，客户端获得的终结点实际上都是可用的终结点。</p><p>首先，我们需要安装第三方库：<code>Consul</code>。接下来，我们可需要通过<code>Docker</code>安装一下<code>Consul</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull consul</span><br><span class="line">docker run --name consul -d -p 8500:8500 consul</span><br></pre></td></tr></table></figure><p>默认情况下，<code>Consul</code>的端口号为：8500，我们可以直接访问：<code>http://localhost:8500</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/02/Gjb9XhpRCI7g2w5.png" alt="Consul 界面效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">Consul 界面效果展示</div></figure><p>接下来，为了让<code>Startup</code>类看起来清爽一点，首先，我们先来写一点扩展方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定的gRPC服务添加健康检查</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> AddGrpcHealthCheck&lt;TService&gt;(<span class="keyword">this</span> IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> configuration = services.BuildServiceProvider().GetService&lt;IConfiguration&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册ConsulClient</span></span><br><span class="line">    services.AddSingleton&lt;IConsulClient, ConsulClient&gt;(_ =&gt; <span class="keyword">new</span> ConsulClient(consulConfig =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> baseUrl = configuration.GetValue&lt;<span class="keyword">string</span>&gt;(<span class="string">"Consul:BaseUrl"</span>);</span><br><span class="line">        consulConfig.Address = <span class="keyword">new</span> Uri(baseUrl);</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册gRPC服务</span></span><br><span class="line">    RegisterConsul&lt;TService&gt;(services).Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>RegisterConsul()</code>方法负责告诉<code>Consul</code>，某个服务对应的IP和端口号分别是多少，采用什么样的方式进行健康检查。</p><p>不过，由于<code>Consul</code>默认不支持<code>gRPC</code>的健康检查，所以，我们使用了更为常见的基于<code>TCP</code>方式的健康检查。你可以认为，只要服务器连接畅通，<code>gRPC</code>服务就是健康的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册指定服务到Consul</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task RegisterConsul&lt;TService&gt;(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serverHost = GetLocalIP();</span><br><span class="line">    <span class="keyword">var</span> serverPort = services.BuildServiceProvider().GetService&lt;IConfiguration&gt;().GetValue&lt;<span class="keyword">int</span>&gt;(<span class="string">"gRPC:Port"</span>);</span><br><span class="line">    <span class="keyword">await</span> RegisterConsul&lt;TService&gt;(services, serverHost, serverPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册指定服务到Consul</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task RegisterConsul&lt;TService&gt;(</span><br><span class="line">  IServiceCollection services, </span><br><span class="line">  <span class="keyword">string</span> serverHost, </span><br><span class="line">  <span class="keyword">int</span> serverPort</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> client = services.BuildServiceProvider().GetService&lt;IConsulClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> registerID = <span class="string">$"<span class="subst">&#123;<span class="keyword">typeof</span>(TService).Name&#125;</span>-<span class="subst">&#123;serverHost&#125;</span>:<span class="subst">&#123;serverPort&#125;</span>"</span>;</span><br><span class="line">    <span class="keyword">await</span> client.Agent.ServiceDeregister(registerID);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.Agent.ServiceRegister(<span class="keyword">new</span> AgentServiceRegistration()</span><br><span class="line">    &#123;</span><br><span class="line">        ID = registerID,</span><br><span class="line">        Name = <span class="keyword">typeof</span>(TService).Name,</span><br><span class="line">        Address = serverHost,</span><br><span class="line">        Port = serverPort,</span><br><span class="line">        Check = <span class="keyword">new</span> AgentServiceCheck</span><br><span class="line">        &#123;</span><br><span class="line">            TCP = <span class="string">$"<span class="subst">&#123;serverHost&#125;</span>:<span class="subst">&#123;serverPort&#125;</span>"</span>,</span><br><span class="line">            Status = HealthStatus.Passing,</span><br><span class="line">            DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">            Interval = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">            Timeout = TimeSpan.FromSeconds(<span class="number">5</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        Tags = <span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"gRpc"</span> &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Consul</code>中的健康检查，更常用的是基于<code>HTTP</code>的健康检查，简单来说，就是我们提供一个接口，供<code>Consul</code>来调用，我们可以去设置请求的头(Header)、消息体(Body)、方法(Method)等等。所以，对于这里的实现，你还可以替换为更一般的实现，即提供一个API接口，然后在这个接口中调用<code>gRPC</code>的客户端。除此以外，如果你擅长写脚本，<code>Consul</code>同样支持脚本级别的健康检查。</p><p>在这里，博主水平扩展(复制)了两套服务，它们分别被部署在<code>5001</code>和<code>6001</code>两个端口上，通过<code>Consul</code>能达到什么效果呢？我们一起来看一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigureServices</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GrpcServerLoggingInterceptor&gt;());</span><br><span class="line">    services.AddGrpcHealthCheck&lt;GreeterService&gt;();</span><br><span class="line">    services.AddGrpcHealthCheck&lt;CalculatorService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;();</span><br><span class="line">        endpoints.MapGrpcService&lt;CalculatorService&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，此时，我们注意到<code>Consul</code>中有两个服务注册进去，它们分别是：<code>GreeterService</code> 和 <code>CalculatorService</code>：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/02/eTBj7Iqn256GXKw.png" alt="gRPC 服务成功注册到 Consul 中" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC 服务成功注册到 Consul 中</div></figure><p>以其中一个<code>CalculatorService</code>为例，我们可以注意到，它的确注册了<code>5001</code>和<code>6001</code>两个实例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/03/xlhMjJ1ZcN3nwBe.png" alt="CalculatorService 的两个实例" referrerpolicy="no-referrer"></div><div class="image-caption">CalculatorService 的两个实例</div></figure><p>至此，我们就完成了基于<code>Consul</code>的健康检查，在这里，图中的绿色标记表示服务可用。</p><h1 id="关于-gRPC-的引申话题"><a href="#关于-gRPC-的引申话题" class="headerlink" title="关于 gRPC 的引申话题"></a>关于 gRPC 的引申话题</h1><p>其实，写到这里的时候，这篇博客就该接近尾声啦，因为对于 gRPC 健康检查的探索基本都已找到答案，可我还是想聊一聊关于 gRPC 的引申话题。理由特别简单，就是在我看来，接下来要讲的这点内容，完全撑不起一篇博客的篇幅，索性就在这篇博客里顺带一提。我打算分享两个话题，<strong>其一，是 gRPC 客户端的负载均衡；其二，是 gRPC 接口的测试工具。</strong></p><h2 id="gRPC-客户端的负载均衡"><a href="#gRPC-客户端的负载均衡" class="headerlink" title="gRPC 客户端的负载均衡"></a>gRPC 客户端的负载均衡</h2><p>截止到目前为止，结合<code>Consul</code>我们已经实现了服务注册和服务发现两个功能。通过调研我们可以发现，针对服务器端的<code>gRPC</code>的负载均衡，目前主要有<code>Nginx</code>和<code>Envoy</code>两种方案，这两种相方案对要更复杂一点，博主目前所在的公司，在<code>gRPC</code>的负载均衡上感觉是个空白，这算是博主想要研究<code>gRPC</code>的一个主要原因。而在这里，由于<code>Consul</code>里注册了所有<code>gRPC</code>服务的终结点信息，所以，我们更容易想到的，其实是客户端的负载均衡，具体怎么实现呢？我们一起看一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从Consul中获取服务终结点信息</span></span><br><span class="line"><span class="keyword">var</span> consulClient = serviceProvider.GetService&lt;IConsulClient&gt;();</span><br><span class="line"><span class="keyword">var</span> serviceName = <span class="keyword">typeof</span>(TGrpcClient).Name.Replace(<span class="string">"Client"</span>, <span class="string">"Service"</span>);</span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">await</span> consulClient.Health.Service(serviceName, <span class="keyword">string</span>.Empty, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> serviceUrls = services.Response.Select(s =&gt; <span class="string">$"<span class="subst">&#123;s.Service.Address&#125;</span>:<span class="subst">&#123;s.Service.Port&#125;</span>"</span>).ToList();</span><br><span class="line"><span class="keyword">if</span> (serviceUrls == <span class="literal">null</span> || !serviceUrls.Any())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Please make sure service <span class="subst">&#123;serviceName&#125;</span> is registered in consul"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造Channel和Client</span></span><br><span class="line"><span class="keyword">var</span> serviceUrl = serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Count - <span class="number">1</span>)];</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">$"https://<span class="subst">&#123;serviceUrl&#125;</span>"</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> <span class="keyword">var</span> client = <span class="keyword">new</span> Calculator.CalculatorClient(channel);</span><br><span class="line"><span class="keyword">await</span> client.CalcAsync(<span class="keyword">new</span> CalculatorRequest() &#123; Num1 = <span class="number">10</span>, Op = <span class="string">"+"</span>, Num2 = <span class="number">12</span> &#125;);</span><br></pre></td></tr></table></figure><p>可以看出，基本思路就是从<code>Consul</code>里拿到对应服务的终结点信息，然后构造出<code>GrpcChannel</code>，再通过<code>GrpcChannel</code>构造出Client即可。</p><p>不过，博主觉得这个过程有一点繁琐，我们有没有办法让这些细节隐藏起来呢？于是，我们有了下面的改进方案：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;TGrpcClient&gt; GetGrpcClientAsync&lt;TGrpcClient&gt;(</span><br><span class="line">  <span class="keyword">this</span> IServiceProvider serviceProvider</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> consulClient = serviceProvider.GetService&lt;IConsulClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> serviceName = <span class="keyword">typeof</span>(TGrpcClient).Name.Replace(<span class="string">"Client"</span>, <span class="string">"Service"</span>);</span><br><span class="line">    <span class="keyword">var</span> services = <span class="keyword">await</span> consulClient.Health.Service(serviceName, <span class="keyword">string</span>.Empty, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> serviceUrls = services.Response.Select(s =&gt; <span class="string">$"<span class="subst">&#123;s.Service.Address&#125;</span>:<span class="subst">&#123;s.Service.Port&#125;</span>"</span>).ToList();</span><br><span class="line">    <span class="keyword">if</span> (serviceUrls == <span class="literal">null</span> || !serviceUrls.Any())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Please make sure service <span class="subst">&#123;serviceName&#125;</span> is registered in consul"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> serviceUrl = serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Count - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">$"https://<span class="subst">&#123;serviceUrl&#125;</span>"</span>);</span><br><span class="line">    <span class="keyword">var</span> constructorInfo = <span class="keyword">typeof</span>(TGrpcClient).GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(GrpcChannel) &#125;);</span><br><span class="line">    <span class="keyword">if</span> (constructorInfo == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Please make sure <span class="subst">&#123;<span class="keyword">typeof</span>(TGrpcClient).Name&#125;</span> is a gRpc client"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clientInstance = (TGrpcClient)constructorInfo.Invoke(<span class="keyword">new</span> <span class="keyword">object</span>[] &#123; channel &#125;);</span><br><span class="line">    <span class="keyword">return</span> clientInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，有没有觉得简单一点？完美！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">await</span> serviceProvider.GetGrpcClientAsync&lt;CalculatorClient&gt;();</span><br><span class="line"><span class="keyword">await</span> client.CalcAsync(<span class="keyword">new</span> CalculatorRequest() &#123; Num1 = <span class="number">1</span>, Num2 = <span class="number">2</span>, Op = <span class="string">"+"</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="gRPC-接口的测试工具"><a href="#gRPC-接口的测试工具" class="headerlink" title="gRPC 接口的测试工具"></a>gRPC 接口的测试工具</h2><p>我猜，大多数看到这个标题会一脸鄙夷，心里大概会想，就测试工具这种东西值得特地写出来吗？诚然，以前写API接口的时候，大家都是用 <a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">Postman</a> 或者 <a href="https://www.apifox.cn/" target="_blank" rel="noopener">Apifox</a> 这样的工具来进行测试的，可是突然有一天你要调试一个<code>gRPC</code>的接口，你总不能每次都调用客户端啊，所以，这里要给大家推荐两个<code>gRPC</code>接口的测试工具，它们分别是: <a href="https://github.com/fullstorydev/grpcurl" target="_blank" rel="noopener">grpcurl</a> 和 <a href="https://github.com/fullstorydev/grpcui" target="_blank" rel="noopener">grpcui</a>，它们都出自同一个人 <a href="https://github.com/fullstorydev" target="_blank" rel="noopener">FullStory</a> 之手，基于Go语言开发，简单介绍下使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 建议使用国内源</span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line">// grpcurl</span><br><span class="line">brew install grpcurl</span><br><span class="line"></span><br><span class="line">// grpcui</span><br><span class="line">go get github.com/fullstorydev/grpcui/...</span><br><span class="line">go install github.com/fullstorydev/grpcui/cmd/grpcui</span><br><span class="line"></span><br><span class="line">// 安装后的路径为：C:\Users\&lt;User&gt;\go\bin\grpcui.exe</span><br><span class="line">grpcui -bind &lt;Your-IP&gt; -plaintext &lt;Your-gRPC-Service&gt;</span><br></pre></td></tr></table></figure><p>虽然这个说明简单而直白，可我还是没能装好，我不得不祭出Docker这个神器，果然它不会令我失望：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull wongnai/grpcui</span><br><span class="line">docker run -e GRPCUI_SERVER=localhost:5001 -p 8080:8080 wongnai/grpcui</span><br></pre></td></tr></table></figure><p>这里有两个重要的参数，其中，<code>8080</code>是<code>grpcui</code>的服务地址，可以按个人喜好进行修改，<code>GRPCUI_SERVER</code>是<code>gRPC</code>服务地址，该工具运行效果如下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/03/gGMaVKquDbtdWUN.png" alt="gRPCUI 接口测试工具" referrerpolicy="no-referrer"></div><div class="image-caption">gRPCUI 接口测试工具</div></figure><p>对于使用者来说，我们只需要选择服务(service)、方法(rpc)、然后填入参数即可，个人感觉非常方便。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文探索并实现了<code>gRPC</code>服务健康检查，主要提供了两种思路：基于<code>IHostedService</code> + <code>Timer</code>的轮询的方案 以及 基于<code>Consul</code>的集服务注册、服务发现、健康检查于一身的方案。特别地，对于后者而言，我们可以顺理成章地联想到客户端的负载均衡，其原理是：<code>Consul</code>中注册了所有<code>gRPC</code>服务的终结点信息，通过<code>IConsulClient</code>可以拿到所有可用的终结点信息，只要以此为基础来构建<code>GrpcChannel</code>即可。根据这个原理，我们引申出了<code>gRPC</code>客户端负载均衡的相关话题，这里我们采用的是随机选择一个终结点信息的做法，事实上，按照一般负载均衡的理论，我们还可以采取轮询、加权、Hash等等的算法，大家可以按照自己的业务场景来选择合适的方法。最后，我们简单介绍了下<code>gRPC</code>接口测试方面的内容，它可以帮助我们更高效地编写、验证<code>gRPC</code>接口。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、参与讨论，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term="微服务" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="健康检查" scheme="https://qinyuanpei.github.io/tags/%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    
      <category term="Consul" scheme="https://qinyuanpei.github.io/tags/Consul/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core gRPC 拦截器的使用技巧分享</title>
    <link href="https://qinyuanpei.github.io/posts/1679688265/"/>
    <id>https://qinyuanpei.github.io/posts/1679688265/</id>
    <published>2021-05-26T09:03:35.000Z</published>
    <updated>2021-06-22T07:04:41.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p><code>gRPC</code>是微软在<code>.NET Core</code> 及其后续版本中主推的 RPC 框架，它使用 <code>Google</code> 的 <code>Protocol Buffers</code> 作为序列化协议，使用 <strong>HTTP/2</strong> 作为通信协议，具有<strong>跨语言</strong>、<strong>高性能</strong>、<strong>双向流式调用</strong>等优点。考虑到，接下来要参与的是，一个以<code>gRPC</code>为核心而构建的微服务项目。因此，博主准备调研一下<code>gRPC</code>的相关内容，而首当其冲的，则是从 .NET Core 3.1 开始就有的拦截器，它类似于<code>ASP.NET Core</code>中的过滤器和中间件，体现了一种面向切面编程(<strong>AOP</strong>)的思想，非常适合在RPC服务调用的时候做某种统一处理，譬如参数校验、身份验证、日志记录等等。在今天这篇博客中，博主主要和大家分享的是，利用 .NET Core gRPC 中的拦截器实现日志记录的简单技巧，希望能给大家带来一点启发。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/28/1MgBG2uRHwEqXvt.jpg" alt="开源、多语言、高性能的 gRPC" referrerpolicy="no-referrer"></div><div class="image-caption">开源、多语言、高性能的 gRPC</div></figure><h1 id="关于-Interceptor-类"><a href="#关于-Interceptor-类" class="headerlink" title="关于 Interceptor 类"></a>关于 Interceptor 类</h1><p><code>Interceptor</code>类是 gRPC 服务拦截器的基类，它本身是一个抽象类，其中定义了下面的虚方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncClientStreamingCall&lt;TRequest, TResponse&gt; AsyncClientStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt; AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> TResponse BlockingUnaryCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task&lt;TResponse&gt; ClientStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> AsyncServerStreamingCall&lt;TResponse&gt; AsyncServerStreamingCall&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task DuplexStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task ServerStreamingServerHandler&lt;TRequest, TResponse&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Task&lt;TResponse&gt; UnaryServerHandler&lt;TRequest, TResponse&gt;();</span><br></pre></td></tr></table></figure><p>整体而言，如果从通信方式上来划分，可以分为：<strong>流式调用</strong> 和 <strong>普通调用</strong>；而如果从使用方来划分，则可以分为：<strong>客户端</strong> 和 <strong>服务端</strong>。进一步讲的话，针对<strong>流式调用</strong>，它还分为：”<strong>单向流</strong>“ 和 “<strong>双向流</strong>“。关于这些细节上的差异，大家可以通过 <code>gRPC</code> 的 <a href="https://www.grpc.io/docs/what-is-grpc/core-concepts/" target="_blank" rel="noopener">官方文档</a> 来了解，这里我们给出的是每一种方法对应的用途：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>AsyncClientStreamingCall</td><td>拦截异步客户端流式调用</td></tr><tr><td>AsyncDuplexStreamingCall</td><td>拦截双向流式调用</td></tr><tr><td>AsyncUnaryCall</td><td>拦截异步普通调用</td></tr><tr><td>BlockingUnaryCall</td><td>拦截阻塞普通调用</td></tr><tr><td>AsyncServerStreamingCall</td><td>拦截异步服务端流式调用</td></tr><tr><td>ClientStreamingServerHandler</td><td>拦截客户端流式调用的服务端处理程序</td></tr><tr><td>DuplexStreamingServerHandler</td><td>拦截双向流式调用的服务端处理程序</td></tr><tr><td>ServerStreamingServerHandler</td><td>拦截服务端流式调用的服务端处理程序</td></tr><tr><td>UnaryServerHandler</td><td>拦截普通调用的服务端处理程序</td></tr></tbody></table><h1 id="实现一个拦截器"><a href="#实现一个拦截器" class="headerlink" title="实现一个拦截器"></a>实现一个拦截器</h1><p>好了，下面我们一起实现一个拦截器。这里，我们使用的是微软官方的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GreeterService : Greeter.GreeterBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GreeterService&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreeterService</span>(<span class="params">ILogger&lt;GreeterService&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HelloReply&gt; <span class="title">SayHello</span>(<span class="params">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HelloReply</span><br><span class="line">        &#123;</span><br><span class="line">            Message = <span class="string">"Hello "</span> + request.Name</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>实现服务器端的普通调用拦截，我们需要重写的方法是<code>UnaryServerHandler</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCServerLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GRPCServerLoggingInterceptor&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GRPCServerLoggingInterceptor</span>(<span class="params">ILogger&lt;GRPCServerLoggingInterceptor&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 UnaryServerHandler() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> Task&lt;TResponse&gt; UnaryServerHandler&lt;TRequest, TResponse&gt;(</span><br><span class="line">      TRequest request, ServerCallContext context, </span><br><span class="line">      UnaryServerMethod&lt;TRequest, TResponse&gt; continuation</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish."</span>);</span><br><span class="line">        _logger.LogInformation(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC请求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> LogRequest&lt;TRequest&gt;(TRequest request)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">is</span> IMessage)</span><br><span class="line">            payload = JsonConvert.SerializeObject(</span><br><span class="line">                (request <span class="keyword">as</span> IMessage)</span><br><span class="line">                .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(request <span class="keyword">as</span> IMessage))</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"Send request of <span class="subst">&#123;<span class="keyword">typeof</span>(TRequest)&#125;</span>:<span class="subst">&#123;payload&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC响应</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> LogResponse&lt;TResponse&gt;(TResponse response, AggregateException exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (response <span class="keyword">is</span> IMessage)</span><br><span class="line">                payload = JsonConvert.SerializeObject(</span><br><span class="line">                  (response <span class="keyword">as</span> IMessage)</span><br><span class="line">                  .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                  .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(response <span class="keyword">as</span> IMessage))</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span>:<span class="subst">&#123;payload&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> errorMsgs = <span class="keyword">string</span>.Join(<span class="string">";"</span>, exception.InnerExceptions.Select(x =&gt; x.Message));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span> throws exceptions: <span class="subst">&#123;errorMsgs&#125;</span>"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>gRPC</code>而言，每一个由<code>.proto</code>声明文件生成的类，都带有一个叫做<code>Descriptor</code>的属性，我们可以利用这个属性获得<code>gRPC</code>请求和响应的详细信息。所以，在<code>LogRequest()</code>和<code>LogResponse()</code>两个方法中，我们均使用了这一思路来记录<code>gRPC</code>的报文信息，因为传输层的<code>gRPC</code>使用了二进制作为数据载体，这可以说是一种用可读性换取高效率的做法，不过幸运的是，我们在这里实现了这个小目标。</p><p>接下来，为了让这个拦截器真正生效，我们还需要修改一下<code>Startup</code>类中注册<code>gRPC</code>这部分的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GRPCServerLoggingInterceptor&gt;());</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/27/3nZXelLPVwJ7AjS.png" alt="gRPC服务器端拦截器效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC服务器端拦截器效果展示</div></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>实现客户端的普通调用拦截，我们需要重写的方法是<code>AsyncUnaryCall()</code>，依样画葫芦即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCClientLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重写 AsyncUnaryCall() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(</span><br><span class="line">        TRequest request,</span><br><span class="line">        ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span><br><span class="line">        AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.ResponseAsync.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.ResponseAsync.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$"Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish."</span>);</span><br><span class="line">        Console.WriteLine(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，为了让拦截器在客户端生效，我们需要这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Grpc.Core.Interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>);</span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line">channel.Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">var</span> invoker = channel.CreateCallInvoker().Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(invoker);</span><br><span class="line"><span class="keyword">await</span> client.SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">"长安书小妆"</span> &#125;);</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/28/XcwmOQbzKTJPtUj.png" alt="gRPC客户端拦截器效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">gRPC客户端拦截器效果展示</div></figure><p>客户端感觉不太好的一点就是，这个<code>Interceptor</code>传入的必须是一个实例，考虑到拦截器内部可能会依赖类似<code>ILogger</code>等等的组件，建议还是通过<code>IoC</code>容器来取得一个拦截器的实例，然后再传入<code>Intercept()</code>方法中。博主所在的项目中，则是非常“<strong>土豪</strong>”地使用了<code>PostSharp</code>，直接走动态编织的方案，果然，“<strong>这次第，怎一个羡字了得</strong>”。当然，<code>gRPC</code>的客户端，其实提供了日志相关的支持，不过，我个人感觉这个有一点无力：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggerFactory = LoggerFactory.Create(logging =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    logging.AddConsole();</span><br><span class="line">    logging.SetMinimumLevel(LogLevel.Debug);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(</span><br><span class="line">    <span class="string">"https://localhost:5001"</span>,</span><br><span class="line">    <span class="keyword">new</span> GrpcChannelOptions &#123; LoggerFactory = loggerFactory &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要分享了<code>gRPC</code>拦截器的使用技巧，<code>gRPC</code>支持一元调用(<strong>UnaryCall</strong>)、流式调用(<strong>StreamingCall</strong>)、阻塞调用(<strong>BlockingCall</strong>)，因为区分客户端和服务器端，所以，实际上会有各种各样的组合方式。<code>gRPC</code>的拦截器实际上就是选择对应的场景去重写相应的方法，其中，拦截器的基类为<code>Interceptor</code>类，这里我们都是以普通的一元调用为例的，大家可以结合各自的业务场景，去做进一步的调整和优化。这里，我们使用<code>IMessage</code>类的<code>Descriptor</code>属性来“反射”报文中定义的字段，这样就实现了针对<code>gRPC</code>服务请求/响应的日志记录功能。关于<code>gRPC</code>中日志和诊断的更进一步的话题，大家可以参考微软的 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/diagnostics?view=aspnetcore-5.0" target="_blank" rel="noopener">官方文档</a> 。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="gRPC" scheme="https://qinyuanpei.github.io/tags/gRPC/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="AOP" scheme="https://qinyuanpei.github.io/tags/AOP/"/>
    
      <category term="日志" scheme="https://qinyuanpei.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>SnowNLP 使用自定义语料进行模型训练</title>
    <link href="https://qinyuanpei.github.io/posts/1772340994/"/>
    <id>https://qinyuanpei.github.io/posts/1772340994/</id>
    <published>2021-05-19T21:22:41.000Z</published>
    <updated>2021-06-22T07:04:41.538Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p><a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 是一个功能强大的中文文本处理库，它囊括了中文分词、词性标注、情感分析、文本分类、关键字/摘要提取、<code>TF/IDF</code>、文本相似度等诸多功能，像<strong>隐马尔科夫模型</strong>、<strong>朴素贝叶斯</strong>、<code>TextRank</code>等算法均在这个库中有对应的应用。如果大家仔细观察过博主的博客，就会发现博主使用了摘要提取这一功能来增强博客的<code>SEO</code>，即通过自然语言处理(<strong>NLP</strong>)技术，提取每一篇文章中的摘要信息。因为 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 本身使用的语料是电商网站评论，所以，当我们面对不同的使用场景时，它自带的这个模型难免会出现“水土不服”。因此，如果我们希望得到更接近实际的结果，最好的方案是使用自定义语料进行模型训练。值得庆幸的是，这一切在 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 中实施起来非常简单，并不需要我们去钻研那些高深莫测的算法。至此，就引出了今天这篇博客的主题，即 SnowNLP 使用自定义语料进行模型训练。</p><p>不知道大家是否还有印象，博主曾经在 <a href="https://blog.yuanpei.me/posts/2758545080/" target="_blank" rel="noopener">《通过Python分析2020年全年微博热搜数据》</a> 这篇文章中提到过 SnowNLP 的模型训练。当时，博主采集了整个 2020 年的微博热搜话题，因为要体现整个一年里的情感变化，博主特意找了两份微博语料，并以此为基础训练出了一个模型文件。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/26/gCcHX7vWlwsZhnI.jpg" alt="2020全年微博热搜情感变化趋势" referrerpolicy="no-referrer"></div><div class="image-caption">2020全年微博热搜情感变化趋势</div></figure><p>那么，具体是怎么样做的呢？我们一起来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> sentiment</span><br><span class="line">sentiment.train(<span class="string">'./train/neg60000.txt'</span>, <span class="string">'./train/pos60000.txt'</span>)</span><br><span class="line">sentiment.save(<span class="string">'weibo.marshal'</span>)</span><br></pre></td></tr></table></figure><p>千万不要怀疑你的眼睛，因为它真的只有短短的三行代码。简单来说，我们只需要准备一个“<strong>积极</strong>”的语料文件，一个“<strong>消极</strong>”的语料文件，它就可以训练出一个模型文件。特别注意的是，如果是在<code>Python 3.X</code>的版本下，最终生成的模型文件的扩展名将会是<code>.3</code>，下图是博主这里训练出的模型文件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/20/EQnaXv3x6Vyfm7j.png" alt="SnowNLP 使用自定义语料进行模型训练" referrerpolicy="no-referrer"></div><div class="image-caption">SnowNLP 使用自定义语料进行模型训练</div></figure><p>好了，一旦训练出这个模型文件，我们就可以考虑替换掉 SnowNLP 的默认模型文件，我们可以在以下位置：<code>\Lib\site-packages\snownlp\sentiment</code> 找到下列文件。为了安全起见，我们首先将原来的模型文件重命名，然后再放入我们自己的模型文件。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/20/C5QS3uhvt1liqXc.png" alt="SnowNLP 使用自定义模型替换默认模型" referrerpolicy="no-referrer"></div><div class="image-caption">SnowNLP 使用自定义模型替换默认模型</div></figure><p>此时，我们就可以利用训练好的模型，分析某一条微博的情感倾向。这里我选取了几条我的微博，看看这个情感倾向预测的结果如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> SnowNLP</span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'我爱你，并不期待回声'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.8760737296091975</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'想找一个人，一起做老爷爷、老奶奶才做的事情，比如，替我拔一拔头上的白头发……[二哈] ​​'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.001629297651780881</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'如果两个人都不爱了，一别两宽，各生欢喜，其实是挺好的结局；可如果还有一个人爱着，对那个人来说，爱又是什么呢？'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.809651945221708</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u'为了发张自拍，特意出来跑步，还有谁？[doge] ​​​'</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.4041057894917053</span></span><br></pre></td></tr></table></figure><p>有人说，双子座是一个白天自愈、晚上孤独的星座，我确信这是真的，因为从我出生的那一刻起，那种宏大宇宙中的孤独感就一直笼罩着我，用一句话来形容，大概就是“<strong>热闹是人家的，我什么都没有</strong>”，因为内心世界里的两个灵魂，从来没有一刻闲歇地在纠缠和撕裂。我一直都想了解一件事情，如果这些基于概率或者是公式的算法，都可以琢磨出人类某个时刻的心境，我们期望别人能懂自己是不是太过矫情，我们是真的了解自己吗？</p><p>OK，说完微博话题这个场景，我们再来说说电影评论这个场景。回想今年过年的时候，一部<a href="https://movie.douban.com/subject/34841067/" target="_blank" rel="noopener">《你好，李焕英》</a>，成为贺岁档电影中的一匹黑马，而相比之下，<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a>则有点“<strong>滑铁卢</strong>”的感觉。为了搞清楚某一部电影真实的评价情况，此时，我们可以考虑使用 SnowNLP ，对影评的情感趋向进行打分。同样地，这里我们找了一部分影评语料，为 SnowNLP 训练一个单独的模型。接下来，我们不妨从豆瓣上抓取一定数量的影评，来验证下我们这里训练好的模型，这里以<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a>为例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/22/5Mo1ncNyEO2K69j.png" alt="从豆瓣上抓取到的电影评论" referrerpolicy="no-referrer"></div><div class="image-caption">从豆瓣上抓取到的电影评论</div></figure><p>可以发现，这些影评的情感趋向介于0到0.1这个区间的数量最多，占到160以上，这意味着约有30%的观众认为这部电影是个不折不扣的烂片。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/22/1hvXtjciPlWBzD9.jpg" alt="唐人街探案3豆瓣影评情感分布" referrerpolicy="no-referrer"></div><div class="image-caption">唐人街探案3豆瓣影评情感分布</div></figure><p>目前，<a href="https://movie.douban.com/subject/27619748/" target="_blank" rel="noopener">《唐人街探案3》</a> 在豆瓣上的评分只有5.5分，其中，2星和3星的评价占到70%以上。由于豆瓣接口的限制，我们大概只能抓到500条左右的影评信息，可即使如此，可以看出大家对这部电影的情绪多少有一点不满。博主当时看这个电影，最大的感受是里面充斥着太多强行搞笑的东西，例如开篇机场那一场打砸抢的戏份，我完全不明白它存在的意义是什么，虽然日本演员们的表演可圈可点，可在这样一个推理和叙事都非常脆弱的故事里，大概就剩下翻来覆去重复使用的搞笑伎俩啦，你敢说医院这场戏和第一部阿香家那场戏没有相似的地方吗？更不用说，医院这场戏大家都在评论里无限吐槽啦！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/22/MRsAc76vgmTEK4z.png" alt="豆瓣电影-唐人街探案3" referrerpolicy="no-referrer"></div><div class="image-caption">豆瓣电影-唐人街探案3</div></figure><p>其实，对于情感，我一直不知道该怎么来讲，可能是程序员的这份理性，让我在维系亲密关系或者说的情感的时候，有时候会生出一种近乎漠然的、置身事外的错觉，换句话说，也许是那种被人称为“<strong>天性凉薄</strong>”的东西。前任同我讲，我最爱的人其实是我自己，并不是她。因为站在她的角度上来讲，她并没有感受到我给予她的爱。我该怎么回答这个问题呢？在一切看似理性的数学计算背后，人类这些极为在乎的情感到底又是什么形式？也许有一天，两个人的感情说变淡就突然变淡，不管我们曾经说过什么样的话，在那一刻都会变得苍白无力，逐年攀升的离婚率触目惊心，可我们每个人都像扑向火焰的飞蛾，在这爱与欲望无法随心所欲的世界里，被欲望裹挟着不断向前。人会变的绝情、冷漠，我们自以为那是成长，可那不过是心变硬了，可这是我们当初期待的长大吗？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/06/08/HrQbtvcjeI1h9M3.png" alt="欢迎来到无法随心所欲的爱与欲望的世界" referrerpolicy="no-referrer"></div><div class="image-caption">欢迎来到无法随心所欲的爱与欲望的世界</div></figure><p>今天，听到袁隆平爷爷去世的消息，除了不断地提醒我们这代人已然老去这个事实以外，也许最大的体会应该是，我们在这个世界上追求的名利、身份和爱，最终都会无可避免地走向消亡，就如同我们身上这具躯壳一样，而真正能流传下去、泽被后世地，永远都是思想、是文化、是技术、是精神。佛家云：人死身灭，大概我们都不得不去接受这个残酷的事实，所以，请放下那些爱而不得、求而不得的执念吧，你一辈子不管遇见多少人，在某一个时候也许就会荡然无存，爱会消失、身会毁灭，这一切都是宇宙间的自然法则，与其去纠结那些“<strong>薛定谔态</strong>”的事物，不如多为这个世界做一点有意义的事情，正如尼采的那句名言，“<strong>对待生命你不妨大胆冒险一点, 因为无论如何你都要失去它</strong>”，我也许并不真正懂得人类的情感，因为它在理性面前毫无意义，世间万物毫无例外地走向那个坍塌的奇点，这难道不是一种荒凉的美感吗？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/05/22/kjR2nVSHlDNrCLi.jpg" alt="人的心情难道不是一个黑洞" referrerpolicy="no-referrer"></div><div class="image-caption">人的心情难道不是一个黑洞</div></figure><p>嘘，如果你读到这里，意外发现这是一篇水字数的博客，而这或许说明了一件事情，我的确是一个会懈怠、会疲倦的活生生的人。关于 SnowNLP 使用自定义语料进行模型训练的话题，这次我们就先写到这里，做数据挖掘的时候，有的人在乎的是最终的结果，而有的人享受的是整个过程，人类的情感或许是相似的，所以，学着去接受这个多样性有点多到奇葩的世界，学着去和平凡而普通的自己和解吧，欢迎大家在评论区交换想法或者观点，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="NLP" scheme="https://qinyuanpei.github.io/tags/NLP/"/>
    
      <category term="训练" scheme="https://qinyuanpei.github.io/tags/%E8%AE%AD%E7%BB%83/"/>
    
      <category term="模型" scheme="https://qinyuanpei.github.io/tags/%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="情感" scheme="https://qinyuanpei.github.io/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>假如时间有温度</title>
    <link href="https://qinyuanpei.github.io/posts/2136925853/"/>
    <id>https://qinyuanpei.github.io/posts/2136925853/</id>
    <published>2021-05-03T14:00:41.000Z</published>
    <updated>2021-06-22T07:04:41.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>我一直在想，世事无常，该是一种什么样的感觉。直到我读到夏目先生的《我是猫》，先生在书中不无感慨地写道，“<strong>世事变迁就像猫的眼珠一样变幻莫测</strong>”。可此时此刻，我会不由得觉得，世事无常，更像是时间突然间有了温度，“<strong>春观夜樱，夏望繁星，秋赏满月，冬会初雪</strong>”，拥有这般温度的时间毫无疑问是浪漫的，可世事无常所带来的时间的温度，更像是某种意义上的极致，譬如从地球两极瞬移到赤道，或者是一场大爆炸后突兀着的宁静。也许，四季还是那个四季，无非是我一厢情愿的自以为是，时间真的有温度吗？</p><p>这次终于可以乘坐高铁回家，可当列车以每小时250公里的速度呼啸而过时，我已来不及仔细留意车窗外的风景。我隐隐约约地觉得，外面的山丘变得平缓，时不时穿过漆黑悠长的隧道，平原上点缀着麦田和葡萄架，等到列车横跨着黄河驶过的时候，我终于确信我回到了故乡。而我不得不说，人生的境遇里实在有太多的似曾相识，正如此刻窗外的风，兀自呼啸着撼动着那棵我自小便认识的树。回家后收到的第一个消息是，家族中一位叔叔的儿子，在工作时不慎从高处摔落下来，送到医院以后终于还是没能抢救过来，听长辈们讲，彼时他们正在参加某个人的婚礼，一时间百感交集。</p><p>可以说，这是我这么多年来，第一次以一个成年人的身份去面对一个人的离开。因为逝者与我为同一辈人，所以于情于理我都要去吊唁一番。于是，快三十岁的人，第一次有了买花圈、写挽联的经历，甚至我在去见这位叔叔的时候，在脑海中浮现了多次的“还请您节哀顺变”，终于还是没能说出口来。或许是因为事出突然，有太多的身后事需要料理，留给悲伤的时间并不多。在逝者面前焚香、叩拜、鞠躬，虽然有长辈从旁指点，可整套动作还是显得有点僵硬。我终于还是想起来，这个只有27岁的年轻人，在我某次回家探亲的时候，自顾自走上前来，面带微笑的自我介绍道，“我是某某某，你不认得我了吗？”</p><p>有时候想想，我喜欢怀旧，喜欢念念不忘，或许就是因为我怕，怕生命中每一次告别都是永诀。同样可以认为是第一次的，也许是公墓，是陵园，这种从前只有在电视上见到过的东西。于是，在夕阳的映照下，半边天空被染成金黄色，而在这一片荒凉中，一座六角形的塔静静地矗立着。站在一个高坡上一眼望去，满眼都是密密麻麻的墓碑。我在想，有一天人们会不会建成更加极致的地下宫殿，就如同城市中越来越多的高楼大厦一样，唯一的不同，或许是那具比单人床还要小一点的棺木，或者是和小酒坛差不多大的骨灰盒。独自站在旷野中，风吹着塔角的铃铛不时发出响声，我敲击不锈钢柱子时，它竟然发出了沉钟一般的轰鸣，难道人真的有灵魂吗？</p><p>对于死亡，从小到大，我着实经历了不少，小学时爷爷去世，中学时有位同学被歹人杀害，大学时有位同学患白血病不治而亡，工作以后有一位同事因意外而溺水身亡……有时候想想，虽然我的人生，可能并不如别人那般精彩绝伦，可比起失去生命的他们，我能见到更多的人，见到更多的事情，这实在是幸运中的幸运。可或许是因为故事的视角发生了改变，所以，此刻比往常有了更多不由分说的感慨，就好像从前的我，虽然一样是某个事件的亲历者，但那时的我，还不大懂得死亡的意义，都说是人死灯灭，可只有你自己知道，一旦别人彻底地忘记了你，忘记了你在这世上的故事，你就大概的确真的死了罢！我们终其一生，不论记忆以文字还是影像的形式存在，所求者不过是记住别人和被别人记住，人生如朝露也好，如雪泥鸿爪也罢，也许，珍惜此时此刻，方能无惧参商永隔的痛苦吧……</p><p>很多年前，作为长孙的我，举着高过我头顶的引魂幡走在前面，风裹挟着引魂幡的纸穗呼呼作响，那时，我还不知道再也见不到一个人，将会是多么难过的一件事情。后来，我偶尔会回想起，夏天做完农活回来，坐在凉席上吃西瓜的情形，就是在那个时候，爷爷开始埋怨头上有白头发，而我则被拉去帮爷爷找白头发。再后来，我偶尔会想有个人帮我找白头发，可明明我还没到三十岁啊，直到我看到三叔后脑勺开始变白，我终于惊觉，这是二十年前的事情了。有时候想想，我人生中最美好的那几年，同这二十年的长度相比，何尝不是沧海一粟呢？人生时常如此，你觉得几十年特别漫长，可二十年你还不是就这样“弹指一挥间”，而人生又特别短暂，短暂到我们怕这次见了就再见不着彼此。这样想来，拉黑或者删除一个人，成本简直低廉到无法想象，因为失去得太容易，大家就不会有这种看似突兀的想法。浮生倥偬，失散在风里的是沙，而失散在水里的是萍，失散的人们，会有引魂幡前来招魂，然后各自相认吗？</p><p>所以，时间有温度吗？我想，该是有的，因为我们会在时间的长河里放下一盏浮灯，它承载着我们记忆深处最温暖的回忆。可也许这只是我们的一厢情愿，时间自顾自地往前走，从来不在乎人的记忆到底如何，就如同窗外呼啸而过的风，它并不懂得人类内心深处的那些情感，所以，更多的时候，我以为，时间是没有温度的，是冰冷的，是荒凉的，就像我在陵园里看到的夕阳一般冰冷，即使它被晚霞映得金黄。有时候，我会期待时间走得稍微慢一点，出于我的自私，我希望我此刻爱着的、曾经爱过的人们，都能老去地稍微慢一点，因为我怕再见不到那个人，因为我怕时间凝固成冰，因为我怕我终有一天要忘记，因为我怕我永远都赶不上时间，这或许是我想在此时此刻赋予时间的温度，如同人的正常体温37度，或许，它是如此的平静甚至是普通，可是啊，活着真的很好啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://qinyuanpei.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="时间" scheme="https://qinyuanpei.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="生死" scheme="https://qinyuanpei.github.io/tags/%E7%94%9F%E6%AD%BB/"/>
    
  </entry>
  
  <entry>
    <title>使用 HttpMessageHandler 实现 HttpClient 请求管道自定义</title>
    <link href="https://qinyuanpei.github.io/posts/2070070822/"/>
    <id>https://qinyuanpei.github.io/posts/2070070822/</id>
    <published>2021-04-28T20:25:47.000Z</published>
    <updated>2021-06-22T07:04:41.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>最近，博主偶然间在 <a href="https://www.cnblogs.com" target="_blank" rel="noopener">博客园</a> 看到一篇文章：<a href="https://www.cnblogs.com/xfrog/p/14703251.html" target="_blank" rel="noopener">ASP.NET Core 扩展库之 Http 请求模拟</a>，它里面介绍了一种利用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.net.http.httpmessagehandler?view=net-5.0" target="_blank" rel="noopener">HttpMessageHandler</a> 来实现 Http 请求模拟的方案。在日常工作中，我们总是不可避免地要和第三方的服务或者接口打交道，尤其是当我们需要面对“<strong>联调</strong>”这样一件事情的时候。通常，我们可以通过类似 <a href="https://github.com/ymfe/yapi" target="_blank" rel="noopener">YAPI</a> 这样的工具来对尚在开发中的接口进行模拟。可是，因为这种方式会让我们的测试代码依赖于一个外部工具，所以，从严格意义上讲，它其实应该属于“<strong>集成测试</strong>”的范畴。在接触前端开发的过程中，对于其中的 <a href="http://mockjs.com/" target="_blank" rel="noopener">Mock.js</a> 印象深刻。故而，当看到 .NET 中有类似实现的时候，好奇心驱使我对其中的核心，即 <code>HttpMessageHandler</code> 产生了浓厚的兴趣。平时，我们更多的是使用 <a href="https://github.com/moq/moq4" target="_blank" rel="noopener">Moq</a> 这样的库来模拟某一个对象的行为，而对一个 Http 请求进行模拟，可以说是开天辟地头一遭。带着这些问题出发，就有了今天这篇博客，通过 <code>HttpMessageHandler</code> 实现 <code>HttpClient</code> 请求管道的自定义。</p><h1 id="什么是-HttpMessageHandler？"><a href="#什么是-HttpMessageHandler？" class="headerlink" title="什么是 HttpMessageHandler？"></a>什么是 HttpMessageHandler？</h1><p>相信大家读过我提到的文章以后，都能找到这里面最核心的一个点：<code>HttpMessageHandler</code>。于是，我们今天要面对的第一个问题就是，什么是 <code>HttpMessageHandler</code>？此时，我们需要一张历久弥新的示意图，来自 <a href="https://www.asp.net/media/4071077/aspnet-web-api-poster.pdf" target="_blank" rel="noopener">微软官方</a>。这里，我们重点关注的是 <code>DelegatingHandler</code>，它继承自 <code>HttpMessageHandler</code>。通过这张图，我们能够获得哪些信息呢？</p><p>我认为，主要有以下几点：<strong>第一，HttpMessageHandler 处于整个 Http 请求管道的第一梯队，每一个路由匹配的请求都会从这里“进入”和“离开”；第二，HttpMessageHandler 可以是全局配置或者针对某个特定的路由，只要这个路由被匹配到就会执行；第三，HttpMessageHandler 可以直接构造 Http 响应并且返回，跳过剩余的管道流程</strong>。不知道大家看到这里会想到什么？坦白讲，我联想到了.NET Core 中的中间件，而唯一不同的地方或许是，中间件是 ASP.NET Core 里的概念，这里则是 ASP.NET Web API 里的概念。尤其是第三点，它对于我们的意义非常重大，因为它，我们才可以做到对一个 Http 请求进行模拟。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/28/AwLZDdqXc5KERky.png" alt="HttpMessageHandler 与 ASP.NET Web API" referrerpolicy="no-referrer"></div><div class="image-caption">HttpMessageHandler 与 ASP.NET Web API</div></figure><p>而事实上，在 ASP.NET Web API 的设计中，它是由一组 <code>HttpMessageHandler</code> 经过“首尾相连”而成，这种管道式的设计使得框架本身具有很高的扩展性。虽然，作为一个服务端框架，ASP.NET Web API 最主要的作用是就是“<strong>处理请求、响应回复</strong>”，可具体采用的处理策略会因具体场景的不同而不同。所以，管道式设计的本质，就是让某一个 <code>Handler</code> 只负责某个单一的消息处理功能，在根据具体场景的不同，选择需要的 <code>Handler</code> 并将其串联成一个完整的消息处理通道。而在这里，这个负责单一的消息处理功能的 <code>Handler</code> 其实就是 <code>HttpMessageHandler</code>，因为它不单单可以对请求消息(<strong>HttpRequestMessage</strong>)进行处理，同时还可以对响应消息(<strong>HttpResponseMessage</strong>)进行处理。此时，我们就不难理解 <code>HttpMessageHandler</code> 的定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">HttpMessageHandler</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HttpMessageHandler</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">virtual</span> HttpResponseMessage <span class="title">Send</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">abstract</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许，你会忍不住问这样一个问题：<code>DelegatingHandler</code> 和 <code>HttpMessageHandler</code> 的区别是什么？ 其实，只要你稍微仔细一点，你就会发现，两者最大的区别是 <code>DelegatingHandler</code> 里新增一个叫做 <code>InnerHandler</code> 的成员，它本身就是一个 <code>HttpMessageHandler</code>。所以，聪明的你又联想到什么呢？我想，或许是一个叫做 <code>RequestDelegate</code> 的委托，还记得我们写中间件是一直都少不了的 <code>Next</code> 吗？不得不说，这里越来越有中间件的味道了。你可以立马想到的一件事情是，除了最后一个 <code>Handler</code> 是 <code>HttpMessageHandler</code> 以外，剩下的前面的所有的 <code>Handler</code> 都是 <code>DelegatingHandler</code>。为什么这样说呢？因为前面的 <code>n-1</code> 个 <code>Handler</code> 都需要串联下一个 <code>Handler</code>，只有第 <code>n</code> 个 <code>Handler</code>可以允许短路，所以，大概就相当于 <code>Use()</code> 和 <code>Run()</code> 的区别？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">DelegatingHandler</span> : <span class="title">HttpMessageHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DelegatingHandler</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DelegatingHandler</span>(<span class="params">HttpMessageHandler innerHandler</span>)</span>;</span><br><span class="line">    <span class="comment">// InnerHandler是实现管道式设计的关键</span></span><br><span class="line">    <span class="keyword">public</span> HttpMessageHandler? InnerHandler &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> HttpResponseMessage <span class="title">Send</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，此时此刻，你能否为 <code>HttpMessageHandler</code> 下一个清晰的定义呢？我想，或许可以这样理解，一种可以对 请求消息(<strong>HttpRequestMessage</strong>) 和 响应消息(<strong>HttpResponseMessage</strong>) 进行处理，同时多个 <code>HttpMessageHandler</code> 可以组成一个完整的消息处理通道的中间件。屏幕前的你又是如何理解的呢？欢迎大家在评论区留言，留下你对于 <code>HttpMessageHandler</code> 的想法或者认识。</p><h1 id="实现自定义请求管道"><a href="#实现自定义请求管道" class="headerlink" title="实现自定义请求管道"></a>实现自定义请求管道</h1><p>好了，搞清楚 <code>HttpMessageHandler</code> 是什么以后，我们就可以考虑自定义请求管道的实现啦！让我们从一个最简单的示例开始，假设我们这里定义了两个自定义的 <code>Handler</code>，它们分别是： <code>HandlerA</code> 和 <code>HandlerB</code>，我们应该如何将其应用到具体的 <code>HttpClient</code>上呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandlerA</span> : <span class="title">DelegatingHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HandlerA&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerA</span>(<span class="params">ILogger&lt;HandlerA&gt; logger</span>)</span> &#123; _logger = logger; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">"This is Handler A"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.SendAsync(request, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HandlerB</span> : <span class="title">DelegatingHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HandlerB&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerB</span>(<span class="params">ILogger&lt;HandlerB&gt; logger</span>)</span> &#123; _logger = logger; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">"This is Handler B"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.SendAsync(request, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们考虑两种场景，依赖注入 和 非依赖注入。对于依赖注入的场景，我们只需要调用<code>AddHttpMessageHandler()</code>方法按顺序注册即可，不需要处理<code>InnerHandler</code>，这里遵循先注册后使用的原则；对于非依赖注入的场景，需要处理<code>InnerHandler</code>，并在构造<code>HttpClient</code>的时候作为参数传入。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddTransient&lt;HandlerA&gt;();</span><br><span class="line">services.AddTransient&lt;HandlerB&gt;();</span><br><span class="line">services.AddHttpClient(<span class="string">"MyClient"</span>, options =&gt; &#123;</span><br><span class="line">  options.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://blog.yuanpei.me/"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .AddHttpMessageHandler&lt;HandlerA&gt;()</span><br><span class="line">  .AddHttpMessageHandler&lt;HandlerB&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非依赖注入</span></span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> HandlerA() &#123; InnerHandler = <span class="keyword">new</span> HandlerB() &#125;;</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient(handler)</span><br></pre></td></tr></table></figure><p>此时，我们就可以得到下面的结果，可以注意到的是，两个<code>Handler</code>的执行顺序与注册顺序一致：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/29/URNWavrVgyzMAxe.png" alt="Handler执行顺序与注册顺序" referrerpolicy="no-referrer"></div><div class="image-caption">Handler执行顺序与注册顺序</div></figure><p>好了，热身环节到此结束！下面，我们来开始实战，这里展示的是 <code>HttpMessageHandler</code> 在日志记录、请求重试 和 接口模拟等方面的应用。</p><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>对于 Http 请求的日志，我们希望记录请求的Url、Http动词、请求时长等信息，而这一点，在一个大量接入第三方接口的系统或者是以 Http 驱动的微服务架构中，常常是不可或缺的一环，对于我们排查故障、监控服务非常有用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params">HttpRequestMessage request, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> correlationId = GetCorrelationId(request);</span><br><span class="line">    <span class="keyword">using</span> (_logger.BeginScope(<span class="string">$"correlationId=<span class="subst">&#123;correlationId&#125;</span>"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> sw = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">        _logger.LogInformation(<span class="string">$"Start Processing HTTP Request <span class="subst">&#123;request.Method&#125;</span> <span class="subst">&#123;request.RequestUri&#125;</span> [Correlation: <span class="subst">&#123;correlationId&#125;</span>]"</span>);</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">base</span>.Send(request, cancellationToken);</span><br><span class="line">         _logger.LogInformation(<span class="string">$"End Processing HTTP Request in <span class="subst">&#123;sw.ElapsedMilliseconds&#125;</span>ms <span class="subst">&#123;response.StatusCode&#125;</span>, [Correlation: <span class="subst">&#123;correlationId&#125;</span>]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetCorrelationId</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">GetCorrelationId</span>(<span class="params">HttpRequestMessage request</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.Headers.TryGetValues(<span class="string">"X-Correlation-ID"</span>, <span class="keyword">out</span> <span class="keyword">var</span> values))</span><br><span class="line">        <span class="keyword">return</span> values.First();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> correlationId = Guid.NewGuid().ToString();</span><br><span class="line">    request.Headers.Add(<span class="string">"X-Correlation-ID"</span>, correlationId);</span><br><span class="line">    <span class="keyword">return</span> correlationId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/29/aORFS3ZQEw8pNbT.png" alt="HttpMessageHandler 实现日志记录" referrerpolicy="no-referrer"></div><div class="image-caption">HttpMessageHandler 实现日志记录</div></figure><h2 id="请求重试"><a href="#请求重试" class="headerlink" title="请求重试"></a>请求重试</h2><p>我们知道，一个系统中接入的外部因素越多，则整个系统的稳定性越低。而国内的产品通常都喜欢”大而全”的”万物互联”，所以，最实际的问题，其实就是调用一个第三方的接口，如何保证其可靠性。所以，考虑请求的故障恢复就显得非常有意义，为此，我们可以引入<code>Polly</code>，在实现<code>SendAsync()</code>方法的时候，通过<code>Polly</code>中的超时、重试等机制对其做一层包装：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RetryableHttpMessageHandler</span> : <span class="title">DelegatingHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;RetryableHttpMessageHandler&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IAsyncPolicy&lt;HttpResponseMessage&gt; _retryPolicy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryableHttpMessageHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        ILogger&lt;RetryableHttpMessageHandler&gt; logger</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _retryPolicy = Policy&lt;HttpResponseMessage&gt;</span><br><span class="line">            .Handle&lt;HttpRequestException&gt;()</span><br><span class="line">            .Or&lt;TimeoutException&gt;()</span><br><span class="line">            .OrResult(x =&gt; (<span class="keyword">int</span>)x.StatusCode &gt;= <span class="number">400</span>)</span><br><span class="line">            .RetryAsync(<span class="number">3</span>, (ret, index) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                _logger.LogInformation(<span class="string">$"调用接口异常：<span class="subst">&#123;ret.Exception?.Message&#125;</span>，状态码：<span class="subst">&#123;ret.Result.StatusCode&#125;</span>, 正在进行第<span class="subst">&#123;index&#125;</span>次重试"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _retryPolicy.ExecuteAsync(() =&gt; <span class="keyword">base</span>.SendAsync(request, cancellationToken));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，我们这里通过<code>HttpClient</code>来请求指定的接口。因为，下面的接口实际上是不存在的。所以，理论上它会返回<code>404</code>这个状态码。而我们的重试策略是，在发生<code>HttpRequestException</code>或者<code>TimeoutException</code>异常以及 Http 响应的状态码大于 400 时，自动触发 3 次重试。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = _clientFactory.CreateClient(<span class="string">"ApiMock"</span>);</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">"/api/fail"</span>);</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/30/OaUyhNF7XYsA8mI.png" alt="HttpMessageHandler 实现请求重试" referrerpolicy="no-referrer"></div><div class="image-caption">HttpMessageHandler 实现请求重试</div></figure><p>可以发现，不多不少刚好是 3 次。除了重试以外，<code>Polly</code>还支持类似超时、断路器等等不同的策略，甚至可以将它们组合起来使用，这些都属于<a href="https://github.com/App-vNext/Polly" target="_blank" rel="noopener">Polly</a>的内容，不作为本文的重点内容来讲解，感兴趣的朋友可以查阅这篇文章：<a href="https://www.cnblogs.com/willick/p/polly.html" target="_blank" rel="noopener">.NET 开源项目 Polly 介绍</a>。需要说明的是，微软官方提供的 <code>Microsoft.Extensions.Http.Polly</code>，它在<code>IHttpClientBuilder</code>上添加了一个名为<code>AddPolicyHandler()</code>的扩展方法，这里的例子可以被简化为下面这样，它和我们这里举的例子是完全一致的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义重试策略</span></span><br><span class="line"><span class="keyword">var</span> retryPolicy = Policy&lt;HttpResponseMessage&gt;</span><br><span class="line">    .Handle&lt;HttpRequestException&gt;()</span><br><span class="line">    .Or&lt;TimeoutException&gt;()</span><br><span class="line">    .OrResult(x =&gt; (<span class="keyword">int</span>)x.StatusCode &gt;= <span class="number">400</span>)</span><br><span class="line">    .RetryAsync(<span class="number">3</span>, (ret, index) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"调用接口异常：<span class="subst">&#123;ret.Exception?.Message&#125;</span>，状态码：<span class="subst">&#123;ret.Result.StatusCode&#125;</span>, 正在进行第<span class="subst">&#123;index&#125;</span>次重试"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册HttpClient并指定重试策略</span></span><br><span class="line">services.AddHttpClient(<span class="string">"ApiMock"</span>, options =&gt; &#123; </span><br><span class="line">  options.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://blog.yuanpei.me"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .AddPolicyHandler(retryPolicy);</span><br></pre></td></tr></table></figure><h2 id="接口模拟"><a href="#接口模拟" class="headerlink" title="接口模拟"></a>接口模拟</h2><p>在集成第三方接口时，在双方确定好接口以后，接口消费方会有一段时间的“黒写”时期。因为在接口提供方的接口没有正式提供前，接口消费方始终只能通过“<strong>模拟</strong>”的方式来进行测试。考虑到单元测试对 <a href="https://github.com/ymfe/yapi" target="_blank" rel="noopener">YAPI</a> 存在耦合，所以，接口模拟同样是一件意义非凡的事情。这里的思路是利用 <code>HttpMessageHandler</code> 的“<strong>短路</strong>”功能，即构造一个 <code>HttpResponseMessage</code> 并返回。</p><p>首先，我们定义一个<code>MockItem</code>类型，它含有两个委托类型的属性<code>RouteSelector</code>和<code>Executor</code>。其中，前者用来匹配路由，而后者则用来处理接口返回值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MockItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;HttpRequestMessage, <span class="keyword">bool</span>&gt; RouteSelector &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;HttpRequestMessage, HttpResponseMessage, Task&gt; Executor &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要定义相应的<code>Handler</code>，这里是<code>ApiMockHttpMessageHandler</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiMockHttpMessageHandler</span>: <span class="title">DelegatingHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;ApiMockHttpMessageHandler&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEnumerable&lt;MockItem&gt; _routes;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiMockHttpMessageHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        ILogger&lt;ApiMockHttpMessageHandler&gt; logger,</span></span></span><br><span class="line"><span class="function"><span class="params">        IEnumerable&lt;MockItem&gt; routes</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _routes = routes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      HttpRequestMessage request, </span></span></span><br><span class="line"><span class="function"><span class="params">      CancellationToken cancellationToken</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 匹配路由并调用其Executor属性</span></span><br><span class="line">        <span class="keyword">var</span> route = _routes.FirstOrDefault(x =&gt; x.RouteSelector?.Invoke(request));</span><br><span class="line">        <span class="keyword">if</span> (route != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">new</span> HttpResponseMessage();</span><br><span class="line">            <span class="keyword">await</span> route.Executor?.Invoke(request, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.Send(request, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的思路是，对于所有注入到<code>Ioc</code>容器中的<code>MockItem</code>，检查其路由是否匹配，如果路由匹配，则通过其指定的<code>Executor</code>对<code>HttpResponseMessage</code>进行加工并返回。为了更加方便地在<code>Ioc</code>容器中进行注入，我们为<code>IServiceCollection</code>编写了相应的扩展方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection AddMock&lt;TReturn&gt;(</span><br><span class="line">    <span class="keyword">this</span> IServiceCollection services, </span><br><span class="line">    <span class="keyword">string</span> url, HttpMethod method, TReturn @<span class="keyword">return</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mockItem = <span class="keyword">new</span> MockItem();</span><br><span class="line">    mockItem.Executor = BuildExecutor&lt;TReturn&gt;(@<span class="keyword">return</span>);</span><br><span class="line">    mockItem.RouteSelector = BuildRouteSelector(url, method);</span><br><span class="line">    <span class="keyword">return</span> services.AddTransient&lt;MockItem&gt;(sp =&gt; mockItem);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection AddMock&lt;TReturn&gt;(</span><br><span class="line">    <span class="keyword">this</span> IServiceCollection services, </span><br><span class="line">    Func&lt;HttpRequestMessage, <span class="keyword">bool</span>&gt; routeSelector, </span><br><span class="line">    Func&lt;HttpRequestMessage, HttpResponseMessage, Task&gt; executor</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mockItem = <span class="keyword">new</span> MockItem();</span><br><span class="line">    mockItem.Executor = executor;</span><br><span class="line">    mockItem.RouteSelector = routeSelector;</span><br><span class="line">    <span class="keyword">return</span> services.AddTransient&lt;MockItem&gt;(sp =&gt; mockItem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Func&lt;HttpRequestMessage, <span class="keyword">bool</span>&gt; <span class="title">BuildRouteSelector</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">string</span> url, HttpMethod method</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Func&lt;HttpRequestMessage, <span class="keyword">bool</span>&gt; selector = request =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="string">"*"</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> url.ToLower() == res.RequestUri.AbsolutePath.ToLower() &amp;&amp; method == res.Method;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> selector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Func&lt;HttpRequestMessage, HttpResponseMessage, Task&gt; BuildExecutor&lt;TReturn&gt;(TReturn @<span class="keyword">return</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Func&lt;HttpRequestMessage, HttpResponseMessage, Task&gt; executor = (request, response) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        response.StatusCode = System.Net.HttpStatusCode.OK;</span><br><span class="line">        <span class="keyword">if</span> (@<span class="keyword">return</span> <span class="keyword">is</span> HttpStatusCode)</span><br><span class="line">            response.StatusCode = (HttpStatusCode)Enum.Parse(</span><br><span class="line">                <span class="keyword">typeof</span>(HttpStatusCode),</span><br><span class="line">                @<span class="keyword">return</span>.ToString()</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (@<span class="keyword">return</span> <span class="keyword">is</span> Exception)</span><br><span class="line">            <span class="keyword">throw</span> @<span class="keyword">return</span> <span class="keyword">as</span> Exception;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (@<span class="keyword">return</span> <span class="keyword">is</span> <span class="keyword">string</span>)</span><br><span class="line">            response.Content = <span class="keyword">new</span> StringContent(@<span class="keyword">return</span> <span class="keyword">as</span> <span class="keyword">string</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            response.Content = <span class="keyword">new</span> StringContent(@<span class="keyword">return</span> == <span class="literal">null</span> ? </span><br><span class="line">                <span class="string">""</span> : JsonConvert.SerializeObject(@<span class="keyword">return</span>)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们就可以在单元测试中对接口进行模拟，这样就实现了真正意义上的单元测试：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 HttpClient并注册ApiMockHttpMessageHandler</span></span><br><span class="line">services.AddHttpClient(<span class="string">"ApiMock"</span>, options =&gt; &#123; </span><br><span class="line">  options.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://blog.yuanpei.me"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .AddHttpMessageHandler&lt;ApiMockHttpMessageHandler&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加3个模拟接口</span></span><br><span class="line">services.AddMock(<span class="string">"/api/status"</span>, HttpMethod.Get, HttpStatusCode.OK);</span><br><span class="line">services.AddMock(<span class="string">"/api/query"</span>, HttpMethod.Post, <span class="keyword">new</span> Exception(<span class="string">"帅哥你谁啊"</span>));</span><br><span class="line">services.AddMock(<span class="string">"/api/order"</span>, HttpMethod.Get, <span class="keyword">new</span> &#123; </span><br><span class="line">  OrderId = <span class="string">"OR09874"</span>, </span><br><span class="line">  CreatedBy = <span class="string">"张三"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> httpClientFactory = serviceProvider.GetRequiredService&lt;IHttpClientFactory&gt;();</span><br><span class="line"><span class="keyword">var</span> httpClient = httpClientFactory.CreateClient(<span class="string">"ApiMock"</span>);</span><br><span class="line"><span class="comment">// 调用/api/order接口</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(<span class="string">"/api/order"</span>);</span><br></pre></td></tr></table></figure><p>下图是模拟接口返回的结果，与我们期望的完全一致：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/30/k9lX12aSpcr8ReV.png" alt="HttpMessageHandler 实现接口模拟" referrerpolicy="no-referrer"></div><div class="image-caption">HttpMessageHandler 实现接口模拟</div></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>古人云：<strong>他山之石，可以攻玉</strong>。原本被接口模拟(<strong>Mock</strong>)所吸引的博主，意外地收获了 <code>HttpMessageHandler</code> 这个令人兴奋的知识点。博主认为，它是一种可以对 请求消息(<strong>HttpRequestMessage</strong>) 和 响应消息(<strong>HttpResponseMessage</strong>) 进行处理，同时多个 <code>HttpMessageHandler</code> 可以组成一个完整的消息处理通道的中间件。在此基础上，我们实现了诸如<strong>日志记录</strong>、<strong>请求重试</strong>、<strong>接口模拟</strong>等等的扩展性功能。除此以外，它还可以应用到 <strong>Http认证头处理</strong> 、<strong>客户端负载均衡</strong>等方面。</p><p>其实，从 ASP.NET、OWIN、Nancy、ASP.NET Core 这样一路走过来，你会发现，管道的概念一直都存在，无非是以不同的形式存在着，譬如 ASP.NET Core 里的中间件，其实是替代了曾经的 <code>HttpHandler</code> 和 <code>HttpModule</code>，就像时间一直都在那里，不快不慢，觉得物是人非、喜新厌旧的多半还是我们。对我而言，写到这里，最大的感慨或许是，曾经试图实现的类似 <code>Servlet</code> 的 Http Server ，现在想起来还是太年轻、太朴实了，可年轻或者朴实，难道不好吗？好了，以上就是这篇博客的全部内容了，如果你觉得这篇博客对你有所帮助或者启发，希望你可以毫不吝啬地给个一键三连。如果你对这篇博客里的内容有意见或者建议，欢迎你评论区留下你的足迹和声音，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="扩展" scheme="https://qinyuanpei.github.io/tags/%E6%89%A9%E5%B1%95/"/>
    
      <category term="HttpClient" scheme="https://qinyuanpei.github.io/tags/HttpClient/"/>
    
      <category term="Mock" scheme="https://qinyuanpei.github.io/tags/Mock/"/>
    
      <category term="管道" scheme="https://qinyuanpei.github.io/tags/%E7%AE%A1%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>ABP vNext 的实体与服务扩展技巧分享</title>
    <link href="https://qinyuanpei.github.io/posts/3619320289/"/>
    <id>https://qinyuanpei.github.io/posts/3619320289/</id>
    <published>2021-04-18T20:42:47.000Z</published>
    <updated>2021-06-22T07:04:41.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>使用 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 有一个月左右啦，这中间最大的一个收获是：ABP vNext 的开发效率真的是非常好，只要你愿意取遵循它模块化、DDD 的设计思想。因为官方默认实现了身份、审计、权限、定时任务等等的模块，所以，ABP vNext 是一个开箱即用的解决方案。通过脚手架创建的项目，基本具备了一个专业项目该有的“<strong>五脏六腑</strong>”，而这可以让我们专注于业务原型的探索。例如，博主是尝试结合 <a href="https://www.antdv.com/docs/vue/introduce-cn/" target="_blank" rel="noopener">Ant Design Vue</a> 来做一个通用的后台管理系统。话虽如此，我们在使用 ABP vNext 的过程中，还是希望可以针对性地对 ABP vNext 进行扩展，毕竟 ABP vNext 无法 100% 满足我们的使用要求。所以，在今天这篇博客中，我们就来说说 ABP vNext 中的扩展技巧，这里主要是指实体扩展和服务扩展这两个方面。我们经常在讲“<strong>开闭原则</strong>”，可扪心自问，我们每次修改代码的时候，是否真正做到了“<strong>对扩展开放，对修改关闭</strong>”呢？ 所以，在面对扩展这个话题时，我们不妨来一起看看 ABP vNext 中是如何实践“<strong>开闭原则</strong>”。</p><h1 id="扩展实体"><a href="#扩展实体" class="headerlink" title="扩展实体"></a>扩展实体</h1><p>首先，我们要说的是扩展实体，什么是实体呢？这其实是领域驱动设计(<strong>DDD</strong>)中的概念，相信对于实体、聚合根和值对象，大家早就耳熟能详了。在 ABP vNext 中，实体对应的类型为<code>Entity</code>，聚合根对应的类型为<code>AggregateRoot</code>。所以，你可以片面地认为，只要继承自<code>Entity</code>基类的类都是实体。通常，实体都会有一个唯一的标识(<strong>Id</strong>)，所以，订单、商品或者是用户，都属于实体的范畴。不过，按照业务边界上的不同，它们会在核心域、支撑域和通用域三者间频繁切换。而对于大多数系统而言，用户都将是一个通用的域。在 ABP vNext 中，其用户信息由<code>AbpUsers</code>表承载，它在架构上定义了<code>IUser</code>接口，借助于EF Core的表映射支持，我们所使用的<code>AppUser</code>本质上是映射到了<code>AbpUsers</code>表中。针对实体的扩展，在面向数据库编程的业务系统中，一个最典型的问题就是，我怎么样可以给<code>AppUser</code>添加字段。所以，下面我们以<code>AppUser</code>为例，来展示如何对实体进行扩展。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/19/dtANSYQqyDz9blw.jpg" alt="DDD 中的实体、聚合根与值对象" referrerpolicy="no-referrer"></div><div class="image-caption">DDD 中的实体、聚合根与值对象</div></figure><p>实际上，ABP vNext 中提供了2种方式，来解决实体扩展的问题，它们分别是：<strong>Extra Properties</strong> 和 <strong>基于 EF Core 的表映射</strong>。在 <a href="https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities" target="_blank" rel="noopener">官方文档</a> 中，我们会得到更加详细的信息，这里简单介绍一下就好：</p><h2 id="Extra-Properties"><a href="#Extra-Properties" class="headerlink" title="Extra Properties"></a>Extra Properties</h2><p>对于第1种方式，它要求我们必须实现<code>IHasExtraProperties</code>接口，这样我们就可以使用<code>GetProperty()</code>和<code>SetProperty()</code>两个方法，其原理是，将这些扩展字段以<code>JSON</code>格式存储在<code>ExtraProperties</code>这个字段上。如果使用<code>MongoDB</code>这样的非关系型数据库，则这些扩展字段可以单独存储。参考示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置扩展字段</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">await</span> _identityUserRepository.GetAsync(userId);</span><br><span class="line">user.SetProperty(<span class="string">"Title"</span>, <span class="string">"起风了，唯有努力生存"</span>);</span><br><span class="line"><span class="keyword">await</span> _identityUserRepository.UpdateAsync(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取扩展字段</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">await</span> _identityUserRepository.GetAsync(userId);</span><br><span class="line"><span class="keyword">return</span> user.GetProperty&lt;<span class="keyword">string</span>&gt;(<span class="string">"Title"</span>);</span><br></pre></td></tr></table></figure><p>可以想象得到，这种方式使用起来没有心智方面的困扰，主要问题是，这些扩展字段不利于关系型数据库的查询。其次，完全以字符串形式存在的键值对，难免存在数据类型的安全性问题。博主的上家公司，在面对这个问题时，采用的方案就是往数据库里加备用字段，从起初的5个，变成后来的10个，最后甚至变成20个，先不说这没完没了的加字段，代码中一直避不开的，其实是各种字符串的<strong>Parse</strong>/<strong>Convert</strong>，所以，大家可以自己去体会这其中的痛苦。</p><h2 id="基于-EF-Core-的表映射"><a href="#基于-EF-Core-的表映射" class="headerlink" title="基于 EF Core 的表映射"></a>基于 EF Core 的表映射</h2><p>对于第2种方式，主要指 EF Core 里的“<strong>表拆分</strong>”或者“<strong>表共享</strong>”，譬如，当我们希望单独创建一个实体<code>SysUser</code>来替代默认的<code>AppUser</code>时，这就是表拆分，因为同一张表中的数据，实际上是被<code>AppUser</code>和<code>SysUser</code>共享啦，或者，你可以将其理解为，EF Core配置两个不同的实体时，它们的<code>ToTable()</code>方法都指向了同一张表。这里唯一不同的是，ABP vNext 中提供了一部分方法用来处理问题，因为牵扯到数据库，所以，还是需要“迁移”。下面，我们以给<code>AppUser</code>扩展两个自定义字段为例：</p><p>首先，我们给<code>AppUser</code>类增加两个新属性，<code>Avatar</code> 和 <code>Profile</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppUser : FullAuditedAggregateRoot&lt;Guid&gt;, IUser</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> Profile &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> Avatar &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  ...</span></span><br></pre></td></tr></table></figure><p>接下来，按照 EF Core 的“<strong>套路</strong>”，我们需要配置下这两个新加的字段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">builder.Entity&lt;AppUser&gt;(b =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AbpUsers</span></span><br><span class="line">    <span class="comment">// Sharing the same table "AbpUsers" with the IdentityUser</span></span><br><span class="line">    b.ToTable(AbpIdentityDbProperties.DbTablePrefix + <span class="string">"Users"</span>); </span><br><span class="line"></span><br><span class="line">    b.ConfigureByConvention();</span><br><span class="line">    b.ConfigureAbpUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Profile</span></span><br><span class="line">    b.Property(x =&gt; x.Profile)</span><br><span class="line">      .HasMaxLength(AppUserConsts.MaxProfileLength)</span><br><span class="line">      .HasColumnName(<span class="string">"Profile"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Avatar</span></span><br><span class="line">    b.Property(x =&gt; x.Avatar)</span><br><span class="line">      .HasMaxLength(AppUserConsts.MaxAvatarLength)</span><br><span class="line">      .HasColumnName(<span class="string">"Avatar"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来，通过<code>MapEfCoreProperty()</code>方法，将新字段映射到<code>IdentityUser</code>实体，你可以理解为，<code>AppUser</code>和<code>IdentityUser</code>同时映射到了<code>AbpUsers</code>这张表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avatar</span></span><br><span class="line">ObjectExtensionManager.Instance.MapEfCoreProperty&lt;IdentityUser, <span class="keyword">string</span>&gt;(</span><br><span class="line">    <span class="keyword">nameof</span>(AppUser.Avatar),</span><br><span class="line">    (entityBuilder, propertyBuilder) =&gt; &#123;</span><br><span class="line">    propertyBuilder.HasMaxLength(AppUserConsts.MaxAvatarLength);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Profile</span></span><br><span class="line">ObjectExtensionManager.Instance.MapEfCoreProperty&lt;IdentityUser, <span class="keyword">string</span>&gt;(</span><br><span class="line">      <span class="keyword">nameof</span>(AppUser.Profile),</span><br><span class="line">      (entityBuilder, propertyBuilder) =&gt; &#123;</span><br><span class="line">      propertyBuilder.HasMaxLength(AppUserConsts.MaxProfileLength);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>既然，连数据库实体都做了扩展，那么，数据传输对象(<strong>DTO</strong>)有什么理由拒绝呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ObjectExtensionManager.Instance</span><br><span class="line">    .AddOrUpdateProperty&lt;<span class="keyword">string</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserDto),</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserCreateDto),</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserUpdateDto),</span><br><span class="line">            <span class="keyword">typeof</span>(ProfileDto),</span><br><span class="line">            <span class="keyword">typeof</span>(UpdateProfileDto),</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Avatar"</span></span><br><span class="line">    )</span><br><span class="line">    .AddOrUpdateProperty&lt;<span class="keyword">string</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserDto),</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserCreateDto),</span><br><span class="line">            <span class="keyword">typeof</span>(IdentityUserUpdateDto),</span><br><span class="line">            <span class="keyword">typeof</span>(ProfileDto),</span><br><span class="line">            <span class="keyword">typeof</span>(UpdateProfileDto)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Profile"</span></span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>经过这一系列的“<strong>套路</strong>”，此时，我们会发现，新的字段已经生效：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/19/WExbQrs61ltcqzy.png" alt="ABP vNext 实体扩展效果展示" referrerpolicy="no-referrer"></div><div class="image-caption">ABP vNext 实体扩展效果展示</div></figure><h1 id="扩展服务"><a href="#扩展服务" class="headerlink" title="扩展服务"></a>扩展服务</h1><p>在 ABP vNext 中，我们还可以对服务进行扩展，得益于依赖注入的深入人心，我们可以非常容易地实现或者替换某一个接口，这里则指 ABP vNext 中的应用服务(ApplicationService)，例如，CrudAppService类可以帮助我们快速实现枯燥的增删改查，而我们唯一要做的，则是定义好实体的主键(<strong>Primary Key</strong>)、定义好实体的数据传输对象(<strong>DTO</strong>)。当我们发现 ABP vNext 中内置的模块或者服务，无法满足我们的使用要求时，我们就可以考虑对原有服务进行替换，或者是注入新的应用服务来扩展原有服务，这就是服务的扩展。在 ABP vNext 中，我们可以使用下面两种方法来对一个服务进行替换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过[Dependency]和[ExposeServices]实现服务替换</span></span><br><span class="line">[<span class="meta">Dependency(ReplaceServices = true)</span>]</span><br><span class="line">[<span class="meta">ExposeServices(typeof(IIdentityUserAppService))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">YourIdentityUserAppService</span> : <span class="title">IIdentityUserAppService</span>, <span class="title">ITransientDependency</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ReplaceService实现服务替换</span></span><br><span class="line">context.Services.Replace(</span><br><span class="line">    ServiceDescriptor.Transient&lt;IIdentityUserAppService, YourIdentityUserAppService&gt;()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里，博主准备的一个示例是，默认的用户查询接口，其返回信息中只有用户相关的字段，我们希望在其中增加角色、组织单元等关联信息，此时。我们可以考虑实现下面的应用服务：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUserManageAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;PagedResultDto&lt;UserDetailQueryDto&gt;&gt; GetUsersWithDetails(</span><br><span class="line">      GetIdentityUsersInput input</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们定义了<code>IUserManageAppService</code>接口，它含有一个分页查询的方法<code>GetUsersWithDetails()</code>。接下来，我们来考虑如何实现这个接口。需要说明的是，在 ABP vNext 中，仓储模式的支持由通用仓储接口<code>IRepository&lt;TEntity, TKey&gt;</code>提供，ABP vNext 会在<code>AddDefaultRepositories()</code>方法中为每一个聚合根注入对应的仓储。同样地，你可以按照个人喜好为指定的实体注入对应的仓储。由于ABP vNext 同时支持 <code>EF Core</code>、<code>Dapper</code> 和 <code>MongoDB</code>，所以，我们还可以使用<code>EfCoreRepository</code>、<code>DapperRepository</code> 以及 <code>MongoDbRepository</code>，它们都是<code>IRepository</code>的具体实现类。在下面的例子中，我们使用的是<code>EfCoreRepository</code>这个类。</p><p>事实上，这里注入的<code>EfCoreIdentityUserRepository</code>、<code>EfCoreIdentityRoleRepository</code> 以及 <code>EfCoreOrganizationUnitRepository</code>，都是<code>EfCoreRepository</code>的子类，这使得我们可以复用 ABP vNext 中关于身份标识的一切基础设施，来实现不同于官方的业务逻辑，而这就是我们所说的服务的扩展。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize(IdentityPermissions.Users.Default)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserManageAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IUserManageAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IdentityUserManager _userManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IOptions&lt;IdentityOptions&gt; _identityOptions;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> EfCoreIdentityUserRepository _userRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> EfCoreIdentityRoleRepository _roleRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> EfCoreOrganizationUnitRepository _orgRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserManageAppService</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        IdentityUserManager userManager,</span></span></span><br><span class="line"><span class="function"><span class="params">        EfCoreIdentityRoleRepository roleRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">        EfCoreIdentityUserRepository userRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">        EfCoreOrganizationUnitRepository orgRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">        IOptions&lt;IdentityOptions&gt; identityOptions</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _userManager = userManager;</span><br><span class="line">        _orgRepository = orgRepository;</span><br><span class="line">        _userRepository = userRepository;</span><br><span class="line">        _roleRepository = roleRepository;</span><br><span class="line">        _identityOptions = identityOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Authorize(IdentityPermissions.Users.Default)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;PagedResultDto&lt;UserDetailQueryDto&gt;&gt; GetUsersWithDetails(</span><br><span class="line">      GetIdentityUsersInput input</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Users</span></span><br><span class="line">        <span class="keyword">var</span> total = <span class="keyword">await</span> _userRepository.GetCountAsync(input.Filter);</span><br><span class="line">        <span class="keyword">var</span> users = <span class="keyword">await</span> _userRepository.GetListAsync(</span><br><span class="line">          input.Sorting, </span><br><span class="line">          input.MaxResultCount, </span><br><span class="line">          input.SkipCount, </span><br><span class="line">          input.Filter, </span><br><span class="line">          includeDetails: <span class="literal">true</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Roles</span></span><br><span class="line">        <span class="keyword">var</span> roleIds = users</span><br><span class="line">          .SelectMany(x =&gt; x.Roles)</span><br><span class="line">          .Select(x =&gt; x.RoleId)</span><br><span class="line">          .Distinct()</span><br><span class="line">          .ToList();</span><br><span class="line">        <span class="keyword">var</span> roles = <span class="keyword">await</span> _roleRepository</span><br><span class="line">          .WhereIf(roleIds.Any(), x =&gt; roleIds.Contains(x.Id))</span><br><span class="line">          .ToListAsync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//OrganizationUnits</span></span><br><span class="line">        <span class="keyword">var</span> orgIds = users</span><br><span class="line">          .SelectMany(x =&gt; x.OrganizationUnits)</span><br><span class="line">          .Select(x =&gt; x.OrganizationUnitId)</span><br><span class="line">          .Distinct()</span><br><span class="line">          .ToList();</span><br><span class="line">        <span class="keyword">var</span> orgs = <span class="keyword">await</span> _orgRepository</span><br><span class="line">          .WhereIf(orgIds.Any(), x =&gt; orgIds.Contains(x.Id))</span><br><span class="line">          .ToListAsync();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> items = ObjectMapper.Map&lt;List&lt;Volo.Abp.Identity.IdentityUser&gt;, List&lt;UserDetailQueryDto&gt;&gt;(users);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> role <span class="keyword">in</span> item.Roles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> roleInfo = roles.FirstOrDefault(x =&gt; x.Id == role.RoleId);</span><br><span class="line">                <span class="keyword">if</span> (roleInfo != <span class="literal">null</span>)</span><br><span class="line">                    ObjectMapper.Map(roleInfo, role);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> org <span class="keyword">in</span> item.OrganizationUnits)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> orgInfo = orgs.FirstOrDefault(x =&gt; x.Id == org.OrganizationUnitId);</span><br><span class="line">                <span class="keyword">if</span> (orgInfo != <span class="literal">null</span>)</span><br><span class="line">                    ObjectMapper.Map(orgInfo, org);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PagedResultDto&lt;UserDetailQueryDto&gt;(total, items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做一点补充说明，应用服务，即<code>ApplicationService</code>类，它集成了诸如<code>ObjectMapper</code>、<code>LoggerFactory</code>、<code>GuidGenerator</code>、国际化、<code>AsyncExecuter</code>等等的特性，继承该类可以让我们更加得心应手地编写代码。曾经，博主写过一篇关于“<strong>动态API</strong>”的<a href="https://blog.yuanpei.me/posts/4236649/" target="_blank" rel="noopener">博客</a>，它可以为我们免去从 Service 到 Controller 的这一层封装，当时正是受到了ABP 框架的启发。当博主再次在 ABP vNext 中看到这个功能时，不免会感慨逝者如斯，而事实上，这个功能真的好用，真香！下面是经过改造以后的用户列表。考虑到，在上一篇博客里，博主已经同大家分享过分页查询方面的实现技巧，这里就不再展开讲啦！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/19/B6SO8Wk4EVh3Pcx.png" alt="对“用户服务”进行扩展" referrerpolicy="no-referrer"></div><div class="image-caption">对“用户服务”进行扩展</div></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>我们时常说，”<strong>对修改关闭，对扩展开放</strong>“，”<strong>单一职责</strong>“，可惜这些原则最多就出现在面试环节。当你接触了真实的代码，你会发现”<strong>修改</strong>“永远比”<strong>扩展</strong>“多，博主曾经就见到过，一个简单的方法因为频繁地”<strong>打补丁</strong>“，最后变得面目全非。其实，有时候并不是维护代码的人，不愿意去”<strong>扩展</strong>“，而是写出可”<strong>扩展</strong>“的代码会更困难一点，尤其是当所有人都不愿意去思考，一味地追求短平快，这无疑只会加速代码的腐烂。在这一点上，ABP vNext 提供了一种优秀的范例，这篇文章主要分享了 ABP vNext 中实体和服务的扩展技巧，<strong>实体扩展解决了如何为数据库表添加扩展字段的问题，服务扩展解决了如何为默认服务扩展功能的问题</strong>，尤其是后者，依赖注入在其中扮演着无比重要的角色。果然，这世上的事情，只有你真正在乎的时候，你才会愿意去承认，那些你曾经轻视过的东西，也许，它们是对的吧！好了，以上就是这篇博客的全部内容，欢迎大家在评论区留言，喜欢的话请记得点赞、收藏、一键三连。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="ABP" scheme="https://qinyuanpei.github.io/tags/ABP/"/>
    
      <category term="扩展" scheme="https://qinyuanpei.github.io/tags/%E6%89%A9%E5%B1%95/"/>
    
      <category term="实体" scheme="https://qinyuanpei.github.io/tags/%E5%AE%9E%E4%BD%93/"/>
    
      <category term="服务" scheme="https://qinyuanpei.github.io/tags/%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>ABP vNext 对接 Ant Design Vue 实现分页查询</title>
    <link href="https://qinyuanpei.github.io/posts/3670340170/"/>
    <id>https://qinyuanpei.github.io/posts/3670340170/</id>
    <published>2021-04-07T21:07:47.000Z</published>
    <updated>2021-06-22T07:04:41.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在 <a href="https://blog.yuanpei.me/posts/2151871792/" target="_blank" rel="noopener">上一篇</a> 博客中，博主和大家分享了如何在 <a href="https://docs.microsoft.com/zh-cn/ef/core/get-started/overview/first-app?tabs=netcore-cli" target="_blank" rel="noopener">EF Core</a> 中实现多租户架构。在这一过程中，博主主要参考了 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 这个框架。从上个月开始，我个人发起了一个项目，基于 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 和 <a href="https://www.antdv.com/docs/vue/introduce-cn/" target="_blank" rel="noopener">Ant Design Vue</a> 来实现一个通用的后台管理系统，希望以此来推进 <a href="https://www.jdon.com/ddd.html" target="_blank" rel="noopener">DDD</a> 和 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a> 的学习，努力打通前端与后端的“<strong>任督二脉</strong>”。因此，接下来的这段时间内，我写作的主题将会围绕 ABP vNext 和 Ant Design Vue。而在今天的这篇博客中，我们来说说 ABP vNext 对接 Ant Design Vue 实现分页查询的问题，希望能让大家在面对类似问题时有所帮助。我不打算写一个系列教程，更多的是从我个人的关注点出发，如果大家有更多想要交流的话题，欢迎大家通过评论或者邮件来留言，谢谢大家！</p><h1 id="ABP-vNext中的分页查询"><a href="#ABP-vNext中的分页查询" class="headerlink" title="ABP vNext中的分页查询"></a>ABP vNext中的分页查询</h1><p>OK，当大家接触过 ABP vNext 以后，就会了解到这样一件事情，即，ABP vNext 中默认提供的分页查询接口，在大多数情况下，通常都会是下面这样的风格。这里以角色查询的接口为例，它对应的请求地址是：<code>/api/identity/roles?SkipCount=0&amp;MaxResultCount=10</code>。此时，我们可以注意到，返回的数据结构中含有<code>totalCount</code>和<code>items</code>两个属性。其中，<code>totalCount</code>表示记录的总数目，<code>items</code>表示当前页对应的记录。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"totalCount"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"items"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Admin"</span>,</span><br><span class="line">      <span class="attr">"isDefault"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"isStatic"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"isPublic"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"concurrencyStamp"</span>: <span class="string">"cb53f2d7-159e-452d-9d9c-021629b500e0"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"39fb19e8-fb34-dfbd-3c70-181f604fd5ff"</span>,</span><br><span class="line">      <span class="attr">"extraProperties"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Manager"</span>,</span><br><span class="line">      <span class="attr">"isDefault"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"isStatic"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"isPublic"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"concurrencyStamp"</span>: <span class="string">"145ec550-7fe7-4c80-85e3-f317a168e6b6"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"39fb6216-2803-20c6-7211-76f8fe38b90e"</span>,</span><br><span class="line">      <span class="attr">"extraProperties"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，ABP vNext 中自带的分页查询，主要是通过<code>SkipCount</code>和<code>MaxResultCount</code>两个参数来实现。假设<code>MaxResultCount</code>，即分页大小为<code>m</code>，则第<code>n</code>页对应的<code>SkipCount</code>应该为<code>(n-1) * m</code>。如果大家对于<code>LINQ</code>非常熟悉的话，应该可以自然而然地联想到<code>Skip()</code>和<code>Take()</code>两个方法，这是一个非常自然的联想，因为 ABP vNext 就是这样实现分页查询的。这里以博主的“<strong>数据字典</strong>”分页查询接口为例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;PagedResultDto&lt;DataDictionaryQueryDto&gt;&gt; GetCategories(</span><br><span class="line">    GetDataDictionaryRequestInput input</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> totalCount = (<span class="keyword">await</span> _dataDictRepository.GetQueryableAsync())</span><br><span class="line">    .WhereIf(!<span class="keyword">string</span>.IsNullOrEmpty(input.Name), x =&gt; x.Name.Contains(input.Name) || x.Name == input.Name)</span><br><span class="line">    .WhereIf(!<span class="keyword">string</span>.IsNullOrEmpty(input.Description), x =&gt; x.Description.Contains(input.Description) || x.Description == input.Description)</span><br><span class="line">    .Count();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> items = (<span class="keyword">await</span> _dataDictRepository.GetQueryableAsync())</span><br><span class="line">    .WhereIf(!<span class="keyword">string</span>.IsNullOrEmpty(input.Name), x =&gt; x.Name.Contains(input.Name) || x.Name == input.Name)</span><br><span class="line">    .WhereIf(!<span class="keyword">string</span>.IsNullOrEmpty(input.Description), x =&gt; x.Description.Contains(input.Description) || x.Description == input.Description)</span><br><span class="line">    .Skip(input.SkipCount)</span><br><span class="line">    .Take(input.MaxResultCount)</span><br><span class="line">    .ToList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PagedResultDto&lt;DataDictionaryQueryDto&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">      TotalCount = totalCount,</span><br><span class="line">      Items = ObjectMapper.Map&lt;List&lt;DataDictionary&gt;, List&lt;DataDictionaryQueryDto&gt;&gt;(items)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，在 ABP vNext 中我们只需要构造好<code>TotalCount</code>和<code>Items</code>这两个属性即可。</p><h1 id="STable组件中的分页查询"><a href="#STable组件中的分页查询" class="headerlink" title="STable组件中的分页查询"></a>STable组件中的分页查询</h1><p>接下来，在 Ant Design Vue 的 Pro 版本中，我们使用<code>STable</code>组件来展示列表类的数据，关于这个组件的使用方法，大家可以参考 <a href="https://github.com/vueComponent/ant-design-vue-pro/blob/master/src/components/Table/README.md" target="_blank" rel="noopener">官方文档</a>。按照最小化可行产品(<strong>MVP</strong>)的理念，一个最简单的<code>STable</code>组件的使用，如下面所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">s-table</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"table"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">size</span>=<span class="string">"default"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:rowKey</span>=<span class="string">"(record) =&gt; record.data.id"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:columns</span>=<span class="string">"columns"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:data</span>=<span class="string">"loadData"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:rowSelection</span>=<span class="string">"&#123; selectedRowKeys: selectedRowKeys, onChange: onSelectChange &#125;"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">s-table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这个组件而言，其中最重要的地方当属<code>data</code>属性，它接受一个函数，该函数的返回值为<code>Promise</code>对象，并且有一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> STable <span class="keyword">from</span> <span class="string">'@/components'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      STable</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 表格列名</span></span><br><span class="line">        columns: [],</span><br><span class="line">        <span class="comment">// 查询条件</span></span><br><span class="line">        queryParam: &#123; &#125;,</span><br><span class="line">        <span class="comment">// 加载数据方法，必须为 Promise 对象</span></span><br><span class="line">        loadData: <span class="function"><span class="params">parameter</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> getRoles(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.queryParam, parameter))</span><br><span class="line">            .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> res.result</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        selectedRowKeys: [],</span><br><span class="line">        selectedRows: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>也许，你会好奇这个<code>parameter</code>到底是个什么东西？可如果我们将其打印出来，就会发现它其实是分页查询相关的参数：<code>Object { pageNo: 1, pageSize: 10 }</code>，而更进一步，如果深入到这个组件的源代码中，我们会注意到组件内部有一个<code>loadData()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">loadData (pagination, filters, sorter) &#123;</span><br><span class="line">  <span class="keyword">this</span>.localLoading = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> parameter = <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">    pageNo: (pagination &amp;&amp; pagination.current) ||</span><br><span class="line">      <span class="keyword">this</span>.showPagination &amp;&amp; <span class="keyword">this</span>.localPagination.current || <span class="keyword">this</span>.pageNum,</span><br><span class="line">    pageSize: (pagination &amp;&amp; pagination.pageSize) ||</span><br><span class="line">      <span class="keyword">this</span>.showPagination &amp;&amp; <span class="keyword">this</span>.localPagination.pageSize || <span class="keyword">this</span>.pageSize</span><br><span class="line">    &#125;,</span><br><span class="line">    (sorter &amp;&amp; sorter.field &amp;&amp; &#123;</span><br><span class="line">      sortField: sorter.field</span><br><span class="line">    &#125;) || &#123;&#125;,</span><br><span class="line">    (sorter &amp;&amp; sorter.order &amp;&amp; &#123;</span><br><span class="line">      sortOrder: sorter.order</span><br><span class="line">    &#125;) || &#123;&#125;, &#123;</span><br><span class="line">    ...filters</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">this</span>.data(parameter)</span><br><span class="line">  <span class="comment">// 对接自己的通用数据接口需要修改下方代码中的 r.pageNo, r.totalCount, r.data</span></span><br></pre></td></tr></table></figure><p>可以注意到，在<code>STable</code>组件内部，它会将分页、排序和过滤三种不同类型的参数，通过<code>Object.assign()</code>方法聚合到一个对象上，这个对象实际上就是我们刚刚打印出来的<code>parameter</code>。为什么这样说呢？因为它接下来就要调用<code>data</code>属性指向的方法啦！还记得这个<code>data</code>是什么吗？不错，它是一个函数，既然是一个函数，当然可以直接调用。到这里，我们可以获得第一个信息，即，<strong>ABP vNext 中的表格组件STable，本身封装了分页查询相关的参数，只要将这些参数传递给后端就可以实现分页查询</strong>。</p><h1 id="实现参数转换层"><a href="#实现参数转换层" class="headerlink" title="实现参数转换层"></a>实现参数转换层</h1><p>既然，这个参数和 ABP vNext 需要的参数不同，为了不修改已有的接口，我们考虑在这中间加一层转换。为此，我们定义下面的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认列表查询条件</span></span><br><span class="line"><span class="keyword">const</span> baseListQuery = &#123;</span><br><span class="line">  page: <span class="number">1</span>,</span><br><span class="line">  limit: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询条件转化</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformAbpListQuery</span> (<span class="params">query</span>) </span>&#123;</span><br><span class="line">  query.filter = query.filter === <span class="string">''</span> ? <span class="literal">undefined</span> : query.filter</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.isNaN(query.pageSize)) &#123;</span><br><span class="line">    query.pageSize = baseListQuery.limit</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.isNaN(query.pageNo)) &#123;</span><br><span class="line">    query.pageNo = baseListQuery.page</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> abpListQuery = &#123;</span><br><span class="line">    maxResultCount: query.pageSize,</span><br><span class="line">    skipCount: (query.pageNo - <span class="number">1</span>) * query.pageSize,</span><br><span class="line">    sorting: <span class="string">''</span>,</span><br><span class="line">    filter: <span class="string">''</span>,</span><br><span class="line">    ...query</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (query.sortField) !== <span class="string">'undefined'</span> &amp;&amp; query.sortField !== <span class="literal">null</span>) &#123;</span><br><span class="line">    abpListQuery.sorting = query.sortOrder === <span class="string">'ascend'</span></span><br><span class="line">      ? query.sortField</span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;query.sortField&#125;</span> Desc`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> abpListQuery</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码非常简单，通过<code>transformAbpListQuery</code>函数，我们就实现了从<code>STable</code>到<code>ABP vNext</code>的参数转换。需要说明的是，这里的排序使用到了 <a href="https://github.com/zzzprojects/System.Linq.Dynamic.Core" target="_blank" rel="noopener">System.Linq.Dynamic.Core</a> 这个库，它可以实现<code>IQueryable</code>级别的、基于字符串的动态表达式构建功能，使用方法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resultSingle = queryable.OrderBy&lt;User&gt;(<span class="string">"NumberProperty"</span>);</span><br><span class="line"><span class="keyword">var</span> resultSingleDescending = queryable.OrderBy&lt;User&gt;(<span class="string">"NumberProperty DESC"</span>);</span><br><span class="line"><span class="keyword">var</span> resultMultiple = queryable.OrderBy&lt;User&gt;(<span class="string">"NumberProperty, StringProperty"</span>);</span><br></pre></td></tr></table></figure><p>所以，当它为降序排序时，我们在排序字段的后面添加<code>DESC</code>即可。关于<code>filter</code>参数，我准备做一套通用性更强的方案，所以，这里就暂时留空啦！接下来，如果大家足够细心的话，会发现<code>STable</code>组件对返回值同样有一定的要求，它要求返回值中至少含有<code>pageNo</code>、<code>totalCount</code>, <code>data</code>三个属性，而这，是我们获得的第二个信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对接自己的通用数据接口需要修改下方代码中的 r.pageNo, r.totalCount, r.data</span></span><br><span class="line"><span class="comment">// eslint-disable-next-line</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">typeof</span> result === <span class="string">'object'</span> || <span class="keyword">typeof</span> result === <span class="string">'function'</span>) </span><br><span class="line">  &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">  result.then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.localPagination = <span class="keyword">this</span>.showPagination </span><br><span class="line">    &amp;&amp; <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.localPagination, &#123;</span><br><span class="line">      current: r.pageNo, <span class="comment">// 返回结果中的当前分页数</span></span><br><span class="line">      total: r.totalCount, <span class="comment">// 返回结果中的总记录数</span></span><br><span class="line">      showSizeChanger: <span class="keyword">this</span>.showSizeChanger,</span><br><span class="line">      pageSize: (pagination &amp;&amp; pagination.pageSize) ||</span><br><span class="line">      <span class="keyword">this</span>.localPagination.pageSize</span><br><span class="line">    &#125;) || <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.localDataSource = r.data <span class="comment">// 返回结果中的数组数据</span></span><br><span class="line">    <span class="keyword">this</span>.localLoading = <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依样画葫芦，我们继续编写转换层的代码，返回值格式参考了 Ant Design Vue 中Mock接口的返回值格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询结果转化</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">transformAbpQueryResult</span> (<span class="params">data, message, code = <span class="number">0</span>, headers = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> responseBody = &#123; &#125;</span><br><span class="line">  responseBody.result = data</span><br><span class="line">  <span class="keyword">if</span> (message !== <span class="literal">undefined</span> &amp;&amp; message !== <span class="literal">null</span>) &#123;</span><br><span class="line">    responseBody.message = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (code !== <span class="literal">undefined</span> &amp;&amp; code !== <span class="number">0</span>) &#123;</span><br><span class="line">    responseBody.code = code</span><br><span class="line">    responseBody._status = code</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (headers !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> headers === <span class="string">'object'</span> </span><br><span class="line">    &amp;&amp; <span class="built_in">Object</span>.keys(headers).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    responseBody._headers = headers</span><br><span class="line">  &#125;</span><br><span class="line">  responseBody.timestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  <span class="keyword">return</span> responseBody</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分页查询结果转化</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">buildPagingQueryResult</span> (<span class="params">queryParam, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> data.items) &#123;</span><br><span class="line">    <span class="comment">// Ant Design Vue 中要求每行数据中必须存在字段：key</span></span><br><span class="line">    item.key = item.id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pagedResult = &#123;</span><br><span class="line">    pageSize: queryParam.pageSize,</span><br><span class="line">    pageNo: queryParam.pageNo,</span><br><span class="line">    totalCount: data.totalCount,</span><br><span class="line">    totalPage: data.totalCount / queryParam.pageSize,</span><br><span class="line">    data: data.items</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> transformAbpQueryResult(pagedResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于分页结果而言，我们会将分页大小、当前页数、总页数、总记录数及其对应的数据，统一封装到一个对象中，然后再将其传递给返回值中的<code>result</code>属性。</p><h1 id="最终对接效果"><a href="#最终对接效果" class="headerlink" title="最终对接效果"></a>最终对接效果</h1><p>好了，写了这么多，我们到底实现了一个什么效果呢？对于一开始的角色查询接口，我们可以这样封装到前端的服务层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getRoles</span> (<span class="params">query</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queryParam = transformAbpListQuery(query)</span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">      url: AppConsts.resourceService.baseUrl + <span class="string">'/api/identity/roles'</span>,</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      params: queryParam</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildPagingQueryResult(queryParam, data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们只需要实现<code>loadData()</code>方法即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getRoles, updateRole, createRole, deleteRole &#125; <span class="keyword">from</span> <span class="string">'@/api/recipe/abp.role'</span></span><br><span class="line"></span><br><span class="line">loadData: <span class="function"><span class="params">parameter</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRoles(<span class="built_in">Object</span>.assign(&#123;&#125;, parameter, <span class="keyword">this</span>.queryParam))</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res.result</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>此时，我们可以注意到，ABP vNext 与 Ant Design Vue 完美地集成在一起，并且参数的转换完全符合我们的预期。这样做的好处显而易见，我们只需要遵循 ABP vNext 的规范进行开发即可，考虑到 ABP vNext 可以直接将<code>ApplicationService</code>暴露为 API 接口，这意味着我们写完了接口，就可以立即开始前后端的联调工作，这无疑可以加快我们的研发效率！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/04/09/Uq1M4ZEOJ5VhTdl.png" alt="ABP vNext 与 Ant Design Vue 完成整合" referrerpolicy="no-referrer"></div><div class="image-caption">ABP vNext 与 Ant Design Vue 完成整合</div></figure><p>好了，以上就是这篇博客的全部内容啦！这篇博客要实现的功能其实并不复杂，唯一的难点是，需要在前端和后端两个技术栈上频繁地切换上下文，这可能就是全栈开发者面临的最大挑战，因为技术世界浩如烟海，而一个人的精力终究有限，古人云：<strong>朝闻道，夕死可矣</strong>，人生百年，吾道不孤，还是请你继续努力哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="ABP" scheme="https://qinyuanpei.github.io/tags/ABP/"/>
    
      <category term="Vue" scheme="https://qinyuanpei.github.io/tags/Vue/"/>
    
      <category term="分页" scheme="https://qinyuanpei.github.io/tags/%E5%88%86%E9%A1%B5/"/>
    
      <category term="前端" scheme="https://qinyuanpei.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>浅议 EF Core 分库分表及多租户架构的实现</title>
    <link href="https://qinyuanpei.github.io/posts/2151871792/"/>
    <id>https://qinyuanpei.github.io/posts/2151871792/</id>
    <published>2021-03-27T17:47:47.000Z</published>
    <updated>2021-06-22T07:04:41.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>各位朋友，大家好，我是 Payne，欢迎大家关注我的博客，我的博客地址是：<a href="https://blog.yuanpei.me" target="_blank" rel="noopener">https://blog.yuanpei.me</a>。最近这段时间，我一直在学习 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 框架，在整个学习过程中，我基本就是在“<strong>文档</strong>”和“<strong>源码</strong>”间来回横跳。我个人推荐大家，多去阅读一点优秀的代码，因为阅读 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 的源代码简直就是一种享受，它可以暂时让你摆脱如泥沼一般的业务代码。言归正传，<a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 是一个支持多租户架构的框架，在了解了其多租户的实现原理以后，从中收获一点微不足道的小技巧。正好前几天，刚刚同一位朋友讨论完分库、分表这类话题。因此，在今天这篇博客中，我想和大家一起探讨下 <a href="https://docs.microsoft.com/zh-cn/ef/core/get-started/overview/first-app?tabs=netcore-cli" target="_blank" rel="noopener">EF Core</a> 关于分库、分表以及多租户架构的实现。此中曲折，可以说是初窥门径，或许我无法提供给你一个开箱即用的方案，至少它可以带给你一点启发。有读者朋友建议我，不要总是写这种“<strong>高深</strong>”、“<strong>复杂</strong>”的话题，适当地迎合读者写点不需要动脑子的东西。对此，我想说，我有我个人技术上的追求，希望大家理解！</p><h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><p>首先，我们一起来探讨分库这个话题。从字面含义上了解，分库就是指<strong>应用程序拥有多个数据库，而这些数据库则拥有相同的表结构</strong>。你可能会问，为什么我们需要分库、分表？答案自然是<strong>性能</strong>，<strong>性能</strong>，还是TM的<strong>性能</strong>。我相信，大家都曾经或多或少地听到过<strong>垂直拆分</strong>、<strong>水平拆分</strong>这样的术语，下图展示了如何在<strong>数据库</strong>这一层级上进行拆分：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/03/29/nX8NBbhP9ToQa2M.png" alt="数据库的垂直拆分与水平拆分" referrerpolicy="no-referrer"></div><div class="image-caption">数据库的垂直拆分与水平拆分</div></figure><p>其实，我们可以从<strong>索引存储</strong>、<strong>B+树高度</strong>、<strong>QPS</strong> 和 <strong>连接数</strong> 这四个不同的角度来审视这个话题。相关观点认为，当单表数据量达到一定量级(阿里巴巴Java开发手册中为500W)时，由于内存无法存储其索引，此时SQL查询会产生磁盘IO；行记录的大小决定了B+树的每个叶子节点能存储多少记录，所以，行记录的大小会影响B+树的高度；单个MySQL物理机实例写QPS峰值大概为1万，一旦业务量达到某个量级，这个瓶颈会逐步凸显出来；单个MySQL实例最大连接数有限，更多的访问量意味着需要更多的连接数。</p><p>在谈论分库、分表的时候，我们忍不住会去想譬如“<strong>自动分表</strong>”和“<strong>路由</strong>”这样的问题，这些子库、子表，到底是提前在数据库里分好呢，还是在运行时期间自动去拆分呢，以及我对库/表进行拆分以后，我应该怎么样找到某条数据对应的库/表。我承认，这些问题并不简单，但当我们对问题进行简化以后，分库本质上就是动态地切换数据库，对不对？无非是拆分后的数据库可能会是类似db_0、db_1等等这样的序列。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/03/29/pmhOTFkZYjAsLXq.png" alt="对 Chinook 进行水平拆分" referrerpolicy="no-referrer"></div><div class="image-caption">对 Chinook 进行水平拆分</div></figure><p>对于数据库的自动拆分，博主尝试过的一种方案是：首先，通过<code>Add-Migration</code>生成迁移。然后，通过循环修改连接字符串的方式，调用<code>Context.Database.Migrate()</code>方法为一个数据库迁移表结构和种子数据。当然，有些朋友不认同在生产环境使用迁移的做法，认为对数据库的操作权限还是应该交给 DBA 来管理，这当然无可厚非。我表达的一直都是一种思路，我不想一个工作六年的人，对技术的态度永远都停留在“能跑”、“能抄”这种水平。</p><p>一旦想清楚这一层，实现起来还是非常简单的。我们在配置中准备多个数据库来模拟分库的场景，实际应用中到底是用<strong>范围</strong>、<strong>Hash</strong> 还是 <strong>配置</strong>，大家结合自己的场景来决定就好。其实，这个思路还可以用来做读写分离，无非是这个库更特殊一点，它是个从库。好了，我们一起来看下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里随机连接到某一个数据库</span></span><br><span class="line"><span class="comment">// 实际应该按照某种方式获得数据库库名后缀</span></span><br><span class="line"><span class="keyword">var</span> shardings = _options.Value.MultiTenants;</span><br><span class="line"><span class="keyword">var</span> sharding = shardings[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, shardings.Count)];</span><br><span class="line">_chinookContext.Database.GetDbConnection().ConnectionString = sharding.ConnectionString;</span><br><span class="line">Console.WriteLine(<span class="string">"--------分库场景--------"</span>);</span><br><span class="line">Console.WriteLine(_chinookContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_chinookContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_chinookContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure><p>事实上，如果选择性地忽略 “<strong>路由</strong>” 和 “<strong>自动分表</strong>” 这两个特性，我们已经在 EF 层面上局部的实现了 “<strong>分库</strong>” 功能：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/03/29/jLxlK3fro8qXSas.png" alt="分库场景" referrerpolicy="no-referrer"></div><div class="image-caption">分库场景</div></figure><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>好了，聊完分库，我们再来聊聊分表。分表就是指同一个数据库里拥有多张结构(<strong>Schema</strong>)相同的表。一个典型的例子是，Excel里的多张Sheet，只要它们拥有相同的结构(<strong>Schema</strong>)，就可以视为同一类型的数据，虽然它们拥有不同的表名。和分库类似，分表的着眼点是避免产生“大表”，从而达到提高查询性能的目的。而对应到 EF(<strong>EntityFramework</strong>) 的场景中，<strong>分表本质上就是在解决 EF 动态适配表名的问题</strong>。同样的，下面两张图展示了如何在<strong>表</strong>这个层级进行拆分：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153851001-806440217.jpg" alt="表的垂直拆分" referrerpolicy="no-referrer"></div><div class="image-caption">表的垂直拆分</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153912863-301123895.jpg" alt="表的水平拆分" referrerpolicy="no-referrer"></div><div class="image-caption">表的水平拆分</div></figure><blockquote><p>图片援引自：<a href="https://www.cnblogs.com/qdhxhz/p/11608222.html" target="_blank" rel="noopener">雨点的名字 - 分库分表(1) — 理论</a></p></blockquote><p>譬如，我们以年为单位，产生了<code>Album_2020</code>和<code>Album_2021</code>两张表。那么，在已经定义好了实体<code>Album</code>的情况下，有没有办法可以让实体<code>Album</code>动态地去适配这两张表呢？或许，熟悉 EF 的你，此刻正在心里暗笑道，这有何难，只要在对应实体的<code>OnModelCreating()</code>方法中，修改<code>ToTable()</code>方法的参数就好了啊。可如果你亲自试一试，就会知道这是你的一厢情愿啦！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/03/29/cIFp74gUAX2Q8xq.png" alt="针对 Album 和 Artist 按年份进行拆分" referrerpolicy="no-referrer"></div><div class="image-caption">针对 Album 和 Artist 按年份进行拆分</div></figure><p>事实上，EF 针对实体和表的映射关系做了缓存，这意味着，一旦在<code>OnModelCreating()</code>方法中确定映射关系，这组映射关系将被缓存下来。在 EF 中，这组映射关系的缓存行为，由<code>IModelCacheKeyFactory</code>接口来决定，它提供了一个<code>Create()</code>方法，如果该方法的返回值与上一次相同，则不会调用<code>OnModelCreating()</code>方法。所以，我们的思路就是，让这个<code>Create()</code>方法返回不同的对象。为此，我们考虑实现<code>IModelCacheKeyFactory</code>接口，并用这个自定义实现来替换微软的默认实现。我们一起来看下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicModelCacheKeyFactory</span> : <span class="title">IModelCacheKeyFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Create</span>(<span class="params">DbContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> context <span class="keyword">is</span> ShardingContext shardingContext</span><br><span class="line">            ? (context.GetType(), shardingContext.ShardingSuffix)</span><br><span class="line">            : (<span class="keyword">object</span>)context.GetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了配合<code>DynamicModelCacheKeyFactory</code>的使用，我们还需要定义用于分表的<code>ShardingContext</code>，它继承自<code>DbContext</code>，我们为其扩展了<code>ShardingSuffix</code>属性，并通过注入的<code>IShardingPolicyProvider</code>接口来获取一个分表后缀。比如，我们有<code>Order</code>表，经过拆分后获得<code>Order_01</code>、<code>Order_02</code>这样的子表，所以，这个分表后缀其实就是01、02。没错，我们还是要去修改<code>ToTable()</code>方法中的表名，不同的是，这里的表名是动态的。注意到，<code>Create()</code>方法返回的是一个元组，所以，不同的<code>ShardingSuffix</code>会产生不同的映射关系。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShardingContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Artist&gt; Artist &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Album&gt; Album &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IShardingPolicyProvider _shardingPolicyProvider;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ShardingSuffix &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShardingContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      DbContextOptions&lt;ShardingContext&gt; options, </span></span></span><br><span class="line"><span class="function"><span class="params">      IShardingPolicyProvider shardingPolicyProvider</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _shardingPolicyProvider = shardingPolicyProvider;</span><br><span class="line">        ShardingSuffix = _shardingPolicyProvider.GetShardingSuffix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Album</span></span><br><span class="line">        <span class="comment">// 动态映射表名，譬如：Album_2021</span></span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;().ToTable(<span class="string">$"Album_<span class="subst">&#123;ShardingSuffix&#125;</span>"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;().HasKey(x =&gt; x.AlbumId);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.AlbumId).HasColumnName(<span class="string">"AlbumId"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.Title).HasColumnName(<span class="string">"Title"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.ArtistId).HasColumnName(<span class="string">"ArtistId"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Artist</span></span><br><span class="line">        <span class="comment">// 动态映射表名，譬如：Artist_2021</span></span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;().ToTable(<span class="string">$"Artist_<span class="subst">&#123;ShardingSuffix&#125;</span>"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;().HasKey(x =&gt; x.ArtistId);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;()</span><br><span class="line">          .Property(x =&gt; x.ArtistId).HasColumnName(<span class="string">"ArtistId"</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;()</span><br><span class="line">          .Property(x =&gt; x.Name).HasColumnName(<span class="string">"Name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于分库、分表以后，怎么去匹配对应的库或者表，这类问题我们称之为路由问题。常见的策略主要有，<strong>范围</strong>、<strong>Hash</strong> 和 <strong>配置</strong>：</p><ul><li>范围最直观的就是按照时间来拆分，比如按年、按月、按天等等，主要的问题是分布不均匀；其次，可以按照Id的范围来划分，比如0到10万、10万到20万依次划分到不同的表里，主要的问题是热点数据带来的性能问题。</li><li>Hash主要指哈希取模。例如，可以针对用户Id做如下处理：<code>HASH(userId) % N</code>，其中，<code>N</code>表示当前拆分表的数目。可以预见的问题是，当<code>N</code>变化的时候，会产生数据迁移的需求，所以，这种方式并不利于扩容，</li><li>配置，顾名思义，就是用一张表来存储数据和子表间的映射关系，每次先按照数据的主键找到子表，然后再从子表中查询所需要的数据。好处是扩容灵活，而缺点同样明显，查询配置表，带来了额外的性能损耗。</li></ul><p>在这里，我们是使用年份来作为分表后缀的。为了方便演示，在实现<code>ShardingByYearPolicy</code>类时，我们直接使用了当前时间，这意味着我们会将<code>Album</code>实体映射到<code>Album_2021</code>这张表，以此类推。在实际使用中，更推荐大家使用 <a href="https://halo.sherlocky.com/archives/xue-hua-suan-fa-snowflake/" target="_blank" rel="noopener">雪花算法</a> 生成Id，因为这样，我们就可以通过Id反推出具体的时间范围，进而决定要映射到哪一个库、哪一张表。关于子表的生成，博主这里是通过迁移来实现的，考虑到EF自动创建数据库/表，都需要先创建迁移，所以，这并不是一个开箱即用的方案。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ShardingByYearPolicy</span> : <span class="title">IShardingPolicyProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetShardingSuffix</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;DateTime.Now.ToString(<span class="string">"yyyy"</span>)&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在我们可以编写简单的代码，来验证我们的这些想法是都正确，即使是最简单的控制台程序，我还是喜欢用依赖注入：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入ShardingContext</span></span><br><span class="line">services.AddDbContext&lt;ShardingContext&gt;(options =&gt; &#123;</span><br><span class="line">    options.UseSqlite(config.GetValue&lt;<span class="keyword">string</span>&gt;(<span class="string">"Database:Default"</span>)); </span><br><span class="line">    <span class="comment">//替换默认实现</span></span><br><span class="line">    options.ReplaceService&lt;IModelCacheKeyFactory, DynamicModelCacheKeyFactory&gt;(); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入IShardingPolicyProvider</span></span><br><span class="line">services.AddTransient&lt;IShardingPolicyProvider, ShardingByYearPolicy&gt;();</span><br></pre></td></tr></table></figure><p>接下来，我们可以通过<code>ShardingContext</code>来匹配<code>Album_2021</code>表：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里应该连接到Album_2021表</span></span><br><span class="line"><span class="comment">// 实际应该按照某种方式获得表名后缀</span></span><br><span class="line">Console.WriteLine(<span class="string">"--------分表场景--------"</span>);</span><br><span class="line">Console.WriteLine(_shardingContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_shardingContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_shardingContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure><p>此时，我们会得到下面的结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/03/29/Evj8wXCIsV1Ddme.png" alt="EF Core 分表效果演示" referrerpolicy="no-referrer"></div><div class="image-caption">EF Core 分表效果演示</div></figure><p>至此，如果选择性地忽略 “<strong>路由</strong>” 和 “<strong>自动分表</strong>” 这两个特性，我们已经在 EF 层面上局部的实现了 “<strong>分表</strong>” 功能。怎么样，是不是还行？</p><h1 id="多租户架构"><a href="#多租户架构" class="headerlink" title="多租户架构"></a>多租户架构</h1><p>最后，我们来聊聊多租户架构这个话题。可能有朋友觉得多租户架构和分库、分表没什么关系，不好意思啊，这是个非常合理的联想，因为还真就有关系，甚至我们还能继续发散到读写分离。你想想看，多租户架构中，如果一个租户一个数据库，这是不是就是分库的场景。而在分库的场景中，如果一个是主库，一个是从库，这是不是就是读写分离的场景。在学习数学的过程中，学会转化问题是一种重要的思维，即让一个不熟悉的问题变成一个熟悉的问题，在今天这篇博客中，从分库发散到多租户、读写分离，正是这一思路的体现，通常情况下，多租户架构有多数据库和单数据库两种实现方式。</p><h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><p>多数据库，指每一个租户一个数据库。这种实现方式的好处是，租户间的数据天然隔离，数据库的访问压力天然隔离。可由于所有租户都共享一套应用程序，随着数据库越来越多，维护的成本亦越来越高。参考分库的实现，我们可以非常容易地实现租户数据库的切换。这里，我们的思路是，调用方在 HTTP 请求中加入自定义的首部字段<code>X-TenantId</code>，<code>DbContext</code>通过该字段来匹配对应的链接字符串，这样就可以实现多数据库的多租户架构：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TenantInfoProvider</span> : <span class="title">ITenantInfoProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> X_TENANT_ID = <span class="string">"X-TenantId"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IHttpContextAccessor _httpContextAccessor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TenantInfoProvider</span>(<span class="params">IHttpContextAccessor httpContextAccessor</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _httpContextAccessor = httpContextAccessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetTenantId</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> httpContext = _httpContextAccessor.HttpContext;</span><br><span class="line">        <span class="keyword">if</span> (httpContext != <span class="literal">null</span> &amp;&amp; httpContext.Request.Headers.ContainsKey(X_TENANT_ID))</span><br><span class="line">            <span class="keyword">return</span> httpContext.Request.Headers[X_TENANT_ID].FirstOrDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，假设我们<code>AppSettings.json</code>文件维护各个租户的连接字符串信息。通常，在实际场景中，我们会将这些信息存储在数据库中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Database"</span>: &#123;</span><br><span class="line">    <span class="attr">"Default"</span>: <span class="string">"Data Source=Chinook.db"</span>,</span><br><span class="line">    <span class="attr">"MultiTenants"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"tenantId"</span>: <span class="string">"01"</span>,</span><br><span class="line">        <span class="attr">"ConnectionString"</span>: <span class="string">"Data Source=Chinook01.db"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"tenantId"</span>: <span class="string">"02"</span>,</span><br><span class="line">        <span class="attr">"ConnectionString"</span>: <span class="string">"Data Source=Chinook02.db"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以通过下面的代码片段来实现租户切换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line"><span class="keyword">var</span> database = _options.Value.MultiTenants.FirstOrDefault(x =&gt; x.TenantId == tenantId);</span><br><span class="line"><span class="keyword">if</span> (database == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Invalid tenantId \"<span class="subst">&#123;tenantId&#125;</span>\""</span>);</span><br><span class="line"></span><br><span class="line">_chinookContext.Database.GetDbConnection().ConnectionString = database.ConnectionString;</span><br><span class="line">Console.WriteLine(<span class="string">"--------多租户 + 多数据库--------"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"TenantId:<span class="subst">&#123;tenantId&#125;</span>"</span>);</span><br><span class="line">Console.WriteLine(_chinookContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_chinookContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_chinookContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure><p>可以注意到，一切如我们所预料的一样，程序自动切换到<code>01</code>这个租户：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/03/29/S5QeCjzdcgG9wpT.png" alt="多租户 + 多数据库" referrerpolicy="no-referrer"></div><div class="image-caption">多租户 + 多数据库</div></figure><h2 id="单数据库"><a href="#单数据库" class="headerlink" title="单数据库"></a>单数据库</h2><p>单数据库，指所有租户都在一个数据库里，使用相同的表结构(<strong>Schema</strong>)，并通过<code>TenantId</code>字段进行区分。<a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 中的多租户架构就是这种模式，而我之前的公司，则是单数据库 + 多数据库的混合模式。这种实现方式的好处是数据库非常精简，而缺点同样很明显，一旦某个租户出现问题，非常容易波及所有租户，因为所有租户都在一个数据库里，数据库的压力实际上是大家一起分担的，租户间相互影响的可能性非常大。</p><p>同样地，我们依然需要用到<code>X-TenantId</code>这个请求头，由于所有租户都在一个数据库上，我们不会再试图去修改链接字符串。EF Core 中针对实体提供了<code>HasQueryFilter()</code>扩展方法，该访问允许我们传入一个 Lambda 表达式。此时，我们所有的请求都会自动带上类似<code>Album.TenantId = &#39;xxxx&#39;</code>这样的条件，这样我们就实现了单数据库的多租户架构。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MulitiTenancyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Artist&gt; Artist &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Album&gt; Album &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ITenantInfoProvider _tenantInfoProvider;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MulitiTenancyContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      DbContextOptions&lt;MulitiTenancyContext&gt; options, </span></span></span><br><span class="line"><span class="function"><span class="params">      ITenantInfoProvider tenantInfoProvider</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _tenantInfoProvider = tenantInfoProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line"></span><br><span class="line">        modelBuilder.ApplyConfiguration(<span class="keyword">new</span> ArtistMap());</span><br><span class="line">        modelBuilder.ApplyConfiguration(<span class="keyword">new</span> AlbumMap());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用 HasQueryFilter 进行租户间数据隔离</span></span><br><span class="line">        <span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(tenantId))</span><br><span class="line">        &#123;</span><br><span class="line">            modelBuilder.Entity&lt;Album&gt;().HasQueryFilter(x =&gt; x.TenantId == tenantId);</span><br><span class="line">            modelBuilder.Entity&lt;Artist&gt;().HasQueryFilter(x =&gt; x.TenantId == tenantId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了在实体上应用这个过滤条件，参照 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 中的实现，我们定义了<code>IMulitiTenancy</code>接口，所有实体均需要实现<code>TenantId</code>字段。为了简化设计，我们直接使用字符串类型来定义租户Id，而在 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 中很多主键都被定义为 <code>Guid</code>，我们掌握核心原理即可，不用过分强求和 <a href="https://github.com/abpframework/abp" target="_blank" rel="noopener">ABP vNext</a> 的一致。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMulitiTenancy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMulitiTenancy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Album</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Album</span> : <span class="title">IMulitiTenancy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> AlbumId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以编写简单的测试代码，来验证我们的想法是否正确。同样地，我还是使用了依赖注入：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里应该查询01租户内的Album</span></span><br><span class="line"><span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line">Console.WriteLine(<span class="string">"--------多租户 + 单数据库--------"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"TenantId:<span class="subst">&#123;tenantId&#125;</span>"</span>);</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure><p>可以注意到，打印出的 SQL 语句中自动带出了过滤条件：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/03/29/7na2eIo4suLhTGY.png" alt="多租户 + 多数据库" referrerpolicy="no-referrer"></div><div class="image-caption">多租户 + 多数据库</div></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客主要探讨了 EF 在分库、分表及多租户架构上实施的可能性。分库、分表的目的是为了提高数据库的查询性能，在这个过程中，我们可以考虑<strong>范围</strong>、<strong>Hash</strong>和<strong>配置</strong>三种路由策略，它们各自有自己的优缺点，需要使用者结合业务场景去衡量。虽然分库、分表在面对百万级别以上的数据时，不失为一种提高性能的方案，可世间万物都是双刃剑，它同样带来了一系列新的问题，譬如<strong>跨库写带来的分布式事务问题，跨库读带来的Join、Count()、排序、分页等问题，数据迁移问题</strong>等等，而如果希望通过Hash(Id)来进行拆分，还需要解决<strong>全局Id唯一的问题</strong>。所以说，这是一个没有标准答案的问题，需要使用者自己去进行取舍。多租户架构、读写分离均可以看作是特殊的分库场景，<code>EF Core</code> 中新增的<code>HasQueryFilter()</code>方法则帮助我们解决了单数据库的多租户架构问题。好了，以上就是这篇博客的全部内容啦，如果大家对文中的观点有建议或者意见，欢迎大家在评论区留言，谢谢！</p><p>附本文源代码：<a href="https://github.com/Regularly-Archive/2021/tree/master/EF.Sharding" target="_blank" rel="noopener">https://github.com/Regularly-Archive/2021/tree/master/EF.Sharding</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据存储" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="数据库" scheme="https://qinyuanpei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="EF" scheme="https://qinyuanpei.github.io/tags/EF/"/>
    
      <category term="架构" scheme="https://qinyuanpei.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="多租户" scheme="https://qinyuanpei.github.io/tags/%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>源代码探案系列之 .NET Core 跨域中间件 CORS</title>
    <link href="https://qinyuanpei.github.io/posts/1276287490/"/>
    <id>https://qinyuanpei.github.io/posts/1276287490/</id>
    <published>2021-03-16T21:25:47.000Z</published>
    <updated>2021-06-22T07:04:41.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>本文是 #<strong>源代码探案系列</strong># 第三篇，今天这篇博客，我们来一起解读下 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的 <a href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src" target="_blank" rel="noopener">CORS</a> 中间件，熟悉这个中间件的的小伙伴们，想必都已经猜出本文的主题：跨域。这确实是一个老生常谈的话题，可我并不认为，大家愿意去深入探究这个问题，因为博主曾经发现，每当工作中遇到跨域问题的时候，更多的是直接重写跨域相关的 HTTP 头。博主曾经写过一篇关于跨域的博客：<a href="https://blog.yuanpei.me/posts/3846545990/" target="_blank" rel="noopener">《聊聊前端跨域的爱恨情仇》</a>，当时是完全以前端的视角来看待跨域。所以，在今天这篇博客里，博主想带领大家从一种新的视角来看待跨域，也许，可以从中发现不一样的东西。</p><h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>关于 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的 <a href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src" target="_blank" rel="noopener">CORS</a>，大家都知道的是，可以通过<code>UseCors()</code>方法在整个 HTTP 请求管道中启用跨域中间件，或者是通过<code>AddCors()</code>方法来定义跨域策略，亦或者通过<code>[EnableCors]</code>来显式地指定跨域策略，更多的细节大家可以参考微软的<a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0" target="_blank" rel="noopener">官方文档</a>，而在这里，我想聊一点大家可能不知道的东西，譬如：服务器端如何处理来自浏览器端的跨域请求？而这一切在 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中又如何实现？带着这些问题来解读 <a href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src" target="_blank" rel="noopener">CORS</a> 中间件的源代码，我们能更快的找到我们想得到的答案。一图胜千言，请允许博主使用这张流程图来“开宗明义”，我们这就开始今天的“<strong>探案</strong>”：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/03/16/m1geMX8PfJwN3Bb.png" alt="一张图览尽 CORS 中间件" referrerpolicy="no-referrer"></div><div class="image-caption">一张图览尽 CORS 中间件</div></figure><h1 id="核心部件"><a href="#核心部件" class="headerlink" title="核心部件"></a>核心部件</h1><p>对于整个 <a href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src" target="_blank" rel="noopener">CORS</a> 中间件而言，核心部件主要有：<a href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsPolicy.cs" target="_blank" rel="noopener">CorsPolicy</a>、<a href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsService.cs" target="_blank" rel="noopener">CorsService</a> 以及 <a href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsMiddleware.cs" target="_blank" rel="noopener">CorsMiddleware</a>。</p><h2 id="CorsPolicy"><a href="#CorsPolicy" class="headerlink" title="CorsPolicy"></a>CorsPolicy</h2><p>整个 <strong>CORS</strong> 中间件中，首当其冲的是<code>ICorsPolicy</code>。这个接口的作用是定义跨域的策略，我们知道<code>CORS</code>中引入了<code>Access-Control</code>系列的 HTTP 头，所以，<code>CorsPolicy</code> 本质上是在定义允许哪些 HTTP 头、HTTP 方法、源(<strong>Origin</strong>) 可以访问受限的资源，以及当跨域请求是一个复杂请求的时候，预检请求的超时时间、是否支持凭据等等：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsPolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> AllowAnyHeader &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> AllowAnyMethod &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> AllowAnyOrigin &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;<span class="keyword">string</span>, <span class="keyword">bool</span>&gt; IsOriginAllowed &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="keyword">string</span>&gt; ExposedHeaders &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="keyword">string</span>&gt; Headers &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="keyword">string</span>&gt; Methods &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="keyword">string</span>&gt; Origins &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> TimeSpan? PreflightMaxAge &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> SupportsCredentials &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>在整个中间件的设计中，与<code>CorsPolicy</code>接口产生直接联系的，是<code>CorsPolicyBuilder</code>和<code>ICorsPolicyProvider</code>。相信大家从命名上就可以了解到，前者是一个基于建造者模式的、针对 <code>CorsPolicy</code>进行“<strong>加工</strong>”的工具类，可以快速地对 跨域策略中允许的 HTTP 方法、HTTP 头、源(<strong>Origin</strong>)等信息进行修改。关于这一点，我们可以从<code>CorsPolicyBuilder</code>提供的方法签名中得到印证，而最终<code>CorsPolicyBuilder</code>通过<code>Build()</code>方法来返回一个“<strong>加工</strong>”好的<code>CorsPolicy</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsPolicyBuilder</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithOrigins</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] origins</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithHeaders</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] headers</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithExposedHeaders</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] exposedHeaders</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithMethods</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] methods</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowCredentials</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">DisallowCredentials</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyOrigin</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyMethod</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyHeader</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetPreflightMaxAge</span>(<span class="params">TimeSpan preflightMaxAge</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetIsOriginAllowed</span>(<span class="params">Func&lt;<span class="keyword">string</span>, <span class="keyword">bool</span>&gt; isOriginAllowed</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetIsOriginAllowedToAllowWildcardSubdomains</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicy <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了通过<code>CorsPolicyBuilder</code>来生成跨域策略，我们还可以通过<code>ICorsPolicyProvider</code>来生成跨域策略。如果你经常使用<code>ASP.NET Core</code>中的<strong>配置系统</strong>和<strong>依赖注入</strong>，对于这种“<strong>套路</strong>”应该不会感到陌生。这里，微软提供了一个默认实现：<code>DefaultCorsPolicyProvider</code>。<code>DefaultCorsPolicyProvider</code>本身依赖<code>CorsOptions</code>，允许使用者传入一个<code>CorsPolicy</code>的实例 或者是一个委托，来自定义跨域策略的“<strong>加工</strong>”细节，并在其内部维护一个字典，来实现<a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0#np" target="_blank" rel="noopener">具名的跨域策略</a>。如果使用者不为当前跨域策略指定名称，则会使用默认的跨域策略名称。在大多数场景下，我们并不会直接使用<code>CorsPolicyBuilder</code>，而是在<code>Startup</code>类中通过委托来定义跨域策略，两者可以说是不同层次上的跨域策略的“<strong>提供者</strong>”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultCorsPolicyProvider的GetPolicyAsync()</span></span><br><span class="line"><span class="keyword">public</span> Task&lt;CorsPolicy?&gt; GetPolicyAsync(HttpContext context, <span class="keyword">string</span>? policyName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    policyName ??= _options.DefaultPolicyName;</span><br><span class="line">    <span class="keyword">if</span> (_options.PolicyMap.TryGetValue(policyName, <span class="keyword">out</span> <span class="keyword">var</span> result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.policyTask!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NullResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CorsOptions</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDefaultPolicy</span>(<span class="params">CorsPolicy policy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDefaultPolicy</span>(<span class="params">Action&lt;CorsPolicyBuilder&gt; configurePolicy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPolicy</span>(<span class="params"><span class="keyword">string</span> name, CorsPolicy policy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPolicy</span>(<span class="params"><span class="keyword">string</span> name, Action&lt;CorsPolicyBuilder&gt; configurePolicy</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> CorsPolicy? GetPolicy(<span class="keyword">string</span> name);</span><br></pre></td></tr></table></figure><h2 id="CorsService"><a href="#CorsService" class="headerlink" title="CorsService"></a>CorsService</h2><p>OK，说完了跨域策略的“<strong>定义</strong>”，现在我们来看看跨域策略是如何被中间件“执行”的，这部分代码被定义在<code>CoreService</code>类的<code>EvaluatePolicy()</code>方法中。可以注意到，如果受限资源允许任意源(<strong>Origin</strong>)访问，则服务器端会认为这是一个不安全的跨域策略。</p><p>接下来，从<code>HttpContext</code>中提取客户端的源(<strong>Origin</strong>)，请求方法(<strong>HttpMethod</strong>)。此时，服务器端可以根据请求方法和 HTTP 头 判断当前请求是都为预检请求。按照<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noopener">CORS</a>规范，当请求方法为<code>OPTION</code>且请求头中含有<code>Access-Control-Request-Method</code>时，即表示这是一个预检请求。</p><p>至此，我们有了两种选择，预检请求会交给<code>EvaluatePreflightRequest()</code>方法去处理，非预检请求会交给<code>EvaluateRequest()</code>方法去处理。除了<code>HttpContext</code>和<code>CorsPolicy</code>这两个参数以外，它们都会接受第三个参数<code>CorsResult</code>，它里面封装了我们一开始判断出来的关于源和预检请求的信息。继续细看，我们会发现这两个方法，都调用了<code>PopulateResult()</code>方法，继续顺着这条线索下去，我们就会发现，这个方法的主要作用是，结合跨域策略设定的各种参数，进一步对上一步生成的<code>CorsResult</code>进行“<strong>加工</strong>”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CorsResult <span class="title">EvaluatePolicy</span>(<span class="params">HttpContext context, CorsPolicy policy</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (policy.AllowAnyOrigin &amp;&amp; policy.SupportsCredentials) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(Resources.InsecureConfiguration, <span class="keyword">nameof</span>(policy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> requestHeaders = context.Request.Headers;</span><br><span class="line">    <span class="keyword">var</span> origin = requestHeaders[CorsConstants.Origin];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);</span><br><span class="line">    <span class="keyword">var</span> isPreflightRequest = isOptionsRequest </span><br><span class="line">        &amp;&amp; requestHeaders.ContainsKey(CorsConstants.AccessControlRequestMethod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> corsResult = <span class="keyword">new</span> CorsResult &#123;</span><br><span class="line">        IsPreflightRequest = isPreflightRequest,</span><br><span class="line">        IsOriginAllowed = IsOriginAllowed(policy, origin),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPreflightRequest) &#123;</span><br><span class="line">        <span class="comment">//预检请求</span></span><br><span class="line">        EvaluatePreflightRequest(context, policy, corsResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非预检请求</span></span><br><span class="line">        EvaluateRequest(context, policy, corsResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> corsResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PopulateResult</span>(<span class="params">HttpContext context, </span></span></span><br><span class="line"><span class="function"><span class="params">    CorsPolicy policy, </span></span></span><br><span class="line"><span class="function"><span class="params">    CorsResult result</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> headers = context.Request.Headers;</span><br><span class="line">    <span class="keyword">if</span> (policy.AllowAnyOrigin) &#123;</span><br><span class="line">        result.AllowedOrigin = CorsConstants.AnyOrigin;</span><br><span class="line">        result.VaryByOrigin = policy.SupportsCredentials;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> origin = headers[CorsConstants.Origin];</span><br><span class="line">        result.AllowedOrigin = origin;</span><br><span class="line">        result.VaryByOrigin = policy.Origins.Count &gt; <span class="number">1</span> </span><br><span class="line">            || !policy.IsDefaultIsOriginAllowed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持凭据</span></span><br><span class="line">    result.SupportsCredentials = policy.SupportsCredentials;</span><br><span class="line">    <span class="comment">// 预检请求超时时间</span></span><br><span class="line">    result.PreflightMaxAge = policy.PreflightMaxAge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://fetch.spec.whatwg.org/#http-new-header-syntax</span></span><br><span class="line">    AddHeaderValues(result.AllowedExposedHeaders, policy.ExposedHeaders);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许的HTTP方法</span></span><br><span class="line">    <span class="keyword">var</span> allowedMethods = policy.AllowAnyMethod ?</span><br><span class="line">        <span class="keyword">new</span>[] &#123; result.IsPreflightRequest ? </span><br><span class="line">                (<span class="keyword">string</span>)headers[CorsConstants.AccessControlRequestMethod] : </span><br><span class="line">                context.Request.Method &#125; :</span><br><span class="line">        policy.Methods;</span><br><span class="line">    AddHeaderValues(result.AllowedMethods, allowedMethods);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许的HTTP头</span></span><br><span class="line">    <span class="keyword">var</span> allowedHeaders = policy.AllowAnyHeader ?</span><br><span class="line">        headers.GetCommaSeparatedValues(CorsConstants.AccessControlRequestHeaders) :</span><br><span class="line">        policy.Headers;</span><br><span class="line">    AddHeaderValues(result.AllowedHeaders, allowedHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这些参数最终的走向是哪里呢？我们注意到<code>CorsService</code>里有一个叫做<code>ApplyResult()</code>的方法，观察方法签名可以发现，它负责把跨域检测的结果应用到 HTTP 响应上，相信大家都能想到，这里会设置各种<code>Access-Control</code>系列的头，比如<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>、<br><code>Access-Control-Max-Age</code>…等等。事实上，在<code>CorsMiddleware</code>中间件中，原本就是先调用<code>EvaluateResult()</code>方法，再调用<code>ApplyResult()</code>方法。当然，实际的代码中，还需要考虑<code>[DisableCors]</code>和<code>[EnableCors]</code>两个特性的影响，会多出一点判断的代码。关于跨域的代码层面的东西，我们就先讲到这里，在下一部分，我们会专门讲<code>CORS</code>里的简单请求和复杂请求。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context, ICorsPolicyProvider corsPolicyProvider</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!context.Request.Headers.ContainsKey(CorsConstants.Origin)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [DisableCors]</span></span><br><span class="line">    <span class="keyword">var</span> corsMetadata = endpoint?.Metadata.GetMetadata&lt;ICorsMetadata&gt;();</span><br><span class="line">    <span class="keyword">if</span> (corsMetadata <span class="keyword">is</span> IDisableCorsAttribute) &#123;</span><br><span class="line">        <span class="keyword">var</span> isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);</span><br><span class="line">        <span class="keyword">var</span> isCorsPreflightRequest = isOptionsRequest </span><br><span class="line">            &amp;&amp; context.Request.Headers.ContainsKey(CorsConstants.AccessControlRequestMethod);</span><br><span class="line">        <span class="keyword">if</span> (isCorsPreflightRequest) &#123;</span><br><span class="line">            <span class="comment">// If this is a preflight request, and we disallow CORS, complete the request</span></span><br><span class="line">            context.Response.StatusCode = StatusCodes.Status204NoContent;</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// [EnableCors]</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (corsMetadata <span class="keyword">is</span> IEnableCorsAttribute enableCorsAttribute &amp;&amp;</span><br><span class="line">        enableCorsAttribute.PolicyName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Evaluate &amp;&amp; Apply</span></span><br><span class="line">        <span class="keyword">return</span> EvaluateAndApplyPolicy(context, corsPolicy);</span><br><span class="line">        <span class="function"><span class="keyword">async</span> Task <span class="title">InvokeCoreAwaited</span>(<span class="params">HttpContext context, Task&lt;CorsPolicy?&gt; policyTask</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> corsPolicy = <span class="keyword">await</span> policyTask;</span><br><span class="line">            <span class="keyword">await</span> EvaluateAndApplyPolicy(context, corsPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="再论CORS"><a href="#再论CORS" class="headerlink" title="再论CORS"></a>再论CORS</h1><p>好了，行文至此。既然这篇博客的主题是“<strong>跨域</strong>”，那么，我们不妨多说一点。我们知道，“<strong>跨域</strong>”产生的背景是，浏览器作为一个公共环境，它本身是不被信任的，所以，为了杜绝非当前域的资源，例如Cookie、API等等被“<strong>窃取</strong>”，浏览器便增加了“<strong>跨域</strong>”这一限制。而为了顺应“<strong>前后端分离</strong>”、“<strong>微服务</strong>”等等的开发思想，“<strong>跨域</strong>”这个问题开始频繁地出现在人们的视野中，从最初的<strong>JSONP</strong>，到如今成为事实标准的<strong>CORS</strong>，甚至从<strong>Vue</strong>里的代理服务器、<strong>Nginx</strong>里的反向代理，我们总是能窥出一点“<strong>跨域</strong>”的影子，“<strong>跨域</strong>”可谓是无处不在。</p><p>那么，什么是 CORS 呢？ CORS ，即跨域资源共享，是一种利用 HTTP 头部来指示服务器端对除自身以外的源(域、协议、端口)是否可以访问指定的资源。你可能会联想到<strong>OAuth2</strong>、<strong>JWT</strong>等等关于认证授权的词汇，请注意，“跨域”始终发生在浏览器端，相对于浏览器，一般意义上的客户端都被视为可信任的。除此之外，CORS提供了一种被称之为“预检”的机制，它可以用来检测服务器端支持的 HTTP 请求头、HTTP 动词，在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://media.prod.mdn.mozit.cloud/attachments/2016/10/28/14295/a21a85eaccd405d608395b4ca8d82538/CORS_principle.png" alt="为什么会发生跨域？" referrerpolicy="no-referrer"></div><div class="image-caption">为什么会发生跨域？</div></figure><p>如上图所示，浏览器端，特别是<code>XMLHttpRequest</code> 、<code>Fetch API</code> 、<code>Web</code>字体 和 <code>Canvas</code>等始终遵循同源策略，<code>domain-a.com</code>和<code>domain-b.com</code>被视为两个不同域，因此，当<code>domain-a.com</code>试图访问<code>domain-b.com</code>下的资源时，就会被浏览器所限制，这就是我们所说的“<strong>跨域</strong>”。可能，这并不是一个特别好的例子，因为 HTML 中某些元素天生就被设计为允许跨域，例如：<code>image</code>、<code>iframe</code>、<code>link</code>、<code>script</code>等等。而如果我们通过“<strong>协商</strong>”来告诉<code>domain-b</code>，<code>domain-a</code>希望访问它下面的资源，这其实就是我们所说的 CORS 啦！这个“<strong>协商</strong>”过程呢，主要有两种，即 <strong>简单请求</strong> 和 <strong>复杂请求</strong>。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>我们将不触发 CORS 预检 的请求称为简单请求，通常情况下，简单请求满足下列条件：</p><ul><li>使用下列方法之一：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener">GET</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener">HEAD</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener">POST</a></li><li>除了被用户代理自动设置的首部字段(例如：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener">Connection</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent" target="_blank" rel="noopener">User-Agent</a>) 和 在 Fetch 规范中定义为 <a href="https://fetch.spec.whatwg.org/#forbidden-header-name" target="_blank" rel="noopener">禁用首部名称</a> 的其他首部，允许人为设置的字段为 Fetch 规范定义的 <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header" target="_blank" rel="noopener">对 CORS 安全的首部字段集合</a>。该集合为：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept" target="_blank" rel="noopener">Accept</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language" target="_blank" rel="noopener">Accept-Language</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language" target="_blank" rel="noopener">Content-Language</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type" target="_blank" rel="noopener">Content-Type</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#dpr" target="_blank" rel="noopener">DPR</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#downlink" target="_blank" rel="noopener">Downlink</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#save-data" target="_blank" rel="noopener">Save-Data</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#viewport-width" target="_blank" rel="noopener">Viewport-Width</a>、<a href="http://httpwg.org/http-extensions/client-hints.html#width" target="_blank" rel="noopener">Width</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type" target="_blank" rel="noopener">Content-Type</a> 的值仅限于下列三者之一：text/plain、multipart/form-data、application/x-www-form-urlencoded</li><li>请求中的任意 <a href="">XMLHttpRequestUpload</a> 对象均没有注册任何事件监听器；<a href="">XMLHttpRequestUpload</a> 对象可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload" target="_blank" rel="noopener">XMLHttpRequest.upload</a> 属性访问。</li><li>请求中没有使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" target="_blank" rel="noopener">ReadableStream</a> 对象。</li></ul><p>对于 <strong>简单请求</strong> ，由于它的 HTTP 动词是确定的，故其跨域主要体现在服务器端返回的 HTTP 响应中，可能出现的响应头有：<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Headers</code>等。所以，如果客户端请求的<code>Origin</code>被包含在服务器端返回的<code>Access-Control-Allow-Origin</code>中，则表示跨域被允许，反之则不被允许。所以，现在大家应该能想明白，为啥那些年里大家稀里糊涂地，把<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Headers</code>设置为<code>*</code>就万事大吉了吧，而对照着中间件的代码，理解这层含义会更容易一点！</p><h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>与简单请求不同，<strong>复杂请求</strong> 要求必须首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS" target="_blank" rel="noopener">OPTIONS</a> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”<strong>预检请求</strong>“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://media.prod.mdn.mozit.cloud/attachments/2019/06/19/16753/b32f78ac26d18e3e155205e4f0057b73/preflight_correct.png" alt="预检请求" referrerpolicy="no-referrer"></div><div class="image-caption">预检请求</div></figure><p>当浏览器检测到，从<code>JavaScript</code>中发起的请求需要被预检。此时，可以注意到，预检请求中同时携带了下面两个首部字段：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-<span class="function"><span class="keyword">Method</span>:</span> POST</span><br><span class="line">Access-Control-Request-Headers：X-PINGOTHER, Content-<span class="keyword">Type</span></span><br></pre></td></tr></table></figure><p>服务器在接受预检请求后，会返回以下响应头：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Allow-Origin: http://foo.example</span><br><span class="line"><span class="keyword">Access</span>-Control-Allow-Methods: POST, <span class="keyword">GET</span>, <span class="keyword">OPTIONS</span></span><br><span class="line"><span class="keyword">Access</span>-Control-Allow-Headers: X-PINGOTHER, Content-<span class="keyword">Type</span></span><br><span class="line"><span class="keyword">Access</span>-Control-Max-Age: <span class="number">86400</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>首部字段<code>Access-Control-Allow-Methods</code>表明服务器允许客户端使用 POST、GET 和 OPTIONS 方法发起请求。</li><li>首部字段<code>Access-Control-Allow-Headers</code>表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type。</li><li>首部字段<code>Access-Control-Max-Age</code>表明该响应的有效时间为 86400 秒，即 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。</li></ul><p>下面整理了 CORS 中常见的 <strong>Access-Control</strong> 系列头部字段：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Access-<span class="keyword">Control</span>-Allow-Origin</span><br><span class="line">Access-<span class="keyword">Control</span>-Expose-Headers</span><br><span class="line">Access-<span class="keyword">Control</span>-<span class="keyword">Max</span>-Age</span><br><span class="line">Access-<span class="keyword">Control</span>-Allow-Credentials</span><br><span class="line">Access-<span class="keyword">Control</span>-Allow-Methods</span><br><span class="line">Access-<span class="keyword">Control</span>-Allow-Headers</span><br><span class="line">Origin</span><br><span class="line">Access-<span class="keyword">Control</span>-Request-<span class="keyword">Method</span></span><br><span class="line">Access-<span class="keyword">Control</span>-Request-Headers</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分别从 <strong>源代码</strong> 和 <strong>规范</strong> 两个角度探讨了 “<strong>跨域</strong>” 这个话题，两者可以说是相辅相成的存在，CORS 中间件实现了 CORS 规范，而通过 CORS 规范帮助我们理解了中间件。“<strong>跨域</strong>”产生的背景是，浏览器作为一个公共环境，它本身是不被信任的，所以，为了杜绝非当前域的资源，例如Cookie、API等等被“<strong>窃取</strong>”，浏览器便增加了 “<strong>跨域</strong>” 这一限制。最初我们通过 <strong>JSONP</strong> 这种方案来解决跨域问题，而后来我们有了<strong>CORS</strong> 这种事实上的标准，其原理上利用 <strong>Origin</strong> 及 <strong>Access-Control</strong>系列的头来标识服务器端可以允许哪些源、以什么样的 HTTP 动词 / 头来访问资源，按照 CORS 规范，浏览器端发起的请求被分为： <strong>简单请求</strong> 和 <strong>复杂请求</strong> 两种，两者最大的区别是，<strong>复杂请求</strong> 必须首先通过 <strong>OPTIONS</strong> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。好了，以上就是这篇博客的全部内容啦，欢迎大家在博客评论中参与讨论，再次谢谢大家，晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="源码" scheme="https://qinyuanpei.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="中间件" scheme="https://qinyuanpei.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="跨域" scheme="https://qinyuanpei.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="https://qinyuanpei.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>源代码探案系列之 .NET Core 限流中间件 AspNetCoreRateLimit</title>
    <link href="https://qinyuanpei.github.io/posts/2396015802/"/>
    <id>https://qinyuanpei.github.io/posts/2396015802/</id>
    <published>2021-03-10T21:52:47.000Z</published>
    <updated>2021-06-22T07:04:41.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>在上一篇文章中，博主带领大家一起深入了解 <a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter" target="_blank" rel="noopener">ConcurrencyLimiter</a> 这个中间件，正当我得意洋洋地向 <a href="https://www.cnblogs.com/catcher1994/" target="_blank" rel="noopener">Catcher Wong</a> 大佬吹嘘这一点小收获时，大佬一脸嫌弃地说，一个单机版的方案有什么好得意的啊。大佬言下之意，显然是指，这个中间件在分布式环境中毫无用武之地。其实，你只需要稍微想一下，就能想明白这个问题。毕竟，它只是通过<code>SeamphoreSlim</code>控制线程数量而已，一旦放到分布式环境中，这个并发控制就被大大地削弱。所以，在今天这篇文章中，博主会带领大家一起“<strong>探案</strong>” <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的限流中间件 <a href="https://github.com/stefanprodan/AspNetCoreRateLimit" target="_blank" rel="noopener">AspNetCoreRateLimite</a>，希望大家可以从中感悟到不一样的东西。对我而言，这可能是人到中年的焦虑感所催生出来的一种源动力，同时亦是为了不让那些订阅专栏的同学失望。</p><p>关于“<strong>限流</strong>”这个话题，我个人以为，它可以引申出非常多的东西，譬如“熔断”和“限流”，其实可以看作是同一类问题的“一体两面”。最早接触熔断，是源于 <strong>Spring Cloud</strong> 中的 <strong>Hystrix</strong>，它其实是指当服务不可用的时候，客户端应该采取什么样的措施去应对，实际使用中我们可能会考虑重试、超时、降级等策略。相应地，当服务端在面对来自客户端的异常流量时，就产生了“限流”这个概念，“限流”可以是线程隔离<strong>(</strong>线程数 + 队列大小限制<strong>)，可以是信号量隔离(</strong>设置最大并发请求数目<strong>)，可以是限制QPS。这里，我们讨论的主要是第三种，而实现限流的常见算法主要有</strong>计数器算法<strong>、</strong>漏桶算法<strong>和</strong>令牌桶算法<strong>。这里，<a href="https://github.com/stefanprodan/AspNetCoreRateLimit" target="_blank" rel="noopener">AspNetCoreRateLimit</a> 这个中间件，则主要使用了</strong>计数器算法**，并配合 <code>IMemoryCache</code> 和 <code>IDistributedCache</code> 分别实现了基于内存和基于分布式缓存的持久化逻辑。</p><h1 id="源代码解读"><a href="#源代码解读" class="headerlink" title="源代码解读"></a>源代码解读</h1><p>首先，使用者通过配置定义了一个或者多个规则，这些规则决定了每个客户端在访问特定终结点时，一段时间内可以访问的最大次数。 <a href="">RateLimitMiddleware</a> 通过注入的<a href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Middleware/RateLimitMiddleware.cs">IRateLimitProcessor</a> 来匹配规则，然后依次判断每个规则是否达到了限流条件。一旦达到限流条件，中间件会改变 HTTP 响应的状态码、响应头、返回值，告知使用者已达到最大调用次数。而针对每一种 <a href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Core/IRateLimitProcessor.cs" target="_blank" rel="noopener">IRateLimitProcessor</a> ，主要通过<code>ProcessRequestAsync()</code> 方法来实现计数，如果上一次的请求对应的时间戳 + 规则中时间间隔 &gt;= 当前时间，则说明请求没有过期，此时，就需要给这个计数增加1。好了，现在我们来针对 <a href="https://github.com/stefanprodan/AspNetCoreRateLimit" target="_blank" rel="noopener">AspNetCoreRateLimit</a> 中的核心部件逐个进行解读。</p><h2 id="RateLimitProcessor"><a href="#RateLimitProcessor" class="headerlink" title="RateLimitProcessor"></a>RateLimitProcessor</h2><p><code>RateLimitProcessor</code>，是一个抽象类，实现了<code>IRateLimitProcessor</code>接口，公开的方法有 3 个：<code>ProcessRequestAsync()</code>、<code>IsWhitelisted()</code> 和 <code>GetRateLimitHeaders()</code>。在此基础上，派生出<code>ClientRateLimitProcessor</code>和<code>IpRateLimitProcessor</code>两个子类。两者最大的不同在于，其所依赖的<code>Store</code>不同，前者为<code>IClientPolicyStore</code>，后者<code>IIpPolicyStore</code>，它们都实现了同一个接口<code>IRateLimitStore</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IRateLimitStore&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="keyword">bool</span>&gt; <span class="title">ExistsAsync</span>(<span class="params"><span class="keyword">string</span> id, CancellationToken cancellationToken = <span class="keyword">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task&lt;T&gt; <span class="title">GetAsync</span>(<span class="params"><span class="keyword">string</span> id, CancellationToken cancellationToken = <span class="keyword">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">RemoveAsync</span>(<span class="params"><span class="keyword">string</span> id, CancellationToken cancellationToken = <span class="keyword">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">SetAsync</span>(<span class="params"><span class="keyword">string</span> id, T entry, TimeSpan? expirationTime = <span class="literal">null</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">        CancellationToken cancellationToken = <span class="keyword">default</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，这些都是典型的基于键-值的存储，所以，不管是基于内存的IMemeryCache，还是基于分布式缓存的IDistributedCache，都可以做到无缝切换。不同的Processor，本质上是它们生成缓存键的方式不同，例如，<code>IpRateLimitProcessor</code>是用一个前缀来表示一组IP，而<code>ClientRateLimitProcessor</code>则是用通过客户端前缀和客户端Id来作为区分：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/IpRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="keyword">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policies = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$"<span class="subst">&#123;_options.IpPolicyPrefix&#125;</span>"</span>,</span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">new</span> List&lt;RateLimitRule&gt;();</span><br><span class="line">    <span class="keyword">if</span> (policies?.IpRules?.Any() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// search for rules with IP intervals containing client IP</span></span><br><span class="line">        <span class="keyword">var</span> matchPolicies = policies.IpRules</span><br><span class="line">            .Where(r =&gt; IpParser.ContainsIp(r.Ip, identity.ClientIp));</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> matchPolicies)</span><br><span class="line">        &#123;</span><br><span class="line">            rules.AddRange(item.Rules);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/ClientRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="keyword">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policy = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$"<span class="subst">&#123;_options.ClientPolicyPrefix&#125;</span>_<span class="subst">&#123;identity.ClientId&#125;</span>"</span>, </span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, policy?.Rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>RateLimitProcessor</code>而言，其实现思路是，通过<code>CounterKeyBuilder</code>及其子类来生成计数器标识(<strong>CounterId</strong>)，然后再通过<code>AsyncKeyLock</code>来实现计数，最终通过<code>IRateLimitCounterStore</code>来实现存储：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">async</span> Task&lt;RateLimitCounter&gt; <span class="title">ProcessRequestAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    ClientRequestIdentity requestIdentity, </span></span></span><br><span class="line"><span class="function"><span class="params">    RateLimitRule rule, </span></span></span><br><span class="line"><span class="function"><span class="params">    CancellationToken cancellationToken = <span class="keyword">default</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">    &#123;</span><br><span class="line">        Timestamp = DateTime.UtcNow,</span><br><span class="line">        Count = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成CounterId</span></span><br><span class="line">    <span class="keyword">var</span> counterId = BuildCounterKey(requestIdentity, rule);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于AsyncLock的计数器</span></span><br><span class="line">    <span class="comment">// serial reads and writes on same key</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">await</span> AsyncLock.WriterLockAsync(counterId).ConfigureAwait(<span class="literal">false</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> entry = <span class="keyword">await</span> _counterStore.GetAsync(counterId, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.HasValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// entry has not expired</span></span><br><span class="line">            <span class="keyword">if</span> (entry.Value.Timestamp + rule.PeriodTimespan.Value &gt;= DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// increment request count</span></span><br><span class="line">                <span class="keyword">var</span> totalCount = entry.Value.Count + _config.RateIncrementer?.Invoke() ?? <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// deep copy</span></span><br><span class="line">                counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">                &#123;</span><br><span class="line">                    Timestamp = entry.Value.Timestamp,</span><br><span class="line">                    Count = totalCount</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计数器存储</span></span><br><span class="line">        <span class="comment">// stores: id (string) - timestamp (datetime) - total_requests (long)</span></span><br><span class="line">        <span class="keyword">await</span> _counterStore.SetAsync(</span><br><span class="line">            counterId, </span><br><span class="line">            counter, </span><br><span class="line">            rule.PeriodTimespan.Value, </span><br><span class="line">            cancellationToken</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AsyncKeyLock"><a href="#AsyncKeyLock" class="headerlink" title="AsyncKeyLock"></a>AsyncKeyLock</h2><p>在分析<code>RateLimitProcessor</code>类的时候，我们提到了<code>AsyncKeyLock</code>。对于<code>AsyncKeyLock</code>的实现，我个人认为这是整个中间件的精华，因为这里出现了，和<code>SeamphoreSlim</code>一样经典的东西，这里用到了自旋锁<code>SpinLock</code>。我个人理解，<code>SpinLock</code> 约等于 <code>Interlocked</code> + 内核级别的while。这部分代码本身并不复杂，难就难在这样一个精妙的想法上面。其中，<a href="">AsyncKeyLockDoorman</a> 这个类的实现，应该是参考了微软的一篇博客—— <a href="https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-7-asyncreaderwriterlock/">Building Async Coordination Primitives, Part 7: AsyncReaderWriterLock</a>，因为<code>ReaderLockAsync()</code>、<code>WriterLockAsync()</code>、<code>ReaderRelease()</code> 和 <code>WriterRelease()</code> 这 4 个关键方法完全一样。结合限流这个场景来看，它是典型的“<strong>多写</strong>”场景，因为如果是相同的请求，那么就会产生相同的计数器标识(<strong>CounterId</strong>)，所以，这个<code>AsyncLockDoorman</code>这个类所定义的上下文边界，其实是“<strong>一读多写</strong>”的问题，所以，我们可以注意到，它里面定义了一个“写”操作的队列<code>_waitingWriters</code>，一个“读操作”的<code>_waitingReader</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncKeyLockDoorman</span>(<span class="params">Action&lt;AsyncKeyLockDoorman&gt; reset</span>)</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 多个写入者</span></span><br><span class="line">    _waitingWriters = <span class="keyword">new</span> Queue&lt;TaskCompletionSource&lt;Releaser&gt;&gt;();</span><br><span class="line">    <span class="comment">// 单个读取者</span></span><br><span class="line">    _waitingReader = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">    _status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    _readerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">false</span>));</span><br><span class="line">    _writerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">true</span>));</span><br><span class="line">    _reset = reset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于“写”操作而言，当一个新的写入者希望进来的时候，如果此时锁没有被别人占用，那么这个新的写入者会获得这个锁，状态值<code>m_status</code>会被修改为-1。反之，如果此时这个锁已经被别人占用了，那么这个新的写入者将会进入等待队列。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">WriterLockAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _status = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> _writerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> waiter = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">            _waitingWriters.Enqueue(waiter);</span><br><span class="line">            <span class="keyword">return</span> waiter.Task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于“读”操作而言，我们来思考这样一个问题，什么时候“读”操作会被允许呢？答案是这一时刻没有写入者正在“写”或者“等”，因为如果不这样的话，就会发生我们平常所说的“<strong>脏读</strong>”，所以，这种情况下，就必须强迫“读取者”去等待写入者“空闲”下来。此时，不难理解<code>ReadLockAsync()</code>的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">ReaderLockAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status &gt;= <span class="number">0</span> &amp;&amp; _waitingWriters.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++_status;</span><br><span class="line">            <span class="keyword">return</span> _readerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++_readersWaiting;</span><br><span class="line">            <span class="keyword">return</span> _waitingReader.Task.ContinueWith(t =&gt; t.Result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们把视线拉回到<code>AsyncKeyLock</code>，它负责维护一组<code>AsyncKeyLockDoorman</code>，其内部部通过一个字典来维护<code>CounterId</code>和<code>AsyncKeyLockDoorman</code>间的关系。与此同时，为了减少创建·AsyncKeyLockDoorman·带来的性能损耗，它使用一个栈来存储<code>AsyncKeyLockDoorman</code>。每次获取<code>AsyncKeyLockDoorman</code>的过程，本质上就是为指定的<code>Key</code>分配<code>AsyncKeyLockDoorman</code>的过程，同时会更新其引用数<code>RefCount</code>。相应地，释放<code>AsyncKeyLockDoorman</code>的过程，本质上就是减少其引用数<code>RefCount</code>，从字典中移除指定<code>Key</code>，“<strong>归还</strong>”对象池的过程：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AsyncKeyLockDoorman <span class="title">GetDoorman</span>(<span class="params"><span class="keyword">string</span> key</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AsyncKeyLockDoorman doorman;</span><br><span class="line">    <span class="keyword">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (!Keys.TryGetValue(key, <span class="keyword">out</span> doorman))</span><br><span class="line">        &#123;</span><br><span class="line">            doorman = (Pool.Count &gt; <span class="number">0</span>) ? Pool.Pop() : </span><br><span class="line">                <span class="keyword">new</span> AsyncKeyLockDoorman(ReleaseDoorman);</span><br><span class="line">            doorman.Key = key;</span><br><span class="line">            Keys.Add(key, doorman);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doorman.RefCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doorman;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReleaseDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReleaseDoorman</span>(<span class="params">AsyncKeyLockDoorman doorman</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (--doorman.RefCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Keys.Remove(doorman.Key);</span><br><span class="line">            <span class="keyword">if</span> (Pool.Count &lt; MaxPoolSize)</span><br><span class="line">            &#123;</span><br><span class="line">                doorman.Key = <span class="literal">null</span>;</span><br><span class="line">                Pool.Push(doorman);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RateLimitMiddleware"><a href="#RateLimitMiddleware" class="headerlink" title="RateLimitMiddleware"></a>RateLimitMiddleware</h2><p>OK，到这里，我们再回过头去看<strong>源代码解读</strong>这里的内容，大概就可以串起来整合中间件的调用链路，<code>Middleware</code>-&gt;<code>RateLimteProcessor</code>-&gt;<code>AsyncKeyLock</code>-&gt;<code>AsyncKeyLockDoorman</code>，坦白来讲，我一直没能想明白为什么要用<code>SpinLock</code>？难道仅仅是为了减少等待时间、提高性能吗？经过精简，我们发现，整个中间件的<code>Invoke()</code>方法，大致要经历下面几个阶段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查限流是否启用</span></span><br><span class="line">    <span class="keyword">if</span> (_options == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户身份</span></span><br><span class="line">    <span class="keyword">var</span> identity = <span class="keyword">await</span> ResolveIdentityAsync(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查白名单</span></span><br><span class="line">    <span class="keyword">if</span> (_processor.IsWhitelisted(identity))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取限流规则</span></span><br><span class="line">    <span class="keyword">var</span> rulesDict = <span class="keyword">new</span> Dictionary&lt;RateLimitRule, RateLimitCounter&gt;();</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">await</span> _processor.GetMatchingRulesAsync(</span><br><span class="line">        identity, </span><br><span class="line">        context.RequestAborted</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> rule <span class="keyword">in</span> rules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取计数器数目</span></span><br><span class="line">        <span class="keyword">var</span> rateLimitCounter = <span class="keyword">await</span> _processor.ProcessRequestAsync(</span><br><span class="line">            identity, </span><br><span class="line">            rule, </span><br><span class="line">            context.RequestAborted</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (rule.Limit &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 请求未过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Timestamp + rule.PeriodTimespan.Value &lt; DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Count &gt; rule.Limit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 各种记日志，告诉调用者多长时间后再重试</span></span><br><span class="line">                <span class="keyword">var</span> retryAfter = rateLimitCounter.Timestamp.RetryAfterFrom(rule);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 中止请求</span></span><br><span class="line">                <span class="keyword">await</span> ReturnQuotaExceededResponse(context, rule, retryAfter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Limit &lt;= 0, 相当于直接不允许放行，中止请求</span></span><br><span class="line">            <span class="keyword">await</span> ReturnQuotaExceededResponse(</span><br><span class="line">                context, </span><br><span class="line">                rule, </span><br><span class="line">                <span class="keyword">int</span>.MaxValue.ToString(System.Globalization.CultureInfo.InvariantCulture)</span><br><span class="line">            ); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置X-Rate-Limit头</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>作为 <a href="https://blog.yuanpei.me/posts/18417412/" target="_blank" rel="noopener">并发限制</a> 这一篇的“姊妹篇”，这一篇的难度相对上一篇堪称“高山仰止”，主要的难点是 <strong>SpinLock</strong> 、“一读多写”的异步读写锁 <strong>AsyncKeyLock</strong> 以及 <strong>AsyncKeyLockDoorman</strong> 。如果大家感兴趣的话，可以去搜索一下 <strong>AsyncKeyLock</strong> 这个关键字，大家就会发现在好多<a href="https://github.com/SixLabors/ImageSharp.Web/" target="_blank" rel="noopener">开源项目</a> 中都能找到类似的代码片段，莫非这是某种神奇的算法吗？阅读源代码，其实是一个无法“立竿见影”的学习方法，有时候我们要通过叙述或者表达来输出我们对待一件事物的看法。这是因为，我们自以为是的“学会”和真正的“学会”，这两者间可能千差万别，就像我最近在用 <a href="https://abp.io" target="_blank" rel="noopener">ABP vNext</a> 搭建一个小项目，阅读文档的时候，眼睛觉得它“学会”了，而实际需要需要扩展或者替换 ABP 的实体/服务的时候。我的手会告诉我，它真的“不会”。做一个知难行易的“调包”侠也许会非常容易，可正因为如此，你要凸显自我就会非常困难。世上的事情，“<strong>夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</strong>”，哪怕就是增长一下见识呢，你说对吧……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="源码" scheme="https://qinyuanpei.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="中间件" scheme="https://qinyuanpei.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="限流" scheme="https://qinyuanpei.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>源代码探案系列之 .NET Core 并发限制中间件 ConcurrencyLimiter</title>
    <link href="https://qinyuanpei.github.io/posts/18417412/"/>
    <id>https://qinyuanpei.github.io/posts/18417412/</id>
    <published>2021-03-04T20:13:47.000Z</published>
    <updated>2021-06-22T07:04:41.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>打算开一个新的专栏——<strong>源代码探案系列</strong>，目的是通过源代码来探索更广阔的技术世界。因为我越来越意识到，我可能缺乏一个结构化的知识体系，虽然处在一个碎片化的时代，从外界接收了大量的信息，可这些碎片化的信息，到底能不能转化为自身可用的知识，其实是需要去认真思考一番。尤其是当我注意到，许多人工作多年，在经历过从“<strong>生手</strong>”到“<strong>熟练工</strong>”这种蜕变以后，居然还是会害怕原理性内容的考察。我承认，程序员这个职业更像是一个“<strong>手艺人</strong>”，可我更想说一句古人的话——<strong>君子不器</strong>。什么是器呢？“<strong>形而上者谓之道，形而下者谓之器</strong>”，用一句更直白的话来说，就是“<strong>不能知其然而不知其所以然</strong>”，这是我一个非CS科班出身的程序员，想去写这样一个专栏的初衷，因为在我看来，“<strong>器</strong>”是永远学不完的，而“<strong>道</strong>”虽然听起来虚无缥缈，实则“<strong>朝闻道，夕死可矣</strong>”。</p><p>作为这个专栏的第一篇博客，我打算从 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的 <a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter" target="_blank" rel="noopener">ConcurrencyLimiter</a> 这个中间件开始。并发是一个爱恨交织的话题，我们喜欢高并发，因为这是程序员跻身高手行列的好机会；我们厌恶并发，因为它引入了多线程、锁、信号量这些复杂的东西。相信大家都曾被并发困扰过，古人云：<strong>他山之石，可以攻玉</strong>，还有什么比阅读源代码更朴实无华的“学习”呢？你找大牛，大牛可能忙着开会、做PPT；你找同事，同事里可能十个有八个都不知道啊。这个中间件的核心是 <code>IQueuePolicy</code> ，其位于以下<a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter/src/QueuePolicies" target="_blank" rel="noopener">位置</a>，它定义了两个核心的方法：<code>TryEnterAsync()</code> 和 <code>OnExit()</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IQueuePolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ValueTask&lt;<span class="keyword">bool</span>&gt; <span class="title">TryEnterAsync</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其默认实现<code>QueuePolicy</code>中，<code>TryEnterAsync()</code>方法，决定着一个请求是会被拒绝还是接受。具体是怎么做呢？它定义了一个最大的并发请求数目，如果实际数超过了最大的并发请求数目，那么请求将会被拒绝。反之，请求将被接受。再仔细看，我们就会发现，它内部使用了<code>SeamphoreSlim</code>和<code>Interlocked</code>，所以，聪明的小伙伴们应该立马会联想到，这两种锁各自的作用是什么。</p><p>其中，<code>Seamphore</code> 是一个 Windows 内核中的一个同步信号量，适用于在多个有限的线程资源中共享内存资源，它就像一个栅栏，本身具有一定的容量，当线程数量达到这个容量后，新的线程就无法再通过，直到某个线程执行完成。<code>SeamphoreSlim</code>是<code>Seamphore</code>优化后的版本，在性能上表现更好一点，更推荐大家使用<code>SeamphoreSlim</code>。</p><p>而 <code>Interlocked</code> 的则是我们熟悉的原子操作，它可以在多个线程中，对共享的内存资源进行原子加或者原子减操作。在这里，<code>Interlocked</code>主要用来控制并发请求数的加和减。如果当前的并发请求数小于最大的并发请求数，表示还可以允许新的请求进来，此时，<code>TryEnterAsync()</code>方法会返回true。如果此时的并发请求数大于最大的并发请求数，则需要对当前请求数进行减操作，此时，<code>TryEnterAsync()</code>方法会返回false。</p><p>一旦搞清楚这一点，结合中间件的代码，我们可以非常容易地想明白,这个并发控制的实现思路。下面是<code>QueuePolicy</code>中<code>TryEnterAsync()</code>和<code>OnExit()</code>两个方法的实现，分别代表了“<strong>加锁</strong>”和“<strong>解锁</strong>”两个不同的阶段。某种程度上，<code>Seamphore</code>更像一个水闸，每次可以通过的“<strong>流量</strong>”是固定的，超出的部分会被直接“<strong>拒绝</strong>”：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“加锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ValueTask&lt;<span class="keyword">bool</span>&gt; <span class="title">TryEnterAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a return value of 'false' indicates that the request is rejected</span></span><br><span class="line">    <span class="comment">// a return value of 'true' indicates that the request may proceed</span></span><br><span class="line">    <span class="comment">// _serverSemaphore.Release is *not* called in this method, </span></span><br><span class="line">    <span class="comment">// it is called externally when requests leave the server</span></span><br><span class="line">    <span class="keyword">int</span> totalRequests = Interlocked.Increment(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//当前请求次数 &gt; 最大请求次数，返回false表示拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (totalRequests &gt; _maxTotalRequest) &#123;</span><br><span class="line">        Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="keyword">bool</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Task task = _serverSemaphore.WaitAsync();</span><br><span class="line">    <span class="keyword">if</span> (task.IsCompletedSuccessfully) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="keyword">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SemaphoreAwaited(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“解锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _serverSemaphore.Release();</span><br><span class="line">    Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="揭秘-StackPolicy"><a href="#揭秘-StackPolicy" class="headerlink" title="揭秘 StackPolicy"></a>揭秘 StackPolicy</h1><p>除了<code>QueuePolicy</code>这种实现以外，官方还提供了<code>StackPolicy</code>的实现。从名称上，我们就能大致区分出它们的不同，因为我相信大家都能拎得清“队列”和“栈”。在实现<code>StackPolicy</code>的过程中，首先会判断是否还有访问请求次数<code>_freeServerSpots</code>，直接返回true，确保中间件可以继续执行。如果<code>_queueLength</code>和我们设置的队列最大容量相同，此时，表示队列已满，需要先取消之前的请求，并保留后来的请求。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ValueTask&lt;<span class="keyword">bool</span>&gt; <span class="title">TryEnterAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_freeServerSpots &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="keyword">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列已满，则取消之前的请求，即_head</span></span><br><span class="line">        <span class="keyword">if</span> (_queueLength == _maxQueueCapacity) &#123;</span><br><span class="line">            _hasReachedCapacity = <span class="literal">true</span>;</span><br><span class="line">            _buffer[_head].Complete(<span class="literal">false</span>);</span><br><span class="line">            _queueLength--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> tcs = _cachedResettableTCS ?? </span><br><span class="line">            = <span class="keyword">new</span> ResettableBooleanCompletionSource(<span class="keyword">this</span>);</span><br><span class="line">        _cachedResettableTCS = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_hasReachedCapacity || _queueLength &lt; _buffer.Count) &#123;</span><br><span class="line">            _buffer[_head] = tcs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _buffer.Add(tcs);</span><br><span class="line">        &#125;</span><br><span class="line">        _queueLength++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// increment _head for next time</span></span><br><span class="line">        <span class="comment">// 如果_head = 最大队列容量，则_head需要移动至首位</span></span><br><span class="line">        _head++;</span><br><span class="line">        <span class="keyword">if</span> (_head == _maxQueueCapacity) &#123;</span><br><span class="line">            _head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tcs.GetValueTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_queueLength == <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots++;</span><br><span class="line"></span><br><span class="line">            f (_freeServerSpots &gt; _maxConcurrentRequests) &#123;</span><br><span class="line">                _freeServerSpots--;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"OnExit must only be called once per successful call to TryEnterAsync"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step backwards and launch a new task</span></span><br><span class="line">    <span class="keyword">if</span> (_head == <span class="number">0</span>) &#123;</span><br><span class="line">        _head = _maxQueueCapacity - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _head--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _buffer[_head].Complete(<span class="literal">true</span>);</span><br><span class="line">    _queueLength--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，现在，你可以感受到这两种策略的差异了，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。此时，如果我们再回过头来看 <a href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs" target="_blank" rel="noopener">ConcurrencyLimiterMiddleware</a> 这个中间件的实现，就会有种恍然大悟的感觉。</p><h1 id="揭秘-Middleware"><a href="#揭秘-Middleware" class="headerlink" title="揭秘 Middleware"></a>揭秘 Middleware</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we only ever call GetResult once on the TryEnterAsync ValueTask b/c it resets.</span></span><br><span class="line">    <span class="comment">// 以下代码片段，其实都是调用IQueuePolicy.TryEnterAsync()</span></span><br><span class="line">    <span class="keyword">var</span> waitInQueueTask = _queuePolicy.TryEnterAsync();</span><br><span class="line">    <span class="keyword">bool</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitInQueueTask.IsCompleted) &#123;</span><br><span class="line">        ConcurrencyLimiterEventSource.Log.QueueSkipped();</span><br><span class="line">        result = waitInQueueTask.Result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> (ConcurrencyLimiterEventSource.Log.QueueTimer())</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">await</span> waitInQueueTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当result为true，表示请求被接收，此时，让中间件继续执行</span></span><br><span class="line">    <span class="comment">// 切记：调用_queuePolicy.OnExit()来释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> _next(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            _queuePolicy.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里就是请求被拒绝的情况，修改状态码以及输出错误信息</span></span><br><span class="line">        ConcurrencyLimiterEventSource.Log.RequestRejected();</span><br><span class="line">        ConcurrencyLimiterLog.RequestRejectedQueueFull(_logger);</span><br><span class="line">        context.Response.StatusCode = StatusCodes.Status503ServiceUnavailable;</span><br><span class="line">        <span class="keyword">await</span> _onRejected(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就理清了整个中间件的运作机制，<a href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs" target="_blank" rel="noopener">ConcurrencyLimiterMiddleware</a> 中注入了<code>IQueuePolicy</code>这个接口，当一个新的请求进来，中间件会调用<code>IQueuePolicy</code>接口的<code>TryEnterAsync()</code>方法，该方法决定了一个请求是会被接受还是拒绝。当请求被接受的时候，中间件会调用<code>_next(context)</code>让请求继续往下走；当请求被拒绝的时候，中间件会修改 HTTP 状态码(503) 和 返回值，保证调用者可以收到错误信息。这就是这个中间件全部的秘密。而如果要在项目中使用这个中间件，同样是非常简单的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 中间件基本法，先注册后使用</span></span><br><span class="line"><span class="comment">// ConfigureServices()</span></span><br><span class="line"><span class="comment">// 或者 services.AddQueuePolicy()</span></span><br><span class="line">services.AddStackPolicy(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.MaxConcurrentRequests = <span class="number">2</span>;</span><br><span class="line">    options.RequestQueueLimit = <span class="number">25</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure()</span></span><br><span class="line">app.UseConcurrencyLimiter();</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，主要揭秘了 <a href="https://github.com/dotnet/aspnetcore" target="_blank" rel="noopener">ASP.NET Core</a> 中的 <a href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter" target="_blank" rel="noopener">ConcurrencyLimiter</a> 中间件，这个中间件的主要功能是控制 ASP.NET Core 中的请求并发。作为这个中间件的核心，微软为 <code>IQueuePolicy</code> 接口提供了 <code>QueuePolicy</code> 和 <code>StackPolicy</code> 两种不同的策略实现。其中，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。对于我们而言，这个中间件最值得学习的地方，其实是<code>SeamphoreSlim</code>和<code>Interlocked</code>，我们经常提到“<strong>锁</strong>”，其实，“<strong>锁</strong>”不单单是指 .NET 中<code>Monitor</code>的语法糖，即<code>lock</code>关键字，在同步信号量以及线程同步的相关话题中，我们还会接触到譬如 <strong>Mutex(互斥锁)</strong>、ReaderWriterLockSlim、<strong>Interlocked(原子操作)</strong>、<strong>SpinLock(自旋锁)</strong> 以及 SeamphoreSlim 等等不同的“<strong>锁</strong>”。除此之外，还有譬如AutoResetEvent、ManualResetEvent 和 ManualResetEventSlim 等等的同步信号量。如果有读者朋友对此感兴趣，可以到 MSDN 上去搜索相关的关键字，能让博主本人和大家从中有所收获，这是我坚持写下去的理由。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="源码" scheme="https://qinyuanpei.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="并发" scheme="https://qinyuanpei.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="中间件" scheme="https://qinyuanpei.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>通过 EmbededFileProvider 实现 Blazor 的静态文件访问</title>
    <link href="https://qinyuanpei.github.io/posts/3789745079/"/>
    <id>https://qinyuanpei.github.io/posts/3789745079/</id>
    <published>2021-02-23T05:37:47.000Z</published>
    <updated>2021-06-22T07:04:41.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>重构我的 <a href="https://blog.yuanpei.me" target="_blank" rel="noopener">独立博客</a> ，是博主今年的计划之一，这个基于 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 的静态博客，最早搭建于2014年，可以说是比女朋友更亲密的存在，陪伴着博主走过了毕业、求职以及此刻的而立之年。其间虽然尝试过像 <a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a> 和 <a href="https://www.gohugo.org/" target="_blank" rel="noopener">Hugo</a> 这样的静态博客生成器，可是考虑到模板、插件等周边生态，这个想法一直被搁置下来。直到最近，突然涌现出通过 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">Blazor</a> 重写博客的想法，尤其是它对于 <a href="https://webassembly.org/" target="_blank" rel="noopener">WebAssembly</a> 的支持，而类似 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a> 和 <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>的组件化开发模式，在开发体验上有着同样不错的表现。所以，今天这篇博客就来聊聊在重写博客过程中的一点收获，即如何让 Blazor 访问本地的静态文件。</p><h1 id="从内嵌资源说起"><a href="#从内嵌资源说起" class="headerlink" title="从内嵌资源说起"></a>从内嵌资源说起</h1><p>首先，我们要引入一个概念，即：内嵌资源。我们平时接触的更多的是本地文件系统，或者是 FTP 、对象存储这类运行在远程服务器上的文件系统，这些都是非内嵌资源，所以，内嵌资源主要是指那些没有目录层级的文件资源，因为它会在编译的时候“<strong>嵌入</strong>”到动态链接库(DLL)中。一个典型的例子是<code>Swagger</code>，它在<code>.NET Core</code>平台下的实现是<a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore" target="_blank" rel="noopener">Swashbuckle.AspNetCore</a>，它允许使用自定义的HTML页面。这里可以注意到，它使用到了<code>GetManifestResourceStream()</code>方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// requires file to be added as an embedded resource</span></span><br><span class="line">    c.IndexStream = () =&gt; GetType().Assembly</span><br><span class="line">        .GetManifestResourceStream(<span class="string">"CustomUIIndex.Swagger.index.html"</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实，这里使用的就是一个内嵌资源。关于内嵌资源，我们有两种方式来定义它：</p><ul><li>在 Visual Studio 中选中指定文件，在其属性窗口中选择生成操作为嵌入的资源：</li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/23/Zftpl5UFnmcLK49.png" alt="如何定义一个文件资源为内嵌资源" referrerpolicy="no-referrer"></div><div class="image-caption">如何定义一个文件资源为内嵌资源</div></figure><ul><li>在项目文件(<strong>.csproj</strong>)中修改对应<code>ItemGroup</code>节点，参考示例如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">"Microsoft.NET.Sdk.Web"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EmbeddedResource</span> <span class="attr">Include</span>=<span class="string">"_config.yml"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CopyToOutputDirectory</span>&gt;</span>Always<span class="tag">&lt;/<span class="name">CopyToOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">EmbeddedResource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就完成了内嵌资源的定义。而定义内嵌资源，本质上还是为了在运行时期间去读取和使用，那么，自然而然地，我们不禁要问，该怎么读取这些内嵌资源呢？在<code>Assembly</code>类中，微软为我们提供了下列接口来处理内嵌资源：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> ManifestResourceInfo <span class="title">GetManifestResourceInfo</span>(<span class="params"><span class="keyword">string</span> resourceName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span>[] <span class="title">GetManifestResourceNames</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Stream <span class="title">GetManifestResourceStream</span>(<span class="params">Type type, <span class="keyword">string</span> name</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Stream <span class="title">GetManifestResourceStream</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>GetManifestResourceNames()</code>方法用来返回所有内嵌资源的名称，<code>GetManifestResourceInfo()</code>方法用来返回指定内嵌资源的描述信息，<code>GetManifestResourceStream()</code>方法用来返回指定内嵌资源的文件流。为了方便大家理解，这里我们准备了一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.GetExecutingAssembly();</span><br><span class="line"><span class="keyword">var</span> resources = assembly.GetManifestResourceNames();</span><br><span class="line">resources.ToList().ForEach(x =&gt; Console.WriteLine(x));</span><br><span class="line"><span class="comment">//ConsoleApp.A.B.示例文档.txt</span></span><br><span class="line"><span class="comment">//ConsoleApp.A._config.yml</span></span><br><span class="line"><span class="keyword">var</span> fileInfo = assembly.GetManifestResourceInfo(resources[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> fileStream = assembly.GetManifestResourceStream(resources[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>此时，我们会发现，内嵌资源都是使用类似<code>A.B.C.D</code>这样的形式来表示资源路径的，因为内嵌资源本身是没有目录层级的。现在，如果我们再回过头去看<code>Swagger</code>的示例，就不难理解为什么会有<code>CustomUIIndex.Swagger.index.html</code>这样一个奇怪的值，因为它对应着实际的物理文件路径，如下图所示，示例代码中输出的资源路径和实际的物理路径存在着对应关系：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/23/jgqxFTPt2OnHMyh.png" alt="项目中的物理路径与内嵌资源路径对照" referrerpolicy="no-referrer"></div><div class="image-caption">项目中的物理路径与内嵌资源路径对照</div></figure><h1 id="EmbededFileProvider"><a href="#EmbededFileProvider" class="headerlink" title="EmbededFileProvider"></a>EmbededFileProvider</h1><p>OK，那么在了解了内嵌资源以后，接下来，我们需要关注的是<code>EmbededFileProvider</code>。需要说明的是，在<code>ASP.NET Core</code>中，微软是通过<code>IFileProvider</code>这个接口来解决文件读取问题的，典型的使用场景有静态文件中间件、Rozar模板引擎以及WWWRoot目录定位等等，通常情况下，我们使用<code>PhysicalFileProvider</code>更多一点，它和<code>EmbededFileProvider</code>一样，都实现了<code>IFileProvider</code>接口，所以，<code>ASP.NET Core</code>可以从不同的来源访问文件信息。</p><p>显然，<code>EmbededFileProvider</code>正是为了内嵌资源而生，它在内部使用到了<code>Assembly</code>类中和内嵌资源相关的接口.所以，除了上面的方式，我们还可以通过下面的方式来访问内嵌资源，需要注意的是，使用<code>EmbededFileProvider</code>需要引用<code>Microsoft.Extensions.FileProviders.Embedded</code>，大家可以比较一下这两种方式地差异：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.GetExecutingAssembly();</span><br><span class="line"><span class="keyword">var</span> provider = <span class="keyword">new</span> EmbeddedFileProvider(assembly);</span><br><span class="line"><span class="comment">//注意，这里写"."或者""都可以</span></span><br><span class="line"><span class="keyword">var</span> resouces = provider.GetDirectoryContents(<span class="string">"."</span>).ToList();</span><br><span class="line"><span class="keyword">var</span> fileInfo = provider.GetFileInfo(resouces[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> fileStream = fileInfo.CreateReadStream();</span><br></pre></td></tr></table></figure><p>除此以外，<code>IFileProvider</code>还有一个最重要的功能，即<code>Watch()</code>方法，它可以监听文件的变化，并返回一个<code>IChangeToken</code>。有没有一种似曾相识燕归来的感觉？没错，博主曾经在 <a href="https://blog.yuanpei.me/posts/835719605/" target="_blank" rel="noopener">基于选项模式实现.NET Core的配置热更新</a> 这篇文章中介绍过它，它是实现配置热更新的关键。事实上，<code>FileConfigurationSource</code>这个类中有一个<code>Provider</code>属性，而它对应的类型恰好是<code>IFileProvider</code>，这难道是巧合吗？不，仔细顺着这条线，我们大概就能明白微软的良苦用心，我们的配置文件自然是来自文件系统，而考虑到内嵌资源的存在，我们面对的文件系统其实是一个广义的文件系统，它可以是物理文件、内嵌文件、Glob、对象存储(<strong>OSS</strong>)等等</p><h1 id="Blazor的奇妙缘分"><a href="#Blazor的奇妙缘分" class="headerlink" title="Blazor的奇妙缘分"></a>Blazor的奇妙缘分</h1><p>好了，千呼万唤始出来，现在终于要讨论 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">Blazor</a> 这个话题啦！众所周知，静态博客生成器里主要存在着两种配置，即站点配置和主题配置，<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 里甚至还支持从特定文件夹里加载自定义的数据。所以，对于静态博客而言，它需要有从外部加载数据这个特性。我们知道，<a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">Blazor</a> 分为服务器和客户端两个版本，两者的区别主要在于 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-5.0" target="_blank" rel="noopener">Rozar</a> 模板由谁来渲染，前者相当于服务端渲染(<strong>SSR</strong>) + <a href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/javascript-client?view=aspnetcore-5.0" target="_blank" rel="noopener">SignalR</a>，而后者则是基于 <a href="https://webassembly.org/" target="_blank" rel="noopener">WebAssembly</a>，它可以直接在浏览器中加载。显然，后者更接近我们静态博客生成器的想法。由于 Hexo 使用 Yaml 作为配置语言，所以，为了读取原来 Hexo 博客的配置，参考 <a href="https://www.cnblogs.com/nianming/p/7097338.html" target="_blank" rel="noopener">实现自己的.NET Core配置Provider之Yaml</a> 这篇博客实现了一个YamlConfigurationProvider。</p><p>在使用的过程中，遇到的问题是，它无法识别配置文件的路径。原因很简单，经过编译的 Blazor 会被打包为 WebAssembly ，而 WebAssembly 在前端加载以后，原来的目录层级早已荡然无存。此时，基于物理文件的 <code>PhysicalFileProvider</code> 将无法工作。解决方案其实大家都能想到，换一种<code>IFileProvider</code>的实现就好了啊！至此，奇妙的缘分产生了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">YamlConfigurationProvider</span> : <span class="title">FileConfigurationProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> FileConfigurationSource _source;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YamlConfigurationProvider</span>(<span class="params">FileConfigurationSource source</span>) : <span class="title">base</span>(<span class="params">source</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> path = _source.Path;</span><br><span class="line">        <span class="keyword">var</span> provider = _source.FileProvider;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = provider.GetFileInfo(path).CreateReadStream())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//核心问题就是这个Stream的来源发生了变化</span></span><br><span class="line">            <span class="keyword">var</span> parser = <span class="keyword">new</span> YamlConfigurationFileParser();</span><br><span class="line">            Data = parser.Parse(stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实，<a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/fundamentals/configuration?view=aspnetcore-3.1" target="_blank" rel="noopener">官方文档</a>中提到过，Blazor 的配置文件默认从 WWWRoot 下的<code>appsettings.json</code>加载，所以，对于像JSON这类静态文件，可以注入HttpClient，以API的方式进行访问。例如，官方文档中推荐的加载配置文件的方式为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient()</span><br><span class="line">&#123;</span><br><span class="line">    BaseAddress = <span class="keyword">new</span> Uri(builder.HostEnvironment.BaseAddress)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">builder.Services.AddScoped(sp =&gt; httpClient);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前方有语法糖，高甜:)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> http.GetAsync(<span class="string">"cars.json"</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> stream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line"></span><br><span class="line">builder.Configuration.AddJsonStream(stream);</span><br></pre></td></tr></table></figure><p>而经过我们这样改造以后，我们还可以这样加载配置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">builder.Configuration.AddYamlFile(</span><br><span class="line">    provider:<span class="keyword">new</span> EmbeddedFileProvider(Assembly.GetExecutingAssembly()),</span><br><span class="line">    path: <span class="string">"_config.yml"</span>,</span><br><span class="line">    optional:<span class="literal">false</span>,</span><br><span class="line">    reloadOnChange:<span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一旦这些配置注入到 IoC 容器里，我们就可以纵享无所不在的依赖注入，这里以某个组件为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@using Microsoft.Extensions.Configuration</span><br><span class="line">@inject IConfiguration Configuration</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container-fluid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-row DreamCat-content-header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mdui-container fade-scale in"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>@Configuration["title"]<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">"subtitle"</span>&gt;</span>@Configuration["subtitle"]<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样地，对于组件内的数据，在大多数场景下，我们可以这样来处理，还是因为有无所不在的依赖注入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@page "/"</span><br><span class="line">@layout MainLayout</span><br><span class="line"></span><br><span class="line">@inject HttpClient httpClient</span><br><span class="line">@using BlazorBlog.Core.Domain.Blog;</span><br><span class="line">@using BlazorBlog.Web.Shared.Partials;</span><br><span class="line">@if (posts != null &amp;&amp; posts.Any())</span><br><span class="line">&#123;</span><br><span class="line">    foreach (var post in posts)</span><br><span class="line">    &#123;</span><br><span class="line">        //这是一个自定义组件</span><br><span class="line">        <span class="tag">&lt;<span class="name">PostItem</span> <span class="attr">Model</span>=<span class="string">post</span>&gt;</span><span class="tag">&lt;/<span class="name">PostItem</span>&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@code</span><br><span class="line">&#123;</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">Post</span>&gt;</span> posts &#123; get; set; &#125;</span><br><span class="line">    protected override async Task OnInitializedAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        posts = await httpClient.GetFromJsonAsync&lt;List&lt;Post&gt;&gt;("content.json");</span><br><span class="line">        await base.OnInitializedAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以给大家展示下尚在开发中的静态博客：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/23/wMED8k6SbqITpma.png" alt="基于 Balzor 的静态博客" referrerpolicy="no-referrer"></div><div class="image-caption">基于 Balzor 的静态博客</div></figure><p>理论上任何文件都可以这样做，主要是考虑到配置这种信息，用依赖注入会更好一点，这样每一个组件都可以使用这些配置，而如果是以 API 的形式集成，以目前 Blazor 打包以后加载的效果来看，页面会有比较大的“<strong>空白期</strong>”。我更加疑惑的是，如果 Blazor 打包后的体积过大，那么浏览器自带的存储空间是否够用呢？一句话总结的话， Blazor 是一个写起来非常舒服的框架，可未来是否会像当年的 Sliverlight 一样，这还要看大家对 WebAssembly 的接受程度，可谓是“<strong>路漫漫其修远兮</strong>”啊……</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，是博主由一个个“<strong>闪念</strong>”而串联起来的脑洞，作为一个实验性质的尝试，希望通过 Blazor 的客户端模式(<strong>WebAssembly</strong>) 实现一个静态博客，而在这个过程中，需要解决 Balzor 读取本地文件的问题，由此，我们引入了这篇博客的主题之一，即：<code>EmbededFileProvider</code>。顺着这条线索，我们梳理了内嵌的文件资源、<code>IFileProvider</code>接口、<code>FileConfigurationProvider</code>、<code>FileConfigurationSource</code>等等一系列看起来毫无关联的概念。事实上，“<strong>冥冥之中自有天意</strong>”，这一切怎么会毫无关联呢？我们最终从文件系统看到了配置系统，聊到了 Blazor 中的配置问题，这里我们熟悉的依赖注入、配置系统都得以延续下来。其实，单单就解决这个问题而言，完全不值得专门写一篇博客，<strong>可从一个点辐射到整个面的这种感悟，在人生的成长中更显得弥足珍贵，希望我们每一个人都能多多跳脱出自己的视角，去努力的看一看这个丰富多彩的世界，在多样性与多元化中去寻找整体上的统一，这是作为技术人员的我，一生都想去探索的哲学</strong>。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论中留下你的想法或者建议，谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term=".NET Core" scheme="https://qinyuanpei.github.io/tags/NET-Core/"/>
    
      <category term="Blazor" scheme="https://qinyuanpei.github.io/tags/Blazor/"/>
    
      <category term="文件" scheme="https://qinyuanpei.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="WebAssembly" scheme="https://qinyuanpei.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>低代码，想说爱你不容易</title>
    <link href="https://qinyuanpei.github.io/posts/2637069146/"/>
    <id>https://qinyuanpei.github.io/posts/2637069146/</id>
    <published>2021-02-15T12:37:47.000Z</published>
    <updated>2021-06-22T07:04:41.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>一直想写篇文章，聊一聊“<strong>低代码</strong>”这个话题。一方面，“<strong>低代码</strong>”这个概念确实非常火，其热度丝毫不亚于曾经的“<strong>中台</strong>”。有人说，2021年是属于“<strong>云原生</strong>”的时代，看起来我们每一年都在被技术的“<strong>娱乐圈</strong>”抛弃，明明连 <code>Kubernetes</code> 都还没有入门呢？人们已然在欢呼雀跃般地声称要抛弃 <code>Docker</code> 。这个世界有时就是如此地魔幻，明明我们生活在一个拥有大量基础设施的时代，我们不必再像前辈们“刀耕火种”一般地去开发软件，可我们的生存空间为什么就越来越狭窄了呢？拼多多事件过去没有多久，腾讯的阳光普照奖再次让“<strong>打工魂</strong>”觉醒，也许果真像大鱼海棠里设定的一样，人的记忆只有7秒。而另一方面，我想结合我最近开发“<strong>工作流</strong>”的感受，来吐槽下这个看起来美好的“<strong>低代码</strong>”。也许，对企业而言，引入“<strong>低代码</strong>”的确能减少研发成本，可博主并不认为，它会降低业务本身的复杂性，如果所有声称“<strong>低代码</strong>”或者“<strong>无代码</strong>”的项目，最终依然需要研发人员来作为收场。对此，我想说，对不起，这不是我想要的“<strong>低代码</strong>”。</p><h1 id="低代码发展现状"><a href="#低代码发展现状" class="headerlink" title="低代码发展现状"></a>低代码发展现状</h1><p>或许，一个人成熟的标志就是，在面对一个未知的事物的时候，决不会不由分说地一通吐槽，就像一个人在职场上，你不能永远都只是学会抱怨，相对于抱怨，人们更希望听到的是解决方案。所以，一个人的成长，本质上就是不断学会为自己、为别人找解决方案的过程，前者是为了认识自我，而后者是为了交换资源。所以，在听我吐槽“<strong>低代码</strong>”前，不妨先一起来看看低代码的发展现状。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/15/j6dAcDPEopHSLCa.png" alt="低代码产品发展现状" referrerpolicy="no-referrer"></div><div class="image-caption">低代码产品发展现状</div></figure><h2 id="国外趋势"><a href="#国外趋势" class="headerlink" title="国外趋势"></a>国外趋势</h2><p>有人认为，“<strong>低代码</strong>”的兴起源于钉钉的低代码应用 <a href="https://www.aliwork.com/" target="_blank" rel="noopener">易搭</a> 的落地。诚然，巨头企业的每一个动向都引领着整个行业的风潮，可低代码这个概念最早要追溯到1980年。彼时，<strong>IBM</strong> 的快速应用程序开发工具(<strong>RAD</strong>)被冠以新的名字——低代码，这是低代码这个概念首次面向大众，此后的40年里，国外诞生了诸如 <a href="https://www.outsystems.com/" target="_blank" rel="noopener">Outsystem</a> 、<a href="https://www.mendix.com/" target="_blank" rel="noopener">Mendix</a> 、 <a href="https://www.zoho.com/creator/developers/" target="_blank" rel="noopener">Zoho Creator</a> 等等的产品，整体发展相对缓慢。直到2015年以后，AWS、Google、Microsoft 和 Oracle 等巨头开始入局低代码领域。2018年，西门子更是宣布以 6 亿欧元收购低代码应用开发领域的领导者 <a href="https://www.mendix.com/" target="_blank" rel="noopener">Mendix</a> 、快速应用开发的低代码平台 <a href="https://www.outsystems.com/" target="_blank" rel="noopener">Outsystem</a> 获得 3.6 亿美金的投资，低代码平台市场开始火爆起来，我们所熟悉的 <a href="https://docs.microsoft.com/zh-cn/power-platform/" target="_blank" rel="noopener">Power Platform</a>，其实就是微软的低代码开发平台，低代码领域通常都需要大量的积累和研发，需要有10到20年左右的技术沉淀。</p><h2 id="国内风云"><a href="#国内风云" class="headerlink" title="国内风云"></a>国内风云</h2><p>国内的低代码领域，相比国外发展起步较晚，可依然涌现出像<a href="https://www.newdao.net/" target="_blank" rel="noopener">牛刀</a>、<a href="https://www.apicloud.com/" target="_blank" rel="noopener">APICloud</a>、<a href="https://www.ivx.cn/" target="_blank" rel="noopener">iVX</a>、<a href="https://www.dadayun.cn/index" target="_blank" rel="noopener">搭搭云</a>、氚云、简道云、云表、<a href="https://www.aliwork.com/" target="_blank" rel="noopener">宜搭云</a>等等产品。从整体上而言，这类这类产品基本上都提供了可视化搭建环境，都声称无需编码即可完成业务系统的搭建。其实，从一名程序员的初心出发，我们所做的一切努力都是为了以后不写代码。经常有人问，怎么样可以做到零缺陷、零 Bug ，其实不写代码就好啦！我们并不担心低代码让我们失业，相反地，如果低代码可以消化掉 30% 的垃圾项目，那么，我们将会有更多的时间去做些有意义的事情，而不是在一个“<strong>劣币驱逐良币</strong>”的市场里，靠着 <code>996</code> 来争个你死我活。而从低代码的商业价值角度来看，<a href="https://www.salesforce.com" target="_blank" rel="noopener">Salesforce</a>、<a href="https://www.appian.co.uk/" target="_blank" rel="noopener">Appian</a>、<a href="https://www.joget.org/" target="_blank" rel="noopener">Joget</a> 这三家公司均已上市，<a href="https://www.mendix.com/" target="_blank" rel="noopener">Mendix</a> 和 <a href="https://www.outsystems.com/" target="_blank" rel="noopener">Outsystem</a> 更是估值 10 亿美元以上的独角兽公司，这正是巨头们入局低代码的原因所在。</p><p>低代码领域，目前关注的重点主要集中在：<strong>表单生成和处理</strong>、<strong>工作流生成和管理</strong>、<strong>办公协作</strong>、<strong>人力资源</strong>、<strong>客户关系</strong>、<strong>ERP</strong> 等企业应用上，就如同 <strong>SAP</strong> 、<strong>金蝶</strong>、 <strong>SCM</strong> 等企业软件一样，每一个软件都曾声称能帮助企业解决某一类问题，低代码领域同样遵循“<strong>二八原则</strong>”，即 80% 的场景，通过定义的方法论、方式、工具集能够实现；而剩下的 20% 的场景或许实现不了，需要使用者通过扩展的方式来自行解决。譬如，针对大多数企业都存在的 CRUD 的需求，通过在线的 Excel 表格来实现基于表的业务驱动。例如 <a href="https://www.seatable.cn/" target="_blank" rel="noopener">SeaTable</a> 就是这类主打协同工作的产品；针对大多数企业都存在的审批类的需求，则可以通过可视化的工作流设计系统来完成。例如 <a href="https://www.grapecity.com.cn/aboutus" target="_blank" rel="noopener">葡萄城</a> 的 <a href="https://www.grapecity.com.cn/developer/spreadjs" target="_blank" rel="noopener">SpreadJS</a> 和 <a href="https://www.grapecity.com.cn/solutions/huozige" target="_blank" rel="noopener">活字格</a> ，同样可以视为低代码平台，甚至早期的 .NET 开发者被人“黑”只会拖控件，这难道不是广义上的低代码吗？</p><h1 id="低代码产品形态"><a href="#低代码产品形态" class="headerlink" title="低代码产品形态"></a>低代码产品形态</h1><p>搞清楚整个低代码的发展现状以后，那么，整个低代码领域主要的产品形态有哪些呢？了解其主要的产品形态，对于我们形成低代码的直观印象非常有帮助。在我看来，主要分为四类：</p><ul><li>表单生成类：以 <a href="https://www.aliwork.com/" target="_blank" rel="noopener">宜搭云</a> 和 <a href="https://www.jnpfsoft.com/" target="_blank" rel="noopener">JNPF</a> 为代表，主张通过可视化的设计器来完成页面布局、编排、设计，即所谓的“所见即所得”，类似的还有 <a href="https://www.ivx.cn/" target="_blank" rel="noopener">iVX</a>。</li><li>工作流生成类：以 Mendix 和 Outsystems 为代表，提供组件式的服务，通过编排工作流来实现特定的业务，即通过流程图的方式来实现业务逻辑部分，不同的节点代表不同的功能，不同的线条代表不同的分支。</li><li>协同工作类：以 <a href="https://www.seatable.cn/" target="_blank" rel="noopener">SeaTable</a> 为代表，基于表的业务驱动开发平台，可以以不同的维度管理数据、对数据可视化、共享协作等等，同时具备自动化规则、脚本运行等能力。</li><li>服务聚合类：以 <a href="https://www.apicloud.com/" target="_blank" rel="noopener">APICloud</a> 为代表，基于API聚合的组件市场工具，通过流程管理工具，可以管理整个应用的开发周期，从产品、设计开始，到研发测试和运营。</li></ul><p>所以，整体而言，低代码产品的核心是<strong>表单引擎</strong> 和 <strong>流程引擎(BPM)</strong>，外围支撑是<strong>BI引擎</strong>、<strong>*协同工作</strong>、<strong>服务聚合</strong>等等，目前，市面上主流的低代码产品，表单引擎和流程引擎(BPM)基本是标配，所以，严格地说起来，上面的分类并不严谨，因为基本上都是混合式的产品形态。下面是部分低代码产品的截图：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/15/sY4r1ZHevJlKIE6.png" alt="某“低代码”二维码应用" referrerpolicy="no-referrer"></div><div class="image-caption">某“低代码”二维码应用</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/15/u6AIRJGCeV4hPSg.png" alt="某“低代码”人力资源管理系统" referrerpolicy="no-referrer"></div><div class="image-caption">某“低代码”人力资源管理系统</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/15/4DyZAzi53wVEn6p.png" alt="某“低代码”可视化搭建系统" referrerpolicy="no-referrer"></div><div class="image-caption">某“低代码”可视化搭建系统</div></figure><h1 id="低代码研发痛点"><a href="#低代码研发痛点" class="headerlink" title="低代码研发痛点"></a>低代码研发痛点</h1><p>相信大家都知道了，接下来的内容是本文真正的重点。为什么要这样说呢？这主要和博主自身的工作有关系，简单来说，公司需要一个想象中的可视化设计器，业务人员只需要通过拖拽就可以完成业务逻辑的编排，而开发人员则需要负责对外输出组件供业务人员使用。这听起来特别像我们刚刚讨论的第二种产品形态对不对？听起来非常美好对不对？我承认这个想法真的符合潮流、非常的“低代码”。所以，我们前期采用了微软的 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/windows-workflow-foundation/" target="_blank" rel="noopener">Windows Workflow Foundation</a> 框架，使用以后的效果大概是下面这个样子：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/15/hYpq4nCk5BsFdHi.jpg" alt="Windows Workflow Foundation 设计器" referrerpolicy="no-referrer"></div><div class="image-caption">Windows Workflow Foundation 设计器</div></figure><h2 id="多人协作不便"><a href="#多人协作不便" class="headerlink" title="多人协作不便"></a>多人协作不便</h2><p>那么，我们在这个过程中到底遇到了哪些问题呢？首先，这种可视化编辑的场景，遇到的第一个问题就是<strong>多人协作</strong>，如果你使用过腾讯文档、钉钉文档这类在线文档类产品，你应该能领悟到我说的这个点。微软的这个框架是采用<code>XMAL</code>这种格式来储存数据的，虽然理论上可以通过 <code>Git</code> 实现多人协作，实际维护起来表示非常地麻烦，所以，我们最终由单人去维护这些工作流。那么，更广义上的低代码又该如何解决这个问题呢？流程图这种东西，就是一种看起来非常清晰，改起来非常麻烦的东西，就像一条锁链一样，你要不停地断开和接上。</p><h2 id="孱弱的表达能力"><a href="#孱弱的表达能力" class="headerlink" title="孱弱的表达能力"></a>孱弱的表达能力</h2><p>其次，是流程图这种表现方式的“表达”问题，就像你如果需要在<code>SQL</code>里表示循环要用到游标一样，这类工作流都无法表达程序三个结构中的循环，更不用说<strong>表达力孱弱</strong>的表达式啦，所以，这就造成一个非常尴尬的问题，你在流程图里写不了太复杂的表达式，一旦业务人员写不出来，就需要开发人员去写辅助性质的代码，类似<strong>正则</strong>、<strong>字符串插值</strong>、<strong>字符串处理</strong>、格式化等等的函数或者API非常缺乏。当然，我最无法忍受的，就是组件与组件间传值的方式，你除了返回JSON和写表再没有其它方式，更何况这个JSON返回给某个组件了，人家还未必能直接解析直接使用呢？因为编辑器无法绑定这种复杂的数据结构。</p><h2 id="混乱的变量和参数"><a href="#混乱的变量和参数" class="headerlink" title="混乱的变量和参数"></a>混乱的变量和参数</h2><p>接下来，我最想吐槽的是，关于<strong>全局变量</strong>和<strong>参数</strong>的问题，在流程图中你经常需要各个分支的标志位(Flag)或者是临时变量，然后你就看到了那种“变量满天飞”的混乱局面，简直像极了你刚开始写的代码，你需要顺着每个线条，逐个点开每个组件的属性面板，查看它都使用了哪些参数或者变量，至此，你终于明白了它的数据是如何流动的。从前，乡愁是成千上万行的代码；现在，乡愁是剪不断理还乱的“<strong>蜘蛛网</strong>”。多年前，我对虚幻引擎(<strong>Unreal</strong>)的蓝图功能有多么憧憬；多年后，我对这种基于流程引擎的低代码就有多排斥。尤其是，当我需要复用某一段逻辑的时候，我只能小心翼翼地选中节点和线条，然后再拷贝过去。</p><h2 id="动态计算-事件顺序-黑盒子"><a href="#动态计算-事件顺序-黑盒子" class="headerlink" title="动态计算/事件顺序/黑盒子"></a>动态计算/事件顺序/黑盒子</h2><p>最后，我参考了一位被 <a href="https://powerapps.microsoft.com/zh-cn/" target="_blank" rel="noopener">Power Apps</a> 所折磨的朋友的意见，除了上面提到的这些问题， <strong>属性</strong>面板或者<strong>公式</strong>无法使用动态计算的值，类似<code>Vue</code> 里面的计算属性，从实际使用的体验来看，这类以流程引擎和表单引擎为主要卖点的低代码工具，其实都会存在这样的问题，而面对这种问题，一般只能通过<code>trick</code>的手段来解决。同样地，<a href="https://powerapps.microsoft.com/zh-cn/" target="_blank" rel="noopener">Power Apps</a> <strong>事件顺序的不确定</strong>问题，因为低代码实际上是框架提供了某种机制，可以帮你完成某个事情，所以，低代码内部对于使用者来说，完全就是一个<strong>黑盒子</strong>，譬如 <a href="https://powerapps.microsoft.com/zh-cn/" target="_blank" rel="noopener">Power Apps</a> 在无网络的环境下使用会卡顿，调试起来非常不便等等。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>坦白来讲，这篇博客实在没什么“技术含量”，无非是按照一个月前的计划在整理内容。我对“低代码”持一种中立的态度，作为程序员，我是希望有这样的技术来简化流程，可以让研发人员从枯燥的“增删改查”中解放出来，留出时间去做更多有意义、有价值的事情。当我了解了低代码和零代码的差异以后，我突然明白，我需要的其实是零代码，因为我希望那帮业务人员能自己搞定，这样就不用再来烦我，可经历这段时间的“低代码”，我清醒地认识到，这个想法根本不现实。<strong>一来业务人员并不像他们想象的那样，除了不会写代码以外无所不能；二来业务的复杂性满足守恒定律，它永远不会消失，只会从一种形式变成另一种形式</strong>。<strong>也许，低代码真的能帮企业省不少钱；也许，企业最喜欢做的事情，就是花点小钱招人外包做这种事情。但我依然想告诫开发者们，不要去追逐这些看起来美好的东西，对企业来说，它今天使用 A 技术，明天使用 B 技术，完全无关紧要。可对于个人而言，这个选择显得非常重要。看一看曾经的 SAP 咨询顾问就知道了，如果有一天 SAP 都倒闭了，你掌握着这些只有在 SAP 上能发挥作用的技术有什么用呢？对技术人员来说，学习通用型的知识和技能，永远比把鸡蛋放在一个篮子里要更保险</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="编程" scheme="https://qinyuanpei.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="低代码" scheme="https://qinyuanpei.github.io/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
      <category term="行业" scheme="https://qinyuanpei.github.io/tags/%E8%A1%8C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>记一次失败的 ThoughtWorks 面试经历</title>
    <link href="https://qinyuanpei.github.io/posts/2837181325/"/>
    <id>https://qinyuanpei.github.io/posts/2837181325/</id>
    <published>2021-02-09T20:37:47.000Z</published>
    <updated>2021-06-22T07:04:41.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>年前朋友问我，要不要试试 ThoughtWorks 澳洲线的岗位。对于这家号称“<strong>世界上面试最难</strong>”的公司，多少还是有一点畏惧，直到朋友安慰我说，它们这次有中级的岗位，还是可以试一试的，梦想还是要有的，万一实现了呢？自此，我凑齐了西安. NET圈子里的四大“天花板”公司的面试：<strong>葡萄城</strong>、<strong>活跃网络</strong>、<strong>奥博杰天</strong>、<strong>ThoughtWorks</strong> ，而对于我来说，亦有幸见识到世界上最难的面试，虽然后来事实证明，这个世界上没有太多的逆袭，可我还是想分享一下我的这次面试经历，因为它让我知道，在过去的两年里，我在哪些方面取得进步，在哪些方面存在不足。当我写下这篇博客的时候，我即将在今年夏天迎来我的29岁，果然我还是希望自己能再努力一点，因为不想让平行世界里的某个人失望。</p><h1 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h1><p>关于ThoughtWorks 的社招流程，大体上由<strong>HomeWork</strong>、<strong>Pair Programming</strong> 和 <strong>Face-to-face Interviews</strong> 3个部分组成，其中，HomeWork，即家庭作业，原则上给3天时间来完成，不过据说可以向 HR 申请更多的时间来完成。<strong>Pair Programming</strong> 和 <strong>Face-to-face Interviews</strong> 通常是安排到同一天来进行的，前者时间为1.5小时，即传说中的结对编程，面试时会有一左一右两名面试官看着你现场写代码。后者时间为1小时，即传说中的技术文化面试，考察技术的深度、广度以及对 Thought Works 敏捷文化的认同感。</p><h2 id="HomeWork"><a href="#HomeWork" class="headerlink" title="HomeWork"></a>HomeWork</h2><p>2月18日，下班以后接到HR小姐姐的电话，在明确了我投简历的意向以后，我收到了HR小姐姐的邮件，基本上就是一个家庭作业，三选一提交，需要在三天内完成。我选择了Conference Track Management 这道题目，因为白天要上班，所以，我为此而连续肝了三个晚上。</p><p>坦白说，不同的阶段对这道题目的理解是不同的，在做家庭作业的阶段，你以为这道题考察的是职责分离和设计模式；而等到结对编程的阶段，你终于意识到，这其实是个背包问题。当然，这并不是说我会错了意，考虑到面试官有上帝视角，他们更容易看清楚问题的全貌。或许，面试官想最想看到的，恰恰就是你从冰山一角到目窥全牛这一瞬间的反应。</p><p>当我接到HR小姐姐的通知，这份作业Review通过时，我内心是非常激动的，因为这意味着我获得了去ThoughtWorks面试的“入场券”。可当我事后再以上帝视角去看待这个题目，我内心又变得非常难过，因为无论怎么看这份作业，都会觉得它设计得并不好，尤其是当它引入弹性时间这个因素以后，我一直深陷于如何从Part 1 到 Part 2，是不是按 Part 2 重新设计会更好一点？此时此刻，终于能理解面试官反馈的，关于扩展性方面的问题。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/09/7Ae6bSmujgvsB9G.jpg" alt="作业反馈01" referrerpolicy="no-referrer"></div><div class="image-caption">作业反馈01</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/09/NEQ9YmjMtHbI8eL.jpg" alt="作业反馈02" referrerpolicy="no-referrer"></div><div class="image-caption">作业反馈02</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/02/09/v6fluwU1bi4akBH.jpg" alt="作业反馈03" referrerpolicy="no-referrer"></div><div class="image-caption">作业反馈03</div></figure><p>关于这部分，我个人建议多多关注：</p><ul><li>编程风格：编码规范、项目结构、代码坏味道等。</li><li>语言特性：澳洲线岗位需要熟悉 .NET Core，所以，我使用 .NET Core 完成整个项目的编写。</li><li>设计模式：选择合适的设计模式，遵循 SOLID 原则。</li><li>TDD：一定要有单元测试代码，这一点TW最为看中。如果写的好，一定是加分项。建议遵循AAA原则来编写用例。</li><li>程序满足要求：程序一定满足题目要求，可执行，运行结果满足题意，这是最基本的要求。</li></ul><h2 id="Pair-Programming"><a href="#Pair-Programming" class="headerlink" title="Pair Programming"></a>Pair Programming</h2><p>提交作业后，等了一周多的时间，1月29日，HR 小姐姐终于联系我了，正如我上文所述，当时听到这个消息非常激动，因为终于有机会去 ThoughtWorks 这家世界上面试最难的公司去看看，ThoughtWorks 西安办公室位于环普产业园，这个地方相信大家都非常熟悉啦！当时算上周末，我给了自己 5 天时间去准备面试，因为我觉得面对 ThoughtWorks 的面试还是要重视一点，虽然后来好多问题都没有被问到。</p><p>结对编程是基本上就是，两个面试官一左一右地坐在你旁边，采用聊天和探讨的方式一起写代码，刚开始本来是用电视投屏“直播”的方式，后来因为 HDMI 接口接触不良的缘故，两位面试官干脆就直接看我电脑屏幕啦！在这个环节，个人感觉解释编码思路花时间太多，重构完有一个用例没有通过。最重要的是，家庭作业阶段的设计不利于现场新需求的开展，所以，这些因素综合起来，导致我结对变成这个部分表现得不好，希望大家引以为戒啊。</p><p>整个结对编程时长为一个半小时(1.5h)，在这段时间，你需要<strong>讲解编码思路</strong>、<strong>完成代码重构</strong>和<strong>完成现场作业</strong>，时间上还是非常紧凑的，回想起那天下午的两个半小时，有种像参加高考的感觉：你以为时间会很长，结果发现时间完全不够用。看起来轻松的氛围下，其实在不经意间考察你的沟通能力、工程能力和学习能力，ThoughtWorks 的面试，往往就是这样的朴实无华且“有趣”……</p><p>对于这部分，我个人建议多多关注：</p><ul><li>工程能力：语言特性、调试能力、设计能力等。像TW非常重视快捷键的使用，频繁使用鼠标会拉低印象分。</li><li>沟通能力：善于倾听和表达、以及理解需求的能力，需要你在面试官的引导下完成需求确认，这个阶段一样可以展示你技术的深/广度，但建议最好长话短说。</li><li>学习能力：要求你对TDD、敏捷开发等有一定的好奇心，面试官教给你的新东西/思路，能否举一反三、学以致用，我是在重构的过程中得到了面试官的指导，对此我表示感谢。</li><li>适应能力：能否以开放的态度接受面试官的重构意见，当意见不一致时，能否有理有据地、自信地表达你的观点，我遇到的问题是，面试官认为我混淆了职责分离和组件依赖。</li></ul><h2 id="Face-to-face-Interviews"><a href="#Face-to-face-Interviews" class="headerlink" title="Face-to-face Interviews"></a>Face-to-face Interviews</h2><p>结对编程环节结束以后，正当我还在关注那个失败用例的时候，两位新的面试官就走了进来，就这样，我迎来了那天下午的“<strong>技术文化面试</strong>”，考虑到天气的原因，我那天穿了一件鬼灭之刃的卫衣就去参加面试了，可那个小房间的闷热还是让人焦躁不安，一杯放凉的白开水，完全不足以缓解那种闷热的感觉。ThoughtWorks 的办公室和大多数外包公司的办公室没有什么区别，不同的是，它的办公室摆满了各种 <strong>O’Reilly</strong> 的动物书，至少在氛围上确实像它对外所展示的那样重视技术。</p><p>在这个环节，我遇到了很多的开放型问题，譬如<strong>你经历过的、印象最深刻的项目是什么</strong>，<strong>你在项目中遇到问题以后都是怎么样去解决的</strong>，<strong>你所在项目的人员配置、研发流程是什么样的……等</strong>等，虽然一开始还是经典的“自我介绍”，可我感觉我在回答这些开放型问题的时候，缺乏一种系统性思考或者某种方法论，它和回答技术问题不同，有时候我们需要层层展开、关注细节，可是在这样的问题上，它需要的是简洁而准确的答案。面试期间，面试官不止一次提示我听清楚她的问题，难道真的是我的沟通能力出了问题吗？</p><p>坦白来讲，这次我准备的很多面试题都没有被问到，我以为至少会问一下.NET Core、微服务 和 DDD 这些东西的。我同样不太明白的，是关于项目经历方面的，为什么面试官会认为，工作中主要负责的内容就是由我一个人单打独斗来的呢？我承认我这几年，性格上收敛了许多，没有了攻击性和对抗性，变成了一个非常随和的人，可我本质上并不是一个喜欢兜售或者推销的人，我并不觉得无法口若悬河是缺乏自信的表现。后来，面试官就考察了一下我的口语，本来就是口干舌燥，说到为什么选择 ThoughtWorks 的时候，大脑有一点卡壳，一边在组织中文，一边在想怎么翻译成英文，还有什么比结结巴巴地说完一段英语更让人难过的呢？</p><p>对于这个部分，我个人建议多多关注：</p><ul><li>系统思考：结合工作经验，不断去提炼类似架构方向、敏捷开发、项目管理方面的内容，不要永远局限在一个点上看待问题，不管是表达还是编程，都采用系统性、结构化的思路来梳理，要做到清晰、准确、完整。</li><li>自信：ThoughtWorks 是一家咨询服务公司，所以，很多研发都是顶着咨询师的头衔，个人觉得还是自信一点，会就是会，正常交流，不会的话，就虚心接受，表现出后期愿意去学习的状态。</li><li>协作能力：能否影响和带动团队中的人一起学习、成长，ThoughtWorks 盛行学习和分享的文化，你一定听说过它们的技术雷达、洞见。</li><li>沟通能力：这体现在你能否和客户正常地沟通、能否和团队成员达成有效的协作，虽然程序员都不大喜欢说话，但你至少应该能传达出正确的声音、能理解来自别人的观点。</li><li>动机：对 ThoughtWorks 的意愿性/认同度，为什么会考虑 ThoughtWorks 等这些问题。</li></ul><h1 id="面试心得"><a href="#面试心得" class="headerlink" title="面试心得"></a>面试心得</h1><p>其实，当天面试一结束，我就知道这次面试大概率是凉了。回去的路上，我和老大哥说了我面试的过程，老大哥说，“<strong>让我冷静，要对自己有信心</strong>”。果然，第二天下午，收到HR小姐姐的回复，说面试没有通过，看了下面试官反馈的意见，<strong>主要是在结对编程过程中重构做得不好，对重构的意义不太明确；其次是面试官觉得我在沟通方面还不够大胆，希望我可以在发展他人方面做出改变</strong>。</p><p>听到这话，怎么突然就有种传销的感觉呢？说到影响别人，从12年开始写博客至今，我自认为我的博客还是帮助到了很多人，可能面试官一直觉得我在单打独斗吧，都2021年了，早就不是求伯君、雷军这些前辈们单打独斗写软件的时代啦，所以，果然还是我的表达出现了问题吗？我的朋友们经常批评说我沉迷于技术无法自拔，可我同样见过30多岁怕别人问原理的“中年”程序员，原本这个行业因为门槛低而越来越内卷，而这个圈子里的人又不以技术为重，有太多单纯为了钱而进入这个行业的人。可当整个行业都越来越“体力”劳动的时候，有很多浮躁的人跑来你面前说，技术并不重要类似的话，这个世界到底怎么了呢？</p><p>我想说什么呢？我认为技术因素和非技术因素都很重要，其实写作一直是我练习表达的一种方式。也许，在那些能言善辩的人眼中，我们这些“闷葫芦”都是些内向的、不太会沟通的人吧！这次面试结束以后，<strong>我打算找点系统性思考方面的书来看看，继续背单词增加词汇量，利用空闲时间来练习口语</strong>。<strong>我从来不认为，一个技术人员努力钻研技术有什么不对，因为这是一个技术人员的基本功。沟通能力能做到妙语生花是一种艺术，而我，追求的目标非常简单，即有条理的、清晰的、结构化的表达，我不追求所谓“高情商”的话术，人类时常因为这些模棱两可的字眼而相互误会，因为信息失真，因为信息冗余</strong>。当然，此刻我的首要目标是，完成那个家庭作业的重构，因为它写得实在是太糟糕啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://qinyuanpei.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="面试" scheme="https://qinyuanpei.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="求职" scheme="https://qinyuanpei.github.io/tags/%E6%B1%82%E8%81%8C/"/>
    
      <category term="感悟" scheme="https://qinyuanpei.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="ThoughtWorks" scheme="https://qinyuanpei.github.io/tags/ThoughtWorks/"/>
    
  </entry>
  
  <entry>
    <title>从 C# 1.0 到 C# 9.0，历代 C# 语言特性一览</title>
    <link href="https://qinyuanpei.github.io/posts/3918433482/"/>
    <id>https://qinyuanpei.github.io/posts/3918433482/</id>
    <published>2021-02-01T22:36:47.000Z</published>
    <updated>2021-06-22T07:04:41.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><h1 id="C-版本历史记录"><a href="#C-版本历史记录" class="headerlink" title="C# 版本历史记录"></a>C# 版本历史记录</h1><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/31/VKRu1xATWYkLqyi.png" alt="从 C# 1.0 到 C# 9.0，历代 C# 语言特性一览" referrerpolicy="no-referrer"></div><div class="image-caption">从 C# 1.0 到 C# 9.0，历代 C# 语言特性一览</div></figure><blockquote><p>说明：因为Markdown下维护这样复杂的表格有一点麻烦，故，这里以图片形式展示出来，如后续内容有更新，请点击 <a href="https://47e58366.wiz06.com/wapp/pages/view/share/s/17VodC2zTAUm24Wzmx3lTnAV2RQJG_0B0AX52FeKVL2zBkmZ" target="_blank" rel="noopener">这里</a> 访问原始笔记链接。<a href="https://www.wiz.cn/index.html" target="_blank" rel="noopener">为知笔记</a> 的表格渲染在移动端表现不佳，为了获得更好的阅读体验，请在电脑端访问查看。</p></blockquote><h1 id="C-版本特性说明"><a href="#C-版本特性说明" class="headerlink" title="C# 版本特性说明"></a>C# 版本特性说明</h1><p>现在是 2021 年，相信 C# 7.0 以前的版本大家都应该没有什么问题，因为像博主这样的 90 后“中年”男人，接触的都是这个版本的 C#。所以，在这里我们主要讲解大家C# 7.0、8.0 以及 9.0 的语法特性。考虑到文章篇幅有限，这里选取的都是博主个人比较喜欢的语法特性，如果这里没有你喜欢的特性，请参考文章末尾的<strong>参考链接</strong>。如果这里的特性你都不喜欢，请你马上关掉这个网页，愿这个世界：Love &amp; Peace。可能你会感觉到我说话变得小心翼翼起来，因为这个世界上有种叫做“<strong>杠精</strong>”的生物，当它从我的只言片语里读出那些挫败感的时候，终于有了嘲笑我们这批步入30岁行列的90后的底气，没错，我在最近的博客评论中被读者“嘲讽”了，让暴风雨来得更猛烈一些吧！</p><h2 id="C-7-0"><a href="#C-7-0" class="headerlink" title="C# 7.0"></a>C# 7.0</h2><p>在 C# 7.0 中，我个人比较喜欢的特性主要有以下几个：<strong>元组和弃元</strong>、<strong>更多的 expression-bodied 成员</strong>、<strong>out 变量</strong>、<strong>异步 Main 方法</strong>、<strong>模式匹配</strong> 和 <strong>引发表达式</strong>。</p><h3 id="元组和弃元"><a href="#元组和弃元" class="headerlink" title="元组和弃元"></a>元组和弃元</h3><p>这个概念乍听起来可能会有一点陌生，其实，按我的理解，这就是增强的元组语法，终于可以摆脱<code>Item1</code>、<code>Item2</code>……啦：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//示例1</span></span><br><span class="line">(<span class="keyword">string</span> Alpha, <span class="keyword">string</span> Beta) namedLetters = (<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"<span class="subst">&#123;namedLetters.Alpha&#125;</span>, <span class="subst">&#123;namedLetters.Beta&#125;</span>"</span>);</span><br><span class="line"> <span class="comment">//示例2</span></span><br><span class="line"><span class="keyword">var</span> alphabetStart = (Alpha: <span class="string">"a"</span>, Beta: <span class="string">"b"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$"<span class="subst">&#123;alphabetStart.Alpha&#125;</span>, <span class="subst">&#123;alphabetStart.Beta&#125;</span>"</span>);</span><br><span class="line"><span class="comment">//示例3</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">string</span> label = <span class="string">"Colors used in the map"</span>;</span><br><span class="line"><span class="keyword">var</span> pair = (count, label);</span><br><span class="line">Console.WriteLine(pair);</span><br></pre></td></tr></table></figure><p>有一段时间，前端同事总和我吹嘘 ES6 里面的解构多么多么好用！对此，我想说，C# 一样可以解构，假设我们现在有下面的一个方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> (<span class="keyword">string</span>, <span class="keyword">double</span>, <span class="keyword">double</span>) GetLocation() </span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">var</span> city = <span class="string">"西安市"</span>;</span><br><span class="line">    <span class="keyword">var</span> lat = <span class="number">33.42</span>d;</span><br><span class="line">    <span class="keyword">var</span> lon = <span class="number">107.40</span>d;</span><br><span class="line">    <span class="keyword">return</span> (city, lon, lat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是简化后的元组的用法，如果是以前，我们还需要返回一个<code>Tuple&lt;string, double, double&gt;</code>。此时，如果我们需要解析城市名称及其经纬度，可以这样做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例4</span></span><br><span class="line">(<span class="keyword">string</span> city, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat) = GetLocation();</span><br><span class="line">Console.WriteLine(<span class="string">$"<span class="subst">&#123;city&#125;</span>,(<span class="subst">&#123;lon&#125;</span>,<span class="subst">&#123;lat&#125;</span>)"</span>);</span><br></pre></td></tr></table></figure><p>OK，那么什么又是弃元呢？继续以上面的代码为例，如果我不关心经纬度，只需要城市名称又该怎么办呢？人家的方法返回的是一个3元的结果，而我们只需要其中的1元，此时，就有了所谓弃元的概念：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">string</span> city, _, _) = GetLocation();</span><br><span class="line">Console.WriteLine(<span class="string">$"<span class="subst">&#123;city&#125;</span>"</span>);</span><br></pre></td></tr></table></figure><p>在 C# 中可以使用下划线<code>_</code>来表示要舍弃的元，是为弃元，怎么样？你学会了吗？</p><h3 id="更多的-expression-bodied-成员"><a href="#更多的-expression-bodied-成员" class="headerlink" title="更多的 expression-bodied 成员"></a>更多的 expression-bodied 成员</h3><p>这部分同样是经过强化的 Lambda 表达式，之前我们可以在成员函数和 只读属性上使用 Lambda 表达式，而现在，我们可以将其运用在<code>构造函数</code>、<code>终结器</code>以及 <code>get</code>和<code>set</code>访问器：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expression-bodied constructor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExpressionMembersExample</span>(<span class="params"><span class="keyword">string</span> label</span>)</span> =&gt; <span class="keyword">this</span>.Label = label;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expression-bodied finalizer</span></span><br><span class="line">~ExpressionMembersExample() =&gt; Console.Error.WriteLine(<span class="string">"Finalized!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> label;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expression-bodied get / set accessors.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Label</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; label;</span><br><span class="line">    <span class="keyword">set</span> =&gt; <span class="keyword">this</span>.label = <span class="keyword">value</span> ?? <span class="string">"Default label"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="out变量"><a href="#out变量" class="headerlink" title="out变量"></a><code>out</code>变量</h3><p>个人认为，这是一个非常不错的改进，终于不用再单独声明<code>out</code>变量啦：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">int</span>.<span class="constructor">TryParse(<span class="params">input</span>, <span class="params">out</span> <span class="params">int</span> <span class="params">result</span>)</span>)</span><br><span class="line">    Console.<span class="constructor">WriteLine(<span class="params">result</span>)</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Console.<span class="constructor">WriteLine(<span class="string">"Could not parse input"</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="异步-Main-方法"><a href="#异步-Main-方法" class="headerlink" title="异步 Main 方法"></a>异步 <code>Main</code> 方法</h3><p>顾名思义，<code>Main</code> 方法现在可以支持 <code>async</code> 关键字啦：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This could also be replaced with the body</span></span><br><span class="line">    <span class="comment">// DoAsyncWork, including its await expressions:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> DoAsyncWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有返回值的情况下，可以考虑返回<code>Task</code>:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> async <span class="built_in">Task</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">await <span class="title">SomeAsyncMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>主要是针对 <code>is</code> 和 <code>switch</code> 语句提供了增强的语法。在这里，对于前者来说，我们可以将判断和赋值两个步骤合二为一：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ComputeAreaModernIs</span>(<span class="params"><span class="keyword">object</span> shape</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shape <span class="keyword">is</span> Square s)</span><br><span class="line">        <span class="keyword">return</span> s.Side * s.Side;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">is</span> Circle c)</span><br><span class="line">        <span class="keyword">return</span> c.Radius * c.Radius * Math.PI;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">is</span> Rectangle r)</span><br><span class="line">        <span class="keyword">return</span> r.Height * r.Length;</span><br><span class="line">    <span class="comment">// elided</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">        message: <span class="string">"shape is not a recognized shape"</span>,</span><br><span class="line">        paramName: <span class="keyword">nameof</span>(shape));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于后者来说，主要打破了传统 <code>switch</code> 语句的常量模式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ComputeArea_Version3</span>(<span class="params"><span class="keyword">object</span> shape</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> Square s <span class="keyword">when</span> s.Side == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> Circle c <span class="keyword">when</span> c.Radius == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> Square s:</span><br><span class="line">            <span class="keyword">return</span> s.Side * s.Side;</span><br><span class="line">        <span class="keyword">case</span> Circle c:</span><br><span class="line">            <span class="keyword">return</span> c.Radius * c.Radius * Math.PI;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">                message: <span class="string">"shape is not a recognized shape"</span>,</span><br><span class="line">                paramName: <span class="keyword">nameof</span>(shape));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引发表达式"><a href="#引发表达式" class="headerlink" title="引发表达式"></a>引发表达式</h3><p>这个主要是针对 <code>throw</code> 关键字的增强，当我看到微软的文档的时候，我突然意识到，这个语法其实我用了很久啦！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景A：条件运算符</span></span><br><span class="line"><span class="keyword">string</span> arg = args.Length &gt;= <span class="number">1</span> ? args[<span class="number">0</span>] :</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"You must supply an argument"</span>);</span><br><span class="line"><span class="comment">//场景B：Null合并运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; name;</span><br><span class="line">    <span class="keyword">set</span> =&gt; name = <span class="keyword">value</span> ??</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(</span><br><span class="line">          paramName: <span class="keyword">nameof</span>(<span class="keyword">value</span>), </span><br><span class="line">          message: <span class="string">"Name cannot be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//场景C：Lambda表达式</span></span><br><span class="line"><span class="function">DateTime <span class="title">ToDateTime</span>(<span class="params">IFormatProvider provider</span>)</span> =&gt;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidCastException(<span class="string">"Conversion to a DateTime is not supported."</span>);</span><br></pre></td></tr></table></figure><p>以上，就是 C# 7.0 中我个人比较喜欢的语法特性。需要了解所有 C# 7.0 语法特性的小伙伴们，则可以参考这里：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-7" target="_blank" rel="noopener">C# 7.0 - C# 7.3 中的新增功能</a>。</p><h2 id="C-8-0"><a href="#C-8-0" class="headerlink" title="C# 8.0"></a>C# 8.0</h2><p>在 C# 8.0 中，我个人比较喜欢的特性主要有以下几个：<strong>默认接口方法</strong>、<strong>异步流</strong>、<strong>索引和范围</strong>。</p><h3 id="默认接口方法"><a href="#默认接口方法" class="headerlink" title="默认接口方法"></a>默认接口方法</h3><p>关于这个，我觉得有点多此一举，如果一定要有一个默认行为，那你用继承来实现不就好啦，接口本来就是用来实现的啊摔！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChineseSayHello</span> : <span class="title">ISayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Who &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> DefaultPersopn = <span class="string">"Anumouse"</span>;</span><br><span class="line">    <span class="keyword">string</span> Who &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Who = DefaultPersopn;</span><br><span class="line">         Console.WriteLine(<span class="string">$"Hello, <span class="subst">&#123;Who&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子里，<code>ChineseSayHello</code>没有实现<code>SayHello()</code>方法不影响编译，因为<code>ISayHello</code>有默认实现，可正因为如此，<code>SayHello()</code>方法属于<code>ISayHello</code>，不属于<code>ChineseSayHello</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，可以编译</span></span><br><span class="line"><span class="keyword">var</span> sayHello = <span class="keyword">new</span> ChineseSayHello() <span class="keyword">as</span> ISayHello;</span><br><span class="line">sayHello.SayHello();</span><br><span class="line"><span class="comment">//错误，无法编译</span></span><br><span class="line"> <span class="keyword">var</span> sayHello = <span class="keyword">new</span> ChineseSayHello();</span><br><span class="line">sayHello.SayHello();</span><br></pre></td></tr></table></figure><h3 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h3><p>该特性可以看作是<code>IEnumerable&lt;T&gt;</code>的一个延伸，即<code>IAsyncEnumerable&lt;T&gt;</code>，主要有下面三个属性：</p><ul><li>它是用 async 修饰符声明的。</li><li>它将返回 IAsyncEnumerable<t>。</t></li><li>该方法包含用于在异步流中返回连续元素的 <code>yield return</code> 语句。</li></ul><p>下面是一个来自微软官方的基本示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成异步流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> System.Collections.Generic.<span class="function">IAsyncEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GenerateSequence</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举异步流</span></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> number <span class="keyword">in</span> <span class="title">GenerateSequence</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和异步流相关的一个概念是：异步可释放，即 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iasyncdisposable" target="_blank" rel="noopener">System.IAsyncDisposable</a>，这个可以参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/garbage-collection/implementing-disposeasync" target="_blank" rel="noopener">实现 DisposeAsync 方法</a>。</p><h3 id="索引和范围"><a href="#索引和范围" class="headerlink" title="索引和范围"></a>索引和范围</h3><p>关于这个，我们换一种说法，可能大家就能接受啦！是什么呢？答案是：切片。切片语法博主经常在 Python 中使用，想不到有生之年居然可以在 C# 里用到这个语法。不过，这个语法糖怎么看都不甜啊，因为没那味儿！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">// index from start index from end</span></span><br><span class="line">    <span class="string">"The"</span>, <span class="comment">// 0 ^9</span></span><br><span class="line">    <span class="string">"quick"</span>, <span class="comment">// 1 ^8</span></span><br><span class="line">    <span class="string">"brown"</span>, <span class="comment">// 2 ^7</span></span><br><span class="line">    <span class="string">"fox"</span>, <span class="comment">// 3 ^6</span></span><br><span class="line">    <span class="string">"jumped"</span>, <span class="comment">// 4 ^5</span></span><br><span class="line">    <span class="string">"over"</span>, <span class="comment">// 5 ^4</span></span><br><span class="line">    <span class="string">"the"</span>, <span class="comment">// 6 ^3</span></span><br><span class="line">    <span class="string">"lazy"</span>, <span class="comment">// 7 ^2</span></span><br><span class="line">    <span class="string">"dog"</span> <span class="comment">// 8 ^1</span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//取最后一个元素</span></span><br><span class="line">Console.WriteLine(<span class="string">$"The last word is <span class="subst">&#123;words[^<span class="number">1</span>]&#125;</span>"</span>);</span><br><span class="line"><span class="comment">//获取第一个元素到第三个元素</span></span><br><span class="line"><span class="keyword">var</span> quickBrownFox = words[<span class="number">1.</span><span class="number">.4</span>];</span><br><span class="line"><span class="comment">//获取倒数第一个元素到倒数第二个元素</span></span><br><span class="line"><span class="keyword">var</span> lazyDog = words[^<span class="number">2.</span>.^<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取全部元素</span></span><br><span class="line"><span class="keyword">var</span> all = words[..];</span><br><span class="line"><span class="comment">//获取开始到第三个元素</span></span><br><span class="line"><span class="keyword">var</span> firstPhrase = words[.<span class="number">.4</span>];</span><br><span class="line"><span class="comment">//获取结束到倒数第二个元素</span></span><br><span class="line"><span class="keyword">var</span> lastPhrase = words[<span class="number">6.</span>.];</span><br></pre></td></tr></table></figure><p>看起来这些东西在 Python 里都有啊，到底是哪里除了问题呢？我觉得更多的是符号上的不同吧， <code>^</code> 这个符号除了表示指数的意思以外，还有按位进行异或运算的意思，所以，这个语法糖加进来以后就会显得相当混乱，而 <code>..</code> 这个符号显然没有 <code>:</code> 写起来方便啊，所以，虽然 C# 从 C# 8.0 开始有了切片语法，可这不是我想要的切片语法啊！</p><p>以上，就是 C# 8.0 中我个人比较喜欢的语法特性。需要了解所有 C# 8.0 语法特性的小伙伴们，则可以参考这里：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-8" target="_blank" rel="noopener">C# 8.0 中的新增功能</a>。</p><h2 id="C-9-0"><a href="#C-9-0" class="headerlink" title="C# 9.0"></a>C# 9.0</h2><p>在 C# 9.0 中，我个人比较喜欢的特性主要有以下几个：<strong>Record</strong>、<strong>顶级语句</strong>、<strong>模式匹配增强</strong>。</p><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p><code>record</code> 是 C# 9.0 中提供的一个新的关键字，地位上等同于 <code>class</code> 和 <code>struct</code>，中文翻译为：记录类型。这是一种引用类型，它提供合成方法来提供值语义，从而实现相等性。 默认情况下，记录是不可变的。简而言之，<code>record</code> 是不可变的引用类型。你可能会说，我们为什么要搞这么一个类型出来呢？难道 <code>class</code> 不香吗？</p><p>我觉得如果要回答这个问题，可以借鉴 <code>DDD</code> 中的<code>实体</code> 和 <code>值对象</code>这两个概念。<code>实体</code> 通常都有一个唯一的标识并且在整个生命周期中具有连续性，这一类角色通过 <code>class</code> 来实现一直都工作得很好。例如，每一个 <code>User</code> 都会有一个唯一的<code>UserId</code> ，我们使用 <code>UserId</code> 来判断其相等性。而 <code>值对象</code> 则是指那些没有唯一的标识、不可变的、通过属性来判断相等性。例如，我们有一个地址 <code>Address</code>，它由省、市、区、县和详细地址组成，那么，问题来了，如果两个 <code>Address</code> 的省、市、区、县和详细地址都相同，这两个 <code>Address</code> 是不是同一个地址呢？常识告诉我们：不会，因为它们是不同的实例。</p><p>这就是 <code>record</code> 出现的原因，对于上面的这个问题，我们可以来解决：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">record Address</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Province &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> District &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> County &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr1 = <span class="keyword">new</span> Address() &#123; Province = <span class="string">"陕西省"</span>, City = <span class="string">"西安市"</span>, District = <span class="string">"雁塔区"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> addr2 = <span class="keyword">new</span> Address() &#123; Province = <span class="string">"陕西省"</span>, City = <span class="string">"西安市"</span>, District = <span class="string">"雁塔区"</span> &#125;;</span><br><span class="line">Console.WriteLine(<span class="string">$"addr1 == addr2：<span class="subst">&#123;addr1 == addr2&#125;</span>"</span>);</span><br></pre></td></tr></table></figure><p>想想以前我们是怎么做的呢？是不是要写类似下面这样的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (addr1.Province == addr2.Province &amp;&amp; addr1.City == addr2.City) &#123;</span><br><span class="line">    <span class="comment">//属性太多啦，我就不一个一个地比较啦，懂得都懂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这就是 <code>record</code> 存在的意义。除此之外呢，这个关键字更多的是语法层面上的，实际上从编译出来的 IL 来看，它本质上依然是一个类，并且它是不可变的。定义记录类型时，编译器会合成其他几种方法：</p><ul><li>基于值的相等性比较方法</li><li>替代 GetHashCode()</li><li>复制和克隆成员</li><li>PrintMembers 和 ToString()</li></ul><p>那么，你可能还会有疑问，假如我定义了两个不同的记录类型，它们都拥有相同的属性成员，如果按值相等来判断的话，岂不是这两个不同的记录类型变成相同的了？这么重要的问题，微软怎么可能没有想到呢？编译器会合成一个 <code>EqualityContract</code> 属性，该属性返回与记录类型匹配的 <code>Type</code> 对象。在这里，微软再一次发挥了<code>元组</code>的威力，对于上面定义的地址，我们可以继续使用解构语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(province, city, district, county) = addr1;</span><br></pre></td></tr></table></figure><p>当然，我相信哪怕到2090年，这个世界上依然会有“<strong>杠精</strong>”：你说这玩意儿不能变？我就想变怎么办？答案是使用<code>with</code>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> record Person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastName &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FirstName &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="keyword">string</span> first, <span class="keyword">string</span> last</span>)</span> =&gt; (FirstName, LastName) = (first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Bill"</span>, <span class="string">"Wagner"</span>);</span><br><span class="line">Person brother = person with &#123; FirstName = <span class="string">"Paul"</span> &#125;; <span class="comment">// 修改FirstName的副本</span></span><br><span class="line">Person clone = person with &#123; &#125;; <span class="comment">// 空集副本</span></span><br></pre></td></tr></table></figure><p>好了，关于记录类型就先为大家介绍到这里，更详细的说明可以参考这里：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/tutorials/exploration/records" target="_blank" rel="noopener">使用记录类型</a>。</p><h3 id="顶级语句"><a href="#顶级语句" class="headerlink" title="顶级语句"></a>顶级语句</h3><p>顶级语句，这个又是一个听起来非常模糊的概念对不对？ 大家可以看一下这篇文章：<a href="https://www.runoob.com/w3cnote/write-hello-world-program-26-different-programming-languages.html" target="_blank" rel="noopener">26 种不同的编程语言的 “Hello World” 程序</a>。怎么样，在众多解释型的语言中，C#、Java 甚至 C++ 的 “<strong>Hello World</strong>” 是不是都看起来有一点臃肿？</p><p>好了，现在可以梦想成真啦！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><p>如果觉得这样还显得臃肿，可以省略 <code>using</code> 部分：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Console.WriteLine(<span class="string">"Hello World!"</span>);</span><br></pre></td></tr></table></figure><p>当然啦，一个项目里显然只能有一个文件可以使用顶级语句，你可以理解为这些代码运行在一个看不见的<code>Main()</code>方法中，而<code>Main()</code>方法显然只能有一个，相比下来，Python 就自由多啦，不过<code>if __name__ == &#39;__main__&#39;</code>的老梗就不再这里展开啦！</p><h3 id="模式匹配增强"><a href="#模式匹配增强" class="headerlink" title="模式匹配增强"></a>模式匹配增强</h3><p>感觉微软在模式匹配的道路上越走越远啊，说好的语法糖呢？这简直是毒药，7.0 里面眼花缭乱的<code>switch</code>都还没学会呢！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsLetter</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">char</span> c</span>)</span> =&gt;</span><br><span class="line">    c <span class="keyword">is</span> &gt;= <span class="string">'a'</span> and &lt;= <span class="string">'z'</span> or &gt;= <span class="string">'A'</span> and &lt;= <span class="string">'Z'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsLetterOrSeparator</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">char</span> c</span>)</span> =&gt;</span><br><span class="line">    <span class="function">c <span class="title">is</span> (<span class="params">&gt;= <span class="string">'a'</span> and &lt;= <span class="string">'z'</span></span>) <span class="title">or</span> (<span class="params">&gt;= <span class="string">'A'</span> and &lt;= <span class="string">'Z'</span></span>) or '.' or ','</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">is</span> not <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就是 C# 9.0 中我个人比较喜欢的语法特性。需要了解所有 C# 9.0 语法特性的小伙伴们，则可以参考这里：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-9" target="_blank" rel="noopener">C# 9.0 中的新增功能</a>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history" target="_blank" rel="noopener">C# 发展历史</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-7" target="_blank" rel="noopener">C# 7.0 - C# 7.3 中的新增功能</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-8" target="_blank" rel="noopener">C# 8.0 中的新增功能</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-9" target="_blank" rel="noopener">C# 9.0 中的新增功能</a></li><li><a href="https://www.cnblogs.com/MingsonZheng/p/11273700.html" target="_blank" rel="noopener">C# 版本与 .NET 版本对应关系以及各版本的特性</a></li><li><a href="https://www.cnblogs.com/microsoft-zyl/p/9093748.html" target="_blank" rel="noopener">C# 语言历史版本特性（C# 1.0到C# 8.0汇总）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qinyuanpei.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="总结" scheme="https://qinyuanpei.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term=".NET" scheme="https://qinyuanpei.github.io/tags/NET/"/>
    
      <category term="CSharp" scheme="https://qinyuanpei.github.io/tags/CSharp/"/>
    
      <category term="语言" scheme="https://qinyuanpei.github.io/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>通过Python分析2020年全年微博热搜数据</title>
    <link href="https://qinyuanpei.github.io/posts/2758545080/"/>
    <id>https://qinyuanpei.github.io/posts/2758545080/</id>
    <published>2021-01-24T22:36:47.000Z</published>
    <updated>2021-06-22T07:04:41.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>几天前， <a href="https://www.cnblogs.com/catcher1994" target="_blank" rel="noopener">Catcher Wong</a> 大佬告诉我，他终于写完了2020年的年终总结。在看完大佬的年终总结以后，我有一种“<strong>前浪被后浪拍死在沙滩上</strong>”的感觉，正如当学生时都看“<strong>别人家的孩子</strong>”，工作以后看的都是“<strong>别人的年终总结</strong>”。我们的生活，其实就是由“<strong>别人</strong>”和“<strong>我们</strong>”交织在一起，而更多的时候，是成为“<strong>大多数</strong>”的“<strong>我们</strong>”，去关注成为“<strong>少数</strong>”的“<strong>别人</strong>”。我想说的是，世间万物互为装饰，就像卞之琳在《断章》里写道，“<strong>明月装饰了你的窗子，你装饰了别人的梦</strong>”。<strong>即便一个人在历史长河中，尤如一叶飘泊不定的孤舟在波涛中摇荡，可每一朵浪花都曾以自己的方式美丽过</strong>，所以，看“别人”的生活，联想“我们”的生活，这便是我同2020告别的一种方式，为此，博主决定抓取2020年全年366天的微博热搜，通过可视化的方式来串联起2020年的回忆。</p><h1 id="热搜抓取"><a href="#热搜抓取" class="headerlink" title="热搜抓取"></a>热搜抓取</h1><p>首先，我们来考虑微博热搜的数据来源。 <a href="https://weibo.com/" target="_blank" rel="noopener">微博</a> 官方提供了一个热搜排行榜的页面：<a href="https://s.weibo.com/top/summary" target="_blank" rel="noopener">https://s.weibo.com/top/summary</a>，可惜这个网站只支持查看当天的热搜，显然这无法满足我们的需求。在搜索引擎的帮助下，找到了两个网站，它们分别是：<a href="https://www.weibotop.cn/" target="_blank" rel="noopener">微博时光机</a> 和 <a href="https://www.enlightent.cn/research/rank/weiboSearchRank" target="_blank" rel="noopener">热搜神器</a>。经过一番权衡，决定选择页面结构更简单一点的 <a href="https://www.weibotop.cn/" target="_blank" rel="noopener">微博时光机</a> 。</p><p>通过抓包，可以快速获得两个关键的接口，它们分别是 <a href="https://www.weibotop.cn/apis/androidrouter/?versioncode=1&=&data=WyJnZXRjbG9zZXN0dGltZSIsWyIyMDIxLTAxLTIwVDIzOjA4OjAyIl1d" target="_blank" rel="noopener">获取timeId接口</a> 和 <a href="https://www.eecso.com/test/weibo/apis/currentitems.php?timeid=326021" target="_blank" rel="noopener">获取历史热搜接口</a>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/22/1pFhJkgodvP5U3G.png" alt="Firefox抓包示意图" referrerpolicy="no-referrer"></div><div class="image-caption">Firefox抓包示意图</div></figure><p>简单来说，我们指定一个日期，第一个接口会返回<code>timeId</code>。接下来，通过这个<code>timeId</code>调用第二个接口就可以获得热搜数据。仔细观察的话，第一个接口传递的<code>data</code>参数像是一个<code>BASE64</code>加密后的结果，尝试解密后发现我的猜想是对的，加密前的内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"getclosesttime"</span>,[<span class="string">"2021-01-20T23:08:02"</span>]]</span><br></pre></td></tr></table></figure><p>这意味着我们只需要改变这里的日期就可以啦，因此，我们的思路无非就是从2020年1月1日开始，依次请求热搜接口获取数据，直到2020年12月31日。这里想顺便吐槽下这个网站的接口设计，居然清一色地全部用数组来返回结果，难道是为了省掉这几个字段来节省流量吗？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/22/G9x8LiybNanBVg2.png" alt="接口返回值说明-1" referrerpolicy="no-referrer"></div><div class="image-caption">接口返回值说明-1</div></figure><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/22/zamj3Fntp9kbQws.png" alt="接口返回值说明-2" referrerpolicy="no-referrer"></div><div class="image-caption">接口返回值说明-2</div></figure><p>吐槽归吐槽，这里我们可以非常容易地写出对应的代码，由于日期和<code>timeId</code>的对应关系是固定的，为了减少后续的请求数量，我们使用<code>MongoDB</code>来对数据进行持久化。同样地，抓取热搜采用了类似的方式，因为历史热搜同样是确定的数据，这里只给出关键的代码，<strong>并不代表你可以无脑地复制、粘贴</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获取指定日期对应的timeId</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_timeId</span><span class="params">(date, cookie)</span>:</span></span><br><span class="line">    cacheKey = date.strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">    records = list(store.find(TABLE_TIME_ID, &#123;<span class="string">'date'</span>: cacheKey&#125;))</span><br><span class="line">    <span class="keyword">if</span> len(records) &gt; <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">return</span> records[<span class="number">0</span>][<span class="string">'timeId'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = <span class="string">"[\"getclosesttime\",[\"&#123;d&#125;\"]]"</span>.format(d=cacheKey)</span><br><span class="line">        data = base64.b64encode(data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        url = <span class="string">'https://www.weibotop.cn/apis/androidrouter/?versioncode=1&amp;=&amp;data='</span> + str(data, <span class="string">'utf-8'</span>)</span><br><span class="line">        data = request(url, cookie)</span><br><span class="line">        timeId = json.loads(data)[<span class="number">0</span>]</span><br><span class="line">        store.insert(TABLE_TIME_ID, [&#123;<span class="string">'date'</span>: cacheKey, <span class="string">'timeId'</span>: timeId &#125;])</span><br><span class="line">        <span class="keyword">return</span> timeId</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定timeId对应的热搜</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weibo_trending</span><span class="params">(timeId, cookie)</span>:</span></span><br><span class="line">    records = list(store.find(TABLE_TRENDING, &#123;<span class="string">'timeId'</span>: timeId&#125;))</span><br><span class="line">    <span class="keyword">if</span> len(records) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> records</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = <span class="string">'https://www.eecso.com/test/weibo/apis/currentitems.php?timeid='</span> + timeId</span><br><span class="line">        data = request(url, cookie)</span><br><span class="line">        data = json.loads(data)</span><br><span class="line">        trendings = list(map(<span class="keyword">lambda</span> x:&#123;<span class="string">'title'</span>:x[<span class="number">0</span>], <span class="string">'createdDate'</span>:x[<span class="number">1</span>], <span class="string">'updatedDate'</span>:x[<span class="number">2</span>], <span class="string">'rank'</span>:int(x[<span class="number">3</span>])&#125;, data))</span><br><span class="line">        <span class="keyword">for</span> trending <span class="keyword">in</span> trendings:</span><br><span class="line">            trending[<span class="string">'timeId'</span>] = timeId</span><br><span class="line">            trending[<span class="string">'href'</span>] = <span class="string">'https://s.weibo.com/weibo?q='</span> + trending[<span class="string">'title'</span>]</span><br><span class="line">            trending[<span class="string">'createdDate'</span>] = datetime.datetime.strptime(trending[<span class="string">'createdDate'</span>], <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">            trending[<span class="string">'updatedDate'</span>] = datetime.datetime.strptime(trending[<span class="string">'updatedDate'</span>], <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">        store.insert(TABLE_TRENDING, trendings)</span><br><span class="line">        <span class="keyword">return</span> trendings</span><br></pre></td></tr></table></figure><p>至此，我们就完成了微博热搜数据的抓取工作！</p><h1 id="热搜分析"><a href="#热搜分析" class="headerlink" title="热搜分析"></a>热搜分析</h1><p>好了，在采集到这些热搜数据以后，我们就可以着手准备热搜数据的分析工作啦！其实，目前这份热搜数据挺简陋的，它只有热搜话题、上榜时间、更新时间以及话题热度这样四个关键字段。而作为辅助，我们增加了热搜话题的链接，如果后续需要更详尽的信息，可能需要从这里来寻找突破口。在今天这篇博客里，我们主要从下面四个维度来分析和挖掘2020年全年的微博热搜：</p><h2 id="全年热搜热度分析"><a href="#全年热搜热度分析" class="headerlink" title="全年热搜热度分析"></a>全年热搜热度分析</h2><p>首先，我们要分析的是全年热搜的热度。何谓热度呢？我个人认为，可以从话题的使用频率和话题的持续时间两个方面来考虑，即，一个话题转发或者参与的人越多，话题持续的时间越长，则认为该话题越“热”。例如罗翔老师说2020年进入了“<strong>全民网课</strong>”的时代，因为“网课”是一个热门话题，而当时的背景则是因为疫情原因无法上学(班)，一时间远程会议/办公/教育变得炙手可热。所以，分析全年的热搜热度，可以让我们去关注每个月都发生了什么事情，而这样，我们就有了和这个世界建立联系的思绪，想想当时的你在做什么，心里又作何感想，这会是一件非常有趣的事情：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/26/OvqeDkFz8IRnKbc.jpg" alt="2020全年微博热搜热度变化趋势" referrerpolicy="no-referrer"></div><div class="image-caption">2020全年微博热搜热度变化趋势</div></figure><p>首先，我们看到的是：<strong>2020全年微博热搜热度变化趋势</strong>。通过这张图，我们可以注意到：在3月份左右国内疫情得到控制以后，大家都渐渐地回归到日常的工作和生活中，相应地，人们在社交媒体上的关注是逐渐下降的，直到7月份以后逐渐开始出现回升。我个人认为可能与下面这件事情有关，<strong>第一，是腾讯公司因为一份虚假合同而起诉老干妈的事件；第二、因为疫情而姗姗来迟的高考推迟到了7月7日和7月8日这两天；第三、张一山、宋妍霏、阚清子、宋茜等一众明星频频登上热搜榜。</strong>对于前两个因素，可以覆盖整个7月份的大多数时间段；对于第三个因素，更多的是从微博这样一个泛娱乐化的平台的属性去考虑，还有什么比吃明星的瓜更开心的事情吗？再往后，我们都知道，迎来了美国大选，不管这场大选闹出了多少风波，此时此刻，终于尘埃落定。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/26/A2gsuvdGqCylpoP.jpg" alt="2020全年微博热搜数量变化趋势" referrerpolicy="no-referrer"></div><div class="image-caption">2020全年微博热搜数量变化趋势</div></figure><p>接下来，我们看到的是：2020全年微博热搜数量变化趋势。通过这张图，我们可以注意到：热搜数量的变化趋势整体上是吻合热搜热度的变化趋势的，两者的“<strong>低谷</strong>”都出现在7月份，不同的是热搜数量的变化要更为“<strong>缓和</strong>”一点，这可能和新浪微博的热搜榜单有一定的关系，不知道是不是因为微博的推荐算法，决定了每个月“<strong>吃瓜</strong>”的次数是差不多的，可如果没有算法来约束这一切，完全由用户及其粉丝自行主导，这会不会演变成现实版的美国大选呢？我特别心疼那位新浪微博的研发小哥<a href="https://weibo.com/u/2006147847" target="_blank" rel="noopener">@丁振凯</a>，<strong>人生中三次遭遇热搜引发的“宕机”：结婚时撞上鹿晗公布恋情，海外度假时撞上双宋官宣、老婆待产撞上华晨宇承认和张碧晨未婚生有一女，简直永远都在扩容的路上</strong>，被誉为“<strong>史上最惨新浪程序员</strong>”一点都不冤枉啊……</p><h2 id="全年热搜情感分析"><a href="#全年热搜情感分析" class="headerlink" title="全年热搜情感分析"></a>全年热搜情感分析</h2><p>李诞在2020年年底策划了一期反跨年晚会，从头到尾都是脱口秀这种“语言类”节目，在这期节目里，有人以毛不易的“歌词”调侃了2020年大家的心境变化，从“<strong>像我这样优秀的人</strong>”到“<strong>消愁</strong>”，有时候打脸就是这么的猝不及防。坦白来说，我有段时间过得特别“<strong>丧</strong>”，“<strong>丧</strong>”到要靠《当幸福来敲门》来打鸡血。那么，整个2020年“<strong>活</strong>”在热搜里的人们的心态变化又是怎么样的呢？所以，接下来我们通过 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 对2020年全年的热搜话题的情感倾向进行分析，到底大家是过得“<strong>积极</strong>”还是“<strong>消极</strong>”呢，让我们一起拭目以待，为了达到更好的效果，博主提前对 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 进行了训练，因为 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a> 自带的语料库主要是电商评论，与我们此刻的场景多少有一点差异。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/26/gCcHX7vWlwsZhnI.jpg" alt="2020全年微博热搜情感变化趋势" referrerpolicy="no-referrer"></div><div class="image-caption">2020全年微博热搜情感变化趋势</div></figure><p>果然，2020年真的是“<strong>丧</strong>”到家啦，366天里平均置信概率在0.5以上的堪称寥寥啊。我有时候会想，我们常常希望在感情中有足够的安全感，希望对方可以“懂”我。诚然，我可以从一个人的朋友圈、微博去分析对方的情感变化，可身为人类的我们，并不是冷冰冰的计算机器。多年后，当我懊恼于曾经没有进行及时的沟通的时候，我静静地坐在电脑面前，你说这些字里行间没有透露出足够充足地信息，可我们依然有办法去反映过去一年里的喜怒哀乐。世事无常，每天都开开心心地面对，固然是心向往之，而生命中更朴实无华地大多数时刻，其实就是此刻如白开水一般索然无味，如果理性的思维最终还是要输给感性的直觉，我希望我可以两者兼有之，今年可能要在外地一个人度过春节啦，希望我的心情可以超过0.5呢……</p><h2 id="全年热搜词云分析"><a href="#全年热搜词云分析" class="headerlink" title="全年热搜词云分析"></a>全年热搜词云分析</h2><p>其实，在做这个分析的时候，我一直在想，也许“<strong>新冠</strong>”或者“<strong>疫情</strong>”这样的字眼会成为2020年的共同记忆吧！至少对博主这样即将步入中年的90后而言，这场疫情留下的深刻记忆丝毫不亚于08年的汶川地震。可转念间又安慰自己道，相比国外愈演愈烈的疫情，我们在三月份左右的时候就基本得到了控制，如果说互联网是没有记忆的，人们对这一切应该会遗忘地非常快，就像这热搜榜上的话题，简直是“你方唱罢我登场”。可惜，互联网的确是有记忆的，即使过去了整整一年，这一切还是通过数据被挖掘出来。这里，我们通过结巴分词对热搜话题进行分词，再通过这些关键词来绘制词云。对于这个结果，突然就变得感性起来，可能这就是所谓的“冥冥之中自有天意”吧，甚至对于2021年来说，<strong>疫情</strong>目前依然是人们关注的热搜话题：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/22/dTVD9lNIP4OwefC.png" alt="2020年全年微博热搜关键词词云" referrerpolicy="no-referrer"></div><div class="image-caption">2020年全年微博热搜关键词词云</div></figure><h2 id="全年热搜人物分析"><a href="#全年热搜人物分析" class="headerlink" title="全年热搜人物分析"></a>全年热搜人物分析</h2><p>曾经在知乎上读到过这样一句话，“<strong>人们宁愿去关心一个蹩脚电影演员的吃喝拉撒和鸡毛蒜皮，而不愿了解一个普通人波涛汹涌的内心世界</strong>”，这句话如果放到2020年的语境中，或许就是，人们在危难的时候会突然关心“<strong>国士无双</strong>”，而在安稳的时候则会更关注“<strong>娱乐八卦</strong>”，考虑到新浪微博是借鉴新浪博客的“名人效应”而起家，所以，我更关心在过去一年里有哪些人都登上过热搜。说实话，我挺怀念某位七十多岁高龄的老人，他和我奶奶差不多同龄，在这个“丧”如此普遍的年代，他带给了我们多少欢乐啊，虽然我预感到会有许多明星靠着“<strong>否认</strong>”、“<strong>道歉</strong>”、“<strong>心疼</strong>”、“<strong>回应</strong>”、“<strong>声明</strong>”等等字眼而登上热搜，可我还是想知道答案啊……</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/25/ZV2zgo7Ssi6XFL8.png" alt="2020全年微博热搜上榜人物分析.png" referrerpolicy="no-referrer"></div><div class="image-caption">2020全年微博热搜上榜人物分析.png</div></figure><p>果然，“<strong>说曹操曹操到</strong>”，2020年以压倒性优势多次登上微博热搜的，居然真的是前美国总统特朗普。虽然说这位美国前总统喜欢孜孜不倦地发推特，史称“<strong>推特治国</strong>”，可在一个某明星代孕风波快速令“<strong>拼夕夕</strong>”事件烟消云散的社交平台上，这位老人能频频进入我们的视野，大概就能说明过去一年里国际形势的风起云涌。我们嘲笑他为“懂王”，甚至“亲切”地称之为“川建国”同志。<strong>有一段时间里，好像每一个人都觉得自己比这位老人更会做总统；同样地，好像每一个人都觉得自己比张小龙更懂得微信</strong>。我无意讨论政治相关的东西，可我依然感谢这位老人在疫情期间带给我们的欢乐，因为我并不觉得，他像媒体眼中的那样滑稽而愚蠢，一个能在商人、明星和总统多重身份中切换自如的人，无论如何会都有他的过人之处，疫情这件事情，换一个人来当这个总统未必会做得比他好。回过头来看，他在2020年都做了哪些事情呢？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/25/9FL8ZMc6blYjy5u.png" alt="2020年特朗普的微博热搜" referrerpolicy="no-referrer"></div><div class="image-caption">2020年特朗普的微博热搜</div></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>其实，在规划这篇博客的时候，我一直在想，该以一种什么样的心态去回顾2020，因为当我看着“<strong>别人</strong>”的年终总结的时候，总有一种难以言说的失落感。一方面，时间在不经意间匆匆逝去，身边的一切都在刻意地想你强调着“<strong>物是人非</strong>”。而另一方面，你需要去面对诸如买房、结婚这种所谓“<strong>某某年龄应该去做的事情</strong>”。当我看到身边的同事，整天坐在一起讨论的无外乎是房子、车子、股票等一切所谓“投资”的事情的时候，我时而会觉得他们有一点枯燥，就是那种我们曾经都不愿意成为的“中年人”。等翻过年，我即将迎来我的29岁，可令人心动的Offer里的“<strong>背水辉</strong>”一样的被嫌弃的年纪，而距离IT行业所谓的“<strong>35岁</strong>”门槛还剩下年时间。</p><p>虽然给自己订了几个目标，可有时候难免会感到懈怠，尤其是当你意识到你再无法抓住某一样东西的时候，或许，你唯一的能做的事情，就是让自己永远不要忘记吧！写数据挖掘相关的内容，不管是在数据的抓取还是分析阶段，都需要投入大量的精力去试验，结合实际去调整写作的方向，在这篇博客中甚至还花了大量时间去训练 <a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP</a>。“<strong>悟已往之不谏，知来者之可追</strong>”，2021年flag我在心里记下来，我不想写出来，因为我怕到时候脸会疼，如果大家觉得这篇博客对你有帮助，欢迎<strong>点赞</strong>和<strong>收藏</strong>，如果可以<strong>一键三连</strong>，那就更好啦！2020，再见！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="可视化" scheme="https://qinyuanpei.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="微博" scheme="https://qinyuanpei.github.io/tags/%E5%BE%AE%E5%8D%9A/"/>
    
      <category term="热搜" scheme="https://qinyuanpei.github.io/tags/%E7%83%AD%E6%90%9C/"/>
    
  </entry>
  
  <entry>
    <title>基于 Python 和 Selenium 实现 CSDN 一键三连自动化</title>
    <link href="https://qinyuanpei.github.io/posts/3148958651/"/>
    <id>https://qinyuanpei.github.io/posts/3148958651/</id>
    <published>2021-01-19T22:35:47.000Z</published>
    <updated>2021-06-22T07:04:41.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/styles/APlayer.min.css"><script src="/assets/scripts/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/scripts/Meting.min.js"></script><p>最近一段时间，博主感觉到了某种危机感，或者说是每一个不再年轻的人都会面对的问题，即，怎么面对来自更年轻的“后浪”们的压力，自打国内IT行业有了35岁这个不成文的“门槛”以后，年轻的“后浪”们仿佛有了更多将“前浪”们拍死在岸上的勇气，我辈忍不住要叹一声后生可畏啊！我认识的 <a href="https://www.cnblogs.com/catcher1994" target="_blank" rel="noopener">Catcher Wong</a> 正是这样一位大佬，此君虽然比我小三岁，可在技术的广/深度以及经验的丰富程度上，足以令我这个”老人”汗颜，单单 <a href="https://github.com/dotnetcore/EasyCaching" target="_blank" rel="noopener">EasyCaching</a> 这一项，就令人望尘莫及啦！我看着他的时候，一如当年 Wesley 大哥看着我的时候，可能这就是某种轮回，姑且执浊酒一杯，致我们终将老去的青春。</p><h1 id="不正经的Kimol君"><a href="#不正经的Kimol君" class="headerlink" title="不正经的Kimol君"></a>不正经的Kimol君</h1><p>关注<a href="https://blog.csdn.net/kimol_justdo" target="_blank" rel="noopener">Kimol君</a>，最早源于他在我博客里留言，作为礼尚往来，我回访了他的博客，然后发现此人人如其名，非常的”不正经”，他的博客访问量出奇地高，在CSDN里写博客多年，深知现在不比从前有运营梦鸽和大白两位小姐姐帮忙推荐到首页，普通的内容很少有机会拥有这样的曝光机会，而像 <a href="https://blog.csdn.net/guolin_blog" target="_blank" rel="noopener">郭霖</a> 这种从 10 年前后开始写移动开发系列博客的“大神”或者是以图形学为主要写作方向的 <a href="https://qianmo.blog.csdn.net/" target="_blank" rel="noopener">诗人“浅墨”</a> ，在通篇都是干货的情况下，长期保持着不错的人气。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/23/hEfkz6xBpildT4o.jpg" alt="这萌萌哒求赞的表情我是做不来的" referrerpolicy="no-referrer"></div><div class="image-caption">这萌萌哒求赞的表情我是做不来的</div></figure><p>起初，我以为此君的流量来自于标题党，譬如<a href="https://blog.csdn.net/kimol_justdo/article/details/108912073" target="_blank" rel="noopener">《学会这招，小姐姐看你的眼神将不一样》</a> 和 <a href="https://blog.csdn.net/kimol_justdo/article/details/110152915" target="_blank" rel="noopener">《震惊！小伙竟然用Python找出了马大师视频中的名场面》</a>这几篇，非常像UC编辑部和微信公众号的风格。我是一个擅长学习的人，主动去借鉴了他博客中的优点，比如尝试使用轻松、幽默的文风，在文章开头放入目录，适当“蹭”热点等等，我甚至专门致敬了一篇博客： <a href="https://qinyuanpei.blog.csdn.net/article/details/110713267" target="_blank" rel="noopener">《厉害了！打工人用Python分析西安市职位信息》</a>。而整个1月份，我就只有一篇博客流量高一点，就这还不是特别正经的”技术”博客，而此君的流量则是一个又一个的1w+ ，可我实在想不通，一个不到100行的Python脚本，真就值得花那么多的流量，真就值得上百条的评论吗？这里放张图大家感受一下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/23/lsB65XjhgY4nZeJ.png" alt="不知道该说什么好" referrerpolicy="no-referrer"></div><div class="image-caption">不知道该说什么好</div></figure><p>仔细研究了他博客里评论的风格，发现有大量类似“夸夸群”风格的评论，就是那种读起来确实像对方读过了你的文章，可实际一想就觉得这是那种“放之四海而皆准”的话。我最近知道了一位大佬的博客，我惊奇地发现，此君居然在上面留过言，我顺着大佬的博客继续找，发现一个非常有意思的事情，此君曾经给我留言过的内容，居然出现在了别人的博客底下，而从这篇博客的评论里继续找，你会发现好像有一个团队专门在做这种事情，互相点赞、互相评论，甚至这些留言都是来自一篇博客都没有的”新人”，至此，基本可以断定，此君“不讲武德”，用作弊的方式在刷流量！当然，他自己都承认了：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/23/7tHqCNkdceUFXxD.png" alt="作弊实锤" referrerpolicy="no-referrer"></div><div class="image-caption">作弊实锤</div></figure><h1 id="年轻人不讲”武德”"><a href="#年轻人不讲”武德”" class="headerlink" title="年轻人不讲”武德”"></a>年轻人不讲”武德”</h1><p>OK，既然现在的年轻人都把心思用到这种事情上，作为一个老年人，必须要让他知道什么叫“耗子尾汁”，我们技术做一点正经事儿不行吗？其实，博客园的博客质量相比 CSDN 是要高出许多的，而正因为如此，CSDN 在全力转在线教育/课程以后，博客这个板块就再无往日的“生气”，如果每个人都像他一样，天天跑别人底下刷评论，发一点不痛不痒的话，甚至是推广某个小圈子里的QQ群，那真正优质的内容又如何能被大家看到呢？博主曾经加过这样的QQ群，你以为是交流技术的群吗？其实是为了推广某个Python 课程，博主本想交流一下<a href="https://qinyuanpei.blog.csdn.net/article/details/110977903" target="_blank" rel="noopener">“半泽直树”</a>，然后就被群管理员给删除了！此君大概是抓取Python 板块排名靠前的博客，通过程序来刷存在感。</p><p>对此，我想说，这玩意儿用 Selenium + Python 简直和闹着玩一样，毕竟在了解网页结构以后，直接上 jQuery 操作 DOM 即可，甚至连抓包都不需要，不信你看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> fake_useragent</span><br><span class="line"><span class="keyword">import</span> os, json, time, random</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, profile)</span>:</span></span><br><span class="line">        os.environ[<span class="string">'TEMPDIR'</span>] = os.path.join(os.path.abspath(<span class="string">'.'</span>), <span class="string">'profile'</span>)</span><br><span class="line">        firefoxProfile = webdriver.FirefoxProfile(profile) </span><br><span class="line">        fireFoxOptions = webdriver.FirefoxOptions()</span><br><span class="line">        self.driver = webdriver.Firefox(</span><br><span class="line">            firefox_options=fireFoxOptions, </span><br><span class="line">            firefox_profile=firefoxProfile</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 批量点赞</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行点赞</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            flag = self.driver.execute_script(<span class="string">"return $('#is-like-span').text().trim()"</span>) == <span class="string">"已赞"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                self.driver.execute_script(<span class="string">"$('#is-like-span').click()"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量收藏</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行收藏</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            flag = self.driver.execute_script(<span class="string">"return $('#is-collection').text()"</span>) == <span class="string">"已收藏"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                self.driver.execute_script(<span class="string">"$('#is-collection').click()"</span>)</span><br><span class="line">                self.driver.execute_script(<span class="string">"$('.csdn-collection-submit').click()"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量关注</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">follow</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行关注</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            flag = <span class="string">'已关注'</span> <span class="keyword">in</span> self.driver.execute_script(</span><br><span class="line">                <span class="string">"return $($('.toolbox-list').children()[6]).find('a').text().trim()"</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                self.driver.execute_script(<span class="string">"$($('.toolbox-list').children()[6]).find('a').click()"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量一键三连</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iloveyuou</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行三连</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            self.driver.execute_script(<span class="string">"$($('.toolbox-list').children()[7]).find('p').click()"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量留言</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">comment</span><span class="params">(self, urls, texts)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        对指定的一组博客地址批量进行评论</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.driver.get(url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            text = random.choice(texts)</span><br><span class="line">            self.driver.execute_script(<span class="string">f"$('#comment_content').text('<span class="subst">&#123;text&#125;</span>')"</span>)</span><br><span class="line">            self.driver.execute_script(<span class="string">f"$('.btn-comment').click()"</span>)</span><br><span class="line">            <span class="comment"># CSDN对评论间隔有要求，那就再睡一会儿</span></span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 热门文章</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hotRank</span><span class="params">(self, channel)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        抓取某个话题下的热门文章</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        url = <span class="string">f'https://blog.csdn.net/phoenix/web/blog/hotRank?page=0&amp;pageSize=25&amp;child_channel=<span class="subst">&#123;channel&#125;</span>'</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0'</span>,</span><br><span class="line">            <span class="string">'Cookie'</span>:<span class="string">'uuid_tt_dd=10_220300310-1611402514139-727015; dc_session_id=10_1611402514139.129755; dc_sid=37a633fe075b2698beeae6fb9c306fb4'</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        response.raise_for_status()</span><br><span class="line">        data = json.loads(response.text)</span><br><span class="line">        <span class="keyword">if</span> (data[<span class="string">'code'</span>] == <span class="number">200</span> <span class="keyword">and</span> data[<span class="string">'message'</span>] == <span class="string">'success'</span>):</span><br><span class="line">            <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x:x[<span class="string">'articleDetailUrl'</span>], data[<span class="string">'data'</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>我们都知道，在通常情况下，Selenium 每次运行时都会打开一个浏览器， 可这个浏览器呢，相对于我们平时使用的浏览器来说是“独立”的，因为细心的朋友一定会发现，虽然我们在 <code>Chrome</code> 或者 <code>Firefox</code> 中早已登录过了某个网站，可此时此刻，当 Selenium 启动浏览器窗口的时候，我们发现这个网站依然是需要登录的。为什么要讨论这个问题呢？因为如果我们希望对 CSDN 实现“一键三连”，登录这一步是必不可少的步骤。那么，有没有一种办法，可以让 Selenium 共享我们本地浏览器中的 Cookie 信息呢？因为只要有了Cookie，我们就可以专注于实现“一键三连”这部分。相信大家都看过上面的代码啦，答案当然是有的，我们为其指定一个配置文件的路径即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 Firefox 配置文件</span></span><br><span class="line"><span class="comment"># 默认路径：C:\\Users\\&lt;User&gt;\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\XXXX.default</span></span><br><span class="line"><span class="comment"># 参考链接：https://support.mozilla.org/zh-CN/kb/用户配置文件</span></span><br><span class="line">profile_dir = <span class="string">'C:\\Users\\YuanPei\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\xypbnthd.default-release'</span></span><br><span class="line">firefoxProfile = webdriver.FirefoxProfile(profile_dir) </span><br><span class="line">fireFoxOptions = webdriver.FirefoxOptions()</span><br><span class="line">webdriver.Firefox(firefox_options=fireFoxOptions, firefox_profile=firefoxProfile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Chrome 配置文件</span></span><br><span class="line"><span class="comment"># 默认路径：C:\\Users\\&lt;User&gt;\\AppData\Local\Google\Chrome\User Data</span></span><br><span class="line">profile_dir = <span class="string">'C:\\Users\\YuanPei\\AppData\Local\Google\Chrome\User Data'</span></span><br><span class="line">chromeOptions = webdriver.ChromeOptions()  </span><br><span class="line">chromeOptions.add_argument(<span class="string">'user-data-dir='</span> + os.path.abspath(profile_dir))  </span><br><span class="line">webdriver.Chrome(chrome_options=chromeOptions)</span><br></pre></td></tr></table></figure><p>这样，Selenium 启动的就不再是一个“裸”的浏览器，我们平时使用的各种配置、插件等等都会被原封不动地加载到 Selenium 中，这其中同样了我们的 Cookie，所以，当大家看到我的代码的时候，会发现这里没有做任何登录相关的事情，这其实是在用“时间”换取技术实现的“简单”，因为要额外加载大量的信息，所以，Selenium 启动的时候会变得缓慢起来，经过博主自己测试，Firefox 启动大概需要1分钟左右，熬过这1分钟接下来就是坦途啦！</p><p>其实，除此以外，关于登录这个问题，我们还有一种方案是对Cookie进行持久化。简而言之，就是利用 Selenium 的<code>get_cookies()</code> 和 <code>add_cookie()</code> 这一组API，第一次打开某个网站的时候，首先人为地或者模拟登录，此时可以获得Cookie并对其进行序列化，而访问那些需要登陆的资源时，则可以对Cookie进行反序列化并将其加载到 Selenium 环境中，基本的代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存Cokie到本地文件</span></span><br><span class="line">cookies = driver.get_cookies()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"cookies.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">json.dump(cookies, fp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地文件加载Cookie</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"cookies.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">cookies = json.load(fp)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">driver.add_cookie(cookie)</span><br></pre></td></tr></table></figure><p>下面来做一个简单的演示， <a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a> 有一个类似微博热搜的 <a href="https://blog.csdn.net/rank/list" target="_blank" rel="noopener">博客榜单</a>。这里，我们会从中筛选前 5 的博客链接来进行“一键三连”操作。与此同时，博主选取了一部分这些年轻人们喜欢用的评论，就在刚刚，我在这篇博客 <a href="https://blog.csdn.net/m0_46405703/article/details/112912541" target="_blank" rel="noopener">《第十二届蓝桥杯模拟赛Python组（第一期）》</a> 下面再次发现 <a href="https://blog.csdn.net/kimol_justdo" target="_blank" rel="noopener">Kimol君</a> 的身影，年轻人你不讲武德啊！我就想起了《开讲啦》里面惹恼易中天教授的那位学生，一个人的文章写得好，大家愿意去读去看，这自然是好事，可正因为梦鸽和大白这些小姐姐们都不在了，这个社区的内容质量完全由点赞、评论、收藏数这些因素在左右着，作为一名博客作者，我更希望别人能真的在读完我的文章后，或者能找出我考虑不周的地方，或者可以就某一个问题深入讨论一番，我发现社区里都喜欢动辄加别人QQ或者微信，可如果这种毫无意义地灌水的评论，这一切又有什么意义呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你经常收到这些评论，千万不要“飘”</span></span><br><span class="line"><span class="comment"># 你觉得这些话都是真心的吗？</span></span><br><span class="line">comments = [</span><br><span class="line">    <span class="string">'代码之路任重道远，愿跟博主努力习之。'</span>,</span><br><span class="line">    <span class="string">'学起来，头秃的那种~'</span>,</span><br><span class="line">    <span class="string">'写的太好了，很实用'</span>,</span><br><span class="line">    <span class="string">'好文！希望博主以后多多分享哈！'</span>,</span><br><span class="line">    <span class="string">'哇，好棒啊，崇拜的小眼神，欢迎回赞，回评哦~~~'</span>,</span><br><span class="line">    <span class="string">'收藏从未停止，学习从未开始。'</span>,</span><br><span class="line">    <span class="string">'大佬，看了您的文章，内心的仰慕之情油然而生，赶紧给大佬点个赞！'</span>,</span><br><span class="line">    <span class="string">'太赞了！666666'</span></span><br><span class="line">]</span><br><span class="line">proxy = Proxy(<span class="string">'C:\\Users\\YuanPei\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\xypbnthd.default-release'</span>)</span><br><span class="line"><span class="comment"># 热搜前5名的文章</span></span><br><span class="line">urls = proxy.hotRank(<span class="string">'python'</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 批量留言，刷存在感</span></span><br><span class="line">proxy.comment(urls, comments)</span><br><span class="line"><span class="comment"># 一键三连</span></span><br><span class="line">proxy.iloveyuou(urls)</span><br></pre></td></tr></table></figure><p>当然啦，像我这里提供的关于点赞(vote)、收藏(collect)、关注(follow)等等方法，同样是可以使用的，这里就不再一一例举啦！本身都是基于 <code>jQuery</code> 来操作DOM，理解上应该没有太大难度，虽然我不大喜欢用 <code>jQuery</code> 写业务代码，可对于爬虫这种事情，自然是越简单越好，因为我不想再去学一门操作 DOM 的语言：XPath， 而关于 Selenium 驱动的安装、配置等细节，可以参考博主的这篇文章：</p><p><a href="https://qinyuanpei.blog.csdn.net/article/details/111351111" target="_blank" rel="noopener">作为技术宅的我，是这样追鬼滅の刃的</a></p><p>博主最近新开了一个付费专栏：<a href="https://blog.csdn.net/qinyuanpei/category_7444699.html" target="_blank" rel="noopener">Python数据挖掘系列</a>，主要介绍关于爬虫、PyECharts、结巴分词、Pandas、Matplotlib、SnowNLP、OpenCV等数据挖掘相关内容，如果大家喜欢或者感兴趣，欢迎订阅。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区，就你对于这篇博客的想法或者意见进行讨论，再次谢谢大家！如果 <a href="https://blog.csdn.net/kimol_justdo" target="_blank" rel="noopener">Kimol君</a> 恰好读至此处，最好能一键三连，我权当作为你打广告的广告费啦，哈哈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/styles/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/scripts/APlayer.min
      
    
    </summary>
    
      <category term="数据分析" scheme="https://qinyuanpei.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="https://qinyuanpei.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://qinyuanpei.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="自动化" scheme="https://qinyuanpei.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Selenium" scheme="https://qinyuanpei.github.io/tags/Selenium/"/>
    
  </entry>
  
</feed>
