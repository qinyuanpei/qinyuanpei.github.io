<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="pragma" content="no-cache"><meta http-equiv="cache-control" content="no-cache"><meta name="msvalidate.01" content="713A48A3FE17D4841C292A6B3942EB4C"><title>使用多线程为你的Python爬虫提速的N种姿势，你会几种？ | 一个人的孤落时辰</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="多线程,技巧,Python,爬虫,秦元培,技术博客,生活随笔,个人博客,NET,Python,数据挖掘,数据分析,NLP"><meta name="description" content="简而言之，Python 在 `concurrent.futures`中为我们提供了 [ThreadPoolExecutor](https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor) 和 [ProcessPoolExecutor](https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor) 两个高级接口，它们都继承自同一个抽象类`Executor`，它可以让我们在线程池或者进程池中异步地执行回调函数，属于官方提供的标准的“线程池”和“进程池”模块，下面，我们来一起看看具体的使用方法：;不过呢，博主好奇 Scrapy 这个爬虫框架的实现原理，发现它是基于 Twisted 这样一个异步网络框架，考虑到目前为止，我们通过 `requests` 来下载图片都是采用同步的方式，除了任务调度上的优化以外，任务本身还存在一定的优化空间，所以，这里就顺带着一起整理出来，这里主要结合 `asyncio` 和 `requests` 来对 Python 中关于异步 I/O 、协程等的使用方法进行演示和说明;除了这种函数式的使用方法以外，我们还可以通过继承`Thread`类并重写其`run()`方法的方式，对于这一点可以参考官方文档中的[线程对象](https://docs.python.org/zh-cn/3/library/threading.html#thread-objects);首先，我们需要了解的是，Python 中的 Thread ，实际上先后有`thread`和`threading`两种模块，它们的关系有一点像 .NET 里的`Thread`和`Task`，考虑到`thread`的使用频率非常低，这里我们更推荐大家使用`threading`，它提供了更高级的、完全的线程管理;庆幸的是，在 Python 中线程与进程在代码的编写上是非常相似的，这里我们需要用到的是`multiprocessing`模块，下面，我们来一起看看 Python 中的进程的的使用方法，你会发现只需要改一下`threading.Thread()`这部分："><meta name="description" content="简而言之，Python 在 &#96;concurrent.futures&#96;中为我们提供了 [ThreadPoolExecutor](https:&#x2F;&#x2F;docs.python.org&#x2F;zh-cn&#x2F;3&#x2F;library&#x2F;concurrent.futures.html#concurrent.futures.ThreadPoolExecutor) 和 [ProcessPoolExecutor](https:&#x2F;&#x2F;do"><meta property="og:type" content="article"><meta property="og:title" content="使用多线程为你的Python爬虫提速的N种姿势，你会几种？"><meta property="og:url" content="https://qinyuanpei.github.io/posts/3247093203/index.html"><meta property="og:site_name" content="一个人的孤落时辰"><meta property="og:description" content="简而言之，Python 在 &#96;concurrent.futures&#96;中为我们提供了 [ThreadPoolExecutor](https:&#x2F;&#x2F;docs.python.org&#x2F;zh-cn&#x2F;3&#x2F;library&#x2F;concurrent.futures.html#concurrent.futures.ThreadPoolExecutor) 和 [ProcessPoolExecutor](https:&#x2F;&#x2F;do"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2021/01/15/I6jZ35R8dDvJUsW.png"><meta property="og:image" content="https://i.loli.net/2021/01/15/kGgPXS8vHMwxoIN.png"><meta property="og:image" content="https://i.loli.net/2021/01/15/jeJTHlkiuors4zw.png"><meta property="og:image" content="https://i.loli.net/2021/01/16/oyJKlOCazQX3RcZ.png"><meta property="og:image" content="https://i.loli.net/2021/01/15/jGKQ2qnVtz9c4DL.png"><meta property="og:image" content="https://i.loli.net/2021/01/16/iCFSawkEMjN2PzO.png"><meta property="og:image" content="https://i.loli.net/2021/01/16/mhtcT78dswjgERa.png"><meta property="article:published_time" content="2021-01-14T20:35:47.000Z"><meta property="article:modified_time" content="2021-09-02T06:24:58.273Z"><meta property="article:author" content="飞鸿踏雪"><meta property="article:tag" content="多线程"><meta property="article:tag" content="技巧"><meta property="article:tag" content="Python"><meta property="article:tag" content="爬虫"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.loli.net/2021/01/15/I6jZ35R8dDvJUsW.png"><link rel="alternate" type="application/atom+xml" title="一个人的孤落时辰" href="/atom.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master//assets/styles/style.css"><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/instantclick.min.js"></script><script>window.lazyScripts=[]</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/brand.jpg)"><div class="brand"><a href="/" class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="avatar"></a><hgroup class="introduce"><h5 class="nickname">飞鸿踏雪</h5><a href="mailto:qinyuanpei@163.com" title="qinyuanpei@163.com" class="mail">qinyuanpei@163.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> 标签</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/books"><i class="icon icon-lg icon-bookmark"></i> 书单</a></li><li class="waves-block waves-effect"><a href="/movies"><i class="icon icon-lg icon-film"></i> 影单</a></li><li class="waves-block waves-effect"><a href="https://qinyuanpei.github.io/poems/"><i class="icon icon-lg icon-folder-open"></i> 诗集</a></li><li class="waves-block waves-effect"><a href="/works"><i class="icon icon-lg icon-code"></i> 实验室</a></li><li class="waves-block waves-effect"><a href="/about"><i class="icon icon-lg icon-circle"></i> 关于我</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">使用多线程为你的Python爬虫提速的N种姿势，你会几种？</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i> </a><a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="menuGithub"><i class="icon icon-lg icon-code-fork"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">使用多线程为你的Python爬虫提速的N种姿势，你会几种？</h1><h5 class="subtitle" id="subtitle"><time datetime="2021-01-14T20:35:47.000Z" itemprop="datePublished" class="page-time">2021-01-14</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>目录</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#楔子"><span class="post-toc-number">1.</span> <span class="post-toc-text">楔子</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#线程与线程池"><span class="post-toc-number">2.</span> <span class="post-toc-text">线程与线程池</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Thread"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Thread</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ThreadPool"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">ThreadPool</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ThreadPoolExecutor"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">ThreadPoolExecutor</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#进程与进程池"><span class="post-toc-number">3.</span> <span class="post-toc-text">进程与进程池</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Process"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Process</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ProcessPool"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">ProcessPool</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ProcessPoolExecutor"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">ProcessPoolExecutor</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#协程与异步I-O"><span class="post-toc-number">4.</span> <span class="post-toc-text">协程与异步I&#x2F;O</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#asyncio"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">asyncio</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#requests"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">requests</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#本文小结"><span class="post-toc-number">5.</span> <span class="post-toc-text">本文小结</span></a></li></ol></nav></aside><article id="post-使用多线程为你的Python爬虫提速的N种姿势，你会几种？" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">使用多线程为你的Python爬虫提速的N种姿势，你会几种？</h1><div class="post-meta"><time class="post-time" title="2021-01-14 20:35:47" datetime="2021-01-14T20:35:47.000Z" itemprop="datePublished">2021-01-14</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></li></ul><span id="lc_counter_container_page_pv" title="文章总阅读量" data-page-url="" data-page-title="使用多线程为你的Python爬虫提速的N种姿势，你会几种？"><i class="icon icon-eye icon-pr"></i><span id="lc_counter_value_page_pv"></span></span> <span><i class="icon icon-clock-o"></i> 29 min.</span></div><div class="post-content" id="post-content" itemprop="postContent"><p>最近博主在优化一个爬虫程序，它是博主在2017年左右刚接触 Python 时写下的一个程序。时过境迁，当 Python 2.X 终于寿终正寝成为过去，当博主终于一只脚迈进30岁的大门，一切都来得猝不及防，像一阵龙卷风裹挟着回忆呼啸而去。和大多数学习 Python 的人一样，博主学习 Python 是从写爬虫开始的，而这个爬虫程序刚好是那种抓取“宅男女神”的程序，下载图片无疑是整个流程里最关键的环节，所以，整个优化的核心，无外乎提升程序的稳定性、提高抓取速度。所以，接下来，我会带大家走近 Python 中的多线程编程，涉及到的概念主要有<code>线程(池)</code>、<code>进程(池)</code>、<code>异步I/O</code>、<code>协程</code>、<code>GIL</code>等，而理解这些概念，对我们而言是非常重要的，因为它将会告诉你选择什么方案更好一点。想让你的爬虫更高效、更快吗？在这里就能找到你的答案。</p><h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>现在，假设我们有一组图片的地址(URL)，我们希望通过<code>requests</code>来实现图片的下载，为此我们定义了<code>Spider</code>类。在这个类中，我们提供了<code>getImage()</code>方法来完成下载这个动作。我们可以非常容易地写出一个“单线程”的版本，但这显然这不是我们今天这篇博客的目的。此时，我们来考虑一个问题，怎么样实现一个“多线程”的版本？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, urls)</span>:</span></span><br><span class="line">        self.session = requests.session()</span><br><span class="line">        self.session.headers[<span class="string">'User-Agent'</span>] = fake_useragent.UserAgent().random</span><br><span class="line">        self.session.headers[<span class="string">"Referer"</span>] = <span class="string">"https://www.nvshens.org"</span></span><br><span class="line">        self.urls = urls</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImage</span><span class="params">(self, url, fileName, retries=<span class="number">5</span>)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;threading.currentThread().name&#125;</span> -&gt; <span class="subst">&#123;url&#125;</span>'</span>)</span><br><span class="line">            response = self.session.get(url, </span><br><span class="line">              allow_redirects=<span class="literal">False</span>, </span><br><span class="line">              timeout=<span class="number">10</span>, </span><br><span class="line">              proxies=<span class="literal">None</span></span><br><span class="line">            )</span><br><span class="line">            response.raise_for_status()</span><br><span class="line">            data = response.content</span><br><span class="line">            imgFile = open(fileName, <span class="string">'wb'</span>)</span><br><span class="line">            imgFile.write(data)</span><br><span class="line">            imgFile.close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> :</span><br><span class="line">            <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">                retries -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.getImage(url, fileName, retries):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h1 id="线程与线程池"><a href="#线程与线程池" class="headerlink" title="线程与线程池"></a>线程与线程池</h1><p>既然提到了线程，我们会非常自然地想到 <code>Thread</code> 和 <code>ThreadPool</code> ，而这几乎是所有编程语言里都有的通用型概念。可是，Python 中的多线程其实是一种“假”的多线程，这又从何说起呢？答案是<strong>全局解释器锁</strong>(<strong>GIL</strong>)，原来在设计 Python 解释器的时候，为了保证同时只有一个线程在运行，引入了这样一个锁，你可以类比游戏开发时主循环的概念来辅助理解。那为什么又说 Python 中的多线程是一种“假”的多线程呢？这是因为它没法发挥出多核的优势，每个线程在执行前都要先获得 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock" target="_blank" rel="noopener">GIL</a> ，这就导致一个问题，即使你有多个核心，线程永远只能用到其中一个核，因为多线程在 Python 中只能交替执行。以一言蔽之， Python 中 I/O 密集型任务相比 CPU 密集型任务更能充分发挥多线程的好处。所以，像爬虫这种和网络打交道的事物，是非常适合使用多线程来提高效率的。在这里，我们我们要介绍的是 <code>Thread</code> 和 <code>ThreadPool</code> 以及 <code>ThreadPoolExecutor</code>。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>首先，我们需要了解的是，Python 中的 Thread ，实际上先后有<code>thread</code>和<code>threading</code>两种模块，它们的关系有一点像 .NET 里的<code>Thread</code>和<code>Task</code>，考虑到<code>thread</code>的使用频率非常低，这里我们更推荐大家使用<code>threading</code>，它提供了更高级的、完全的线程管理。例如，我们现在面临的这个“多线程”下载的问题，使用<code>threading</code>的话可以这样解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Thread下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByThread</span><span class="params">(self)</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(self.urls)):</span><br><span class="line">        thread = threading.Thread(</span><br><span class="line">          target=self.getImage, </span><br><span class="line">          args=(self.urls[index], <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>,)</span><br><span class="line">        )</span><br><span class="line">        threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        thread.start()</span><br></pre></td></tr></table></figure><p>可以注意到，当我们需要构造一个线程时，只需要指定<code>target</code>和<code>args</code>两个参数，其中，前者是指线程执行的方法，后者是指传递给线程所执行的方法的参数。当我们需要启动线程时，只需要调用线程的<code>start()</code>方法，而通过<code>setDaemon()</code>方法则可以设置一个线程为守护线程。关于守护线程，这里简单说明一下，一旦一个线程被设置为守护线程，那么，只要线程执行的方法中存在等待时间譬如<code>time.sleep(1)</code>，此时等待时间下面的代码都不会再执行。如果线程中执行的方法是一个耗时的操作，此时，我们还可以通过<code>join()</code>方法来阻塞主线程，以确保主线程再子线程执行完后再结束。除了这种函数式的使用方法以外，我们还可以通过继承<code>Thread</code>类并重写其<code>run()</code>方法的方式，对于这一点可以参考官方文档中的<a href="https://docs.python.org/zh-cn/3/library/threading.html#thread-objects" target="_blank" rel="noopener">线程对象</a>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/15/I6jZ35R8dDvJUsW.png" alt="使用Thread下载" referrerpolicy="no-referrer"></div><div class="image-caption">使用Thread下载</div></figure><h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p>对于线程，我们都知道它是作为一种系统资源而存在的，所以，和这个世界上的大多数资源一样，无法供我们肆意地挥霍和浪费。在 <a href="https://blog.yuanpei.me/posts/2414960312/" target="_blank" rel="noopener">.NET Core中对象池(Object Pool)的使用</a> 这篇博客中，我曾经大家介绍过“对象池”这种设计，和这篇博客中所提到的原理一样，线程池相对于普通线程而言多了一种可复用的可能性，这意味着我们可以用有限的线程来下载可能无限多的图片资源。在 Python 中我们使用 <code>threadpool</code> 模块来实现线程池的功能，需要注意的是这是一个第三方的模块。下面，我们来一起看看具体的使用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ThreadPool下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByThreadPool</span><span class="params">(self, poolSize=<span class="number">3</span>)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        args.append((<span class="literal">None</span>, &#123;<span class="string">'url'</span>: self.urls[index], <span class="string">'fileName'</span>: <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>&#125;))</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = threadpool.ThreadPool(poolSize)</span><br><span class="line">    requests = threadpool.makeRequests(self.getImage, args)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> requests]</span><br><span class="line">    pool.wait()</span><br></pre></td></tr></table></figure><p>在这里，我们声明了一个指定大小的线程池，通过一个方法<code>getImage()</code>和一组参数<code>args</code>来构造“请求”，再将这些请求全部放进线程池里，此时，线程池会自动等待这些“请求”执行完毕。这里唯一比较难理解的，可能是如何构造参数<code>args</code>，尤其是当被执行的方法需要传递多个参数的时候。其实这里有两种传参的方式，第一种是按数组来解构，此时我们可以写<code>[([&#39;&#39;,&#39;&#39;], None), ([&#39;&#39;,&#39;&#39;], None)]</code>；而第二种则是按字典来解构，此时我们可以写<code>[(None, {&#39;url&#39;:&#39;&#39;, &#39;fileName&#39;:&#39;&#39;}), (None, {&#39;url&#39;:&#39;&#39;, &#39;fileName&#39;:&#39;&#39;})</code>。两者的区别主要在<code>None</code>的位置，不知道大家有没有发现规律。这里我们准备了张图片，而线程池最大线程是3个，理论上某个线程会被重复使用，实际结果又是如何呢？</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/15/kGgPXS8vHMwxoIN.png" alt="使用ThreadPool下载" referrerpolicy="no-referrer"></div><div class="image-caption">使用ThreadPool下载</div></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>对于<a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a>，相信不用我多说什么，你就能知道它是做什么的吧，这就是博主反复提及的命名规范的问题。简而言之，Python 在 <code>concurrent.futures</code>中为我们提供了 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a> 和 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">ProcessPoolExecutor</a> 两个高级接口，它们都继承自同一个抽象类<code>Executor</code>，它可以让我们在线程池或者进程池中异步地执行回调函数，属于官方提供的标准的“<strong>线程池</strong>”和“<strong>进程池</strong>”模块，下面，我们来一起看看具体的使用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ThreadPoolExecutor下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByThreadPoolExecutor</span><span class="params">(self, poolSize=<span class="number">3</span>)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">      args.append(&#123;<span class="string">'url'</span>: self.urls[index], <span class="string">'fileName'</span>: <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>&#125;)</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=poolSize)</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        task = pool.submit(self.getImage(arg[<span class="string">'url'</span>], arg[<span class="string">'fileName'</span>]), arg)</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    wait(tasks, return_when=ALL_COMPLETED)</span><br><span class="line">    <span class="comment"># tasks = pool.map(lambda arg:self.getImage(arg['url'], arg['fileName']), args)</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>submit()</code>方法和<code>map()</code>方法的区别，前者相当于声明线程后并不立即执行，故而，需要<code>wait()</code>方法来等待所有任务执行结束；而后者则相当于声明线程并理解执行，故而，返回值实际是每一个任务执行的结果的集合，这里就隐隐有一点 .NET 中 <code>Task</code> 的味道啦！同样地，我们给了一个最大线程数：3，它能否得到和<code>threadpool</code> 类似的结果呢？我们拭目以待：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/15/jeJTHlkiuors4zw.png" alt="使用ThreadPoolExecutor下载" referrerpolicy="no-referrer"></div><div class="image-caption">使用ThreadPoolExecutor下载</div></figure><h1 id="进程与进程池"><a href="#进程与进程池" class="headerlink" title="进程与进程池"></a>进程与进程池</h1><p>看到这里，可能有读者朋友会忍不住吐槽，博主你三十岁不到，怎么越来越糊涂了啊，你这博客标题明明写的是多线程，怎么写着写着就写到进程上来了呢？其实，这里是紧接着 GIL 这个话题来讲的。既然 Python 中的多线程更适合 I/O 密集型的任务，那么，是不是说 Python 不适合处理 CPU 密集型的任务呢？答案是否定的，我们这里将多进程理解为并行就会更容易想明白一点。我们都知道操作系统可以同时执行多个任务，而这每一个任务其实就是一个进程，而每个进程内又可以同时执行多个子任务，这每一个子任务其实就是一个线程。这样说，我们或许就能明白，这意味着，如果我们的确需要并行地去处理某些任务，进程(池)或许是个不错的选择。同样地，这里介绍的是，<code>Process</code>、<code>ProcessPool</code> 和 <code>ProcessPoolExecutor</code>。</p><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>关于进程，我个人感觉比线程要更好理解一点，因为不论是 Windows 下的任务管理器，亦或者是我们经常听到的“杀进程”，它都不算是一个特别陌生或者抽象的概念，而线程这种东西呢，大概是只有程序员会关注，同时爱之弥深、恨之弥切的一种事物。庆幸的是，在 Python 中线程与进程在代码的编写上是非常相似的，这里我们需要用到的是<code>multiprocessing</code>模块，下面，我们来一起看看 Python 中的进程的的使用方法，你会发现只需要改一下<code>threading.Thread()</code>这部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Process下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByProcess</span><span class="params">(self)</span>:</span></span><br><span class="line">    process = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(self.urls)):</span><br><span class="line">        proc = multiprocessing.Process(</span><br><span class="line">          target=self.getImage, </span><br><span class="line">          args=(self.urls[index], <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>,)</span><br><span class="line">        )</span><br><span class="line">        process.append(proc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> proc <span class="keyword">in</span> process:</span><br><span class="line">        proc.start()</span><br></pre></td></tr></table></figure><p>此时，我们可以得到下面的结果，可以发现它都是在主线程上运行：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/16/oyJKlOCazQX3RcZ.png" alt="使用Process下载" referrerpolicy="no-referrer"></div><div class="image-caption">使用Process下载</div></figure><h2 id="ProcessPool"><a href="#ProcessPool" class="headerlink" title="ProcessPool"></a>ProcessPool</h2><p>既然有“线程池”，又怎么能少得了进程池呢？同样地，它位于<code>multiprocessing</code>模块中，通过<code>apply()</code>方法来执行某个任务，下面是一个基本的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用multiprocessing.Pool()下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByProcessPool</span><span class="params">(self, poolSize=<span class="number">3</span>)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        args.append((self.urls[index], <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>, ))</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = multiprocessing.Pool(poolSize)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        pool.apply(self.getImage, arg)</span><br></pre></td></tr></table></figure><p>有朋友难免会好奇“进程池”和“线程池”有什么不一样，我想，下面这张图会告诉你答案：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/15/jGKQ2qnVtz9c4DL.png" alt="使用multiprocessing.Pool()下载" referrerpolicy="no-referrer"></div><div class="image-caption">使用multiprocessing.Pool()下载</div></figure><h2 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h2><p>和 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a> 类似，我们还可以使用 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">ProcessPoolExecutor</a> 来实现“进程池”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ProcessPoolExecutor下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadByProcessPoolExecutor</span><span class="params">(self, poolSize=<span class="number">3</span>)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        args.append(&#123;<span class="string">'url'</span>: self.urls[index], <span class="string">'fileName'</span>: <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span>&#125;)</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = ProcessPoolExecutor(max_workers=poolSize)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        pool.submit(self.getImage(arg[<span class="string">'url'</span>], arg[<span class="string">'fileName'</span>]), arg)</span><br></pre></td></tr></table></figure><p>可以看到，“进程池”中的代码都是在主线程上执行的，这一点和<code>multiprocessing.Pool()</code>完全一致：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/16/iCFSawkEMjN2PzO.png" alt="使用ProcessPoolExecutor下载" referrerpolicy="no-referrer"></div><div class="image-caption">使用ProcessPoolExecutor下载</div></figure><h1 id="协程与异步I-O"><a href="#协程与异步I-O" class="headerlink" title="协程与异步I/O"></a>协程与异步I/O</h1><p>其实，如果单单从 I/O 密集型和 CPU 密集型两种场景而言，这篇博客到这里就差不多应该结束啦！不过呢，博主好奇 Scrapy 这个爬虫框架的实现原理，发现它是基于 Twisted 这样一个异步网络框架，考虑到目前为止，我们通过 <code>requests</code> 来下载图片都是采用同步的方式，除了任务调度上的优化以外，任务本身还存在一定的优化空间，所以，这里就顺带着一起整理出来，这里主要结合 <code>asyncio</code> 和 <code>requests</code> 来对 Python 中关于异步 I/O 、协程等的使用方法进行演示和说明。</p><h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/asyncio.html" target="_blank" rel="noopener">asyncio</a> 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async/await</strong> 语法，它是构建 I/O 密集型和高层级 <strong>结构化</strong> 网络代码的最佳选择。它提供了类似并发地执行<a href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a>、网络 I/O 和进程间通信(<strong>IPC</strong>)、<a href="https://docs.python.org/zh-cn/3.7/library/asyncio-eventloop.html#asyncio-event-loop" target="_blank" rel="noopener">事件循环</a>等等的能力，例如，我们可以通过下面的代码来创建和使用<a href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(what, delay)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="string">'你好'</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="string">'Hello'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式1</span></span><br><span class="line"><span class="comment"># Python 3.7 + </span></span><br><span class="line">asyncio.rum(main())</span><br><span class="line"><span class="comment"># Python 3.7 -</span></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>参考官方文档，我们还可以使<code>create_task()</code>方法来创建<code>asyncio</code>的并发任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Python 3.7 + </span></span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="string">'你好'</span>, <span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="string">'Hello'</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="comment"># Python 3.7 -</span></span><br><span class="line">    task1 = asyncio.get_event_loop().(say_after(<span class="string">'你好'</span>, <span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.get_event_loop().(say_after(<span class="string">'Hello'</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>这是因为 Python 中的协程、任务 和 Future 都是可等待对象，故而，凡有 <strong>async</strong> 处皆可 <strong>await</strong> ，果然，主流编程语言的最终走向是如此的一致啊，回头想想 .NET 中 Thread 、 ThreadPool 、 Task 的进化历程，是不是有种“<strong>天下大势，分久必合</strong>”的感觉呢？</p><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>好了，当我们对异步 I/O、协程有了一个基本的了解以后，我们就可以考虑结合着 <code>requests</code> 来做一点小小的尝试，我们大多数时候写的 <code>requests</code> 相关的代码，基本上都是博主这里<code>getImage()</code>类似的画风，最多再加上流式传输(Stream) 和 <code>iter_content</code>。为了配合异步 I/O来使用，我们这里需要定义一个异步的方法<code>getImageAsync()</code>，一起来看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">getImageAsync</span><span class="params">(self, url, fileName, retries=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;threading.currentThread().name&#125;</span> -&gt; <span class="subst">&#123;url&#125;</span>'</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: fake_useragent.UserAgent().random,</span><br><span class="line">            <span class="string">'Referer'</span>: <span class="string">"https://www.nvshens.org"</span></span><br><span class="line">        &#125;</span><br><span class="line">        future = asyncio.get_event_loop().run_in_executor(</span><br><span class="line">            <span class="literal">None</span>, </span><br><span class="line">            functools.partial(requests.get, url, headers=headers)</span><br><span class="line">        )</span><br><span class="line">        response = <span class="keyword">await</span> future</span><br><span class="line">        data = response.content</span><br><span class="line">        imgFile = open(fileName, <span class="string">'wb'</span>)</span><br><span class="line">        imgFile.write(data)</span><br><span class="line">        imgFile.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">await</span> self.getImageAsync(url, fileName, retries):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>接下来，我们还需要定义<code>downloadAsync()</code>方法，这里我们使用了<code>create_task()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">downloadAsync</span><span class="params">(self)</span>:</span></span><br><span class="line">    count = len(self.urls)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        url = self.urls[index]</span><br><span class="line">        fileName = <span class="string">f'<span class="subst">&#123;str(index)&#125;</span>.jpg'</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.get_event_loop().create_task(self.getImageAsync(url, fileName))</span><br></pre></td></tr></table></figure><p>此时，我们可以在入口函数中这样调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spider = Spider(urls)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(spider.downloadAsync())</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure><p>看看结果：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2021/01/16/mhtcT78dswjgERa.png" alt="异步I/O + Requests 实现并行下载]" referrerpolicy="no-referrer"></div><div class="image-caption">异步I/O + Requests 实现并行下载]</div></figure><p>这里，针对本文中提到的各种方法，博主做了一个简单对比：</p><table><thead><tr><th>项目</th><th>时间</th></tr></thead><tbody><tr><td>Thread</td><td>0:00:01.789790</td></tr><tr><td>ThreadPool</td><td>0:00:00.134065</td></tr><tr><td>ThreadPoolExecutor</td><td>0:00:06.510224</td></tr><tr><td>Process</td><td>0:00:00.100506</td></tr><tr><td>ProcessPool</td><td>0:00:11.046871</td></tr><tr><td>ProcessPoolExecutor</td><td>0:00:02.226153</td></tr><tr><td>AsyncIO</td><td>0:00:04.096083</td></tr></tbody></table><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文从线程(池)、进程(池)和异步 I/O 三个方面探讨和尝试了多线程编程在 Python 爬虫领域的简单应用。其实，除了以上这些优化的思路以外，我们还可以借助队列(<strong>Queue</strong>)这类数据结构来改善现有方案的设计，大家可以注意到我给<code>getImage()</code>方法增加了错误重试的机制，这同样是为了增强爬虫程序的健壮性，而关于这个错误重试机制，考虑通过装饰器来进行改良则又是一个新的努力的方向，所以说，没有 deadline 才能让我们不断地自我改善，而有 deadline 只能让我们赶紧做完赶紧清净。好了，以上就是这篇博客的全部内容啦，最后要送给大家一个福利，本文中援引的爬虫程序已开源，地址是：<a href="https://github.com/qinyuanpei/zngirls" target="_blank" rel="noopener">https://github.com/qinyuanpei/zngirls</a>，感兴趣的朋友可以自己去玩一玩，你懂的哦！</p><div class="recommended_posts"><h1>推荐阅读</h1><ul><li><a href="https://qinyuanpei.github.io/posts/3959327595/">C#中Socket通信编程的同步实现</a></li><li><a href="https://qinyuanpei.github.io/posts/345410188/">《C#多线程编程实战》读书笔记</a></li><li><a href="https://qinyuanpei.github.io/posts/305484621/">C#中的扩展方法学习总结</a></li><li><a href="https://qinyuanpei.github.io/posts/2414960312/">.NET Core中对象池(Object Pool)的使用</a></li><li><a href="https://qinyuanpei.github.io/posts/116795088/">.NET Core POCOController在动态Web API中的应用</a></li></ul></div></div><blockquote class="post-copyright" id="post-copyright"><div class="content"><p><b>版权声明：</b> <a href="https://qinyuanpei.github.io/posts/3247093203/" rel="external">使用多线程为你的Python爬虫提速的N种姿势，你会几种？</a> ，由&nbsp;<a href="/about" target="_blank" rel="external">飞鸿踏雪</a>&nbsp; 首次发表于&nbsp;<a href="/" target="_blank" rel="external">一个人的孤落时辰</a>&nbsp; ，本文地址为：<a href="https://qinyuanpei.github.io/posts/3247093203/" target="_blank" rel="external">https://qinyuanpei.github.io/posts/3247093203/</a> ，转载请注明 <b>作者</b> 和 <b>出处</b> 。</p></div><footer><a href="https://qinyuanpei.github.io"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="飞鸿踏雪"> 飞鸿踏雪</a></footer></blockquote><div class="page-reward"><a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E5%B7%A7/" rel="tag">技巧</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/3247093203/&title=《使用多线程为你的Python爬虫提速的N种姿势，你会几种？》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/3247093203/&title=《使用多线程为你的Python爬虫提速的N种姿势，你会几种？》 — 一个人的孤落时辰&source=一个人的孤落时辰 | 纵有疾风起，人生不言弃 | 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地 | 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/3247093203/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《使用多线程为你的Python爬虫提速的N种姿势，你会几种？》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/3247093203/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/3247093203/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/posts/3148958651/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">基于 Python 和 Selenium 实现 CSDN 一键三连自动化</h4></a></div><div class="waves-block waves-effect next"><a href="/posts/3406626380/" id="post-next" class="post-nav-link"><div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">实现网页长截图的常见思路总结</h4></a></div></nav><div id="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">new Valine({el:"#comment",notify:!1,verify:!0,appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",placeholder:"云中谁寄锦书来，雁字回时，月满西楼。&#10;Tips：如果希望收到我的评论回复，请至少留下你的邮箱哦:)",path:"https://qinyuanpei.github.io/posts/3247093203/",avatar:"identicon",requiredFields:["nick","mail"]})</script></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 赠人玫瑰，手有余香 <i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" alt="打赏二维码"></div><label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" data-alipay="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/alipay.jpg"><div class="reward-toggle-ctrol"><span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-label"></span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div><script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/yoniu.min.js"></script><style type="text/css">body.active-yp{overflow:hidden}.yp-fc-btn{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:space-between;font-size:13px}.yp-fc-btn span{cursor:pointer;padding:2px 10px;color:#4b4b4b;border:#4b4b4b 1px solid;border-radius:5px}#yp-hide{position:fixed;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:center;flex-direction:column;left:0;top:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);z-index:99999;visibility:hidden}#yoniu-poster{box-sizing:border-box;width:350px;height:467.2px;background-color:#fff;margin:0 auto;padding:0;line-height:1.6;text-align:justify}.yp-img{min-height:240px;position:relative;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:flex-end;flex-direction:column;background-position:50% 50%;background-size:cover;overflow:hidden}.yp-img>div{padding:10px 20px}.yp-name{display:block;color:#fff;font-size:20px;font-weight:600;text-shadow:#4b4b4b .1em .1em .2em;margin-top:10px}.yp-sort{padding:3px 10px;font-size:12px;color:#fff;background:#2e2e2e}.yp-des{color:#2e2e2e;font-size:14px;margin:20px;height:67.2px}.yp-qcode{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;margin:10px;padding:10px 20px;background:#f5f5f5;color:#818181;border-radius:10px}.yp-tips{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;color:#ccc;margin:0 10px 10px;font-size:10px;letter-spacing:1.5px}.yp-btns{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:stretch;justify-content:center;width:350px;margin:0 auto}.yp-btns>span{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:center;font-size:14px;padding:10px 15px;background:rgba(0,0,0,.2);color:#f5f5f5;cursor:pointer}.yp-btns>span>a{color:#f5f5f5}.yp-btns>span>a:hover{text-decoration:none}#yp-close{font-size:18px;font-weight:600}</style><div id="yp-hide"><div id="yoniu-poster"><div class="yp-img" id="yp-img"><div><span class="yp-sort"></span> <span class="yp-name">使用多线程为你的Python爬虫提速的N种姿势，你会几种？</span></div></div><div class="yp-des">最近博主在优化一个爬虫程序，它是博主在2017年左右刚接触 Python 时写下的一个程序。时过境迁，当 Python 2.X 终于寿终正寝成为...</div><div class="yp-qcode"><span>扫描二维码阅读原文</span> <img id="yp-qcode" width="64px" src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/3247093203/"></div><div class="yp-tips"><span>一个人的孤落时辰</span> <span><time class="post-time" title="2021-01-14 20:35:47" datetime="2021-01-14T20:35:47.000Z" itemprop="datePublished">2021-01-14</time></span></div></div><div class="yp-btns"><span id="yp-load-yp" onclick="load_yp()">生成海报</span> <span><a id="yp-download"></a></span> <span id="yp-close" onclick="close_yp()">×</span></div></div><script type="text/javascript">function show_yp(){window.scrollTo(0,0),document.body.setAttribute("class","active-yp");let e=document.getElementsByTagName("img")[1];null!=e&&void 0!==e?document.getElementById("yp-img").style.backgroundImage=`url(${e.src})`:document.getElementById("yp-img").style.backgroundColor="#d7dbf0",document.getElementById("yp-hide").style.visibility="visible"}function close_yp(){var e=document.body.getAttribute("class");e=e.replace("active-yp",""),document.body.setAttribute("class",e),document.getElementById("yp-hide").style.visibility="hidden"}function load_yp(){document.getElementById("yp-load-yp").textContent="海报生成中...",setTimeout((function(){h2c_()}),2e3)}</script></div><footer class="footer"><div class="top"><p><span id="lc_counter_container_site_uv"><i class="icon icon-user"></i><span id="lc_counter_value_site_uv"></span> </span><span id="lc_counter_container_site_pv"><i class="icon icon-eye"></i><span id="lc_counter_value_site_pv"></span></span></p><p><a id="jinrishici-sentence" href="https://www.jinrishici.com/" target="_blank" rel="noopener">加载中</a></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><script>jinrishici.load((function(e){document.querySelector("#subtitle").innerText=e.data.content,document.querySelector("#jinrishici-sentence").innerText=e.data.content}))</script><p><span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span> <span><a href="https://github.com/qinyuanpei" target="_blank" rel="license noopener" title="Github"><i class="icon icon-lg icon-github"></i> </a></span><span><a href="https://weibo.com/1278609231/profile" target="_blank" rel="license noopener" title="微博"><i class="icon icon-lg icon-weibo"></i> </a></span><span><a href="https://www.douban.com/people/60029335/" target="_blank" rel="license noopener" title="豆瓣"><i class="icon icon-lg icon-douban"></i> </a></span><span><a href="https://www.zhihu.com/people/qinyuanpei" target="_blank" rel="license noopener" title="知乎"><i class="icon icon-lg icon-zhihu-square"></i> </a></span><span><a href="https://blog.csdn.net/qinyuanpei" target="_blank" rel="license noopener" title="CSDN"><i class="icon icon-lg">C</i> </a></span><span><a href="https://music.163.com/#/user/home?id=47002864" target="_blank" rel="license noopener" title="网易音乐"><i class="icon icon-lg icon-wangyiyunyinyue"></i></a></span></p></div><div class="bottom"><p><span>飞鸿踏雪 &copy; 2014 - 2021</span><br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & Theme by <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a><br></p><p>Hosted by <a href="https://pages.github.com" target="_blank" rel="noopener" style="font-weight:700">Github Pages</a></p><p></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/3247093203/&title=《使用多线程为你的Python爬虫提速的N种姿势，你会几种？》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/3247093203/&title=《使用多线程为你的Python爬虫提速的N种姿势，你会几种？》 — 一个人的孤落时辰&source=一个人的孤落时辰 | 纵有疾风起，人生不言弃 | 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地 | 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/3247093203/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《使用多线程为你的Python爬虫提速的N种姿势，你会几种？》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/3247093203/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/3247093203/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/3247093203/" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.6/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/echarts-wordcloud.min.js" async></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis">{tags}</div><time class="flex-col time">{date}</time></div></a></li></template><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/search.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/heart.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/leancloud-counter.min.js"></script><script>(new VisitorCounter).init({appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",region:"华北",domain:"",collectIP:!0,collectUA:!0})</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/vconsole.min.js"></script><script type="text/javascript">if(location.href.indexOf("debug=true")>-1)var vConsole=new VConsole</script><script></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/ribbon.min.js"></script><script>var blocks=document.getElementsByTagName("blockquote");blocks.length>0&&"post-copyright"!=blocks[0].id&&(blocks[0].hidden=!0)</script></body></html>