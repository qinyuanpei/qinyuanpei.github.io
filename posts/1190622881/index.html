<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="pragma" content="no-cache"><meta http-equiv="cache-control" content="no-cache"><meta name="msvalidate.01" content="713A48A3FE17D4841C292A6B3942EB4C"><title>Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮 | 一个人的孤落时辰</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="Unity3D,游戏开发,uGUI,秦元培,技术博客,生活随笔,个人博客,NET,Python,数据挖掘,数据分析,NLP"><meta name="description" content="本文通过对网络上两种比较通用的不规则按钮制作方案进行对比和研究，解决了基于多边形碰撞器实现不规则按钮这个过程中存在的问题，剖析了基于精灵像素检测实现不规则按钮 这个过程的内部原理，从易用性角度来讲，后者要优于前者，而这种方法的缺陷主要来自于它对图片类型的限制以及允许像素可读写这两个方面，它必须是Advance类型，所以普通的Texture或者Sprite拥有的特性在这里它都无法享受，比如我们无法为其做颜色渐变这类Tween动画、无法使用精灵特有的图集特性等等，于此同时它必须允许像素可读写，因此在实际使用中它会在内存中复制一份，在执行效率上可能会受到影响;我们必须意识到的一点是，这个方法的空间复杂度为O(n-1)，所以随着多边形顶点��目的增加，这个方法的执行效率会越来越低，如果对不规则精灵的边界没有十分苛刻的要求的话，我的建议是我们使用多边形碰撞器标记出一个相对模糊的边界即可，因为现在我们这个方法主要依靠数学计算，没有涉及到摄像机相关计算，所以宣雨松[博客](http://www.xuanyusong.com/archives/3492)中有朋友指出他的方法仅仅适用于Canvas的模式为Screen-Space Camera这种情况，而我目前这个方法对除了World Space以外都是可以使用的，我最大的疑虑来自对鼠标位置进行转化的时候是否应该使用Screen.width和Screen.height，因为我担心可能会出现屏幕适配这种需求;mod=viewthread&amp;tid=41050&amp;highlight=uGUI%2B%E4%B8%8D%E8%A7%84%E5%88%99&amp;mobile=2)指出可以使用多边形碰撞器的OverlapPoint方法来判断一个点是否在多边形内部，可是经过我测试，这种方式和宣雨松提供的方法有着类似地问题，无论是否对坐标系进行转换，这个方法都返回false，响应区域与上图完全一致;* 2、RolygonCollider2D中的points属性即多边形顶点数组存储的是相对于UI元素的相对坐标，在进行计算的时候应该统一转化为绝对坐标，这个过程在宣雨松的代码中有所涉及，但我认为对UI元素来讲，应该使用transform.GetComponent&lt;RectTransform&gt;().position而非transform.position，因为transform.position最初是给3D物体使用的，而实际上这里是存在误差的;这段代码说实话我理解的不是很透彻，而且令人费解的是实际结论和算法结论完全相反，因为按照我现在这样的设计，当cn为偶数时返回为true，此时应该表示该点再多边形外部啊，可是事实上我测试这段代码的时候，它居然是可以正常工作的，即当该方法返回true的时候我的点击确实是在多边形内部，所以这是一段可以正常工作同时让我感到费解的代码，而且当我屏蔽了cn为0的这种情况以后，现在它已经可以完美的工作了"><meta name="description" content="本文通过对网络上两种比较通用的不规则按钮制作方案进行对比和研究，解决了基于多边形碰撞器实现不规则按钮这个过程中存在的问题，剖析了基于精灵像素检测实现不规则按钮 这个过程的内部原理，从易用性角度来讲，后者要优于前者，而这种方法的缺陷主要来自于它对图片类型的限制以及允许像素可读写这两个方面，它必须是Advance类型，所以普通的Texture或者Sprite拥有的特性在这里它都无法享受，比如我们无法为"><meta property="og:type" content="article"><meta property="og:title" content="Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮"><meta property="og:url" content="https://qinyuanpei.github.io/posts/1190622881/index.html"><meta property="og:site_name" content="一个人的孤落时辰"><meta property="og:description" content="本文通过对网络上两种比较通用的不规则按钮制作方案进行对比和研究，解决了基于多边形碰撞器实现不规则按钮这个过程中存在的问题，剖析了基于精灵像素检测实现不规则按钮 这个过程的内部原理，从易用性角度来讲，后者要优于前者，而这种方法的缺陷主要来自于它对图片类型的限制以及允许像素可读写这两个方面，它必须是Advance类型，所以普通的Texture或者Sprite拥有的特性在这里它都无法享受，比如我们无法为"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fzixy1fofqj20go0ci0uv.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fzixb7h3alj20go0aaq75.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fzix81in93j20go0ciwik.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fzix19xqm8j206n06ndfv.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/None.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/None.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/None.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fz68k3znzij20p1061dfv.jpg"><meta property="article:published_time" content="2016-07-08T21:58:39.000Z"><meta property="article:modified_time" content="2021-10-11T03:19:55.221Z"><meta property="article:author" content="飞鸿踏雪"><meta property="article:tag" content="Unity3D"><meta property="article:tag" content="游戏开发"><meta property="article:tag" content="uGUI"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fzixy1fofqj20go0ci0uv.jpg"><link rel="alternate" type="application/atom+xml" title="一个人的孤落时辰" href="/atom.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest//assets/styles/style.css"><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/instantclick.min.js"></script><script>window.lazyScripts=[]</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/brand.jpg)"><div class="brand"><a href="/" class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="avatar"></a><hgroup class="introduce"><h5 class="nickname">飞鸿踏雪</h5><a href="mailto:qinyuanpei@163.com" title="qinyuanpei@163.com" class="mail">qinyuanpei@163.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> 标签</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/books"><i class="icon icon-lg icon-bookmark"></i> 书单</a></li><li class="waves-block waves-effect"><a href="/movies"><i class="icon icon-lg icon-film"></i> 影单</a></li><li class="waves-block waves-effect"><a href="/works"><i class="icon icon-lg icon-code"></i> 实验室</a></li><li class="waves-block waves-effect"><a href="/about"><i class="icon icon-lg icon-circle"></i> 关于我</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i> </a><a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="menuGithub"><i class="icon icon-lg icon-code-fork"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮</h1><h5 class="subtitle" id="subtitle"><time datetime="2016-07-08T21:58:39.000Z" itemprop="datePublished" class="page-time">2016-07-08</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Unity3D/">Unity3D</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>目录</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#从用户体验说起"><span class="post-toc-number">1.</span> <span class="post-toc-text">从用户体验说起</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#两种不同的方案"><span class="post-toc-number">2.</span> <span class="post-toc-text">两种不同的方案</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#多边形碰撞器"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">多边形碰撞器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#精灵像素检测"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">精灵像素检测</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#小结"><span class="post-toc-number">3.</span> <span class="post-toc-text">小结</span></a></li></ol></nav></aside><article id="post-Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮</h1><div class="post-meta"><time class="post-time" title="2016-07-08 21:58:39" datetime="2016-07-08T21:58:39.000Z" itemprop="datePublished">2016-07-08</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Unity3D/">Unity3D</a></li></ul><span id="lc_counter_container_page_pv" title="文章总阅读量" data-page-url="" data-page-title="Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮"><i class="icon icon-eye icon-pr"></i><span id="lc_counter_value_page_pv"></span></span> <span><i class="icon icon-clock-o"></i> 38 min.</span></div><div class="post-content" id="post-content" itemprop="postContent"><p>&emsp;&emsp;各位朋友大家好，欢迎关注我的博客，我的博客地址是<a href="http://www.qinyuanpei.com" target="_blank" rel="noopener">http://www.qinyuanpei.com</a>。最近因为受到工作上业务因素影响，所以博主在Unity引擎上的研究有所停滞。虽然目前的工作内容和Unity3D没有直接的关联，可是我觉得工程师应该有这样一种情怀，即工作和兴趣是完全不同的两个概念。编程对我而言，首先是一种兴趣，其次是一份工作。所以我宁愿在每天下班以后继续研究自己感兴趣的东西，而非为了取悦这个世界、为了加班而加班。最近广电总局让整个游戏行业都坐立不安了，因为其新发布的一系列规定，让中国的独立游戏开发者怨声载道。可是我们更应该看到积极的一面是，无数的小游戏公司会在最近数月内大量消失，或许对中国野蛮生长的游戏行业这是一次“形式”上的整顿，可对我们开发者来说，在这个过程中努力提升自我、巩固基础永远比追求时髦、流行的技术或者框架有意义的多，因为热闹的从来都是昙花一现般的璀璨，而永恒的永远都是历久弥新的真理。好了，闲言少叙，今天我们的话题是在uGUI中使用不规则精灵制作按钮。</p><a id="more"></a><h1 id="从用户体验说起"><a href="#从用户体验说起" class="headerlink" title="从用户体验说起"></a>从用户体验说起</h1><p>&emsp;&emsp;我们都知道在现代应用程序设计中，用户体验(UX)和用户界面(UI)是两个非常重要的内容。为什么用户体验(UX)和用户界面(UI)会显得如此重要呢？这是因为从普通用户的角度来讲，用户界面(UI)是其接触到一个产品时最先看到的最直观的东西，而在这个过程中产生的直观感受就是用户体验(UX)，所以说到底这是一个产品给用户的“第一印象”。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/4c36074fly1fzixy1fofqj20go0ci0uv.jpg" alt="UX和UI" referrerpolicy="no-referrer"></div><div class="image-caption">UX和UI</div></figure><p>&emsp;&emsp;最近百度UE总监刘超在IXDC峰会上的演讲引起了大家的关注，抛开百度在人才选拔机制中存在的问题以及刘超本人在设计领域是否具备专业能力这两个问题，这件事情真正让大家吐槽的是什么呢？答案是用户体验。虽然IXDC并非国际级别的大型会议，但是我相信大家组织这样的活动，其本意是为了探讨交互、设计领域内的新方法和新思维，因为随着互联网行业的发展，交互和设计这个领域越来越被人们所关注，所以在这样一个场合下，当与会嘉宾都在试图向人们输出干货的时候，刘超以一个非常糟糕的“用户体验”来给大家讲什么是用户体验，这件事情起源自刘超的一个个人行为，结果牵一发而动全身，最终升级为百度继“魏则西事件”以后的又一次公关危机。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/4c36074fly1fzixb7h3alj20go0aaq75.jpg" alt="什么叫设计" referrerpolicy="no-referrer"></div><div class="image-caption">什么叫设计</div></figure><p>&emsp;&emsp;我到底想说什么呢？我说的本质上就是用户体验的问题，在这个事件中，刘超穿着上的不得体(短裤搭配拖鞋?)、PPT制作的粗制滥造(校招时所用修改)、演讲过程的敷衍糊弄(说相声、猜谜语)等因素，让刘超在与会者心目中的地位瞬间滑落到冰点，进而引发人们对百度在交互设计领域内的能力的怀疑，联想到百度最近这些年内出现的问题，这件事情难免会被人作为指责百度这家企业价值观问题，我想这是这个事情为什么会让大家如此关注的一个原因吧。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/4c36074fly1fzix81in93j20go0ciwik.jpg" alt="WTF!" referrerpolicy="no-referrer"></div><div class="image-caption">WTF!</div></figure><p>&emsp;&emsp;那么，我们说这些到底和今天的主题有什么关系呢？我想说这当然有关系啊，因为我们提出的这个问题就是一个用户体验的问题。我们知道游戏行业对美术资源高度依赖，不管是2D游戏还是3D游戏，一个项目组中前期主要的工作量其实都在美术这边，虽然不同的游戏引擎、GUI框架都为我们提供了标准的控件样式，然而在这样一个注重多样性的时代，默认样式、系统字体都会让人觉得这个产品缺乏新意，因此这种要求体现在游戏项目中就变成了，我们使用大量的图片资源来解决界面和字体的问题。</p><p>&emsp;&emsp;例如，我们通常使用BMFont来制作位图字体，这是为了同时满足字体的多样性和资源的容量这两个要求。再比如我们在使用cocos2d-x和Unity3D引擎开发游戏的时候，我们将大量的时间花费在了UI的制作上，这一切的一切从本质上来讲都是为了提升产品的童虎体验。这样我们就会遇到一个问题，UI中的按钮默认情况下都是规则的矩形，而实际上美术提供的素材常常是不规则的，因此如果继续使用以矩形为标准的这套机制，在实际使用中可能出现“用户点击在不该响应的区域结果程序响应了用户操作”这样的问题，为了解决这个问题，提升这一点点细微的用户体验，我们需要花费时间和精力来了解下面这些内容。</p><h1 id="两种不同的方案"><a href="#两种不同的方案" class="headerlink" title="两种不同的方案"></a>两种不同的方案</h1><p>&emsp;&emsp;目前，关于这个问题如何，解决通过搜索引擎我们能找到两种不同的方案：</p><ul><li>多边形碰撞器: 该方法是指给精灵(Sprite)添加一个多边形碰撞器(Rolygon Collider)组件，利用该组件来标记精灵的边界，这样通过比较鼠标位置和边界可以判断点击是否发生在精灵内部。这种方法的详细说明可以参考宣雨松的这篇文章：<a href="http://www.xuanyusong.com/archives/3492" target="_blank" rel="noopener">UGUI研究院之不规则按钮的响应区域（十四）</a></li><li>精灵像素检测: 该方法是指通过读取精灵(Sprite)在某一点的像素值(RGBA)，如果该点的像素值中的Alpha&lt;0.5则表示该点处是透明的，即用户点击的位置在精灵边界以外，否则用户点击的位置在精灵边界内部。这种方法的详细说明可以参考<a href="http://m.manew.com/forum.php?mod=viewthread&tid=45046&highlight=uGUI%2B%E4%B8%8D%E8%A7%84%E5%88%99&mobile=2" target="_blank" rel="noopener">这里</a></li></ul><h2 id="多边形碰撞器"><a href="#多边形碰撞器" class="headerlink" title="多边形碰撞器"></a>多边形碰撞器</h2><p>&emsp;&emsp;多边形碰撞器这种方案从本质上来讲，其核心思路是验证某一点是否在任意多边形内部，因为在这里RolygonCollider2D组件的作用体现在：第一，它可以在编辑器下进行可视化编辑对用户友好；第二，它可以在帮助我们标记精灵边界的同时保留顶点信息。所以在这里RolygonCollider2D组件相当于为我们提供任意多边形的顶点信息，而接下来我们要做是将鼠标位置转化为屏幕坐标，这样我们就获得了某一点的坐标。整体思路看起来是没有问题的，但我个人以及网友<a href="http://m.manew.com/forum.php?mod=viewthread&tid=41050&highlight=uGUI%2B%E4%B8%8D%E8%A7%84%E5%88%99&mobile=2" target="_blank" rel="noopener">AwayMe</a>都认为宣雨松这个算法存在问题，具体的理由如下：</p><ul><li><p>1、uGUI中的元素采用的是以屏幕中心为原点(0,0)的平面直角坐标系，而普通屏幕坐标采用的是以左下角为原点(0,0)的平面直角坐标系，所以多边形顶点数组和鼠标位置不在一个坐标系内，使用AABBB这样的碰撞检测算法存在问题。</p></li><li><p>2、RolygonCollider2D中的points属性即多边形顶点数组存储的是相对于UI元素的相对坐标，在进行计算的时候应该统一转化为绝对坐标，这个过程在宣雨松的代码中有所涉及，但我认为对UI元素来讲，应该使用transform.GetComponent<recttransform>().position而非transform.position，因为transform.position最初是给3D物体使用的，而实际上这里是存在误差的。</recttransform></p></li><li><p>3、我怀疑宣雨松提供的这个ContainsPoint方法的正确性，因为按照我的理解修改这个方法以后，发现界面响应的情况和实际情况是有所出入的，如下图所示，在整个区域内该方法都返回false。为了排除因为我的方法而对结果产生的影响，我使用宣雨松的代码进行了测试，结论是这个方法不管进行坐标系的转换与否，它在整个区域内的返回值都是false，因此我认为这个方法是错误的，虽然从理解算法的角度来看，它应该是根据线性差值来判断点在多边形中每条边的哪一侧的。</p></li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/4c36074fly1fzix19xqm8j206n06ndfv.jpg" alt="响应区域说明" referrerpolicy="no-referrer"></div><div class="image-caption">响应区域说明</div></figure><p>&emsp;&emsp;在评论中网友<a href="http://m.manew.com/forum.php?mod=viewthread&tid=41050&highlight=uGUI%2B%E4%B8%8D%E8%A7%84%E5%88%99&mobile=2" target="_blank" rel="noopener">AwayMe</a>指出可以使用多边形碰撞器的OverlapPoint方法来判断一个点是否在多边形内部，可是经过我测试，这种方式和宣雨松提供的方法有着类似地问题，无论是否对坐标系进行转换，这个方法都返回false，响应区域与上图完全一致。</p><p>&emsp;&emsp;所以不管网络上有没有高质量的内容，一个核心的问题是你能否从中找到答案。如果你可以直接找到解决方案这可能是最好的结局；如果找不到直接的解决方案，却能够有所启发并独立解决问题，这是我们希望看到的结果。可是有时候人们并不这样想啊，人们想得到的是可以运行的代码而非解决问题的思路，因为可能人们并不想解决这个问题。</p><p>&emsp;&emsp;好了，经过知乎上相关<a href="http://www.zhihu.com/question/26551754?f3fb8ead20=b6b9d1289bcc893ff2fa0abd1e65fc52" target="_blank" rel="noopener">答案</a>我找到了这篇<a href="http://geomalgorithms.com/a03-_inclusion.html" target="_blank" rel="noopener">文章</a>，文章中提到了判断一个点是否在任意多边形内部的两种方法，分别为Corssing Number和Winding Number。这两种方法在理论层面的相关细节请大家自行阅读这篇<a href="http://geomalgorithms.com/a03-_inclusion.html" target="_blank" rel="noopener">文章</a>，我们这里选择的是前者，其基本思想是计算从该点引出的射线与多边形边界橡胶的次数，当其为奇数时表示该点在多边形内部，当其为偶数时表示在多边形外部。这里有一个有意思的事情是宣雨松选择的方法应该是著名的<a href="https://www.baidu.com/s?ie=UTF-8&wd=Ray-Crossing" target="_blank" rel="noopener">Ray-Crossing</a>算法，可是为什么在这里会出现这样的问题呢？</p><p>&emsp;&emsp;孰是孰非，一切都交给实践来证明吧！下面是我根据<a href="http://geomalgorithms.com/a03-_inclusion.html" target="_blank" rel="noopener">文章</a>中提供的算法改写的一段C#代码：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bool ContainsPoint2(Vector2[] polyPoints,Vector2 p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//统计射线和多边形交叉次数</span></span><br><span class="line">	int cn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历多边形顶点数组中的每条边</span></span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;polyPoints.Length<span class="number">-1</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//正常情况下这一步骤可以忽略这里是为了统一坐标系</span></span><br><span class="line">		polyPoints [i].<span class="symbol">x</span> += transform.GetComponent&lt;RectTransform&gt; ().position.<span class="symbol">x</span>;</span><br><span class="line">		polyPoints [i].<span class="symbol">y</span> += transform.GetComponent&lt;RectTransform&gt; ().position.<span class="symbol">y</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从当前位置发射向上向下两条射线</span></span><br><span class="line">		<span class="keyword">if</span>(((polyPoints [i].<span class="symbol">y</span> &lt;= p.<span class="symbol">y</span>) &amp;&amp; (polyPoints [i + <span class="number">1</span>].<span class="symbol">y</span> &gt; p.<span class="symbol">y</span>)) </span><br><span class="line">			|| ((polyPoints [i].<span class="symbol">y</span> &gt; p.<span class="symbol">y</span>) &amp;&amp; (polyPoints [i + <span class="number">1</span>].<span class="symbol">y</span> &lt;= p.<span class="symbol">y</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//compute the actual edge-ray intersect x-coordinate</span></span><br><span class="line">			float vt = (float)(p.<span class="symbol">y</span> - polyPoints [i].<span class="symbol">y</span>) / (polyPoints [i + <span class="number">1</span>].<span class="symbol">y</span> - polyPoints [i].<span class="symbol">y</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//p.x &lt; intersect</span></span><br><span class="line">			<span class="keyword">if</span>(p.<span class="symbol">x</span> &lt; polyPoints [i].<span class="symbol">x</span> + vt * (polyPoints [i + <span class="number">1</span>].<span class="symbol">x</span> - polyPoints [i].<span class="symbol">x</span>))</span><br><span class="line">				++cn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实际测试发现cn为0的情况即为宣雨松算法中存在的问题</span></span><br><span class="line">	<span class="comment">//所以在这里进行屏蔽直接返回false这样就可以让透明区域不再响应</span></span><br><span class="line">	<span class="keyword">if</span>(cn == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回true表示在多边形外部否则表示在多边形内部</span></span><br><span class="line">	<span class="keyword">return</span> cn % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码说实话我理解的不是很透彻，而且令人费解的是实际结论和算法结论完全相反，因为按照我现在这样的设计，当cn为偶数时返回为true，此时应该表示该点再多边形外部啊，可是事实上我测试这段代码的时候，它居然是可以正常工作的，即当该方法返回true的时候我的点击确实是在多边形内部，所以这是一段可以正常工作同时让我感到费解的代码，而且当我屏蔽了cn为0的这种情况以后，现在它已经可以完美的工作了</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/None.jpg" alt="正五边形精灵" referrerpolicy="no-referrer"></div><div class="image-caption">正五边形精灵</div></figure><p>同样的，我们这里使用一张正五边形的精灵图片，然后编写下面的代码：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基于多边形碰撞器实现的不规则按钮 </span></span><br><span class="line"><span class="comment"> * 作者：PayneQin</span></span><br><span class="line"><span class="comment"> * 日期：2016年7月9日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line">public class UnregularButtonWithCollider : MonoBehaviour,IPointerClickHandler</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">	<span class="comment">/// 多边形碰撞器</span></span><br><span class="line">	<span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">	PolygonCollider2D polygonCollider;</span><br><span class="line"></span><br><span class="line">	void Start()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取多边形碰撞器</span></span><br><span class="line">		polygonCollider = transform.GetComponent&lt;PolygonCollider2D&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public void OnPointerClick(PointerEventData eventData)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//对2D屏幕坐标系进行转换</span></span><br><span class="line">		Vector2 <span class="literal">local</span>;</span><br><span class="line">		<span class="literal">local</span>.<span class="symbol">x</span> = eventData.position.<span class="symbol">x</span> - (float)Screen.width / <span class="number">2.0</span>f;</span><br><span class="line">		<span class="literal">local</span>.<span class="symbol">y</span> = eventData.position.<span class="symbol">y</span> - (float)Screen.height / <span class="number">2.0</span>f;</span><br><span class="line">		<span class="keyword">if</span>(ContainsPoint(polygonCollider.points,<span class="literal">local</span>))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			Debug.Log (<span class="string">"这是一个正五边形!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">	<span class="comment">/// 判断指定点是否在给定的任意多边形内</span></span><br><span class="line">	<span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">	bool ContainsPoint(Vector2[] polyPoints,Vector2 p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//统计射线和多边形交叉次数</span></span><br><span class="line">		int cn = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历多边形顶点数组中的每条边</span></span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;polyPoints.Length<span class="number">-1</span>; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//正常情况下这一步骤可以忽略这里是为了统一坐标系</span></span><br><span class="line">			polyPoints [i].<span class="symbol">x</span> += transform.GetComponent&lt;RectTransform&gt; ().position.<span class="symbol">x</span>;</span><br><span class="line">			polyPoints [i].<span class="symbol">y</span> += transform.GetComponent&lt;RectTransform&gt; ().position.<span class="symbol">y</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//从当前位置发射向上向下两条射线</span></span><br><span class="line">			<span class="keyword">if</span>(((polyPoints [i].<span class="symbol">y</span> &lt;= p.<span class="symbol">y</span>) &amp;&amp; (polyPoints [i + <span class="number">1</span>].<span class="symbol">y</span> &gt; p.<span class="symbol">y</span>)) </span><br><span class="line">			   || ((polyPoints [i].<span class="symbol">y</span> &gt; p.<span class="symbol">y</span>) &amp;&amp; (polyPoints [i + <span class="number">1</span>].<span class="symbol">y</span> &lt;= p.<span class="symbol">y</span>)))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//compute the actual edge-ray intersect x-coordinate</span></span><br><span class="line">				float vt = (float)(p.<span class="symbol">y</span> - polyPoints [i].<span class="symbol">y</span>) / (polyPoints [i + <span class="number">1</span>].<span class="symbol">y</span> - polyPoints [i].<span class="symbol">y</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//p.x &lt; intersect</span></span><br><span class="line">				<span class="keyword">if</span>(p.<span class="symbol">x</span> &lt; polyPoints [i].<span class="symbol">x</span> + vt * (polyPoints [i + <span class="number">1</span>].<span class="symbol">x</span> - polyPoints [i].<span class="symbol">x</span>))</span><br><span class="line">					++cn;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//实际测试发现cn为0的情况即为宣雨松算法中存在的问题</span></span><br><span class="line">		<span class="comment">//所以在这里进行屏蔽直接返回false这样就可以让透明区域不再响应</span></span><br><span class="line">		<span class="keyword">if</span>(cn == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回true表示在多边形外部否则表示在多边形内部</span></span><br><span class="line">		<span class="keyword">return</span> cn % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现现在它可以正常工作啦！我们必须意识到的一点是，这个方法的空间复杂度为O(n-1)，所以随着多边形顶点数目的增加，这个方法的执行效率会越来越低，如果对不规则精灵的边界没有十分苛刻的要求的话，我的建议是我们使用多边形碰撞器标记出一个相对模糊的边界即可，因为现在我们这个方法主要依靠数学计算，没有涉及到摄像机相关计算，所以宣雨松<a href="http://www.xuanyusong.com/archives/3492" target="_blank" rel="noopener">博客</a>中有朋友指出他的方法仅仅适用于Canvas的模式为Screen-Space Camera这种情况，而我目前这个方法对除了World Space以外都是可以使用的，我最大的疑虑来自对鼠标位置进行转化的时候是否应该使用Screen.width和Screen.height，因为我担心可能会出现屏幕适配这种需求。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/None.jpg" alt="演示效果1" referrerpolicy="no-referrer"></div><div class="image-caption">演示效果1</div></figure><h2 id="精灵像素检测"><a href="#精灵像素检测" class="headerlink" title="精灵像素检测"></a>精灵像素检测</h2><p>&emsp;&emsp;精灵像素检测这个方案的灵感来自Image组件，我们在MonoDevelop或者Visual Studio中通过”转到定义”这个功能可以获得Image组件的内部细节。我们发现uGUI在处理控件是否被点击的时候，主要是根据IsRaycastLocationValid这个方法的返回值来进行判断的，而这个方法用到的基本原理则是判断指定点对应像素的RGBA数值中的Alpha是否大于某个指定临界值。例如，我们知道半透明通常是指Alpha=0.5，而对一个.png格式的图片来说半透明甚至完全透明的区域理论上不应该被响应的，所以根据这个原理我们只需要设定一个透明度的临界值然后对当前鼠标位置对应的像素进行判断就可以了，因此这种方法叫做精灵像素检测。</p><p>&emsp;&emsp;下面我们来一起看这段uGUI的代码，这段代码通过MonoDevelop或者Visual Studio的”转到定义”功能可以找到，这里我做了简单的注释帮助大家理解代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 screenPoint, Camera eventCamera</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当透明度&gt;=1.0时，表示点击在可响应区域返回true</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.m_EventAlphaThreshold &gt;= <span class="number">1f</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当没有指定精灵时为什么要返回true?</span></span><br><span class="line">	Sprite overrideSprite = <span class="keyword">this</span>.overrideSprite;</span><br><span class="line">	<span class="keyword">if</span>(overrideSprite == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//坐标系转换	</span></span><br><span class="line">	Vector2 local;</span><br><span class="line">	RectTransformUtility.ScreenPointToLocalPointInRectangle(<span class="keyword">base</span>.rectTransform, screenPoint, eventCamera, <span class="keyword">ref</span> local);</span><br><span class="line">	Rect pixelAdjustedRect = <span class="keyword">base</span>.GetPixelAdjustedRect ();</span><br><span class="line">	local.x += <span class="keyword">base</span>.rectTransform.get_pivot ().x * pixelAdjustedRect.get_width ();</span><br><span class="line">	local.y += <span class="keyword">base</span>.rectTransform.get_pivot ().y * pixelAdjustedRect.get_height ();</span><br><span class="line">	local = <span class="keyword">this</span>.MapCoordinate(local, pixelAdjustedRect);</span><br><span class="line">	Rect textureRect = overrideSprite.get_textureRect ();</span><br><span class="line">	Vector2 vector = <span class="keyword">new</span> Vector2(local.x / textureRect.get_width (), local.y / textureRect.get_height ());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算屏幕坐标对应的UV坐标</span></span><br><span class="line">	<span class="keyword">float</span> num = Mathf.Lerp(textureRect.get_x (), textureRect.get_xMax (), vector.x) / (<span class="keyword">float</span>)overrideSprite.get_texture().get_width();</span><br><span class="line">	<span class="keyword">float</span> num2 = Mathf.Lerp(textureRect.get_y (), textureRect.get_yMax (), vector.y) / (<span class="keyword">float</span>)overrideSprite.get_texture().get_height();</span><br><span class="line">	<span class="keyword">bool</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//核心方法：像素检测</span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		result = (overrideSprite.get_texture().GetPixelBilinear(num, num2).a &gt;= <span class="keyword">this</span>.m_EventAlphaThreshold);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(UnityException ex)&#123;</span><br><span class="line">		Debug.LogError(<span class="string">"Using clickAlphaThreshold lower than 1 on Image whose sprite texture cannot be read. "</span> + ex.Message + <span class="string">" Also make sure to disable sprite packing for this sprite."</span>, <span class="keyword">this</span>);</span><br><span class="line">		result = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//返回结果	</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中我们可以看出，这个方法核心在第31行代码，即传入一个UV坐标返回一个RGBA数值并将其和临界值相比较。可是在此之前，我们看到在引入uGUI及其专属组件RectTransform以后，现在Unity中的坐标系转换变得更加复杂了，我个人看到这部分代码是相当凌乱的，或许我应该找时间补习下矩阵变换了吧。所以现在我们就有思路啦，我们有两种方式，第一种基于这个思路重新定制一个Image组件;第二种直接修改Image组件的eventAlphaThreshold属性。考虑到坐标系转换这里非常复杂，显然第二种方式更容易接受，为什么这里可以直接修改eventAlphaThreshold属性呢，因为它在Image组件内部和代码中的m_EventAlphaThreshold相关联，这就是这篇<a href="http://m.manew.com/forum.php?mod=viewthread&tid=45046&highlight=uGUI%2B%E4%B8%8D%E8%A7%84%E5%88%99&mobile=2" target="_blank" rel="noopener">文章</a>的完整解释啦！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/None.jpg" alt="圆形精灵图片" referrerpolicy="no-referrer"></div><div class="image-caption">圆形精灵图片</div></figure><p>&emsp;&emsp;好了，现在我们来一个简单的测试，我们这里准备一张圆形的精灵图片(如上图)，然后编写下面的代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基于精灵像素检测实现的不规则按钮 </span></span><br><span class="line"><span class="comment"> * 作者：PayneQin</span></span><br><span class="line"><span class="comment"> * 日期：2016年7月9日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnregularButtonWithPixel</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPointerClickHandler</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> Image组件</span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">	<span class="keyword">private</span> Image image;</span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 透明度临界值</span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">	[<span class="meta">Range(0.0f,0.5f)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">float</span> Alpha;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="comment">//获取Image组件</span></span><br><span class="line">		image = transform.GetComponent&lt;Image&gt;();</span><br><span class="line">		<span class="comment">//设定透明度临界值</span></span><br><span class="line">		image.eventAlphaThreshold = Alpha;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		Debug.Log(<span class="string">"这是一个圆形!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我为了让大家在学(复)习(制)的时候更容易理解，我在Click事件的响应上，使用的是实现IPointerClickHandler接口这种方法，希望通过动态绑定这种方式添加事件响应的可以自己解决，我是不会为了满足你们的好(懒)奇(惰)而奉献出我的EventTriggerListener的代码的。好了，现在我们要做的就是为需要响应点击的不规则精灵附加该脚本，这样就可以解决不规则精灵响应的问题了。这种方法使用起来非常简单，需要注意的是：图片的类型必须是Advance且保证可读可写。因为我们在脚本中访问了像素，而简单伴随着的代价就是我们无法使用图集、该图片在内存中会复制一份，所以在项目性能上允许的情况下这种方法还是可以考虑使用的。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/4c36074fly1fz68k3znzij20p1061dfv.jpg" alt="演示效果2" referrerpolicy="no-referrer"></div><div class="image-caption">演示效果2</div></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&emsp;&emsp;本文通过对网络上两种比较通用的不规则按钮制作方案进行对比和研究，解决了基于多边形碰撞器实现不规则按钮这个过程中存在的问题，剖析了基于精灵像素检测实现不规则按钮 这个过程的内部原理，从易用性角度来讲，后者要优于前者，而这种方法的缺陷主要来自于它对图片类型的限制以及允许像素可读写这两个方面，它必须是Advance类型，所以普通的Texture或者Sprite拥有的特性在这里它都无法享受，比如我们无法为其做颜色渐变这类Tween动画、无法使用精灵特有的图集特性等等，于此同时它必须允许像素可读写，因此在实际使用中它会在内存中复制一份，在执行效率上可能会受到影响。而从技术性角度来讲，我个人更推推崇前者，因为在这个过程中我们学到了新的知识，明白了如何利用一个算法来解决实际的问题，而且它不会限制我们对精灵的使用，所有精灵拥有的特性在这里我们都可以使用，无非是在寻找算法、解决问题的过程中我们耗费了大量精力，可是这是值得的啊，不是吗？这就是我们做这件事情的意义所在。从昨天开始研究这两个问题到今天写完整篇文章，整个人是非常疲惫的，欢迎大家继续关注我的博客，今天的内容就是这样啦，谢谢大家！</p><div class="recommended_posts"><h1>推荐阅读</h1><ul><li><a href="https://qinyuanpei.github.io/posts/305484621/">C#中的扩展方法学习总结</a></li><li><a href="https://qinyuanpei.github.io/posts/3120185261/">EasyAR尝鲜系列教程之Hello EasyAR</a></li><li><a href="https://qinyuanpei.github.io/posts/1156673678/">EasyAR尝鲜系列教程之自定义Marker的实现</a></li><li><a href="https://qinyuanpei.github.io/posts/316230277/">EasyAR尝鲜系列教程之视频播放功能的实现</a></li><li><a href="https://qinyuanpei.github.io/posts/927393529/">Unity3D游戏场景优化系列之批处理</a></li></ul></div></div><blockquote class="post-copyright" id="post-copyright"><div class="content"><p><b>版权声明：</b> <a href="https://qinyuanpei.github.io/posts/1190622881/" rel="external">Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮</a> ，由&nbsp;<a href="/about" target="_blank" rel="external">飞鸿踏雪</a>&nbsp; 首次发表于&nbsp;<a href="/" target="_blank" rel="external">一个人的孤落时辰</a>&nbsp; ，本文地址为：<a href="https://qinyuanpei.github.io/posts/1190622881/" target="_blank" rel="external">https://qinyuanpei.github.io/posts/1190622881/</a> ，转载请注明 <b>作者</b> 和 <b>出处</b> 。</p></div><footer><a href="https://qinyuanpei.github.io"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="飞鸿踏雪"> 飞鸿踏雪</a></footer></blockquote><div class="page-reward"><a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uGUI/" rel="tag">uGUI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/1190622881/&title=《Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/1190622881/&title=《Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮》 — 一个人的孤落时辰&source=&emsp;&emsp;各位朋友大家好，欢迎关注我的博客，我的博客地址是http://www.qinyuanpei.com。最近因为受到工作上业务因素影响..." data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/1190622881/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/1190622881/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/1190622881/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/posts/1150143610/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">在Unity3D中使用uGUI实现3D旋转特效</h4></a></div><div class="waves-block waves-effect next"><a href="/posts/1700650235/" id="post-next" class="post-nav-link"><div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">使用C#开发HTTP服务器系列之实现Get和Post</h4></a></div></nav><div id="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">new Valine({el:"#comment",notify:!1,verify:!0,appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",placeholder:"云中谁寄锦书来，雁字回时，月满西楼。&#10;Tips：如果希望收到我的评论回复，请至少留下你的邮箱哦:)",path:"https://qinyuanpei.github.io/posts/1190622881/",avatar:"identicon",requiredFields:["nick","mail"]})</script></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 赠人玫瑰，手有余香 <i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" alt="打赏二维码"></div><label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" data-alipay="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/alipay.jpg"><div class="reward-toggle-ctrol"><span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-label"></span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div><script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/yoniu.min.js"></script><style type="text/css">body.active-yp{overflow:hidden}.yp-fc-btn{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:space-between;font-size:13px}.yp-fc-btn span{cursor:pointer;padding:2px 10px;color:#4b4b4b;border:#4b4b4b 1px solid;border-radius:5px}#yp-hide{position:fixed;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:center;flex-direction:column;left:0;top:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);z-index:99999;visibility:hidden}#yoniu-poster{box-sizing:border-box;width:350px;height:467.2px;background-color:#fff;margin:0 auto;padding:0;line-height:1.6;text-align:justify}.yp-img{min-height:240px;position:relative;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:flex-end;flex-direction:column;background-position:50% 50%;background-size:cover;overflow:hidden}.yp-img>div{padding:10px 20px}.yp-name{display:block;color:#fff;font-size:20px;font-weight:600;text-shadow:#4b4b4b .1em .1em .2em;margin-top:10px}.yp-sort{padding:3px 10px;font-size:12px;color:#fff;background:#2e2e2e}.yp-des{color:#2e2e2e;font-size:14px;margin:20px;height:67.2px}.yp-qcode{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;margin:10px;padding:10px 20px;background:#f5f5f5;color:#818181;border-radius:10px}.yp-tips{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;color:#ccc;margin:0 10px 10px;font-size:10px;letter-spacing:1.5px}.yp-btns{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:stretch;justify-content:center;width:350px;margin:0 auto}.yp-btns>span{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:center;font-size:14px;padding:10px 15px;background:rgba(0,0,0,.2);color:#f5f5f5;cursor:pointer}.yp-btns>span>a{color:#f5f5f5}.yp-btns>span>a:hover{text-decoration:none}#yp-close{font-size:18px;font-weight:600}</style><div id="yp-hide"><div id="yoniu-poster"><div class="yp-img" id="yp-img"><div><span class="yp-sort">Unity3D</span> <span class="yp-name">Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮</span></div></div><div class="yp-des">&emsp;&emsp;各位朋友大家好，欢迎关注我的博客，我的博客地址是http://www.qinyuanpei.com。最近因为受到工作上业...</div><div class="yp-qcode"><span>扫描二维码阅读原文</span> <img id="yp-qcode" width="64px" src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/1190622881/"></div><div class="yp-tips"><span>一个人的孤落时辰</span> <span><time class="post-time" title="2016-07-08 21:58:39" datetime="2016-07-08T21:58:39.000Z" itemprop="datePublished">2016-07-08</time></span></div></div><div class="yp-btns"><span id="yp-load-yp" onclick="load_yp()">生成海报</span> <span><a id="yp-download"></a></span> <span id="yp-close" onclick="close_yp()">×</span></div></div><script type="text/javascript">function show_yp(){window.scrollTo(0,0),document.body.setAttribute("class","active-yp");let e=document.getElementsByTagName("img")[1];null!=e&&void 0!==e?document.getElementById("yp-img").style.backgroundImage=`url(${e.src})`:document.getElementById("yp-img").style.backgroundColor="#d7dbf0",document.getElementById("yp-hide").style.visibility="visible"}function close_yp(){var e=document.body.getAttribute("class");e=e.replace("active-yp",""),document.body.setAttribute("class",e),document.getElementById("yp-hide").style.visibility="hidden"}function load_yp(){document.getElementById("yp-load-yp").textContent="海报生成中...",setTimeout((function(){h2c_()}),2e3)}</script></div><footer class="footer"><div class="top"><p><span id="lc_counter_container_site_uv"><i class="icon icon-user"></i><span id="lc_counter_value_site_uv"></span> </span><span id="lc_counter_container_site_pv"><i class="icon icon-eye"></i><span id="lc_counter_value_site_pv"></span></span></p><p><a id="jinrishici-sentence" href="https://www.jinrishici.com/" target="_blank" rel="noopener">加载中</a></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><script>jinrishici.load((function(e){document.querySelector("#subtitle").innerText=e.data.content,document.querySelector("#jinrishici-sentence").innerText=e.data.content}))</script><p><span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span> <span><a href="https://github.com/qinyuanpei" target="_blank" rel="license noopener" title="Github"><i class="icon icon-lg icon-github"></i> </a></span><span><a href="https://weibo.com/1278609231/profile" target="_blank" rel="license noopener" title="微博"><i class="icon icon-lg icon-weibo"></i> </a></span><span><a href="https://www.douban.com/people/60029335/" target="_blank" rel="license noopener" title="豆瓣"><i class="icon icon-lg icon-douban"></i> </a></span><span><a href="https://www.zhihu.com/people/qinyuanpei" target="_blank" rel="license noopener" title="知乎"><i class="icon icon-lg icon-zhihu-square"></i> </a></span><span><a href="https://blog.csdn.net/qinyuanpei" target="_blank" rel="license noopener" title="CSDN"><i class="icon icon-lg">C</i> </a></span><span><a href="https://music.163.com/#/user/home?id=47002864" target="_blank" rel="license noopener" title="网易音乐"><i class="icon icon-lg icon-wangyiyunyinyue"></i></a></span></p></div><div class="bottom"><p><span>飞鸿踏雪 &copy; 2014 - 2021</span><br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & Theme by <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a><br></p><p>Hosted by <a href="https://pages.github.com" target="_blank" rel="noopener" style="font-weight:700">Github Pages</a></p><p></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/1190622881/&title=《Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/1190622881/&title=《Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮》 — 一个人的孤落时辰&source=&emsp;&emsp;各位朋友大家好，欢迎关注我的博客，我的博客地址是http://www.qinyuanpei.com。最近因为受到工作上业务因素影响..." data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/1190622881/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/1190622881/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/1190622881/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/1190622881/" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.6/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/echarts-wordcloud.min.js" async></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis">{tags}</div><time class="flex-col time">{date}</time></div></a></li></template><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/search.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/heart.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/leancloud-counter.min.js"></script><script>(new VisitorCounter).init({appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",region:"华北",domain:"",collectIP:!0,collectUA:!0})</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/vconsole.min.js"></script><script type="text/javascript">if(location.href.indexOf("debug=true")>-1)var vConsole=new VConsole</script><script></script><script>var blocks=document.getElementsByTagName("blockquote");blocks.length>0&&"post-copyright"!=blocks[0].id&&(blocks[0].hidden=!0)</script></body></html>