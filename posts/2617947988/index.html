<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="pragma" content="no-cache"><meta http-equiv="cache-control" content="no-cache"><meta name="msvalidate.01" content="713A48A3FE17D4841C292A6B3942EB4C"><title>gRPC 借助 Any 类型实现接口的泛化调用 | 一个人的孤落时辰</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="gRPC,Protobuf,Any,秦元培,技术博客,生活随笔,个人博客,NET,Python,数据挖掘,数据分析,NLP"><meta name="description" content="google.protobuf.Any Data = 1;google.protobuf.Any Data = 1;默认的 `Any` 类型，只能对 `Protobuf` 生成的类型(即实现了 IMessage 接口)进行 `Pack` ，如果我们想做得更绝一点(最好还是不要)，那么，可以使用自定义的 `MyAny` 类型：;此时，我们可以借助 `Any` 类型来实现类似泛型、模板类的东西，它本质上还是 ` IMessage` 接口的实现类，唯一的不同是增加了 Pack/Unpack 这组静态方法，可以帮助我们实现 `Any` 和 `IMessage` 的相互转换，关于本文中使用的的实例，可以参考：[ProtobufAny](https://github.com/Regularly-Archive/2021/tree/master/src/ProtobufAny)，好了，以上就是这篇博客的全部内容，如果有朋友对文章中的内容和观点存在疑问，欢迎在评论区积极留言，谢谢大家;# Protobuf 里的 Any 类型"><meta name="description" content="google.protobuf.Any Data &#x3D; 1;google.protobuf.Any Data &#x3D; 1;默认的 &#96;Any&#96; 类型，只能对 &#96;Protobuf&#96; 生成的类型(即实现了 IMessage 接口)进行 &#96;Pack&#96; ，如果我们想做得更绝一点(最好还是不要)，那么，可以使用自定义的 &#96;MyAny&#96; 类型：;此时，我们可以借助 &#96;Any&#96; 类型来实现类似泛型、模板类的东西，它本质"><meta property="og:type" content="article"><meta property="og:title" content="gRPC 借助 Any 类型实现接口的泛化调用"><meta property="og:url" content="https://qinyuanpei.github.io/posts/2617947988/index.html"><meta property="og:site_name" content="一个人的孤落时辰"><meta property="og:description" content="google.protobuf.Any Data &#x3D; 1;google.protobuf.Any Data &#x3D; 1;默认的 &#96;Any&#96; 类型，只能对 &#96;Protobuf&#96; 生成的类型(即实现了 IMessage 接口)进行 &#96;Pack&#96; ，如果我们想做得更绝一点(最好还是不要)，那么，可以使用自定义的 &#96;MyAny&#96; 类型：;此时，我们可以借助 &#96;Any&#96; 类型来实现类似泛型、模板类的东西，它本质"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-12-10T11:53:29.000Z"><meta property="article:modified_time" content="2022-03-07T01:40:22.302Z"><meta property="article:author" content="飞鸿踏雪"><meta property="article:tag" content="gRPC"><meta property="article:tag" content="Protobuf"><meta property="article:tag" content="Any"><meta name="twitter:card" content="summary"><link rel="alternate" type="application/atom+xml" title="一个人的孤落时辰" href="/atom.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest//assets/styles/style.css"><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/instantclick.min.js"></script><script>window.lazyScripts=[]</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/brand.jpg)"><div class="brand"><a href="/" class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="avatar"></a><hgroup class="introduce"><h5 class="nickname">飞鸿踏雪</h5><a href="mailto:qinyuanpei@163.com" title="qinyuanpei@163.com" class="mail">qinyuanpei@163.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> 标签</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/books"><i class="icon icon-lg icon-bookmark"></i> 书单</a></li><li class="waves-block waves-effect"><a href="/movies"><i class="icon icon-lg icon-film"></i> 影单</a></li><li class="waves-block waves-effect"><a href="/columns"><i class="icon icon-lg icon-battery"></i> 专栏</a></li><li class="waves-block waves-effect"><a href="/works"><i class="icon icon-lg icon-code"></i> 实验室</a></li><li class="waves-block waves-effect"><a href="/about"><i class="icon icon-lg icon-circle"></i> 关于我</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">gRPC 借助 Any 类型实现接口的泛化调用</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i> </a><a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="menuGithub"><i class="icon icon-lg icon-code-fork"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">gRPC 借助 Any 类型实现接口的泛化调用</h1><h5 class="subtitle" id="subtitle"><time datetime="2021-12-10T11:53:29.000Z" itemprop="datePublished" class="page-time">2021-12-10</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>目录</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Protobuf-里的-Any-类型"><span class="post-toc-number">1.</span> <span class="post-toc-text">Protobuf 里的 Any 类型</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#在-NET-中使用-Any-类型"><span class="post-toc-number">2.</span> <span class="post-toc-text">在 .NET 中使用 Any 类型</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#本文小结"><span class="post-toc-number">3.</span> <span class="post-toc-text">本文小结</span></a></li></ol></nav></aside><article id="post-gRPC-借助-Any-类型实现接口的泛化调用" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">gRPC 借助 Any 类型实现接口的泛化调用</h1><div class="post-meta"><time class="post-time" title="2021-12-10 11:53:29" datetime="2021-12-10T11:53:29.000Z" itemprop="datePublished">2021-12-10</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul><span id="lc_counter_container_page_pv" title="文章总阅读量" data-page-url="" data-page-title="gRPC 借助 Any 类型实现接口的泛化调用"><i class="icon icon-eye icon-pr"></i><span id="lc_counter_value_page_pv"></span></span> <span><i class="icon icon-clock-o"></i> 15 min.</span></div><div class="post-content" id="post-content" itemprop="postContent"><p>我发现，人们非常喜欢在一件事情上反复横跳。譬如，以编程语言为例，人们喜欢静态的、强类型语言的严谨和安全，可难免会羡慕动态的、弱类型语言的自由和灵活。于是，在过去的这些年里，我们注意到，<code>.NET</code> 的世界里出现了 <code>dynamic</code> 类型，<code>JavaScript</code> 的世界里出现了 <code>TypeScript</code>，甚至连 <code>Python</code> 都开始支持类型标注。这种动与静、强与弱的角逐，隐隐然有种太极圆转、轮回不绝的感觉。果然，“城外的人想冲进去，城里的人想逃出来”，钱钟书先生说的固然是婚姻，可世上的事情，也许都差不多罢！人们反复横跳的样子，像极了「九品芝麻官」里的方唐镜。曾经有段时间，好多人吹捧 <a href="https://v3.cn.vuejs.org/" target="_blank" rel="noopener">Vue3</a> + <a href="https://www.tslang.cn/" target="_blank" rel="noopener">TypeScript</a> 的技术栈，有位前辈一针见血地戳破了这种叶公好龙式的喜欢，“你那么喜欢 TypeScript，不还是关掉了 ESLint 的规则，项目里全部都用 Any”。对于这个吐槽，我表示非常真实，因为我们对于动与静、强与弱的心理变化是非常微妙的。常言道，“动态类型一时爽，代码重构火葬场”，你是如何看待编程语言里的动与静静、强与弱的呢？在 gRPC 中我们通过 Protobuf 来描述接口的参数和返回值，由此对服务提供/消费方进行约束。此时，参数和返回值都是静态的、强类型的。如果我们希望提供某种“泛型”的接口，又该如何去做呢？所以，这篇文章我们来聊聊 gPRC 里的 Any 类型。</p><h1 id="Protobuf-里的-Any-类型"><a href="#Protobuf-里的-Any-类型" class="headerlink" title="Protobuf 里的 Any 类型"></a>Protobuf 里的 Any 类型</h1><p>在讲 Any 类型前，我想，我们应该想明白，为什么需要这样一个类型？现在，假设我们有下面的 <code>Protobuf</code> 定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vehicle</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> VehicleId = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> FleetNo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Officer</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Officer</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> OfficerId = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> Department = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，按照<code>Protobuf</code>的规范，我们必须像下面这样定义对应的集合：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VehicleList</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">VehicleList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Vehicle List = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OfficerList</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">OfficerList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Officer List = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到，在<code>C#</code> 中我们只需要使用 <code>List&lt;Vehicle&gt;</code> 和 <code>List&lt;Officer&gt;</code> 即可，这样难免就会形成一种割裂感，因为你几乎要为每一种类型建立对应的表示集合的类型，从语义化的角度考虑，我们更希望使用下面的 <code>Protobuf</code> 定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Any List = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>VehicleList</code> 和 <code>OfficerList</code> 就可以统一到 <code>Collection</code> 这个类型中，这样，不但减少了花在类型定义的时间，更能帮助我们打开一点思路。在过去，我们编写 API 的时候，通常会定义下面的类来返回结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ApiResult&lt;TData&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Msg &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> TData Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，当我们用 gPRC 来做微服务的时候，我们希望在 <code>Protobuf</code> 中沿用这个设计：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ApiResult</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> Code = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> Msg = <span class="number">2</span>;</span><br><span class="line">  Any Data = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，它可以和我们在 <code>C#</code> 中的认知联系起来，不会让你有太多心智上的负担。基于上述两种诉求，我们发现， <code>Protobuf</code> 中存在着需要泛化的场景，你可以理解为，我们需要用 <code>Protobuf</code> 来表示泛型或者模板类这样的东西。幸运的是，Google 为我们定义了 <code>Any</code> 类型，它到底是何方神圣呢？我们一起来看看：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Any</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> type_url = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">bytes</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，它就是这样的朴实无华，甚至比古天乐还要平平无奇，简单来说，<code>type_url</code>字段告诉你这是一个什么类型，<code>value</code>字段里则存放对应的二进制数据，而这就是 <code>Any</code> 类型的全部秘密！</p><h1 id="在-NET-中使用-Any-类型"><a href="#在-NET-中使用-Any-类型" class="headerlink" title="在 .NET 中使用 Any 类型"></a>在 .NET 中使用 Any 类型</h1><p>好了，下面我们来演示，如何在 .NET 中使用 <code>Any</code> 类型。通过前面我们已经知道， <code>Any</code> 类型和我们自定义的消息没有区别，所以，它同样实现了 <code>IMessage</code> 和 <code>IMessage&lt;Any&gt;</code>两个接口，唯一不同的地方在于，它拥有<code>Pack()</code>、<code>Unpack&lt;T&gt;()</code>、<code>TryUnpack&lt;T&gt;()</code>这样几个静态方法，这是实现任意 <code>IMessage</code> 到 <code>Any</code> 相互转换的关键。现在，假设我们现在有如下的 <code>Protobuf</code> 定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AnyRequest</span> </span>&#123;</span><br><span class="line">  google.protobuf.Any Data = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AnyResponse</span> </span>&#123;</span><br><span class="line">  google.protobuf.Any Data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> Name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> Name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果我们希望在 <code>AnyRequest</code> 或者 <code>AnyResponse</code> 里传递 <code>Any</code> 类型，我们可以这样做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anyRequest = <span class="keyword">new</span> AnyRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo -&gt; Any，默认类型地址前缀</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.Name = <span class="string">"Foo"</span>;</span><br><span class="line">anyRequest.Data = Any.Pack(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bar -&gt; Any, 自定义类型地址前缀</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line">bar.Name = <span class="string">"Bar"</span>;</span><br><span class="line">anyRequest.Data = Any.Pack(bar, <span class="string">"type.company.com/bar"</span>);</span><br></pre></td></tr></table></figure><p>反过来，我们可以从 <code>Any</code> 中解析出 <code>IMessage</code> ：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.Data.Is(Foo.Descriptor))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Any -&gt; Foo</span></span><br><span class="line">  <span class="keyword">var</span> foo = request.Data.Unapck&lt;Foo&gt;();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (request.Data.Is(Bar.Descriptor))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Any -&gt; Bar</span></span><br><span class="line">  <span class="keyword">var</span> bar = request.Data.Unapck&lt;Bar&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的 <code>Any</code> 类型，只能对 <code>Protobuf</code> 生成的类型(即实现了 IMessage 接口)进行 <code>Pack</code> ，如果我们想做得更绝一点(最好还是不要)，那么，可以使用自定义的 <code>MyAny</code> 类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyAny</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> TypeUrl = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">bytes</span> Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地，我们为 <code>MyAny</code> 类型编写一点扩展方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyAnyExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyAny <span class="title">Pack</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">object</span> obj, <span class="keyword">string</span> typeUrlPrefix = <span class="string">""</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> any = <span class="keyword">new</span> MyAny();</span><br><span class="line">        any.TypeUrl = <span class="string">$"<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;obj.GetType().FullName&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(obj));</span><br><span class="line">        any.Value = Google.Protobuf.ByteString.CopyFrom(bytes);</span><br><span class="line">        <span class="keyword">return</span> any;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Unpack&lt;T&gt;(<span class="keyword">this</span> MyAny any, <span class="keyword">string</span> typeUrlPrefix = <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> typeUrl = <span class="string">$"<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;<span class="keyword">typeof</span>(T).FullName&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">if</span> (typeUrl == any.TypeUrl)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> json = Encoding.UTF8.GetString(any.Value.ToByteArray());</span><br><span class="line">            <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> Is&lt;T&gt;(<span class="keyword">this</span> MyAny any, <span class="keyword">string</span> typeUrlPrefix = <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> typeUrl = <span class="string">$"<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;<span class="keyword">typeof</span>(T).FullName&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">return</span> typeUrl == any.TypeUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们就可以对任意类型进行处理，虽然，此时此刻，从严格意义上来讲，它已不再属于 <code>Protobuf</code> 的范畴，因为序列化/反序列化都交给了 JSON ：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = serviceProvider.GetService&lt;ProtobufAny.Greeter.GreeterClient&gt;();</span><br><span class="line">client.Ping(<span class="keyword">new</span> Foo() &#123; Name = <span class="string">"Foo"</span> &#125;.Pack());</span><br><span class="line">client.Ping(<span class="keyword">new</span> Bar() &#123; Name = <span class="string">"Foo"</span> &#125;.Pack());</span><br><span class="line">client.Ping(<span class="keyword">new</span> &#123; X = <span class="number">0</span>, Y = <span class="number">1</span>, Z = <span class="number">0</span> &#125;.Pack());</span><br></pre></td></tr></table></figure><p>这样看起来是不是非常酷？我始终认为，这件事情是有意义的，一个系统中最多的接口显然是查询接口，此时，我们可以构建一个通用的 <a href="https://github.com/qinyuanpei/DynamicSearch" target="_blank" rel="noopener">查询</a> 来处理，使用者只需要传递一个实体、一个Proto，一组过滤条件，它就可以返回对应的数据，这样是不是比写一个又一个差不多的接口要好一点呢？过去我们开发 API，主张用数据传输对象(DTO)来隔离持久化层和业务层，从这个角度来看，Protobuf 本身就是 一种 DTO ，对于大多数相似的、模板化的、套路化的接口，我们完全可以考虑用这种方案来实现，只要双方约定好类型即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在业务层构建通用的查询</span></span><br><span class="line"><span class="keyword">public</span> QueryReply Query&lt;TInput, TOutput&gt;(SearchParameters searchParameters) <span class="keyword">where</span> TInput : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = _chinookContext.Set&lt;TInput&gt;().AsQueryable().Search(searchParameters).ToList();</span><br><span class="line">    <span class="keyword">var</span> output = result.Adapt&lt;List&lt;TOutput&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reply = <span class="keyword">new</span> QueryReply();</span><br><span class="line">    reply.List.AddRange(output.Select(x =&gt; x.Pack()));</span><br><span class="line">    <span class="keyword">return</span> reply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x =&gt; &#123; 1, 2, 3 &#125;.Contains(x.AlbumId)</span></span><br><span class="line"><span class="keyword">var</span> searchParameters = SearchParameters();</span><br><span class="line">searchParameters.QueryModel = <span class="keyword">new</span> QueryModel();</span><br><span class="line">searchParameters.QueryModel.Add(<span class="keyword">new</span> Condition() &#123; Field = <span class="string">"AlbumId"</span>, Op = Operation.StdIn, Value = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在服务层解析参数，完全可以由调用方提供 SearchParameters</span></span><br><span class="line"><span class="keyword">var</span> inputType = Type.GetType(request.InputType);</span><br><span class="line"><span class="keyword">var</span> outputType = Type.GetType(request.OutputType);</span><br><span class="line"><span class="keyword">if</span> (inputType != <span class="literal">null</span> &amp;&amp; outputType != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> queryMethod = _queryService.GetType().GetMethod(<span class="string">"Query"</span>).MakeGenericMethod(inputType, outputType);</span><br><span class="line">    QueryReply queryResult = (QueryReply)queryMethod.Invoke(_queryService, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; </span><br><span class="line">      <span class="keyword">new</span> DynamicSearch.Core.SearchParameters()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> Task.FromResult(queryResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>对于编程语言中的动与静、强与弱，我个人觉得还是要看场景，只要双方定义好契约，我相信，它都可以运作起来，当然，更多的时候，我们是在灵活与严谨间反复横跳。作为一门 DSL，Protobuf 虽然可以对服务提供/消费方产生一定约束，可当我们面对需要泛型或者模板类的场景的时候，这种做法就变成了一种负担，更不必说它缺乏对继承的支持。想象一下，你要写二十多个大同小异的接口，譬如为每一张数据表写一个 <code>GetXXXById()</code> 的接口。此时，我们可以借助 <code>Any</code> 类型来实现类似泛型、模板类的东西，它本质上还是 <code>IMessage</code> 接口的实现类，唯一的不同是增加了 Pack/Unpack 这组静态方法，可以帮助我们实现 <code>Any</code> 和 <code>IMessage</code> 的相互转换，关于本文中使用的的实例，可以参考：<a href="https://github.com/Regularly-Archive/2021/tree/master/src/ProtobufAny" target="_blank" rel="noopener">ProtobufAny</a>，好了，以上就是这篇博客的全部内容，如果有朋友对文章中的内容和观点存在疑问，欢迎在评论区积极留言，谢谢大家！</p><div class="recommended_posts"><h1>推荐阅读</h1><ul><li><a href="https://qinyuanpei.github.io/posts/1657075397/">ASP.NET Core gRPC 健康检查的探索与实现</a></li><li><a href="https://qinyuanpei.github.io/posts/2167892202/">ASP.NET Core gRPC 打通前端世界的尝试</a></li><li><a href="https://qinyuanpei.github.io/posts/1679688265/">ASP.NET Core gRPC 拦截器的使用技巧分享</a></li><li><a href="https://qinyuanpei.github.io/posts/2742255459/">ASP.NET Core gRPC 集成 Polly 实现优雅重试</a></li><li><a href="https://qinyuanpei.github.io/posts/3942175942/">ASP.NET Core 搭载 Envoy 实现 gRPC 服务代理</a></li></ul></div></div><blockquote class="post-copyright" id="post-copyright"><div class="content"><p><b>版权声明：</b> <a href="https://qinyuanpei.github.io/posts/2617947988/" rel="external">gRPC 借助 Any 类型实现接口的泛化调用</a> ，由&nbsp;<a href="/about" target="_blank" rel="external">飞鸿踏雪</a>&nbsp; 首次发表于&nbsp;<a href="/" target="_blank" rel="external">一个人的孤落时辰</a>&nbsp; ，本文地址为：<a href="https://qinyuanpei.github.io/posts/2617947988/" target="_blank" rel="external">https://qinyuanpei.github.io/posts/2617947988/</a> ，转载请注明 <b>作者</b> 和 <b>出处</b> 。</p></div><footer><a href="https://qinyuanpei.github.io"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="飞鸿踏雪"> 飞鸿踏雪</a></footer></blockquote><div class="page-reward"><a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Any/" rel="tag">Any</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Protobuf/" rel="tag">Protobuf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gRPC/" rel="tag">gRPC</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/2617947988/&title=《gRPC 借助 Any 类型实现接口的泛化调用》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/2617947988/&title=《gRPC 借助 Any 类型实现接口的泛化调用》 — 一个人的孤落时辰&source=一个人的孤落时辰 | 纵有疾风起，人生不言弃 | 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地 | 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/2617947988/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《gRPC 借助 Any 类型实现接口的泛化调用》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/2617947988/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/2617947988/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/posts/2478147871/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">浅议非典型 Web 应用场景下的身份认证</h4></a></div><div class="waves-block waves-effect next"><a href="/posts/1213387651/" id="post-next" class="post-nav-link"><div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">分布式丛林探险系列之 Redis 集群模式</h4></a></div></nav><div id="comment"></div><script src="//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">new Valine({el:"#comment",notify:!1,verify:!0,appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",placeholder:"云中谁寄锦书来，雁字回时，月满西楼。&#10;Tips：如果希望收到我的评论回复，请至少留下你的邮箱哦:)",path:"https://qinyuanpei.github.io/posts/2617947988/",avatar:"identicon",requiredFields:["nick","mail"]})</script></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 赠人玫瑰，手有余香 <i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" alt="打赏二维码"></div><label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" data-alipay="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/alipay.jpg"><div class="reward-toggle-ctrol"><span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-label"></span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div><script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/yoniu.min.js"></script><style type="text/css">body.active-yp{overflow:hidden}.yp-fc-btn{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:space-between;font-size:13px}.yp-fc-btn span{cursor:pointer;padding:2px 10px;color:#4b4b4b;border:#4b4b4b 1px solid;border-radius:5px}#yp-hide{position:fixed;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:center;flex-direction:column;left:0;top:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);z-index:99999;visibility:hidden}#yoniu-poster{box-sizing:border-box;width:350px;height:467.2px;background-color:#fff;margin:0 auto;padding:0;line-height:1.6;text-align:justify}.yp-img{min-height:240px;position:relative;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:flex-end;flex-direction:column;background-position:50% 50%;background-size:cover;overflow:hidden}.yp-img>div{padding:10px 20px}.yp-name{display:block;color:#fff;font-size:20px;font-weight:600;text-shadow:#4b4b4b .1em .1em .2em;margin-top:10px}.yp-sort{padding:3px 10px;font-size:12px;color:#fff;background:#2e2e2e}.yp-des{color:#2e2e2e;font-size:14px;margin:20px;height:67.2px}.yp-qcode{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;margin:10px;padding:10px 20px;background:#f5f5f5;color:#818181;border-radius:10px}.yp-tips{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;color:#ccc;margin:0 10px 10px;font-size:10px;letter-spacing:1.5px}.yp-btns{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:stretch;justify-content:center;width:350px;margin:0 auto}.yp-btns>span{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:center;font-size:14px;padding:10px 15px;background:rgba(0,0,0,.2);color:#f5f5f5;cursor:pointer}.yp-btns>span>a{color:#f5f5f5}.yp-btns>span>a:hover{text-decoration:none}#yp-close{font-size:18px;font-weight:600}</style><div id="yp-hide"><div id="yoniu-poster"><div class="yp-img" id="yp-img"><div><span class="yp-sort">编程语言</span> <span class="yp-name">gRPC 借助 Any 类型实现接口的泛化调用</span></div></div><div class="yp-des">我发现，人们非常喜欢在一件事情上反复横跳。譬如，以编程语言为例，人们喜欢静态的、强类型语言的严谨和安全，可难免会羡慕动态的、弱类型语言的自由和灵...</div><div class="yp-qcode"><span>扫描二维码阅读原文</span> <img id="yp-qcode" width="64px" src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/2617947988/"></div><div class="yp-tips"><span>一个人的孤落时辰</span> <span><time class="post-time" title="2021-12-10 11:53:29" datetime="2021-12-10T11:53:29.000Z" itemprop="datePublished">2021-12-10</time></span></div></div><div class="yp-btns"><span id="yp-load-yp" onclick="load_yp()">生成海报</span> <span><a id="yp-download"></a></span> <span id="yp-close" onclick="close_yp()">×</span></div></div><script type="text/javascript">function show_yp(){window.scrollTo(0,0),document.body.setAttribute("class","active-yp");let e=document.getElementsByTagName("img")[1];null!=e&&void 0!==e?document.getElementById("yp-img").style.backgroundImage=`url(${e.src})`:document.getElementById("yp-img").style.backgroundColor="#d7dbf0",document.getElementById("yp-hide").style.visibility="visible"}function close_yp(){var e=document.body.getAttribute("class");e=e.replace("active-yp",""),document.body.setAttribute("class",e),document.getElementById("yp-hide").style.visibility="hidden"}function load_yp(){document.getElementById("yp-load-yp").textContent="海报生成中...",setTimeout((function(){h2c_()}),2e3)}</script></div><footer class="footer"><div class="top"><p><span id="lc_counter_container_site_uv"><i class="icon icon-user"></i><span id="lc_counter_value_site_uv"></span> </span><span id="lc_counter_container_site_pv"><i class="icon icon-eye"></i><span id="lc_counter_value_site_pv"></span></span></p><p><a id="jinrishici-sentence" href="https://www.jinrishici.com/" target="_blank" rel="noopener">加载中</a></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><script>jinrishici.load((function(e){document.querySelector("#subtitle").innerText=e.data.content,document.querySelector("#jinrishici-sentence").innerText=e.data.content}))</script><p><span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span> <span><a href="https://github.com/qinyuanpei" target="_blank" rel="license noopener" title="Github"><i class="icon icon-lg icon-github"></i> </a></span><span><a href="https://weibo.com/1278609231/profile" target="_blank" rel="license noopener" title="微博"><i class="icon icon-lg icon-weibo"></i> </a></span><span><a href="https://www.douban.com/people/60029335/" target="_blank" rel="license noopener" title="豆瓣"><i class="icon icon-lg icon-douban"></i> </a></span><span><a href="https://www.zhihu.com/people/qinyuanpei" target="_blank" rel="license noopener" title="知乎"><i class="icon icon-lg icon-zhihu-square"></i> </a></span><span><a href="https://blog.csdn.net/qinyuanpei" target="_blank" rel="license noopener" title="CSDN"><i class="icon icon-lg">C</i> </a></span><span><a href="https://music.163.com/#/user/home?id=47002864" target="_blank" rel="license noopener" title="网易音乐"><i class="icon icon-lg icon-wangyiyunyinyue"></i></a></span></p></div><div class="bottom"><p><span>飞鸿踏雪 &copy; 2014 - 2022</span><br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & Theme by <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a><br></p><p>Hosted by <a href="https://pages.github.com" target="_blank" rel="noopener" style="font-weight:700">Github Pages</a></p><p></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/2617947988/&title=《gRPC 借助 Any 类型实现接口的泛化调用》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/2617947988/&title=《gRPC 借助 Any 类型实现接口的泛化调用》 — 一个人的孤落时辰&source=一个人的孤落时辰 | 纵有疾风起，人生不言弃 | 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地 | 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/2617947988/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《gRPC 借助 Any 类型实现接口的泛化调用》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/2617947988/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/2617947988/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/2617947988/" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.6/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/echarts-wordcloud.min.js" async></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis">{tags}</div><time class="flex-col time">{date}</time></div></a></li></template><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/search.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/heart.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/leancloud-counter.min.js"></script><script>(new VisitorCounter).init({appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",region:"华北",domain:"",collectIP:!0,collectUA:!0})</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/vconsole.min.js"></script><script type="text/javascript">if(location.href.indexOf("debug=true")>-1)var vConsole=new VConsole</script><script></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/assets/scripts/ribbon.min.js"></script><script>var blocks=document.getElementsByTagName("blockquote");blocks.length>0&&"post-copyright"!=blocks[0].id&&(blocks[0].hidden=!0)</script></body></html>