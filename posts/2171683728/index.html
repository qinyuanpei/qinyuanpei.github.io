<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="pragma" content="no-cache"><meta http-equiv="cache-control" content="no-cache"><meta name="msvalidate.01" content="713A48A3FE17D4841C292A6B3942EB4C"><title>函数式编程常用术语 | 一个人的孤落时辰</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="编程,读书,函数式编程,秦元培,技术博客,生活随笔,个人博客,NET,Python,数据挖掘,数据分析,NLP"><meta name="description" content="本文对函数式编程中的常见术语如高阶函数、局部套用/柯里化、惰性求值等结合C#语言进行了简单分析;举一个基本的例子，.NET中IEnumerable&lt;T&gt;接口提供了大量的如Select、Where等扩展方法，而这些扩展方法同样会返回IEnumerable&lt;T&gt;类型，并且这些扩展方法不会改变原来的集合，所有的修改都是作用在一个新的集合上，这就是函数式编程的不可变性;常用的函数式编程术语有高阶函数、柯里化/局部调用、惰性求值，递归等;首先，函数式编程中强调无状态、不可变性，认为函数是一等公民，并且在函数式编程中每一个函数都是一个纯函数，它是数学概念咋计算机领域的一种延伸，和冯.诺依曼计算机体系不同，函数式编程的核心思想是以lambda演算为基础的表达式求值，并且函数式编程强调无副作用;自然是同样的道理啦，因为我们都知道，在C#中委托是一种类似函数指针的概念，因为当我们需要传入和返回一个函数的时候，选择委托这种特殊的类型可谓是恰如其分啦，这样并不会影响我们去理解高阶函数"><meta name="description" content="本文对函数式编程中的常见术语如高阶函数、局部套用&#x2F;柯里化、惰性求值等结合C#语言进行了简单分析;举一个基本的例子，.NET中IEnumerable接口提供了大量的如Select、Where等扩展方法，而这些扩展方法同样会返回IEnumerable类型，并且这些扩展方法不会改变原来的集合，所有的修改都是作用在一个新的集合上，这就是函数式编程的不可变性;常用的函数式编程术语有高阶函数、柯里化&#x2F;局部调用"><meta property="og:type" content="article"><meta property="og:title" content="函数式编程常用术语"><meta property="og:url" content="https://qinyuanpei.github.io/posts/2171683728/index.html"><meta property="og:site_name" content="一个人的孤落时辰"><meta property="og:description" content="本文对函数式编程中的常见术语如高阶函数、局部套用&#x2F;柯里化、惰性求值等结合C#语言进行了简单分析;举一个基本的例子，.NET中IEnumerable接口提供了大量的如Select、Where等扩展方法，而这些扩展方法同样会返回IEnumerable类型，并且这些扩展方法不会改变原来的集合，所有的修改都是作用在一个新的集合上，这就是函数式编程的不可变性;常用的函数式编程术语有高阶函数、柯里化&#x2F;局部调用"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2017-02-02T19:21:12.000Z"><meta property="article:modified_time" content="2021-09-02T12:49:47.798Z"><meta property="article:author" content="飞鸿踏雪"><meta property="article:tag" content="编程"><meta property="article:tag" content="读书"><meta property="article:tag" content="函数式编程"><meta name="twitter:card" content="summary"><link rel="alternate" type="application/atom+xml" title="一个人的孤落时辰" href="/atom.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master//assets/styles/style.css"><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/instantclick.min.js"></script><script>window.lazyScripts=[]</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/brand.jpg)"><div class="brand"><a href="/" class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="avatar"></a><hgroup class="introduce"><h5 class="nickname">飞鸿踏雪</h5><a href="mailto:qinyuanpei@163.com" title="qinyuanpei@163.com" class="mail">qinyuanpei@163.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> 标签</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/books"><i class="icon icon-lg icon-bookmark"></i> 书单</a></li><li class="waves-block waves-effect"><a href="/movies"><i class="icon icon-lg icon-film"></i> 影单</a></li><li class="waves-block waves-effect"><a href="https://qinyuanpei.github.io/poems/"><i class="icon icon-lg icon-folder-open"></i> 诗集</a></li><li class="waves-block waves-effect"><a href="/works"><i class="icon icon-lg icon-code"></i> 实验室</a></li><li class="waves-block waves-effect"><a href="/about"><i class="icon icon-lg icon-circle"></i> 关于我</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">函数式编程常用术语</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i> </a><a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="menuGithub"><i class="icon icon-lg icon-code-fork"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">函数式编程常用术语</h1><h5 class="subtitle" id="subtitle"><time datetime="2017-02-02T19:21:12.000Z" itemprop="datePublished" class="page-time">2017-02-02</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>目录</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#什么是函数式编程？"><span class="post-toc-number">1.</span> <span class="post-toc-text">什么是函数式编程？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数式编程的常用术语"><span class="post-toc-number">2.</span> <span class="post-toc-text">函数式编程的常用术语</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#高阶函数-Higer-Order-Function"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">高阶函数(Higer-Order-Function)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#柯里化-Curring-局部套用"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">柯里化(Curring)&#x2F;局部套用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#惰性求值"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">惰性求值</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数式编程的利弊探讨"><span class="post-toc-number">3.</span> <span class="post-toc-text">函数式编程的利弊探讨</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#本文小结"><span class="post-toc-number">4.</span> <span class="post-toc-text">本文小结</span></a></li></ol></nav></aside><article id="post-函数式编程常用术语" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">函数式编程常用术语</h1><div class="post-meta"><time class="post-time" title="2017-02-02 19:21:12" datetime="2017-02-02T19:21:12.000Z" itemprop="datePublished">2017-02-02</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul><span id="lc_counter_container_page_pv" title="文章总阅读量" data-page-url="" data-page-title="函数式编程常用术语"><i class="icon icon-eye icon-pr"></i><span id="lc_counter_value_page_pv"></span></span> <span><i class="icon icon-clock-o"></i> 30 min.</span></div><div class="post-content" id="post-content" itemprop="postContent"><p>&emsp;&emsp;近年来函数式编程这种概念渐渐流行起来，尤其是在React/Vuejs这两个前端框架的推动下，函数式编程就像股新思潮一般瞬间席卷整个技术圈。虽然博主接触到的前端技术并不算深入，可这并不妨碍我们通过类似概念的延伸来理解这种概念。首先，函数式编程是一种编程范式，而我们所熟悉的常见编程范式则有<strong>命令式编程(Imperative Programmming)</strong>、<strong>函数式编程(Functional Programming)</strong>、<strong>逻辑式编程(Logic Programming)</strong>、<strong>声明式编程(Declarative Programming)</strong>和<strong>响应式编程(Reactive Programming)</strong>等。现代编程语言 在发展过程中实际上都在借鉴不同的编程范式，比如Lisp和Haskell 是最经典的函数式编程语言，而SmartTalk、C++和Java则是最经典的命令式编程语言。微软的C#语言最早主要借鉴Java语言，在其引入lambda和LINQ特性以后，使得C#开始具备实施函数式编程的基础，而最新的Java8同样开始强化lambda这一特性，为什么lambda会如此重要呢？这或许要从函数式编程的基本术语开始说起。</p><a id="more"></a><h1 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h1><p>&emsp;&emsp;我们提到函数式编程是一种编程范式，它的基本思想是将计算机运算当作是数学中的函数，同时避免了状态和变量的概念。一个直观的理解是，在函数式编程中面向数据，函数是第一等公民，而我们传统的命令式编程中面向过程，类是第一等公民。为什么我们反复提到lambda呢？因为函数式编程中最重要的基础是lambda演算(Lambda Calculus)，并且lambda演算的函数可以接受函数作为参数和返回值，这听起来和数学有关，的确函数式编程是面向数学的抽象，任何计算机运算在这里都被抽象为表达式求值，简而言之，函数式程序即为一个表达式。值得一提的是，函数式编程是图灵完备的，这再次说明数学和计算机技术是紧密联系在一起的。虽然在博主心目中认为，图灵这位天纵英才的英国数学家，是真正的计算机鼻祖，但历史从来都喜欢开玩笑的，因为现代计算机是以冯.诺依曼体系为基础的，而这一体系天生就是面向过程即命令式的，在这套体系下计算机的运算实则是硬件的一种抽象，命令式程序实际上是一组指令集。因此，函数式程序目前依然需要编译为该体系下的计算机指令来执行，这听起来略显遗憾，可这对我们来说并不重要，下面让我们来一窥函数式编程的真容：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = map(lambda x: x * x, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  </span><br><span class="line">print squares</span><br></pre></td></tr></table></figure><p>这是使用Python编写的函数式编程风格的代码，或许看到这样的代码，我们内心是完全崩溃的，可是它实现得其实是这样一个功能，即将集合{0, 1, 2, 3, 4}中的每个元素进行平方操作，然后返回一个新的集合。如果使用命令式编程，我们注定无法使用如此简单的代码实现这个功能。而这个功能在.NET中其实是一个Select的功能：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span><span class="literal">[]</span> <span class="built_in">array</span> = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[]</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">int</span><span class="literal">[]</span> result = <span class="built_in">array</span>.<span class="constructor">Select(<span class="params">m</span> =&gt; <span class="params">m</span> <span class="operator">*</span> <span class="params">m</span>)</span>.<span class="constructor">ToArray()</span>;</span><br></pre></td></tr></table></figure><p>这就是函数式编程的魅力，我们所做的事情都是由一个个函数来完成的，这个函数定义了输入和输出，而我们只需要将数据作为参数传递给函数，函数会返回我们期望的结果。好了，下面再看一个例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = reduce(lambda a, x: a + x, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print sum</span><br></pre></td></tr></table></figure><p>即使我们从来没有了解过函数式编程，从命名我们依然可以看出这是一个对集合中的元素求和的功能实现，这就是规范命名的重要性。幸运的是.NET中同样有类似的扩展方法，我喜欢Linq，我喜欢lambda：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[]<span class="built_in"> array </span>=<span class="built_in"> new </span>int[]&#123;0, 1, 2, 3, 4&#125;;</span><br><span class="line">int result = array.Sum();</span><br></pre></td></tr></table></figure><p>考虑到博主写不出更复杂的函数式编程的代码示例，这里不再列举更多的函数式编程风格的代码，可是我们从直观上来理解函数式编程，就会发现函数式编程同lambda密不可分，函数在这里扮演着重要的角色。好了，下面我们来了解下函数式编程中的常用术语。</p><h1 id="函数式编程的常用术语"><a href="#函数式编程的常用术语" class="headerlink" title="函数式编程的常用术语"></a>函数式编程的常用术语</h1><p>&emsp;&emsp;函数式编程首先是一种编程范式，这意味着它和面向对象编程一样，都是一种编程的思想。而函数式编程最基本的两个特性就是不可变数据和表达式求值。基于两个基础特性，我们延伸出了各种函数式编程的相关概念，而这些概念就是函数式编程的常用术语。常用的函数式编程术语有高阶函数、柯里化/局部调用、惰性求值，递归等。在了解这些概念前，我们先来理解，什么是函数式编程的不可变性。不可变性，意味着在函数式编程中没有变量的概念，即操作不会改变原有的值而是修改新产生的值。举一个基本的例子，.NET中IEnumerable<t>接口提供了大量的如Select、Where等扩展方法，而这些扩展方法同样会返回IEnumerable<t>类型，并且这些扩展方法不会改变原来的集合，所有的修改都是作用在一个新的集合上，这就是函数式编程的不可变性。实现不可变性的前提是纯函数，即函数不会产生副作用。一个更为生动的例子是，如果我们尝试对一个由匿名类型组成的集合进行修改，会被提示该匿名类型的属性为只读属性，这意味着数据是不可改变的，如果我们要坚持对数据进行“修改”，唯一的方法就是调用一个函数。</t></t></p><h2 id="高阶函数-Higer-Order-Function"><a href="#高阶函数-Higer-Order-Function" class="headerlink" title="高阶函数(Higer-Order-Function)"></a>高阶函数(Higer-Order-Function)</h2><p>&emsp;&emsp;高阶函数是指函数自身能够接受函数，并返回函数的一种函数。这个概念听起来好像非常复杂的样子，其实在我们使用Linq的时候，我们就是在使用高阶函数啦。这里介绍三个非常有名的高阶函数，即Map、Filter和Fold，这三个函数在Linq中分别对应于Select、Where和Sum。我们可以通过下面的例子来理解：</p><ul><li>Map函数需要一个元素集合和一个访问该元素集合中每一个元素的函数，该函数将生成一个新的元素集合，并返回这个新的元素集合。通过C#中的迭代器可以惰性实现Map函数：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IEnumerable</span>&lt;<span class="type">R</span>&gt; <span class="type">Map</span>&lt;<span class="type">T</span>,<span class="type">R</span>&gt;(<span class="type">Func</span>&lt;<span class="type">T</span>,<span class="type">R</span>&gt; <span class="function"><span class="keyword">func</span>, <span class="title">IEnumerable</span>&lt;T&gt; <span class="title">list</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	foreach(<span class="type">T</span> item <span class="keyword">in</span> list)</span><br><span class="line">		yield <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Filter函数需要一个元素集合和一个筛选该元素结合的函数，该函数将从原始元素集合中筛选中符合条件的元素，然后组成一个新的元素集合，并返回这个新的元素集合。通过C#中的Predicate<t>委托类型，我们可以写出下面的代码：<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span> Filter</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(Predicate</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span> predicate, IEnumerable</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span> list)</span></span><br><span class="line"><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">	foreach(T <span class="type">item</span> <span class="keyword">in</span> list)</span></span><br><span class="line"><span class="xquery">	&#123;</span></span><br><span class="line"><span class="xquery">		<span class="keyword">if</span>(predicate(<span class="type">item</span>))</span></span><br><span class="line"><span class="xquery">			yield <span class="keyword">return</span> <span class="type">item</span>;</span></span><br><span class="line"><span class="xquery">	&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></t></li><li>Fold函数实际上代表了一系列函数，而最重要的两个例子是左折叠和右折叠，这里我们选择相对简单地左折叠来实现累加的功能，它需要一个元素集合，一个累加函数和一个初始值，我们一起来看下面的代码实现：<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R Fold&lt;T,R&gt;(Func&lt;R,T,R&gt; func, IEnumerable&lt;T&gt; <span class="built_in">list</span>, R startValue = default(R))</span><br><span class="line">&#123;</span><br><span class="line">	R <span class="literal">result</span> = startValue;</span><br><span class="line">	foreach(T <span class="built_in">item</span> <span class="keyword">in</span> <span class="built_in">list</span>)</span><br><span class="line">		<span class="literal">result</span> = func(<span class="literal">result</span>, <span class="built_in">item</span>);</span><br><span class="line"><span class="built_in">	return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>相信现在大家应该理解什么是高阶函数了，这种听起来非常数学的名词，当我们尝试用代码来描述的时候会发现非常简单。相信大家都经历过学生时代，临近期末考试的时候死记硬背名词解释的情形，其实可以用简洁的东西描述清楚的概念，为什么需要用这种方式来理解呢？为什么我这里选择了C#中的委托来编写这些示例代码呢？自然是同样的道理啦，因为我们都知道，在C#中委托是一种类似函数指针的概念，因为当我们需要传入和返回一个函数的时候，选择委托这种特殊的类型可谓是恰如其分啦，这样并不会影响我们去理解高阶函数。</p><h2 id="柯里化-Curring-局部套用"><a href="#柯里化-Curring-局部套用" class="headerlink" title="柯里化(Curring)/局部套用"></a>柯里化(Curring)/局部套用</h2><p>&emsp;&emsp;柯里化(Curring)得名于数学家Haskell Curry，你的确没有看错，这位伟大的数学家不仅创造了Haskell这门函数式编程语言，而且提出了局部套用(Currin)这种概念。所谓局部套用，就是指不管函数中有多少个参数，都可以函数视为函数类的成员，而这些函数只有一个形参，局部套用和部分应用息息相关，尤其是部分应用是保证函数模块化的两个重要技术之一(部分应用和组合<strong>(Composition)</strong>是保证函数模块化的两个重要技术)。众所周知，在C#中一个函数一旦完成定义，那么它的参数列表就是确定的，即相对静态。它不能像Python和Lua一样去动态改变参数列表，虽然我们可以通过缺省参数来减少参数的个数，可是在大多数情况下，我们都需要在调用函数前准备好所有参数，而局部套用所做的事情与这个理念截然相反，它的目标是用非完全的参数列表去调用函数。我们来一起看下面这个例子：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="keyword">add</span> = (x,y) =&gt; &#123;<span class="keyword">return</span> x + y;&#125;;</span><br></pre></td></tr></table></figure><p>这是一个由匿名方法定义的委托类型，显然我们需要在调用这个方法前准备好两个参数x和y，这意味着C#不允许我们在改变参数列表的情况下调用这个方法。而通过局部套用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; curriedAdd =&gt; (x) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (y) =&gt; &#123; <span class="keyword">return</span> x + y;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上在这里两个参数x和y的顺序对最终结果没有任何影响，我们这样写仅仅是为了符合人类正常的认知习惯，而此时我们注意到我们在调用curriedAdd时会发生质的的变化：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x和y同时被传入add</span></span><br><span class="line">add(<span class="symbol">x</span>,<span class="symbol">y</span>)</span><br><span class="line"><span class="comment">//x和y可以不同时被传入curriedAdd</span></span><br><span class="line">curriedAdd(<span class="symbol">x</span>)(<span class="symbol">y</span>);</span><br></pre></td></tr></table></figure><p>而如果我们将这里的函数用Lambda表达式来表示，则会发现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt; add = (x,y) =&gt; <span class="keyword">return</span> x + y;</span><br><span class="line">Func&lt;<span class="built_in">int</span>,Fucn&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;&gt; curriedAdd = x = &gt; y =&gt; x + y;</span><br></pre></td></tr></table></figure><p>至此，对一般的局部套用，存在：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;...&gt; f = <span class="function">(<span class="params">part1, part2, part3, ...</span>) =&gt;</span> ... 可转换为：</span><br><span class="line">Func&lt;...&gt; cf = <span class="function"><span class="params">part1</span> =&gt;</span> <span class="function"><span class="params">part2</span> =&gt;</span> part3 ... =&gt; ...</span><br></pre></td></tr></table></figure><p>则称后者为前者的局部套用形式。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>&emsp;&emsp;我们在前文中曾经提到过，在函数式编程中函数是第一等公民，而这里的函数更接近数学意义上的函数，即将函数视为一个可以对表达式求值的纯函数，所以我们这里自然而然地就提到了惰性求值。首先，博主这里想说说求值策略这个问题，求值策略通常有严格求值和非严格求值两种，而对C#语言来讲，它在大多数情况下使用严格求值策略，即参数在传递给函数前求值。与之相对应的，我们将参数在传递给函数前不进行求值或者延迟求值的这种情况，称为非严格求值策略。一个经典的例子是C#中的“短路”效应：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isTrue = (<span class="number">10</span> &lt; <span class="number">5</span>) &amp;&amp; (<span class="name">MyCheck</span>())</span><br></pre></td></tr></table></figure><p>因为在这里表达式的第一部分返回值为false，因此在实际调用中第二部分根本不会执行，因为无论第二部分返回true还是false，实际上对整个表达式的结果都不会产生影响。这是一个非常经典的非严格求值的例子，同样的，布尔运算中的”||”运算符，同样存在这个问题。所以，至此我们可以领会到惰性求值的优点，即使程序的执行效率更好，尤其是在避免高昂运算代价的时候，我们要牢记：懒惰是程序员的一种美德，使用更简洁的代码来满足需求，是一名游戏程序员的永恒追求。我们可以联想那些在代码片段中优先return的场景，这大概勉强可以用这种理论来解释吧！例如我们强大的Linq，原谅我如此执著于举Linq的例子，Linq的一个特点是当数据需要被使用的时候开始计算，即数据是延迟加载的，而在此之前我们所有对数据的操作，从某种意义上来讲，更像是定义了一系列函数，这好像和数据库中的事务非常相近啦，其实这就是在告诉我们，懒惰是一种美德啊，哈哈！</p><h1 id="函数式编程的利弊探讨"><a href="#函数式编程的利弊探讨" class="headerlink" title="函数式编程的利弊探讨"></a>函数式编程的利弊探讨</h1><p>&emsp;&emsp;好了，现在让我们从函数式编程的各种术语中解放出来，高屋建瓴般地从更高的层面上探讨下函数式编程的利弊。当你讨论一种东西的利弊时，一种习惯性的做法是找一种东西来和它作比较，如果Windows和Linux、SQL和NoSQ、面向对象和函数式…等等，我们常常关注一件事物的利弊，而非去寻找哪一个是最好。可惜自以为是的人类，常常以此来自我设限，划分各自的阵营，这当真是件无聊的事情，就像我一直不喜欢SQL和正则表达式，所以我就去了解数据库的设计、模式匹配相关内容，最终感觉颇有一番收获，我想这是我们真正的目的吧！好了，下面我们说说函数式编程有哪些优缺点？首先，函数式编程极大地改善了程序的模块化程度，高阶函数、递归和惰性求值让程序充分函数化，函数式让编程可以以一种声明式的风格来增强程序语义。当然，函数式编程的缺点是，我们这个现实世界本来就不是纯粹的，函数式编程强调的数据不可变性，意味着我们无法去模拟事物状态变化，因此我们不能为了追求无副作用、无锁而忽视现实，这个世界上总有些肮脏的问题，无法让我们用纯函数的思维去解决，这个时候我们不能说要让设计去适应这个世界，任何技术或者框架的诞生归根到底是为了解决问题，而函数式编程或者是面向对象编程，本质都是一种编程思想，我们最终是为了解决问题，就像这个世界有时候并不是面向对象的，我们用面向对象来描述这个世界，或许仅仅是我们自己的理解，这个世界到底是什么样子的，大概只有上帝会知道吧！</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>&emsp;&emsp;本文主要对函数式编程及其常见术语进行了简要讨论，主要根据《C#函数式程序设计》一书整理并辅以博主的理解而成。首先，函数式编程中强调无状态、不可变性，认为函数是一等公民，并且在函数式编程中每一个函数都是一个纯函数，它是数学概念咋计算机领域的一种延伸，和冯.诺依曼计算机体系不同，函数式编程的核心思想是以lambda演算为基础的表达式求值，并且函数式编程强调无副作用。本文对函数式编程中的常见术语如高阶函数、局部套用/柯里化、惰性求值等结合C#语言进行了简单分析。或许对我们而言，函数式编程是一个新鲜事物，可正如我们第一次接触面向对象编程时一样，我们并不知道这样一种编程思想会持续到今天。我不认为函数式编程会彻底替代面向对象编程，就像Web开发无法彻底替换原生开发一样，函数式编程会作为面向对象的一种延伸和补充，所以本文对函数式编程的理解实际上是非常肤浅的，可这个世界本来就是在不断变化的，希望我们可以在恰当的场景下去权衡选择什么样的技术，对这个世界而言，我们永远都是探索者，或许永远都不存在完全能满足现实场景的编程范式吧！</p><div class="recommended_posts"><h1>推荐阅读</h1><ul><li><a href="https://qinyuanpei.github.io/posts/2041685704/">C#中Socket通信编程的异步实现</a></li><li><a href="https://qinyuanpei.github.io/posts/345410188/">《C#多线程编程实战》读书笔记</a></li><li><a href="https://qinyuanpei.github.io/posts/3411909634/">一道 HashSet 面试题引发的蝴蝶效应</a></li><li><a href="https://qinyuanpei.github.io/posts/2637069146/">低代码，想说爱你不容易</a></li><li><a href="https://qinyuanpei.github.io/posts/187480982/">异步Lambda表达式问题的探索</a></li></ul></div></div><blockquote class="post-copyright" id="post-copyright"><div class="content"><p><b>版权声明：</b> <a href="https://qinyuanpei.github.io/posts/2171683728/" rel="external">函数式编程常用术语</a> ，由&nbsp;<a href="/about" target="_blank" rel="external">飞鸿踏雪</a>&nbsp; 首次发表于&nbsp;<a href="/" target="_blank" rel="external">一个人的孤落时辰</a>&nbsp; ，本文地址为：<a href="https://qinyuanpei.github.io/posts/2171683728/" target="_blank" rel="external">https://qinyuanpei.github.io/posts/2171683728/</a> ，转载请注明 <b>作者</b> 和 <b>出处</b> 。</p></div><footer><a href="https://qinyuanpei.github.io"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="飞鸿踏雪"> 飞鸿踏雪</a></footer></blockquote><div class="page-reward"><a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/2171683728/&title=《函数式编程常用术语》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/2171683728/&title=《函数式编程常用术语》 — 一个人的孤落时辰&source=&emsp;&emsp;近年来函数式编程这种概念渐渐流行起来，尤其是在React/Vuejs这两个前端框架的推动下，函数式编程就像股新思潮一般瞬间席卷整个..." data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/2171683728/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《函数式编程常用术语》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/2171683728/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/2171683728/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/posts/2314414875/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">愿浮萍乘风破浪</h4></a></div><div class="waves-block waves-effect next"><a href="/posts/3568552646/" id="post-next" class="post-nav-link"><div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">基于Mono和VSCode打造轻量级跨平台IDE</h4></a></div></nav><div id="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">new Valine({el:"#comment",notify:!1,verify:!0,appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",placeholder:"云中谁寄锦书来，雁字回时，月满西楼。&#10;Tips：如果希望收到我的评论回复，请至少留下你的邮箱哦:)",path:"https://qinyuanpei.github.io/posts/2171683728/",avatar:"identicon",requiredFields:["nick","mail"]})</script></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 赠人玫瑰，手有余香 <i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" alt="打赏二维码"></div><label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" data-alipay="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/alipay.jpg"><div class="reward-toggle-ctrol"><span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-label"></span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div><script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/yoniu.min.js"></script><style type="text/css">body.active-yp{overflow:hidden}.yp-fc-btn{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:space-between;font-size:13px}.yp-fc-btn span{cursor:pointer;padding:2px 10px;color:#4b4b4b;border:#4b4b4b 1px solid;border-radius:5px}#yp-hide{position:fixed;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:center;flex-direction:column;left:0;top:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);z-index:99999;visibility:hidden}#yoniu-poster{box-sizing:border-box;width:350px;height:467.2px;background-color:#fff;margin:0 auto;padding:0;line-height:1.6;text-align:justify}.yp-img{min-height:240px;position:relative;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:flex-end;flex-direction:column;background-position:50% 50%;background-size:cover;overflow:hidden}.yp-img>div{padding:10px 20px}.yp-name{display:block;color:#fff;font-size:20px;font-weight:600;text-shadow:#4b4b4b .1em .1em .2em;margin-top:10px}.yp-sort{padding:3px 10px;font-size:12px;color:#fff;background:#2e2e2e}.yp-des{color:#2e2e2e;font-size:14px;margin:20px;height:67.2px}.yp-qcode{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;margin:10px;padding:10px 20px;background:#f5f5f5;color:#818181;border-radius:10px}.yp-tips{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;color:#ccc;margin:0 10px 10px;font-size:10px;letter-spacing:1.5px}.yp-btns{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:stretch;justify-content:center;width:350px;margin:0 auto}.yp-btns>span{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:center;font-size:14px;padding:10px 15px;background:rgba(0,0,0,.2);color:#f5f5f5;cursor:pointer}.yp-btns>span>a{color:#f5f5f5}.yp-btns>span>a:hover{text-decoration:none}#yp-close{font-size:18px;font-weight:600}</style><div id="yp-hide"><div id="yoniu-poster"><div class="yp-img" id="yp-img"><div><span class="yp-sort"></span> <span class="yp-name">函数式编程常用术语</span></div></div><div class="yp-des">&emsp;&emsp;近年来函数式编程这种概念渐渐流行起来，尤其是在React/Vuejs这两个前端框架的推动下，函数式编程就像股新思潮一般瞬...</div><div class="yp-qcode"><span>扫描二维码阅读原文</span> <img id="yp-qcode" width="64px" src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/2171683728/"></div><div class="yp-tips"><span>一个人的孤落时辰</span> <span><time class="post-time" title="2017-02-02 19:21:12" datetime="2017-02-02T19:21:12.000Z" itemprop="datePublished">2017-02-02</time></span></div></div><div class="yp-btns"><span id="yp-load-yp" onclick="load_yp()">生成海报</span> <span><a id="yp-download"></a></span> <span id="yp-close" onclick="close_yp()">×</span></div></div><script type="text/javascript">function show_yp(){window.scrollTo(0,0),document.body.setAttribute("class","active-yp");let e=document.getElementsByTagName("img")[1];null!=e&&void 0!==e?document.getElementById("yp-img").style.backgroundImage=`url(${e.src})`:document.getElementById("yp-img").style.backgroundColor="#d7dbf0",document.getElementById("yp-hide").style.visibility="visible"}function close_yp(){var e=document.body.getAttribute("class");e=e.replace("active-yp",""),document.body.setAttribute("class",e),document.getElementById("yp-hide").style.visibility="hidden"}function load_yp(){document.getElementById("yp-load-yp").textContent="海报生成中...",setTimeout((function(){h2c_()}),2e3)}</script></div><footer class="footer"><div class="top"><p><span id="lc_counter_container_site_uv"><i class="icon icon-user"></i><span id="lc_counter_value_site_uv"></span> </span><span id="lc_counter_container_site_pv"><i class="icon icon-eye"></i><span id="lc_counter_value_site_pv"></span></span></p><p><a id="jinrishici-sentence" href="https://www.jinrishici.com/" target="_blank" rel="noopener">加载中</a></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><script>jinrishici.load((function(e){document.querySelector("#subtitle").innerText=e.data.content,document.querySelector("#jinrishici-sentence").innerText=e.data.content}))</script><p><span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span> <span><a href="https://github.com/qinyuanpei" target="_blank" rel="license noopener" title="Github"><i class="icon icon-lg icon-github"></i> </a></span><span><a href="https://weibo.com/1278609231/profile" target="_blank" rel="license noopener" title="微博"><i class="icon icon-lg icon-weibo"></i> </a></span><span><a href="https://www.douban.com/people/60029335/" target="_blank" rel="license noopener" title="豆瓣"><i class="icon icon-lg icon-douban"></i> </a></span><span><a href="https://www.zhihu.com/people/qinyuanpei" target="_blank" rel="license noopener" title="知乎"><i class="icon icon-lg icon-zhihu-square"></i> </a></span><span><a href="https://blog.csdn.net/qinyuanpei" target="_blank" rel="license noopener" title="CSDN"><i class="icon icon-lg">C</i> </a></span><span><a href="https://music.163.com/#/user/home?id=47002864" target="_blank" rel="license noopener" title="网易音乐"><i class="icon icon-lg icon-wangyiyunyinyue"></i></a></span></p></div><div class="bottom"><p><span>飞鸿踏雪 &copy; 2014 - 2021</span><br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & Theme by <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a><br></p><p>Hosted by <a href="https://pages.github.com" target="_blank" rel="noopener" style="font-weight:700">Github Pages</a></p><p></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/2171683728/&title=《函数式编程常用术语》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/2171683728/&title=《函数式编程常用术语》 — 一个人的孤落时辰&source=&emsp;&emsp;近年来函数式编程这种概念渐渐流行起来，尤其是在React/Vuejs这两个前端框架的推动下，函数式编程就像股新思潮一般瞬间席卷整个..." data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/2171683728/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《函数式编程常用术语》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/2171683728/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/2171683728/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/2171683728/" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.6/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/echarts-wordcloud.min.js" async></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis">{tags}</div><time class="flex-col time">{date}</time></div></a></li></template><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/search.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/heart.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/leancloud-counter.min.js"></script><script>(new VisitorCounter).init({appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",region:"华北",domain:"",collectIP:!0,collectUA:!0})</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/vconsole.min.js"></script><script type="text/javascript">if(location.href.indexOf("debug=true")>-1)var vConsole=new VConsole</script><script></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/ribbon.min.js"></script><script>var blocks=document.getElementsByTagName("blockquote");blocks.length>0&&"post-copyright"!=blocks[0].id&&(blocks[0].hidden=!0)</script></body></html>