<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="pragma" content="no-cache"><meta http-equiv="cache-control" content="no-cache"><meta name="msvalidate.01" content="713A48A3FE17D4841C292A6B3942EB4C"><title>.NET Core中对象池(Object Pool)的使用 | 一个人的孤落时辰</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="技巧,.NET Core,对象池,设计模式,秦元培,技术博客,生活随笔,个人博客,NET,Python,数据挖掘,数据分析,NLP"><meta name="description" content="因为此前实现基于RabbitMQ的EventBus的时候，我们是每次创建一个Channel，即官方所谓的“短连接”的方式，因为Channel本质上是Connection在TCP连接上的一个虚拟连接，所以，每次创建Channel都会占用一个TCP连接，当我们系统中的TCP连接被用完的时候，就会出现无法连接、连接过慢的问题，为了解决这个问题，我们最终引入了对象池，实际上这里是实现了一个Channel“池”，关于是否应该实现Connection“池”，这一点我还没有想好，总而言之，游戏世界里可以复用的GameObject、各种数据库里的连接池，都是对象池模式在各自领域中的具体实现，这就是这篇博客的内容啦，欢迎大家在评论中留言，谢谢大家;在这个项目中，它提供了一个持久化连接的类`DefaultRabbitMQPersistentConnection`，主要解决了RabbitMQ在连接断开后自动重连的问题，可实际上我们都知道，RabbitMQ提供的连接数是有一个上限的，如果频繁地使用短连接的方式，即通过`ConnectionFactory`的`CreateConnection()`方法来创建一个连接，从本质上讲，一个`Connection`对象就是一个TCP连接，而`Channel`则是每个`Connection`对象下有限的虚拟连接，注意“有限”这个限定词，这意味着`Channel`和`Connection`一样，都不能毫无节制的创建下去;实现对象池可以考虑`ConcurrentBag&lt;T&gt;`、`Stack&lt;T&gt;`、`Queue&lt;T&gt;`以及`BlockingCollection&lt;T&gt;`等多种数据结构，而微软在.NET Core中已经为我们实现了一个简单的对象池，大多数情况下，我们只需要定义自己的`IPooledObjectPolicy&lt;T&gt;`去决定对象应该怎么样“借”、怎么样“还”;public void Return(T item);return item"><meta name="description" content="因为此前实现基于RabbitMQ的EventBus的时候，我们是每次创建一个Channel，即官方所谓的“短连接”的方式，因为Channel本质上是Connection在TCP连接上的一个虚拟连接，所以，每次创建Channel都会占用一个TCP连接，当我们系统中的TCP连接被用完的时候，就会出现无法连接、连接过慢的问题，为了解决这个问题，我们最终引入了对象池，实际上这里是实现了一个Channel“"><meta property="og:type" content="article"><meta property="og:title" content=".NET Core中对象池(Object Pool)的使用"><meta property="og:url" content="https://qinyuanpei.github.io/posts/2414960312/index.html"><meta property="og:site_name" content="一个人的孤落时辰"><meta property="og:description" content="因为此前实现基于RabbitMQ的EventBus的时候，我们是每次创建一个Channel，即官方所谓的“短连接”的方式，因为Channel本质上是Connection在TCP连接上的一个虚拟连接，所以，每次创建Channel都会占用一个TCP连接，当我们系统中的TCP连接被用完的时候，就会出现无法连接、连接过慢的问题，为了解决这个问题，我们最终引入了对象池，实际上这里是实现了一个Channel“"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2020/08/22/lReo7LQa1SODZpc.png"><meta property="og:image" content="https://i.loli.net/2020/08/22/M6ojLtqgKc5pfCA.png"><meta property="article:published_time" content="2020-08-15T16:37:23.000Z"><meta property="article:modified_time" content="2021-08-06T08:54:37.437Z"><meta property="article:author" content="飞鸿踏雪"><meta property="article:tag" content="技巧"><meta property="article:tag" content=".NET Core"><meta property="article:tag" content="对象池"><meta property="article:tag" content="设计模式"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.loli.net/2020/08/22/lReo7LQa1SODZpc.png"><link rel="alternate" type="application/atom+xml" title="一个人的孤落时辰" href="/atom.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master//assets/styles/style.css"><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/instantclick.min.js"></script><script>window.lazyScripts=[]</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/brand.jpg)"><div class="brand"><a href="/" class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="avatar"></a><hgroup class="introduce"><h5 class="nickname">飞鸿踏雪</h5><a href="mailto:qinyuanpei@163.com" title="qinyuanpei@163.com" class="mail">qinyuanpei@163.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> 标签</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/books"><i class="icon icon-lg icon-bookmark"></i> 书单</a></li><li class="waves-block waves-effect"><a href="/movies"><i class="icon icon-lg icon-film"></i> 影单</a></li><li class="waves-block waves-effect"><a href="https://qinyuanpei.github.io/poems/"><i class="icon icon-lg icon-folder-open"></i> 诗集</a></li><li class="waves-block waves-effect"><a href="/works"><i class="icon icon-lg icon-code"></i> 实验室</a></li><li class="waves-block waves-effect"><a href="/about"><i class="icon icon-lg icon-circle"></i> 关于我</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">.NET Core中对象池(Object Pool)的使用</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i> </a><a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="menuGithub"><i class="icon icon-lg icon-code-fork"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">.NET Core中对象池(Object Pool)的使用</h1><h5 class="subtitle" id="subtitle"><time datetime="2020-08-15T16:37:23.000Z" itemprop="datePublished" class="page-time">2020-08-15</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>目录</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#什么是对象池"><span class="post-toc-number">1.</span> <span class="post-toc-text">什么是对象池</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#NET-Core中的对象池"><span class="post-toc-number">2.</span> <span class="post-toc-text">.NET Core中的对象池</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#回到起点"><span class="post-toc-number">3.</span> <span class="post-toc-text">回到起点</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#本文小结"><span class="post-toc-number">4.</span> <span class="post-toc-text">本文小结</span></a></li></ol></nav></aside><article id="post-NET-Core中对象池-Object-Pool-的使用" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">.NET Core中对象池(Object Pool)的使用</h1><div class="post-meta"><time class="post-time" title="2020-08-15 16:37:23" datetime="2020-08-15T16:37:23.000Z" itemprop="datePublished">2020-08-15</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul><span id="lc_counter_container_page_pv" title="文章总阅读量" data-page-url="" data-page-title=".NET Core中对象池(Object Pool)的使用"><i class="icon icon-eye icon-pr"></i><span id="lc_counter_value_page_pv"></span></span> <span><i class="icon icon-clock-o"></i> 20 min.</span></div><div class="post-content" id="post-content" itemprop="postContent"><p>在此前的博客中，博主参考 <a href="https://github.com/dotnet-architecture/eShopOnContainers" target="_blank" rel="noopener">eShopOnContainers</a> 实现了一个基于RabbitMQ的事件总线(EventBus)。在这个项目中，它提供了一个持久化连接的类<code>DefaultRabbitMQPersistentConnection</code>，主要解决了RabbitMQ在连接断开后自动重连的问题，可实际上我们都知道，RabbitMQ提供的连接数是有一个上限的，如果频繁地使用短连接的方式，即通过<code>ConnectionFactory</code>的<code>CreateConnection()</code>方法来创建一个连接，从本质上讲，一个<code>Connection</code>对象就是一个TCP连接，而<code>Channel</code>则是每个<code>Connection</code>对象下有限的虚拟连接，注意“有限”这个限定词，这意味着<code>Channel</code>和<code>Connection</code>一样，都不能毫无节制的创建下去。此时，官方推荐的做法有两种：(1)：一个<code>Connection</code>对应多个<code>Channel</code>同时保证每个<code>Channel</code>线程独占；(2)：创建一个<code>Connection</code>池同时定期清除无效连接。这里的第二种做法，显然就是我们今天要说的对象池(Object Pool)啦，我们将从这里拉开这篇博客的帷幕。</p><h1 id="什么是对象池"><a href="#什么是对象池" class="headerlink" title="什么是对象池"></a>什么是对象池</h1><p>首先，我们来回答第一个问题，什么是对象池？简单来说，它就是一种为对象提供可复用性能力的软件设计思路。俗话说<strong>“有借有还，再借不难”</strong>，而对象池就是通过“借”和“还”这样两个动作来保证对象可以被重复使用，进而节省频繁创建对象的性能开销。对象池在游戏设计中使用的更普遍一点，因为游戏中大量存在着像子弹、怪物等等这类可复用的对象，你在玩第一人称射击游戏(FPS)时，总是有源源不断的子弹或者丧尸出现，可事实上这不过是数字世界的循环再生，因为玩家的电脑内存始终都有一个上限。而在数据库的世界里，则存在着一个被称为“连接池”的东西，每当出现数据库无法连接的情况时，经验丰富的开发人员往往会先检查“连接池”是否满了，这其实就是对象池模式在特定领域的具体实现啦，所以，对象池本质上就是负责一组对象创建和销毁的容器，下面是一个基本的对象池示意图：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2020/08/22/lReo7LQa1SODZpc.png" alt="对象池示意图" referrerpolicy="no-referrer"></div><div class="image-caption">对象池示意图</div></figure><p>可以注意到， 对象池最大的优势就是可以自主地管理“池子”内的每个对象，决定它们是需要被回收还是可以重复使用。我们都知道，创建一个新的对象，需要消耗一定的系统资源，而一旦这些对象可以重复地使用，就能有效地节省系统资源的开销，这对于我们提高系统性能会非常有帮助。也许，现在计算机的硬件水平越来越好，可我们还是要重新拾起这个领域的基础知识，即数据结构、算法、数学和英语。如果你完全理解了对象池模式，你应该可以非常轻松地给出你的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectPool&lt;T&gt; : IObjectPool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Func&lt;T&gt; _instanceFactory;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentBag&lt;T&gt; _instanceItems;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ObjectPool</span>(<span class="params">Func&lt;T&gt; instanceFactory</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    _instanceFactory = instanceFactory ?? </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(instanceFactory));</span><br><span class="line">    _instanceItems = <span class="keyword">new</span> ConcurrentBag&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="keyword">if</span> (_instanceItems.TryTake(<span class="keyword">out</span> item)) <span class="keyword">return</span> item;</span><br><span class="line">    <span class="keyword">return</span> _instanceFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Return</span>(<span class="params">T item</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    _instanceItems.Add(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上代码片段来自微软的一篇文档：<a href="https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-create-an-object-pool" target="_blank" rel="noopener">How to: Create an Object Pool by Using a ConcurrentBag</a>。实际上，除了<code>ConcurrentBag&lt;T&gt;</code>，我们可以选择的数据结构还可以是<code>Stack&lt;T&gt;</code>、<code>Queue&lt;T&gt;</code>以及<code>BlockingCollection&lt;T&gt;</code>，此中差别，大家可以自己去体会。</p><h1 id="NET-Core中的对象池"><a href="#NET-Core中的对象池" class="headerlink" title=".NET Core中的对象池"></a>.NET Core中的对象池</h1><p>在.NET Core中，微软已经为我们提供了对象池的实现，即<code>Microsoft.Extensions.ObjectPool</code>。它主要提供了三个核心的组件，分别是<code>ObjectPool</code>、<code>ObjectPoolProvider</code>和<code>IPooledObjectPolicy</code>，关于这三者间的关系，我绘制了下面的UML图来作为说明：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://i.loli.net/2020/08/22/M6ojLtqgKc5pfCA.png" alt="ObjectPool核心组件及其关系" referrerpolicy="no-referrer"></div><div class="image-caption">ObjectPool核心组件及其关系</div></figure><p>可以注意到，<code>ObjectPool&lt;T&gt;</code>是一个抽象类，它对外提供了Get()和Return()两个方法，所谓的“有借有还”，这一点没什么可说的。接下来，<code>ObjectPoolProvider</code>同样是一个抽象类，它的职责就是创建<code>ObjectPool&lt;T&gt;</code>，所以，它提供了两个<code>Create&lt;T&gt;()</code>方法，两者的区别是，无参数版本本质上使用的是<code>DefaultPooledObjectPolicy&lt;T&gt;</code>。顾名思义，它同<code>DefaultObjectPool&lt;T&gt;</code>、<code>DefaultObjectPoolProvider</code>一样，都是微软提供的默认实现，其中<code>IPooledObjectPolicy&lt;T&gt;</code>可以为不同的对象池定义不同的策略，来决定对象如何“借”、是否可以“还”。默认的对象池<code>DefaultObjectPool&lt;T&gt;</code>内部使用<code>ObjectWrapper[]</code>这个数组来管理对象，数组的大小等于maximumRetained - 1，因为它单独指定了首项，默认情况下，这个maximumRetained等于<code>Environment.ProcessorCount * 2</code>，这里主要用到了<code>Interlocked.CompareExchange()</code>方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> T <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> item = _firstItem;</span><br><span class="line">  <span class="keyword">if</span> (item == <span class="literal">null</span> || Interlocked.CompareExchange(<span class="keyword">ref</span> _firstItem, <span class="literal">null</span>, item) != item)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> items = _items;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      item = items[i].Element;</span><br><span class="line">      <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; Interlocked.CompareExchange(<span class="keyword">ref</span> items[i].Element, <span class="literal">null</span>, item) == item)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item = Create();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-inline to improve its code quality as uncommon path</span></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">Create</span>(<span class="params"></span>)</span> =&gt; _fastPolicy?.Create() ?? _policy.Create();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Return</span>(<span class="params">T obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_isDefaultPolicy || (_fastPolicy?.Return(obj) ?? _policy.Return(obj)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_firstItem != <span class="literal">null</span> || Interlocked.CompareExchange(<span class="keyword">ref</span> _firstItem, obj, <span class="literal">null</span>) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> items = _items;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.Length &amp;&amp; Interlocked.CompareExchange(<span class="keyword">ref</span> items[i].Element, obj, <span class="literal">null</span>) != <span class="literal">null</span>; ++i)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要用到<code>Interlocked.CompareExchange()</code>这个方法，对于<code>Get()</code>方法而言，它将<code>items[i].Element</code>和<code>null</code>进行交换，相当于将指定元素设为null并返回原始值；而对于<code>Return()</code>方法而言，如果将<code>items[i].Element</code>和<code>obj</code>交换后的值不为null，则表示指定元素已经“归还”，因为这个方法只有在第一个参数和第三个参数相等时才会发生交换。好了，了解了.NET Core中对象池的实现以后，我们来一起看看具体的使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> service = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用DefaultObjectPoolProvider</span></span><br><span class="line">service.AddSingleton&lt;ObjectPoolProvider, DefaultObjectPoolProvider&gt;();</span><br><span class="line"><span class="comment">//使用默认策略</span></span><br><span class="line">service.AddSingleton&lt;ObjectPool&lt;Foo&gt;&gt;(serviceProvider =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> objectPoolProvider = serviceProvider.GetRequiredService&lt;ObjectPoolProvider&gt;();</span><br><span class="line">  <span class="keyword">return</span> objectPoolProvider.Create&lt;Foo&gt;();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//使用自定义策略</span></span><br><span class="line">service.AddSingleton&lt;ObjectPool&lt;Foo&gt;&gt;(serviceProvider =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> objectPoolProvider = serviceProvider.GetRequiredService&lt;ObjectPoolProvider&gt;();</span><br><span class="line">  <span class="keyword">return</span> objectPoolProvider.Create(<span class="keyword">new</span> FooObjectPoolPolicy());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceProvider = _service.BuildServiceProvider();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectPool = _serviceProvider.GetService&lt;ObjectPool&lt;Foo&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有借有还，两次是同一个对象</span></span><br><span class="line"><span class="keyword">var</span> item1 = objectPool.Get();</span><br><span class="line">objectPool.Return(item1);</span><br><span class="line"><span class="keyword">var</span> item2 = objectPool.Get();</span><br><span class="line">Assert.AreEqual(item1, item2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有借无还，两次是不同的对象</span></span><br><span class="line"><span class="keyword">var</span> item3 = objectPool.Get();</span><br><span class="line"><span class="keyword">var</span> item4 = objectPool.Get();</span><br><span class="line">Assert.AreEqual(item3, item4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>其中，<code>Foo</code>和<code>FooObjectPoolPolicy</code>是两个非常典型的“工具类”，类似我们所说的“工具人”：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> DateTime? CreatedAt &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> CreatedBy &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FooObjectPoolPolicy : IPooledObjectPolicy&lt;Foo&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Foo <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Foo()</span><br><span class="line">    &#123;</span><br><span class="line">      Id = Guid.NewGuid().ToString(<span class="string">"N"</span>),</span><br><span class="line">      CreatedAt = DateTime.Now,</span><br><span class="line">      CreatedBy = <span class="string">"Ezio"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Return</span>(<span class="params">Foo obj</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你需要控制对象池内的对象如何被创建的时候，你可以考虑实现自定义的<code>IPooledObjectPolicy&lt;T&gt;</code>，否则，<code>DefaultPooledObjectPolicy&lt;T&gt;</code>这个默认实现完全可以满足你的使用，而这就是.NET Core中对象池的所有用法，一个实现起来并不复杂但是在某些场景下非常有用的软件设计模式。</p><h1 id="回到起点"><a href="#回到起点" class="headerlink" title="回到起点"></a>回到起点</h1><p>好了，回到我们一开始的问题，即：如何解决RabbitMQ在多次重连后提示连接数不足的问题。由于Channel对象本质上是Connection对象上的TCP连接的软连接，所以，每当创建一个新的Channel的时候，实际上会独占一个TCP连接。考虑到在使用RabbitMQ的时候，发布消息/消费消息每次都是创建一个Channel，在高并发场景下可能会导致TCP连接数被用完，进而出现无法连接或者响应过慢等一系列问题。既然TCP连接数是有限的，为什么不考虑复用这些TCP连接呢？从这个角度上来看，数据库连接池承担了相同的角色，增加连接数说到底是一种“治标不治本”的做法。在具体实现上，可以考虑Connection“池”和Channel“池”，我们我们像官方推荐的做法一样，一个Connection对应多个Channel，实际上只需要实现Channel“池”。除非在多个Connection对应多个Channel的情况下，我们需要考虑同时实现Connection“池”和Channel“池”。坦白说，我这里一直没能找到实现Connection“池”的相关资料，高冷的 <a href="https://www.cnblogs.com/catcher1994/" target="_blank" rel="noopener">Catcher</a> 大神只是让我去认真读官方文档，搞清楚Connection和Channel的关系。而这个Channel“池”的实现，结合这篇博客里的内容，实现起来是非常简单的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ChannelObjectPoolPolicy : IPooledObjectPolicy&lt;IModel&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IConnectionFactory _connectionFactory;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChannelObjectPoolPolicy</span>(<span class="params">IConnectionFactory connectionFactory</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    _connectionFactory = connectionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IModel <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> connection = _connectionFactory.CreateConnection();</span><br><span class="line">    <span class="keyword">return</span> connection.CreateModel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Return</span>(<span class="params">IModel obj</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj.IsOpen)</span><br><span class="line">    &#123;</span><br><span class="line">      obj?.Dispose();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步是实现<code>IPooledObjectPolicy&lt;IModel&gt;</code>，注意到，这里通过构造函数注入了<code>ConnectionFactory</code>，所以，除了常规的注入项以外，这里还需要注入<code>ConnectionFactory</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IConnectionFactory, ConnectionFactory&gt;(sp =&gt; <span class="keyword">new</span> ConnectionFactory() &#123; </span><br><span class="line">    HostName = <span class="string">"localhost"</span>, </span><br><span class="line">    UserName = <span class="string">"guest"</span>, </span><br><span class="line">    Password = <span class="string">"guest"</span> </span><br><span class="line">&#125;);</span><br><span class="line">services.AddSingleton&lt;ObjectPoolProvider, DefaultObjectPoolProvider&gt;();</span><br><span class="line">services.AddSingleton&lt;ObjectPool&lt;IModel&gt;&gt;(serviceProvider =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> objectPoolProvider = serviceProvider.GetRequiredService&lt;ObjectPoolProvider&gt;();</span><br><span class="line">  <span class="keyword">var</span> connectionFactory = serviceProvider.GetRequiredService&lt;ConnectionFactory&gt;();</span><br><span class="line">  <span class="keyword">return</span> objectPoolProvider.Create(<span class="keyword">new</span> ChannelObjectPoolPolicy(connectionFactory));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，我们只需要在EventBus里注入<code>ObjectPool&lt;IModel&gt;</code>即可，此时，我们调用Channel的画风是下面这样子的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = _channelPool.Get();</span><br><span class="line"><span class="keyword">try</span> &#123;  <span class="comment">//在这里做点什么吧  &#125;</span></span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//好借好还，再借不难</span></span><br><span class="line">  _channelPool.Return(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Connection“池”的实现，我认为我的想法还不太成熟，暂时列入未来的思考计划中，所以，这篇博客就先写到这里。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>对象池(ObjectPool)是一种通过复用对象来减少资源开销进而实现提高系统性能的软件设计模式，其核心是控制容器内对象的生命周期来规避系统的主动回收，从对象池中(ObjectPool)“借”出的对象必须要及时“归还”，否则会造成对象池(ObjectPool)中没有可用资源。实现对象池可以考虑<code>ConcurrentBag&lt;T&gt;</code>、<code>Stack&lt;T&gt;</code>、<code>Queue&lt;T&gt;</code>以及<code>BlockingCollection&lt;T&gt;</code>等多种数据结构，而微软在.NET Core中已经为我们实现了一个简单的对象池，大多数情况下，我们只需要定义自己的<code>IPooledObjectPolicy&lt;T&gt;</code>去决定对象应该怎么样“借”、怎么样“还”。因为此前实现基于RabbitMQ的EventBus的时候，我们是每次创建一个Channel，即官方所谓的“短连接”的方式，因为Channel本质上是Connection在TCP连接上的一个虚拟连接，所以，每次创建Channel都会占用一个TCP连接，当我们系统中的TCP连接被用完的时候，就会出现无法连接、连接过慢的问题，为了解决这个问题，我们最终引入了对象池，实际上这里是实现了一个Channel“池”，关于是否应该实现Connection“池”，这一点我还没有想好，总而言之，游戏世界里可以复用的GameObject、各种数据库里的连接池，都是对象池模式在各自领域中的具体实现，这就是这篇博客的内容啦，欢迎大家在评论中留言，谢谢大家！</p><div class="recommended_posts"><h1>推荐阅读</h1><ul><li><a href="https://qinyuanpei.github.io/posts/305484621/">C#中的扩展方法学习总结</a></li><li><a href="https://qinyuanpei.github.io/posts/116795088/">.NET Core POCOController在动态Web API中的应用</a></li><li><a href="https://qinyuanpei.github.io/posts/1734098504/">.NET Core原生DI扩展之基于名称的注入实现</a></li><li><a href="https://qinyuanpei.github.io/posts/1658310834/">.NET Core原生DI扩展之属性注入实现</a></li><li><a href="https://qinyuanpei.github.io/posts/3247093203/">使用多线程为你的Python爬虫提速的N种姿势，你会几种？</a></li></ul></div></div><blockquote class="post-copyright"><div class="content"><p><b>版权声明：</b> <a href="https://qinyuanpei.github.io/posts/2414960312/" rel="external">.NET Core中对象池(Object Pool)的使用</a> ，由&nbsp;<a href="/about" target="_blank" rel="external">飞鸿踏雪</a>&nbsp; 首次发表于&nbsp;<a href="/" target="_blank" rel="external">一个人的孤落时辰</a>&nbsp; ，本文地址为：<a href="https://qinyuanpei.github.io/posts/2414960312/" target="_blank" rel="external">https://qinyuanpei.github.io/posts/2414960312/</a> ，转载请注明 <b>作者</b> 和 <b>出处</b> 。</p></div><footer><a href="https://qinyuanpei.github.io"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="飞鸿踏雪"> 飞鸿踏雪</a></footer></blockquote><div class="page-reward"><a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NET-Core/" rel="tag">.NET Core</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0/" rel="tag">对象池</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E5%B7%A7/" rel="tag">技巧</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/2414960312/&title=《.NET Core中对象池(Object Pool)的使用》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/2414960312/&title=《.NET Core中对象池(Object Pool)的使用》 — 一个人的孤落时辰&source=一个人的孤落时辰 | 纵有疾风起，人生不言弃 | 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地 | 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/2414960312/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《.NET Core中对象池(Object Pool)的使用》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/2414960312/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/2414960312/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/posts/3086300103/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">Dapper.Contrib在Oracle环境下引发ORA-00928异常问题的解决</h4></a></div><div class="waves-block waves-effect next"><a href="/posts/3424138425/" id="post-next" class="post-nav-link"><div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">利用MySQL的Binlog实现数据同步与订阅(下)：EventBus篇</h4></a></div></nav><div id="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">new Valine({el:"#comment",notify:!1,verify:!0,appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",placeholder:"云中谁寄锦书来，雁字回时，月满西楼。&#10;Tips：如果希望收到我的评论回复，请至少留下你的邮箱哦:)",path:"https://qinyuanpei.github.io/posts/2414960312/",avatar:"identicon",requiredFields:["nick","mail"]})</script></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 赠人玫瑰，手有余香 <i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" alt="打赏二维码"></div><label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" data-alipay="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/alipay.jpg"><div class="reward-toggle-ctrol"><span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-label"></span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div><script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/yoniu.min.js"></script><style type="text/css">body.active-yp{overflow:hidden}.yp-fc-btn{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:space-between;font-size:13px}.yp-fc-btn span{cursor:pointer;padding:2px 10px;color:#4b4b4b;border:#4b4b4b 1px solid;border-radius:5px}#yp-hide{position:fixed;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:center;flex-direction:column;left:0;top:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);z-index:99999;visibility:hidden}#yoniu-poster{box-sizing:border-box;width:350px;height:467.2px;background-color:#fff;margin:0 auto;padding:0;line-height:1.6;text-align:justify}.yp-img{min-height:240px;position:relative;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:flex-end;flex-direction:column;background-position:50% 50%;background-size:cover;overflow:hidden}.yp-img>div{padding:10px 20px}.yp-name{display:block;color:#fff;font-size:20px;font-weight:600;text-shadow:#4b4b4b .1em .1em .2em;margin-top:10px}.yp-sort{padding:3px 10px;font-size:12px;color:#fff;background:#2e2e2e}.yp-des{color:#2e2e2e;font-size:14px;margin:20px;height:67.2px}.yp-qcode{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;margin:10px;padding:10px 20px;background:#f5f5f5;color:#818181;border-radius:10px}.yp-tips{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;color:#ccc;margin:0 10px 10px;font-size:10px;letter-spacing:1.5px}.yp-btns{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:stretch;justify-content:center;width:350px;margin:0 auto}.yp-btns>span{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:center;font-size:14px;padding:10px 15px;background:rgba(0,0,0,.2);color:#f5f5f5;cursor:pointer}.yp-btns>span>a{color:#f5f5f5}.yp-btns>span>a:hover{text-decoration:none}#yp-close{font-size:18px;font-weight:600}</style><div id="yp-hide"><div id="yoniu-poster"><div class="yp-img" id="yp-img"><div><span class="yp-sort"></span> <span class="yp-name">.NET Core中对象池(Object Pool)的使用</span></div></div><div class="yp-des">在此前的博客中，博主参考 eShopOnContainers 实现了一个基于RabbitMQ的事件总线(EventBus)。在这个项目中，它提供...</div><div class="yp-qcode"><span>扫描二维码阅读原文</span> <img id="yp-qcode" width="64px" src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/2414960312/"></div><div class="yp-tips"><span>一个人的孤落时辰</span> <span><time class="post-time" title="2020-08-15 16:37:23" datetime="2020-08-15T16:37:23.000Z" itemprop="datePublished">2020-08-15</time></span></div></div><div class="yp-btns"><span id="yp-load-yp" onclick="load_yp()">生成海报</span> <span><a id="yp-download"></a></span> <span id="yp-close" onclick="close_yp()">×</span></div></div><script type="text/javascript">function show_yp(){window.scrollTo(0,0),document.body.setAttribute("class","active-yp");let e=document.getElementsByTagName("img")[1];null!=e&&void 0!==e?document.getElementById("yp-img").style.backgroundImage=`url(${e.src})`:document.getElementById("yp-img").style.backgroundColor="#d7dbf0",document.getElementById("yp-hide").style.visibility="visible"}function close_yp(){var e=document.body.getAttribute("class");e=e.replace("active-yp",""),document.body.setAttribute("class",e),document.getElementById("yp-hide").style.visibility="hidden"}function load_yp(){document.getElementById("yp-load-yp").textContent="海报生成中...",setTimeout((function(){h2c_()}),2e3)}</script></div><footer class="footer"><div class="top"><p><span id="lc_counter_container_site_uv"><i class="icon icon-user"></i><span id="lc_counter_value_site_uv"></span> </span><span id="lc_counter_container_site_pv"><i class="icon icon-eye"></i><span id="lc_counter_value_site_pv"></span></span></p><p><a id="jinrishici-sentence" href="https://www.jinrishici.com/" target="_blank" rel="noopener">加载中</a></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><script>jinrishici.load((function(e){document.querySelector("#subtitle").innerText=e.data.content,document.querySelector("#jinrishici-sentence").innerText=e.data.content}))</script><p><span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span> <span><a href="https://github.com/qinyuanpei" target="_blank" rel="license noopener" title="Github"><i class="icon icon-lg icon-github"></i> </a></span><span><a href="https://weibo.com/1278609231/profile" target="_blank" rel="license noopener" title="微博"><i class="icon icon-lg icon-weibo"></i> </a></span><span><a href="https://www.douban.com/people/60029335/" target="_blank" rel="license noopener" title="豆瓣"><i class="icon icon-lg icon-douban"></i> </a></span><span><a href="https://www.zhihu.com/people/qinyuanpei" target="_blank" rel="license noopener" title="知乎"><i class="icon icon-lg icon-zhihu-square"></i> </a></span><span><a href="https://blog.csdn.net/qinyuanpei" target="_blank" rel="license noopener" title="CSDN"><i class="icon icon-lg">C</i> </a></span><span><a href="https://music.163.com/#/user/home?id=47002864" target="_blank" rel="license noopener" title="网易音乐"><i class="icon icon-lg icon-wangyiyunyinyue"></i></a></span></p></div><div class="bottom"><p><span>飞鸿踏雪 &copy; 2014 - 2021</span><br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & Theme by <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a><br></p><p>Hosted by <a href="https://pages.github.com" target="_blank" rel="noopener" style="font-weight:700">Github Pages</a></p><p></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/2414960312/&title=《.NET Core中对象池(Object Pool)的使用》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/2414960312/&title=《.NET Core中对象池(Object Pool)的使用》 — 一个人的孤落时辰&source=一个人的孤落时辰 | 纵有疾风起，人生不言弃 | 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地 | 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/2414960312/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《.NET Core中对象池(Object Pool)的使用》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/2414960312/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/2414960312/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/2414960312/" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.6/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/echarts-wordcloud.min.js" async></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis">{tags}</div><time class="flex-col time">{date}</time></div></a></li></template><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/search.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/heart.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/leancloud-counter.min.js"></script><script>(new VisitorCounter).init({appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",region:"华北",domain:"",collectIP:!0,collectUA:!0})</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/vconsole.min.js"></script><script type="text/javascript">if(location.href.indexOf("debug=true")>-1)var vConsole=new VConsole</script><script></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/ribbon.min.js"></script></body></html>