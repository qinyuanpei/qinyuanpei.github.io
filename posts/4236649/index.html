<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="pragma" content="no-cache"><meta http-equiv="cache-control" content="no-cache"><meta name="msvalidate.01" content="713A48A3FE17D4841C292A6B3942EB4C"><title>通过动态Controller实现从WCF到Web API的迁移. | 一个人的孤落时辰</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="RESTful,WebApi,动态代理,秦元培,技术博客,生活随笔,个人博客,NET,Python,数据挖掘,数据分析,NLP"><meta name="description" content="DynamicControllerActivator 实现了IHttpControllerActivator接口，这里我们通过单例模式获得了DynamicHttpControllerManager对象的一个实例，其内部封装了Castle的容器接口IWindsorContainer，所以，在这里我们直接通过controllerType从容器中Resolve对应的Controller即可，而默认情况下，所有的Controller都实现了IHttpController接口，所以，这一步我们需要做一个显示的类型转换，后面我们会通过它替换微软默认的实现，这样，当一个请求被发送过来的时候，我们实际上是从这个自定义容器中获取对应Controller的实例;老实说，通过自定义IHttpControllerActivator的方式实现依赖注入的方式并不常见，因为更一般的情况是，大家在Global.asax里初始化像Unity、Autofac等等类似的容器，然后在Controller里通过容器去Resolve一个服务出来，对于IHttpControllerActivator接口而言，它只有一个Create()方法，在这篇文章中，我们是通过Castle这个容器来实现依赖注入的，所以，你大概可以想象出它的过程，首先把所有动态生成的Controller全部注入到Ioc容器中，然后再根据传入的类型获取对应Controller的实例;在这个过程中，我们回顾了ASP.NET MVC的基本原理，了解了MVC是如何根据路由筛选Controller、激活Controller和筛选Action，在此基础上，我们对微软的MVC进行了一次Hack，使用我们自定义的组件替换了微软的默认实现，从而可以让原来托管在ServiceHost上的接口，通过Web API来访问和调用;同理，我们还需要告诉MvcHandler，它应该调用哪个方法，这时候我们需要IHttpActionSelector，因为从路由信息中我们可以提取到ActionName参数，因此，通过通过typeof(Controller).GetMethod(ActionName)，就可以获得对应ActionName对应的方法，熟悉反射的朋友应该都知道，它会返回MethodInfo这个类型，实际上IHttpActionSelector所做的事情，就是把MethodInfo传给MvcHandler，因为此时只要通过反射调用这个方法即可，Controller的实例在上一步就创建好了，而调用方法所需要的参数，则被存储在当前请求的上下文HttpContext里面，至此万事具备;我们都知道在ASP.NET下，要写一个Web API必须继承ApiController，就是说这个类必须实现了IHttpController接口，就是因为有这个限制，所以，我们不得不通过Castle来动态生成一个Controller，既然现在ASP.NET Core里可以打破这一限制，那么实现起来自然会非常简单"><meta name="description" content="DynamicControllerActivator 实现了IHttpControllerActivator接口，这里我们通过单例模式获得了DynamicHttpControllerManager对象的一个实例，其内部封装了Castle的容器接口IWindsorContainer，所以，在这里我们直接通过controllerType从容器中Resolve对应的Controller即可，而默认情况下"><meta property="og:type" content="article"><meta property="og:title" content="通过动态Controller实现从WCF到Web API的迁移."><meta property="og:url" content="https://qinyuanpei.github.io/posts/4236649/index.html"><meta property="og:site_name" content="一个人的孤落时辰"><meta property="og:description" content="DynamicControllerActivator 实现了IHttpControllerActivator接口，这里我们通过单例模式获得了DynamicHttpControllerManager对象的一个实例，其内部封装了Castle的容器接口IWindsorContainer，所以，在这里我们直接通过controllerType从容器中Resolve对应的Controller即可，而默认情况下"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g4a1c3r3i8j20rz0f43yj.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g49w0oxqkej20p50fuwfa.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g49z1cvrw3j20pe05njrj.jpg"><meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g49z2ku45tj20il06dmxa.jpg"><meta property="article:published_time" content="2019-06-08T13:48:41.000Z"><meta property="article:modified_time" content="2021-06-23T05:36:14.065Z"><meta property="article:author" content="飞鸿踏雪"><meta property="article:tag" content="RESTful"><meta property="article:tag" content="WebApi"><meta property="article:tag" content="动态代理"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g4a1c3r3i8j20rz0f43yj.jpg"><link rel="alternate" type="application/atom+xml" title="一个人的孤落时辰" href="/atom.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master//assets/styles/style.css"><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/instantclick.min.js"></script><script>window.lazyScripts=[]</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading" class="active"></div><aside id="menu" class="hide"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/brand.jpg)"><div class="brand"><a href="/" class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="avatar"></a><hgroup class="introduce"><h5 class="nickname">飞鸿踏雪</h5><a href="mailto:qinyuanpei@163.com" title="qinyuanpei@163.com" class="mail">qinyuanpei@163.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> 标签</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/books"><i class="icon icon-lg icon-bookmark"></i> 书单</a></li><li class="waves-block waves-effect"><a href="/movies"><i class="icon icon-lg icon-film"></i> 影单</a></li><li class="waves-block waves-effect"><a href="https://qinyuanpei.github.io/poems/"><i class="icon icon-lg icon-folder-open"></i> 诗集</a></li><li class="waves-block waves-effect"><a href="/works"><i class="icon icon-lg icon-code"></i> 实验室</a></li><li class="waves-block waves-effect"><a href="/about"><i class="icon icon-lg icon-circle"></i> 关于我</a></li></ul></div></div></aside><main id="main"><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">通过动态Controller实现从WCF到Web API的迁移.</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i> </a><a href="https://github.com/qinyuanpei/qinyuanpei.github.io" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="menuGithub"><i class="icon icon-lg icon-code-fork"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">通过动态Controller实现从WCF到Web API的迁移.</h1><h5 class="subtitle" id="subtitle"><time datetime="2019-06-08T13:48:41.000Z" itemprop="datePublished" class="page-time">2019-06-08</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>目录</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#如何对类和接口进行组合"><span class="post-toc-number">1.</span> <span class="post-toc-text">如何对类和接口进行组合</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#重温ASP-NET-MVC原理"><span class="post-toc-number">2.</span> <span class="post-toc-text">重温ASP.NET MVC原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一张图了解MVC"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">一张图了解MVC</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#IControllerFactory接口"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">IControllerFactory接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#IHttpControllerActivator接口"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">IHttpControllerActivator接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#IHttpControllerSelector接口"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">IHttpControllerSelector接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#IhttpActionSelector接口"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">IhttpActionSelector接口</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#关键组件的自定义实现"><span class="post-toc-number">3.</span> <span class="post-toc-text">关键组件的自定义实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DynamicControllerActivator"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">DynamicControllerActivator</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DynamicHttpControllerSelector"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">DynamicHttpControllerSelector</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DynamicHttpActionSelector"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">DynamicHttpActionSelector</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#容器注册及服务替换"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">容器注册及服务替换</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#接口迁移后的二三事"><span class="post-toc-number">4.</span> <span class="post-toc-text">接口迁移后的二三事</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP动词支持"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">HTTP动词支持</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#接口返回值优化"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">接口返回值优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#POCOController"><span class="post-toc-number">5.</span> <span class="post-toc-text">POCOController</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#本文小结"><span class="post-toc-number">6.</span> <span class="post-toc-text">本文小结</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#参考文章"><span class="post-toc-number">7.</span> <span class="post-toc-text">参考文章</span></a></li></ol></nav></aside><article id="post-通过动态Controller实现从WCF到Web-API的迁移" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">通过动态Controller实现从WCF到Web API的迁移.</h1><div class="post-meta"><time class="post-time" title="2019-06-08 13:48:41" datetime="2019-06-08T13:48:41.000Z" itemprop="datePublished">2019-06-08</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul><span id="lc_counter_container_page_pv" title="文章总阅读量" data-page-url="" data-page-title="通过动态Controller实现从WCF到Web API的迁移."><i class="icon icon-eye icon-pr"></i><span id="lc_counter_value_page_pv"></span></span> <span><i class="icon icon-clock-o"></i> 45 min.</span></div><div class="post-content" id="post-content" itemprop="postContent"><p>在《<strong>又见AOP之基于RealProxy实现WCF动态代理</strong>》这篇文章中，我和大家分享了关于使用动态代理来简化WCF调用过程的相关内容，当时我试图解决的问题是，项目中大量通过T4生成甚至手动编写的“代理方法”。今天，我想和大家分享的是，如何通过动态的Controller来实现从WCF到Web API的迁移。为什么会有这个环节呢？因为我们希望把一个老项目逐步迁移到.NET Core上面，在这个过程中首当其冲的就是WCF，它在项目中主要承担着内部RPC的角色，因为.NET Core目前尚未提供针对WCF服务端的支持，因此面对项目中成百上千的WCF接口，我们必须通过Web API重新“包装”一次，区别于那些通过逐个API进行改造的方式，这里我们通过Castle动态生成Controller来实现从WCF到Web API的迁移。</p><h1 id="如何对类和接口进行组合"><a href="#如何对类和接口进行组合" class="headerlink" title="如何对类和接口进行组合"></a>如何对类和接口进行组合</h1><p>首先，我们来思考这样一个问题，假设现在有一个类BaseClass、一个接口IBaseService及其实现类BaseService，我们有没有什么办法，可以让这个类和接口组合起来呢？联系面向对象编程的相关知识，我们应该可以想到最常见的两种方式，即BaseService继承BaseClass(或者反过来)、BaseClass实现IBaseService接口。考虑到语言本身是否支持多继承的因素，第二种方式可能会更具有适用性。可如果这个问题，就仅仅到这种程度，我相信大家一定会感到失望，因为这的确没有什么好说的。现在的问题是，假如BaseClass类、BaseService类都已经存在了，我们有没有什么思路，可以把它们组合到一个类中呢？这又和我们今天要讨论的内容有什么关系呢？</p><p>好了，不卖关子啦，下面隆重请出Castle中的Dynamic Proxy，我们曾经介绍过Castle中的动态代理，它可以为指定的类和接口创建对应的代理类，除此以外，它提供了一种称为<strong>AdditionalInterfaces</strong>的接口，这个接口可以在某个代理对象上“组合”一个或者多个接口，换句话说，代理对象本身包含被代理对象的全部功能，同时又可以包含某个接口的全部功能，这样就实现了一个类和一个接口的组合。为什么我们会需要这样一个功能呢？因为假如我们可以把一个ApiController类和指定的接口类如CalculatorService进行组合，在某种程度上，CalculatorService就变成了一个ApiController，这样就实现了我们的目标的第一步，即动态生成一个ApiController。与此同时，它会包含我们现有的全部功能，为了方便大家理解，我们从下面这个简单的例子开始：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> IEchoService定义</span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEchoService</span> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Echo</span> (<span class="params"><span class="keyword">string</span> receiver</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> IEchoServicee实现</span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EchoService</span> : <span class="title">IEchoService</span> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Echo</span> (<span class="params"><span class="keyword">string</span> receiver</span>)</span> &#123;</span><br><span class="line">         Console.WriteLine (<span class="string">$"Hi，<span class="subst">&#123;receiver&#125;</span>"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> 空类EmptyClass</span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmptyClass</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EchoInterceptor</span> : <span class="title">IInterceptor</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> IEchoService _realObject;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">EchoInterceptor</span> (<span class="params">IEchoService realObject</span>)</span> &#123;</span><br><span class="line">         _realObject = realObject;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Intercept</span> (<span class="params">IInvocation invocation</span>)</span> &#123;</span><br><span class="line">         invocation.Method.Invoke (_realObject, invocation.Arguments);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> container = <span class="keyword">new</span> WindsorContainer ();</span><br><span class="line"> container.Register (</span><br><span class="line">     Component.For&lt;EchoService, IEchoService&gt;(),</span><br><span class="line">     Component.For (<span class="keyword">typeof</span> (EchoInterceptor)).LifestyleTransient(),</span><br><span class="line">     Component.For (<span class="keyword">typeof</span> (EmptyClass)).Proxy.AdditionalInterfaces (<span class="keyword">typeof</span>(IEchoService))</span><br><span class="line">     .Interceptors (<span class="keyword">typeof</span> (EchoInterceptor)).LifestyleTransient()</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> emptyClass = container.Resolve&lt;EmptyClass&gt; ();</span><br><span class="line"> <span class="keyword">var</span> methodInfo = emptyClass.GetType().GetMethod (<span class="string">"Echo"</span>);</span><br><span class="line"> methodInfo.Invoke (emptyClass, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="string">"Dynamic WebApi"</span> &#125;);</span><br></pre></td></tr></table></figure><p>此时，我们会发现通过Castle动态生成的代理类，同时具备了类和接口的功能。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/4c36074fly1g4a1c3r3i8j20rz0f43yj.jpg" alt="通过Castle实现类和接口的组合功能" referrerpolicy="no-referrer"></div><div class="image-caption">通过Castle实现类和接口的组合功能</div></figure><h1 id="重温ASP-NET-MVC原理"><a href="#重温ASP-NET-MVC原理" class="headerlink" title="重温ASP.NET MVC原理"></a>重温ASP.NET MVC原理</h1><p>OK，通过第一个例子，我们已经达到了第一个目的。接下来，顺着这个思路，我们不妨想象一下，如果把这个BaseClass换成BaseController会怎么样呢？因为在一个OO的语言里，一切都是Class，所以，Web开发中的Controller同样不会脱离这个体系。不过，在这之前，我们需要复习下ASP.NET MVC的原理，为什么要说这个呢？因为接下来的内容，都和它有重大的关联，我们实际上是自己实现了ASP.NET MVC中几个关键的环节，所以，在博主看来，这部分内容是非常重要的，这几乎是这篇文章中实现的最细节部分，因为第一个目标，说句实话，Castle帮我们简化到了只有4行代码。</p><h2 id="一张图了解MVC"><a href="#一张图了解MVC" class="headerlink" title="一张图了解MVC"></a>一张图了解MVC</h2><p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g49w0oxqkej20p50fuwfa.jpg" alt=" 一张图了解MVC"></p><p>通常来讲，当我们在MVC中接收到一个Url请求后，这个请求会被UrlRoutingModule拦截。此时，请求的上下文HttpContext会被封装到HttpContextWrapper对象中。而根据当前请求的HttpContext，则可以提取出符合当前Url的路由对象RouteData，它会被进一步封装为RequestContext对象。接下来，从RequestContext对象中获取RouteData，它对应一个RouteHandler，是IHttpHandler的一个实现类。对于MVC而言，则对应MvcHandler。通过调用MvcHandler，对应的Controller会被反射激活，进而调用具体的Action。以上就是整个MVC请求的过程描述，可以看出最关键的两个组件是UrlRoutingModule和MvcHandler，前者的作用是解析Controller和Action名称，后者的作用则是根据Controller名称去反射调用具体的Action，大家可以通过上面的图来理解这个过程。</p><p>在这里，其实我们只需要关注第二部分:-D，即MvcHandler，因为我们会在默认路由的基础上，增加一个自定义路由来“标记”这些动态的Controller，所以，我们集中关注MvcHandler这部分即可，虽然这里提到它会根据Controller的名称来反射激活相应的Controller实例、调用具体的Action，但这仅仅是宏观上的一种认识。我们来看一下，它具体是怎么反射出Controller以及调用Action的。</p><h2 id="IControllerFactory接口"><a href="#IControllerFactory接口" class="headerlink" title="IControllerFactory接口"></a>IControllerFactory接口</h2><p>第一个关键的组件是IControllerFactory接口，顾名思义，它是作用是创建Controller，可实际上，这个组件除了完成创建Controller的工作以外，还会涉及到Controller类型的解析、Controller实例激活、Controller实例释放、会话状态行为选项获取等多个功能。这里有一个激活的过程，我们可以将其理解为Controller的初始化，因为Controller在使用的过程中往往会通过IoC容器来注入相关服务，所以，你可以理解为在构造Controller的过程中，我们需要一个IoC容器来完成依赖注入相关的事情，微软默认提供了一个DefaultControllerFactory的实现，它内部是通过IHttpControllerActivator接口来完成依赖注入的，而这恰恰是我们要关注的第二个组件。</p><h2 id="IHttpControllerActivator接口"><a href="#IHttpControllerActivator接口" class="headerlink" title="IHttpControllerActivator接口"></a>IHttpControllerActivator接口</h2><p>老实说，通过自定义IHttpControllerActivator的方式实现依赖注入的方式并不常见，因为更一般的情况是，大家在Global.asax里初始化像Unity、Autofac等等类似的容器，然后在Controller里通过容器去Resolve一个服务出来，对于IHttpControllerActivator接口而言，它只有一个Create()方法，在这篇文章中，我们是通过Castle这个容器来实现依赖注入的，所以，你大概可以想象出它的过程，首先把所有动态生成的Controller全部注入到Ioc容器中，然后再根据传入的类型获取对应Controller的实例。在本文中，我们重写了默认的HttpControllerActivator，这里主要指Create()方法，因为我们希望实现的效果是，动态的Controller全部从Castle容器中获取，而静态的Controller依然按照微软的设计来获取。</p><h2 id="IHttpControllerSelector接口"><a href="#IHttpControllerSelector接口" class="headerlink" title="IHttpControllerSelector接口"></a>IHttpControllerSelector接口</h2><p>OK，现在有了Controller以后，我们怎么让MVC路由到正确的Controller上面去呢？这时候，必然需要有人来解析路由啊，这就是第三个组件——IHttpControllerSelector。这又是一个顾名思义的接口，充分说明命名是件多么重要的事情。在这里我们重写了SelectController()方法，当路由信息中存在ServiceName和ActionName时，就去检查容器中是否存在对应的Controller，如果存在就返回一个HttpControllerDescriptor，这是一个用以描述控制器上下文信息的类型。反之，会调用默认的base.SelectController()方法，这样做还是为了兼容微软原来的设计，因为我们不希望在引入动态Controller后，导致普通的Controller无法正常工作。</p><h2 id="IhttpActionSelector接口"><a href="#IhttpActionSelector接口" class="headerlink" title="IhttpActionSelector接口"></a>IhttpActionSelector接口</h2><p>同理，我们还需要告诉MvcHandler，它应该调用哪个方法，这时候我们需要IHttpActionSelector，因为从路由信息中我们可以提取到ActionName参数，因此，通过通过typeof(Controller).GetMethod(ActionName)，就可以获得对应ActionName对应的方法，熟悉反射的朋友应该都知道，它会返回MethodInfo这个类型，实际上IHttpActionSelector所做的事情，就是把MethodInfo传给MvcHandler，因为此时只要通过反射调用这个方法即可，Controller的实例在上一步就创建好了，而调用方法所需要的参数，则被存储在当前请求的上下文HttpContext里面，至此万事具备！我们要做的，就是顺着这些思路去实现以上组件。</p><h1 id="关键组件的自定义实现"><a href="#关键组件的自定义实现" class="headerlink" title="关键组件的自定义实现"></a>关键组件的自定义实现</h1><p>OK，下面我们来看看如何针对这些组件， 来分别实现我们的自定义组件，实现这些自定义组件并对MVC中的默认组件进行替换，这就是我们这篇文章中实现动态Controller的一个基本原理。</p><h2 id="DynamicControllerActivator"><a href="#DynamicControllerActivator" class="headerlink" title="DynamicControllerActivator"></a>DynamicControllerActivator</h2><p>DynamicControllerActivator 实现了IHttpControllerActivator接口，这里我们通过单例模式获得了DynamicHttpControllerManager对象的一个实例，其内部封装了Castle的容器接口IWindsorContainer，所以，在这里我们直接通过controllerType从容器中Resolve对应的Controller即可，而默认情况下，所有的Controller都实现了IHttpController接口，所以，这一步我们需要做一个显示的类型转换，后面我们会通过它替换微软默认的实现，这样，当一个请求被发送过来的时候，我们实际上是从这个自定义容器中获取对应Controller的实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicHttpControllerActivtor</span> : <span class="title">IHttpControllerActivator</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> IHttpController <span class="title">Create</span>(<span class="params">HttpRequestMessage request, HttpControllerDescriptor controllerDescriptor, Type controllerType</span>)</span></span><br><span class="line"><span class="function"></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (IHttpController)DynamicHttpControllerManager.GetInstance().Resolve(controllerType);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DynamicHttpControllerSelector"><a href="#DynamicHttpControllerSelector" class="headerlink" title="DynamicHttpControllerSelector"></a>DynamicHttpControllerSelector</h2><p>如果说DynamicControllerActivator 是真正实现控制器的<strong>“激活”</strong>部分，那么在此之前，我们需要实现控制器的<strong>“筛选”</strong>部分，换言之，一个请求被发送过来的时候，到底应该用哪一个Controller去处理这个请求呢？所以，我们来看看DynamicHttpControllerSelector这个组件是如何实现的，这里我们重写SelectController()这个方法来完成控制器的<strong>“筛选”</strong>部分的工作。可以注意到，我们首先会判断路由信息中是否存在ServiceName和ActionName这两个值，因为对于动态的Controller，我们默认使用的路由模板是<strong>services/{ServiceName}/{ActionName}</strong>，这里使用services前缀是为了区别于微软默认的api前缀，当然，强迫症的你同样可以使用相同的前缀。</p><p>接下来，我们会判断ServiceName是否在容器中注册过，如果注册了就从容器里取出对应的服务，并构造DynamicHttpControllerDescriptor对象，否则调用父类方法按微软默认实现去处理。那么，这个DynamicHttpControllerDescriptor对象，又是何方神圣呢？从名称上我们大概可以了解，这应该是一个对控制器相关信息进行描述的类型，它继承了HttpControllerDescriptor这个父类，目前没有任何扩展性的实现。对于DynamicHttpControllerDescriptor，它最重要的参数是构造函数中第三个参数，即 controllerType，因为DynamicControllerActivator 实际上就是根据它来工作的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicHttpControllerSelector</span>: <span class="title">DefaultHttpControllerSelector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpConfiguration _configuration;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 构造函数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="configuration"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicHttpControllerSelector</span>(<span class="params">HttpConfiguration configuration</span>) :</span></span><br><span class="line"><span class="function">        <span class="title">base</span>(<span class="params">configuration</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> HttpControllerDescriptor <span class="title">SelectController</span>(<span class="params">HttpRequestMessage request</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> routeData = request.GetRouteData().Values;</span><br><span class="line">        <span class="keyword">if</span> (routeData.ContainsKey(<span class="string">"ServiceName"</span>) &amp;&amp; routeData.ContainsKey(<span class="string">"ActionName"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> serviceName = routeData[<span class="string">"ServiceName"</span>].ToString();</span><br><span class="line">            <span class="keyword">var</span> actionName = routeData[<span class="string">"ActionName"</span>].ToString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DynamicHttpControllerManager.GetInstance().ContainsService(serviceName))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> controllerInfo = DynamicHttpControllerManager.GetInstance().GetControllerInfo(serviceName);</span><br><span class="line">                <span class="keyword">var</span> controller = DynamicHttpControllerManager.GetInstance().Resolve(serviceName);</span><br><span class="line">                <span class="keyword">if</span> (controller == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">base</span>.SelectController(request);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> controllerDescriptor = <span class="keyword">new</span> DynamicHttpControllerDescriptor(_configuration, serviceName, controllerInfo.ControllerType);</span><br><span class="line">                controllerDescriptor.Properties[<span class="string">"ServiceName"</span>] = serviceName;</span><br><span class="line">                controllerDescriptor.Properties[<span class="string">"ActionName"</span>] = actionName;</span><br><span class="line">                controllerDescriptor.Properties[<span class="string">"IsDynamicController"</span>] = <span class="literal">true</span>;</span><br><span class="line">                controllerDescriptor.Properties[<span class="string">"ServiceType"</span>] = controllerInfo.ServiceType;</span><br><span class="line">                controllerDescriptor.Properties[<span class="string">"ControllerType"</span>] = controller.GetType();</span><br><span class="line">                <span class="keyword">return</span> controllerDescriptor;</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.SelectController(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DynamicHttpActionSelector"><a href="#DynamicHttpActionSelector" class="headerlink" title="DynamicHttpActionSelector"></a>DynamicHttpActionSelector</h2><p>既然通过路由中的ServiceName可以对Controller进行<strong>“筛选”</strong>，那么，我们自然可以通过路由中的ActionName来对Action进行<strong>筛选”</strong>。Action是控制器中的概念，对应一般的接口或者类，我们称之为方法，因此，DynamicHttpActionSelector在这里实现针对Action的筛选，它继承ApiControllerActionSelector类并重写了SelectAction()方法，下面给出具体的实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicHttpActionSelector</span> : <span class="title">ApiControllerActionSelector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> HttpActionDescriptor <span class="title">SelectAction</span>(<span class="params">HttpControllerContext controllerContext</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> isDynamicController = controllerContext.ControllerDescriptor.Properties.ContainsKey(<span class="string">"IsDynamicController"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDynamicController)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> controllerType = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">            <span class="keyword">if</span> (controllerContext.ControllerDescriptor.Properties.TryGetValue(<span class="string">"ControllerType"</span>, <span class="keyword">out</span> controllerType))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> actionName = controllerContext.ControllerDescriptor.Properties[<span class="string">"ActionName"</span>].ToString();</span><br><span class="line">                <span class="keyword">var</span> methodInfo = ((Type)controllerType).GetMethod(actionName);</span><br><span class="line">                <span class="keyword">if</span> (methodInfo == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">base</span>.SelectAction(controllerContext);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DynamicHttpActionDescriptor(controllerContext.ControllerDescriptor, methodInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.SelectAction(controllerContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和筛选Controller的过程类似，首先我们会判断这是不是一个动态的Controller，请注意在DynamicHttpControllerSelector中，我们为ControllerDescriptor添加了大量的Properties，这些Properties可以在这里继续使用。显然，我们只需要关注动态的Controller即可，如果可以通过ActionName找到对应的MethodInfo，那就说明当前Controller中存在指定的Action，反之则需要调用父类方法按微软默认的实现去处理。其实，这里不好的一点就是，我们的通过反射获取MethodInfo时，需要传入ActionName即方法的名字，而方法的名字是区分大小写的，这会导致我们的URL必须区分大小写，这不太符合RESTful API风格。同样额，这里定义了一个类型DynamicHttpActionDescriptor，它继承自ReflectedHttpActionDescriptor，它需要传入MethodInfo，这样MVC就知道应该去调用控制器的哪一个方法了。</p><h2 id="容器注册及服务替换"><a href="#容器注册及服务替换" class="headerlink" title="容器注册及服务替换"></a>容器注册及服务替换</h2><p>在我们实际的业务系统中，存在着大量的WCF接口，它们都是通过ServiceHost这种方式来托管，然后在调用端通过代理类的方式来相互调用，因此把WCF迁移到Web API上，被抛弃的仅仅是这些.svc的文件，而这些WCF接口依然可以继续使用。在之前的文章中，我们用Castle的Dynamic Proxy来代替各种手写的代理类，在这篇文章中我们继续沿用ICalculator这个接口示例，它包含着最为简单加减乘除四个方法，那么，我们应该怎样把这个接口变成一个Web API呢？这就是所谓的容器注册和服务替换啦！首先我们来注册ICalculator这个服务，它的代码只有一行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DynamicHttpControllerManager.GetInstance().RegisterType&lt;CalculatorService, ICalculator&gt;();</span><br></pre></td></tr></table></figure><p>这是一个典型的依赖注入，其中CalculatorService是ICalculator的实现类，它到底做了什么呢？我们来看看本质：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> RegisterType&lt;TImplement, TInterface&gt;(<span class="keyword">string</span> serviceName = <span class="string">""</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(serviceName))</span><br><span class="line">        serviceName = GetServiceName&lt;TImplement&gt;();</span><br><span class="line"></span><br><span class="line">    _container.Register(</span><br><span class="line">        Component.For(<span class="keyword">typeof</span>(TImplement), <span class="keyword">typeof</span>(TInterface)),</span><br><span class="line">        Component.For&lt;DynamicApiInterceptor&lt;TInterface&gt;&gt;().LifestyleTransient(),</span><br><span class="line">        Component.For&lt;BaseController&lt;TInterface&gt;&gt;().Proxy.AdditionalInterfaces(<span class="keyword">typeof</span>(TInterface))</span><br><span class="line">            .Interceptors&lt;DynamicApiInterceptor&lt;TInterface&gt;&gt;().LifestyleTransient()</span><br><span class="line">            .Named(serviceName)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    _controllerInfoList.Add(serviceName, <span class="keyword">new</span> DynamicControllerInfo(<span class="keyword">typeof</span>(TInterface)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有觉得这段代码非常熟悉，实际上这就是我们这篇文章最开始提出的问题：怎么样对一个类和接口进行租户。一开始我们是用一个最普通的类、一个最普通的接口来演示这种可能性，而这里我们不过将其推广到一个特殊的场景，如果这个类是一个继承了ApiController的BaseController呢？这是一个由一般到特殊的过程。如你所见，内部的确使用了Castle的容器来处理依赖注入，而_controllerInfoList则存储了Controller相关的信息，方便我们在整个流程中随时获取这些信息。完成容器注册以后，我们就可以着手对MVC中的默认组件进行替换工作啦，我个人建议，替换工作放在整个Global.asax的最前面：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> configuration = GlobalConfiguration.Configuration;</span><br><span class="line"><span class="keyword">var</span> dynamicControllerSelector = <span class="keyword">new</span> DynamicHttpControllerSelector(configuration);</span><br><span class="line"><span class="keyword">var</span> dynamicHttpControllerActivtor = <span class="keyword">new</span> DynamicHttpControllerActivtor();</span><br><span class="line"><span class="keyword">var</span> dynamicActionSelector = <span class="keyword">new</span> DynamicHttpActionSelector();</span><br><span class="line">GlobalConfiguration.Configuration.Services.Replace(<span class="keyword">typeof</span>(IHttpControllerSelector), dynamicControllerSelector);</span><br><span class="line">GlobalConfiguration.Configuration.Services.Replace(<span class="keyword">typeof</span>(IHttpActionSelector), dynamicActionSelector);</span><br><span class="line">GlobalConfiguration.Configuration.Services.Replace(<span class="keyword">typeof</span>(IHttpControllerActivator), dynamicHttpControllerActivtor);</span><br></pre></td></tr></table></figure><p>假设现在我希望调用ICalcultor接口中的Add方法，理论上它的URL应该是<strong><a href="http://localhost/Service/Calculator/Add" target="_blank" rel="noopener">http://localhost/Service/Calculator/Add</a></strong>，因为截至到目前为止，所有的接口默认都是通过Get来访问的，下面是整个流程第一次跑通时的截图：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/4c36074fly1g49z1cvrw3j20pe05njrj.jpg" alt="迁移后的ICalculator接口" referrerpolicy="no-referrer"></div><div class="image-caption">迁移后的ICalculator接口</div></figure><h1 id="接口迁移后的二三事"><a href="#接口迁移后的二三事" class="headerlink" title="接口迁移后的二三事"></a>接口迁移后的二三事</h1><p>现在，我们完成了ICalculator接口的改造，它从一个WCF服务变成了一个Web API，而在这个过程中，我们发现一点点问题。首先，Web API中的URL是不区分大小写的，而我们这里的ServiceName、ActionName都是严格区分大小写的。其次，接口方法中的out、ref、params等关键字不适用于Web API语境，需要进一步对接口进行改造。再者，Web API需要区分GET、POST、PUT、DELETE等动词，返回值需要统一调整为JSON格式。最后，完成改造的动态API需要通过RestSharp或者HttpClient等HTTP客户端来调用，以替换原有的WCF代理方法。这里简单对后面这两个问题做下说明，因为前两个问题，都是历史遗留问题啦，哈哈😄。</p><h2 id="HTTP动词支持"><a href="#HTTP动词支持" class="headerlink" title="HTTP动词支持"></a>HTTP动词支持</h2><p>为了让接口支持不同的HTTP动词，我们需要对整个设计进行进一步优化。为什么我会把这件事情看得如此重要呢？因为在我看来，RESTful风格的API大概会有这样几种级别，第一种级别指仅仅使用了HTTP协议来设计API，第二种级别是在API设计中引入资源的概念，第三种级别是合理地使用HTTP动词如GET、POST、PUT等，第四种级别是使用HATEOSA来返回用户接下来可能的意图。可惜在实际的应用种，能做到第二种级别的都相当不容易啦。比如某接口不支持GET操作，原因是它需要附加token在Body中，因此在改造接口的过程中，哪怕参数是最简单的值类型，它还是必须要用POST方式来请求。可其实这种问题，如果把token附加在HTTP首部中，或者干脆就使用标准的Authorizatin字段完全就能解决啊。为了让这个方案更完美一点，我们对DynamicHttpActionDescriptor进行改造，重写它的SupportedHttpMethods属性：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDynamicController = controllerDescriptor.Properties.ContainsKey(<span class="string">"IsDynamicController"</span>);</span><br><span class="line"><span class="keyword">if</span> (isDynamicController)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceType = controllerDescriptor.Properties[<span class="string">"ServiceType"</span>];</span><br><span class="line">    <span class="keyword">var</span> httpVerbAttributes = ((Type)serviceType).GetMethod(methodInfo.Name).GetCustomAttributes&lt;Attribute&gt;()</span><br><span class="line">        .Where(t =&gt; <span class="keyword">typeof</span>(IActionHttpMethodProvider).IsAssignableFrom(t.GetType()))</span><br><span class="line">        .ToList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (httpVerbAttributes.Any())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据路由来获取Http动词</span></span><br><span class="line">        <span class="keyword">if</span> (httpVerbAttributes.Count &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Multiple http verb matched in method <span class="subst">&#123;methodInfo.Name&#125;</span> of <span class="subst">&#123;((Type)serviceType).Name&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line">             _httpVerbs = GetHttpVerbByRoute(httpVerbAttributes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据方法名称获取Http动词</span></span><br><span class="line">            _httpVerbs = GetHttpVerbByMethod(methodInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其原理说起来并不复杂，检查方法上是否有HTTPGet、HttpPost、HttpPut等标签，如果存在，则添加相应的HTTP动词到<strong>_httpVerbs</strong>集合中；如果不存在，则根据方法的名字来构建相应的HTTP动词。譬如以Add、Create等开头的方法对应POST请求，以Get开头的方法对应GET请求，以Update开头的方法对应PUT请求，以Delete开头的方法对应DELETE请求等。最终，我们只需要把<strong>_httpVerbs</strong>作为SupportedHttpMethods属性的返回值即可。</p><h2 id="接口返回值优化"><a href="#接口返回值优化" class="headerlink" title="接口返回值优化"></a>接口返回值优化</h2><p>通常在编写控制器的时候，我们会使用JSON作为接口的返回值，这是因为JSON在信息冗余度上相比XML更低，而且JSON和JavaScript有着密不可分的联系，所以使用JSON作为返回值会流行起来一点都不奇怪。我们知道，WCF是可以实现Web Service这种所谓的SOAP架构的，而WebService本质上是使用XML进行通信的HTTP，在调用WCF接口的时候，接口的参数、返回值都会被序列化为XML。平时我们手写Controller的时候，通常是在Controller层调用一层薄薄的Service层，然后对结果进行封装，使其成为对前端更友好的数据类型，可当我们调用动态的Controller时，其接口的返回值是在接口中定义好的，我们不可能去修改已经在使用中的Service定义。</p><p>虽然微软的Web API中可以自动对返回值进行序列化，参考最经典的ValuesController，它是微软对RESTful风格的一种标准实现，具体表现为Get()、Post()、Put()、Delete()四个方法，分别对应GTE、POST()、PUT()、DELETE(四个HTTP动词，这就是所谓的约定大于配置，并且这些方法的返回值都不是ActionResult或者IHttpActionResult，但整个框架依然可以帮我们将其序列化为JSON，这一切是为什么呢？其实，我们只需要重写DynamicHttpActionDescriptor的ReturnType属性，同时重写DynamicHttpActionDescriptor的ExecuteAsync()方法就可以达到这一目的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> Type ReturnType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span>(DynamicApiResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;<span class="keyword">object</span>&gt; <span class="title">ExecuteAsync</span>(<span class="params">HttpControllerContext controllerContext, IDictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt; arguments, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">base</span>.ExecuteAsync(controllerContext, arguments, cancellationToken)</span><br><span class="line">        .ContinueWith(task =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (task.Result == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> DynamicApiResult() &#123; Flag = <span class="literal">true</span> &#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (task.Result <span class="keyword">is</span> DynamicApiResult)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> task.Result;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DynamicApiResult() &#123; Flag = <span class="literal">true</span>, Result = task.Result &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AggregateException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中大家大致可以猜出DynamicApiResult的结构了，它包含三个属性：Flag、Msg、Result。这是一个最常见的Web API的返回值封装，即通过Flag判断方法是否调用成功，通过Msg来返回异常信息，通过Result来返回具体的返回值。最近对接某公司的API接口的时候，发现一个非常奇葩的现象，一般没有返回值可以返回null或者空字符串，可这家公司居然返回的是<strong>”无数据”</strong>，你以为这是放在Msg里的吗？不，人家是放在Result里的。对此，我只能说，互联网发展到2019年了，那些年野蛮生长留下的坑却还一直都在。好了，现在我们来看看接口调用的结果，喏，这次是不是感觉顺眼多啦！</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img src="https://ww1.sinaimg.cn/large/4c36074fly1g49z2ku45tj20il06dmxa.jpg" alt="优化后的ICalculator接口返回值" referrerpolicy="no-referrer"></div><div class="image-caption">优化后的ICalculator接口返回值</div></figure><h1 id="POCOController"><a href="#POCOController" class="headerlink" title="POCOController"></a>POCOController</h1><p>其实，这篇文章写到这里就已经结束啦，因为对于一般的ASP.NET项目，这篇文章里所分享这些内容，基本上可以实现我们最初的目标，即把老系统中的WCF接口迁移到Web API上，从长远的角度来看，这是为了后续迁移到.NET Core上做准备，其实不单单是WCF，任何的接口、服务都可以顺着这种思路去做扩展，手写Controller虽然是最容易上手的实践方式，可随着业务的不断推进，无一例外地出现接口爆炸的现象，在没有注册中心的情况下，业务系统间互相调对方的Web API简直叫一个混乱，你能想象一家公司里的不同业务系统，居然没有通用的网关去做接口的授权吗？反正我最近是见识到了某友的混乱。这篇文章中的思路，其实是参考了Abp这个框架中的DynamicApiController这一功能，可我们大多数人都没怎么好好用过这项技术，.NET Core就来了，Abp官方着手开发的Abp vNext就是基于.NET Core的下一代Abp框架，不知道届时会不会有这个功能。</p><p>既然说到了,NET Core，那么就不可避免地要说到.NET Core里的POCOController。因为ASP.NET与ASP.NET Core的机制完全不同，所以，我们在这篇文章里的实现是无法直接用到ASP,NET Core里的，这听起来有点遗憾是不是，就在我写这篇博客的前几天，我看到有人把Abp的DynamicApiController移植到了.NET Core下面，还是熟悉的味道，但内部的原理已然大为不同。具体来讲, .NET Core下的POCOController特性会让这一切更简单。所谓POCOController，就是指任意一个类都可以是Controller。我们都知道在ASP.NET下，要写一个Web API必须继承ApiController，就是说这个类必须实现了IHttpController接口，就是因为有这个限制，所以，我们不得不通过Castle来动态生成一个Controller，既然现在ASP.NET Core里可以打破这一限制，那么实现起来自然会非常简单。限于这篇文章的篇幅(截至到这里已经将近6000余字)，我将在下一篇文章中和大家分享这一特性的相关内容。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>在传统的ASP.NET项目向ASP.NET Core迁移的过程中，我们遇到的第一个阻力就是作为内部RPC使用的WCF。因此，收到上一篇文章基于Castle动态代理这一思路的影响，参考Abp框架中的DynamicApiController功能，我们分享了一种可以为任意接口动态生成Controller的思路，其核心原理是通过Castle中的<strong>AdditionalInterfaces</strong>功能，将指定接口和ApiController进行组合，使得一个普通的接口可以像Controller一样被调用。在这个过程中，我们回顾了ASP.NET MVC的基本原理，了解了MVC是如何根据路由筛选Controller、激活Controller和筛选Action，在此基础上，我们对微软的MVC进行了一次Hack，使用我们自定义的组件替换了微软的默认实现，从而可以让原来托管在ServiceHost上的接口，通过Web API来访问和调用。当然，这篇文章里没有实现自定义的路由、过滤器的支持，所谓抛砖引玉，Abp的代码本身在Github上就可以找到，大家如何对此感兴趣的话，可以做进一步的研究和扩展。我们实现了服务端的切换，这意味着在客户端同样需要一次切换，预知后事如何，请大家关注我的下一篇博客，以上就是我这篇博客的全部内容了，谢谢大家！</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.cnblogs.com/1zhk/p/5399548.html" target="_blank" rel="noopener">Castle中AdditionalInterfaces用法介绍</a></li><li><a href="https://www.cnblogs.com/1zhk/p/5418694.html" target="_blank" rel="noopener">ABP源码分析三十五：ABP中动态WebAPI原理解析</a></li><li><a href="https://github.com/FJQBT/ABP" target="_blank" rel="noopener">https://github.com/FJQBT/ABP</a></li></ul><div class="recommended_posts"><h1>推荐阅读</h1><ul><li><a href="https://qinyuanpei.github.io/posts/2488769283/">WebApiClient中动态路由的实现与使用</a></li><li><a href="https://qinyuanpei.github.io/posts/478946932/">原生JavaScript实现Hexo博客推荐功能</a></li><li><a href="https://qinyuanpei.github.io/posts/380519286/">声明式RESTful客户端WebApiClient在项目中的应用</a></li><li><a href="https://qinyuanpei.github.io/posts/4116164325/">通过ApiExplorer为Swagger提供MVC扩展</a></li><li><a href="https://qinyuanpei.github.io/posts/3670340170/">ABP vNext 对接 Ant Design Vue 实现分页查询</a></li></ul></div></div><blockquote class="post-copyright"><div class="content"><p><b>版权声明：</b> <a href="https://qinyuanpei.github.io/posts/4236649/" rel="external">通过动态Controller实现从WCF到Web API的迁移.</a> ，由&nbsp;<a href="/about" target="_blank" rel="external">飞鸿踏雪</a>&nbsp; 首次发表于&nbsp;<a href="/" target="_blank" rel="external">一个人的孤落时辰</a>&nbsp; ，本文地址为：<a href="https://qinyuanpei.github.io/posts/4236649/" target="_blank" rel="external">https://qinyuanpei.github.io/posts/4236649/</a> ，转载请注明<b>作者</b>和<b>出处</b>。</p></div><footer><a href="https://qinyuanpei.github.io"><img src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" alt="飞鸿踏雪"> 飞鸿踏雪</a></footer></blockquote><div class="page-reward"><a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a></div><div class="post-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebApi/" rel="tag">WebApi</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="tag">动态代理</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/4236649/&title=《通过动态Controller实现从WCF到Web API的迁移.》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/4236649/&title=《通过动态Controller实现从WCF到Web API的迁移.》 — 一个人的孤落时辰&source=一个人的孤落时辰 | 纵有疾风起，人生不言弃 | 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地 | 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/4236649/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《通过动态Controller实现从WCF到Web API的迁移.》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/4236649/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/4236649/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/posts/1071063696/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">使用ASP.NET Core和Hangfire实现HTTP异步化方案</h4></a></div><div class="waves-block waves-effect next"><a href="/posts/3677280829/" id="post-next" class="post-nav-link"><div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">《Web API 的设计与开发》读书笔记</h4></a></div></nav><div id="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">new Valine({el:"#comment",notify:!1,verify:!0,appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",placeholder:"云中谁寄锦书来，雁字回时，月满西楼。&#10;Tips：如果希望收到我的评论回复，请至少留下你的邮箱哦:)",path:"https://qinyuanpei.github.io/posts/4236649/",avatar:"identicon",requiredFields:["nick","mail"]})</script></article><div id="reward" class="page-modal reward-lay"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><h3 class="reward-title"><i class="icon icon-quote-left"></i> 赠人玫瑰，手有余香 <i class="icon icon-quote-right"></i></h3><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" alt="打赏二维码"></div><label class="reward-toggle"><input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/wechat.png" data-alipay="https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master//assets/images/alipay.jpg"><div class="reward-toggle-ctrol"><span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-label"></span> <span class="reward-toggle-item alipay">支付宝</span></div></label></div></div><script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/yoniu.min.js"></script><style type="text/css">body.active-yp{overflow:hidden}.yp-fc-btn{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:space-between;font-size:13px}.yp-fc-btn span{cursor:pointer;padding:2px 10px;color:#4b4b4b;border:#4b4b4b 1px solid;border-radius:5px}#yp-hide{position:fixed;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:center;flex-direction:column;left:0;top:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);z-index:99999;visibility:hidden}#yoniu-poster{box-sizing:border-box;width:350px;height:467.2px;background-color:#fff;margin:0 auto;padding:0;line-height:1.6;text-align:justify}.yp-img{min-height:240px;position:relative;display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:flex-end;flex-direction:column;background-position:50% 50%;background-size:cover;overflow:hidden}.yp-img>div{padding:10px 20px}.yp-name{display:block;color:#fff;font-size:20px;font-weight:600;text-shadow:#4b4b4b .1em .1em .2em;margin-top:10px}.yp-sort{padding:3px 10px;font-size:12px;color:#fff;background:#2e2e2e}.yp-des{color:#2e2e2e;font-size:14px;margin:20px;height:67.2px}.yp-qcode{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;margin:10px;padding:10px 20px;background:#f5f5f5;color:#818181;border-radius:10px}.yp-tips{display:flex;display:-webkit-flex;display:-ms-flexbox;justify-content:space-between;align-items:center;color:#ccc;margin:0 10px 10px;font-size:10px;letter-spacing:1.5px}.yp-btns{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:stretch;justify-content:center;width:350px;margin:0 auto}.yp-btns>span{display:flex;display:-webkit-flex;display:-ms-flexbox;align-items:center;justify-content:center;font-size:14px;padding:10px 15px;background:rgba(0,0,0,.2);color:#f5f5f5;cursor:pointer}.yp-btns>span>a{color:#f5f5f5}.yp-btns>span>a:hover{text-decoration:none}#yp-close{font-size:18px;font-weight:600}</style><div id="yp-hide"><div id="yoniu-poster"><div class="yp-img" id="yp-img"><div><span class="yp-sort"></span> <span class="yp-name">通过动态Controller实现从WCF到Web API的迁移.</span></div></div><div class="yp-des">在《又见AOP之基于RealProxy实现WCF动态代理》这篇文章中，我和大家分享了关于使用动态代理来简化WCF调用过程的相关内容，当时我试图解...</div><div class="yp-qcode"><span>扫描二维码阅读原文</span> <img id="yp-qcode" width="64px" src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/4236649/"></div><div class="yp-tips"><span>一个人的孤落时辰</span> <span><time class="post-time" title="2019-06-08 13:48:41" datetime="2019-06-08T13:48:41.000Z" itemprop="datePublished">2019-06-08</time></span></div></div><div class="yp-btns"><span id="yp-load-yp" onclick="load_yp()">生成海报</span> <span><a id="yp-download"></a></span> <span id="yp-close" onclick="close_yp()">×</span></div></div><script type="text/javascript">function show_yp(){window.scrollTo(0,0),document.body.setAttribute("class","active-yp");let e=document.getElementsByTagName("img")[1];null!=e&&void 0!==e?document.getElementById("yp-img").style.backgroundImage=`url(${e.src})`:document.getElementById("yp-img").style.backgroundColor="#d7dbf0",document.getElementById("yp-hide").style.visibility="visible"}function close_yp(){var e=document.body.getAttribute("class");e=e.replace("active-yp",""),document.body.setAttribute("class",e),document.getElementById("yp-hide").style.visibility="hidden"}function load_yp(){document.getElementById("yp-load-yp").textContent="海报生成中...",setTimeout((function(){h2c_()}),2e3)}</script></div><footer class="footer"><div class="top"><p><span id="lc_counter_container_site_uv"><i class="icon icon-user"></i><span id="lc_counter_value_site_uv"></span> </span><span id="lc_counter_container_site_pv"><i class="icon icon-eye"></i><span id="lc_counter_value_site_pv"></span></span></p><p><a id="jinrishici-sentence" href="https://www.jinrishici.com/" target="_blank" rel="noopener">加载中</a></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><script>jinrishici.load((function(e){document.querySelector("#subtitle").innerText=e.data.content,document.querySelector("#jinrishici-sentence").innerText=e.data.content}))</script><p><span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span> <span><a href="https://github.com/qinyuanpei" target="_blank" rel="license noopener" title="Github"><i class="icon icon-lg icon-github"></i> </a></span><span><a href="https://weibo.com/1278609231/profile" target="_blank" rel="license noopener" title="微博"><i class="icon icon-lg icon-weibo"></i> </a></span><span><a href="https://www.douban.com/people/60029335/" target="_blank" rel="license noopener" title="豆瓣"><i class="icon icon-lg icon-douban"></i> </a></span><span><a href="https://www.zhihu.com/people/qinyuanpei" target="_blank" rel="license noopener" title="知乎"><i class="icon icon-lg icon-zhihu-square"></i> </a></span><span><a href="https://blog.csdn.net/qinyuanpei" target="_blank" rel="license noopener" title="CSDN"><i class="icon icon-lg">C</i> </a></span><span><a href="https://music.163.com/#/user/home?id=47002864" target="_blank" rel="license noopener" title="网易音乐"><i class="icon icon-lg icon-wangyiyunyinyue"></i></a></span></p></div><div class="bottom"><p><span>飞鸿踏雪 &copy; 2014 - 2021</span><br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & Theme by <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a><br></p><p>Hosted by <a href="https://pages.github.com" target="_blank" rel="noopener" style="font-weight:700">Github Pages</a></p><p></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://qinyuanpei.github.io/posts/4236649/&title=《通过动态Controller实现从WCF到Web API的迁移.》 — 一个人的孤落时辰&pic=https://cdn.jsdelivr.net/gh/qinyuanpei/blog.yuanpei.me@master/assets/images/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://qinyuanpei.github.io/posts/4236649/&title=《通过动态Controller实现从WCF到Web API的迁移.》 — 一个人的孤落时辰&source=一个人的孤落时辰 | 纵有疾风起，人生不言弃 | 隐约雷鸣，阴霾天空，即使天无雨，我亦留此地 | 隐约雷鸣，阴霾天空，但盼风雨来，能留你在此" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://qinyuanpei.github.io/posts/4236649/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《通过动态Controller实现从WCF到Web API的迁移.》 — 一个人的孤落时辰&url=https://qinyuanpei.github.io/posts/4236649/&via=https://qinyuanpei.github.io" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://qinyuanpei.github.io/posts/4236649/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li><li><a class="google share-sns" target="_blank" onclick="show_yp()" data-title=" 生成海报"><i class="icon icon-file-image-o"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://qinyuanpei.github.io/posts/4236649/" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.6/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js"></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/echarts-wordcloud.min.js" async></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/main.min.js"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis">{tags}</div><time class="flex-col time">{date}</time></div></a></li></template><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/search.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/heart.min.js" async></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/leancloud-counter.min.js"></script><script>(new VisitorCounter).init({appId:"JbHqRp2eMrTgIwYpfERH0g79-gzGzoHsz",appKey:"VsiKvLuiBGvJL1XrAfv7siY2",region:"华北",domain:"",collectIP:!0,collectUA:!0})</script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/vconsole.min.js"></script><script type="text/javascript">if(location.href.indexOf("debug=true")>-1)var vConsole=new VConsole</script><script></script><script src="//cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@master/assets/scripts/ribbon.min.js"></script></body></html>