<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RabbitMQ on 元视角</title><link>http://example.org/tags/rabbitmq/</link><description>Recent content in RabbitMQ on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 07 Mar 2022 09:34:36 +0000</lastBuildDate><atom:link href="http://example.org/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml"/><item><title>七种武器：延迟队列的原理和实现总结</title><link>http://example.org/posts/summary-of-the-principle-and-implementation-of-delay-queue/</link><pubDate>Mon, 07 Mar 2022 09:34:36 +0000</pubDate><guid>http://example.org/posts/summary-of-the-principle-and-implementation-of-delay-queue/</guid><description>“这是最好的时代，这是最坏的时代”，英国作家查尔斯·狄更斯在两百多年前写下的这句话，如果从辩证的角度来看，它或许可以适用于任何一个时代。我们生活在一个怎样的时代呢？我想，或许是一个矛盾的时代。因为，有时它让你对未来有无限的期待，有时它又会让你陷入无尽的绝望，特别是当集体和个人的命运形成强烈反差的时候，当实用主义、精致利己主义开始盛行的时候，我们偶尔会感慨罗曼蒂克的消亡、怀念从前慢、追忆芳华，可下一秒就被卷入到同时间赛跑的庸庸碌碌当中。生活节奏越来越快，人们越来越追求实时、速度、效率，选择当下的同时，意味着选择实时满足，譬如，我想吃一块美味的蛋糕，我现在就要吃。与之相对的，则被称之延迟满足，譬如，制定一个长期的写作计划以实现个人知识网络的构建。由此可见，人生本来就有快有慢、有张有弛，此时，便引入了这篇文章的主题——延迟队列。
什么是延迟队列 延迟队列，即 DelayQueue，所以，顾名思义，首先，它是一个队列，对于队列这种数据结构，相信大家都不陌生啦！这是一种先入先出(FIFO)的数据结构，就像现实生活中排队讲究先来后到一样，普通队列中的元素都是有序的。相比普通队列，延迟队列主要多了一个延迟的属性，此时，元素何时出队不再取决于入队顺序，而是入队时指定的延迟时间，它表示该元素希望在经过该指定时间后被处理。从某种意义上来讲，延迟队列更像是一种以时间作为权重的集合。我想，单纯地介绍概念，不一定能真正深入人心，所以，请允许我举几个生活中的例子：当你在网上购物的时候，如果下单后一段时间内没有完成付款，那这个订单就会被自动取消；当你通过 Outlook 预约了会议以后，Outlook 会在会议开始前 15 分钟提醒所有与会人员；当你在网上叫外卖以后，平台会在订单即将超时前 10 分钟通知外卖小哥&amp;hellip;这样看起来，是不是顿时觉得延迟队列的使用场景还是挺广泛的呢？因为工作上的关系，博主接触类似场景的机会还是蛮多的，所以，想系统地研究下相关的技术，最终，就有了今天这篇博客，下面我们来看看具体的实现方式有哪些。
延迟队列的实现方式 延迟队列思维导图我知道，在一个短视频横行的时代，人们的注意力注定要被那些实时满足的事物消耗掉，在我有预感到，不会有多少人愿意在我这篇自以为是的文字前驻留的时候，我唯有识趣地放出这个思维导图，TLDR的这种心理，其实我完全可以感同身受，因为看一部电影永远比看一本书容易，当媒介从文字变成图片再到视频，本质上是我们获取信息的能力下降了，我们变得只能接受低密度的信息。当然，这是一个时代的症结，你可以拥有你的选择，是独善其身还是随波逐流？
数据结构 JDK 中提供了一个延迟队列的实现 DelayQueue，位于 Java.util.concurrent 这个包下面，它是一个 BlockingQueue，本质上封装了一个 PriorityQueue，队列中的元素只有到达了Delay时间，才允许从队列中取出。如下图所示，队列中放入三个订单，分别设置订单在当前时间的第 5、10、15 秒后取消：
延迟队列示意图对于 Java 中的 DelayQueue 而言，其对应的代码实现如下面所示：
Order Order1 = new Order(&amp;#34;Order1&amp;#34;, 5, TimeUnit.SECONDS); Order Order2 = new Order(&amp;#34;Order2&amp;#34;, 10, TimeUnit.SECONDS); Order Order3 = new Order(&amp;#34;Order3&amp;#34;, 15, TimeUnit.SECONDS); DelayQueue&amp;lt;Order&amp;gt; delayQueue = new DelayQueue&amp;lt;&amp;gt;(); delayQueue.put(Order1); delayQueue.put(Order2); delayQueue.put(Order3); System.out.println(&amp;#34;订单延迟队列开始时间:&amp;#34; + LocalDateTime.now().format(DateTimeFormatter.ofPattern(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;))); while (delayQueue.size() != 0) { Order task = delayQueue.</description></item><item><title>利用 MySQL 的 Binlog 实现数据同步与订阅(下)：EventBus 篇</title><link>http://example.org/posts/3424138425/</link><pubDate>Fri, 31 Jul 2020 12:01:14 +0000</pubDate><guid>http://example.org/posts/3424138425/</guid><description>终于到这个系列的最后一篇，在前两篇博客中，我们分别了介绍了Binlog的概念和事件总线(EventBus)的实现，在完成前面这将近好几千字的铺垫以后，我们终于可以进入正题，即通过 EventBus 发布 Binlog，再通过编写对应的 EventHandler 来订阅这些 Binlog，这样就实现了我们“最初的梦想”。坦白说，这个过程实在有一点漫长，庆幸的是，它终于还是来了。
Binlog 读取与解析 首先，我们通过 Python-Mysql-Replication 这个项目来读取 Binlog，直接通过pip install mysql-replication安装即可。接下来，我们编写一个简单的脚本文件，这再次印证那句名言——人生苦短，我用 Python：
def readBinLog(): stream = BinLogStreamReader( # 填写IP、账号、密码即可 connection_settings = { &amp;#39;host&amp;#39;: &amp;#39;&amp;#39;, &amp;#39;port&amp;#39;: 3306, &amp;#39;user&amp;#39;: &amp;#39;&amp;#39;, &amp;#39;passwd&amp;#39;: &amp;#39;&amp;#39; }, # 每台服务器唯一 server_id = 3, # 主库Binlog读写完毕时是否阻塞连接 blocking = True, # 筛选指定的表 only_tables = [&amp;#39;order_info&amp;#39;, &amp;#39;log_info&amp;#39;], # 筛选指定的事件 only_events = [DeleteRowsEvent, WriteRowsEvent, UpdateRowsEvent]) for binlogevent in stream: for row in binlogevent.rows: event = { &amp;#34;schema&amp;#34;: binlogevent.</description></item><item><title>利用 MySQL 的 Binlog 实现数据同步与订阅(中)：RabbitMQ 篇</title><link>http://example.org/posts/580694660/</link><pubDate>Wed, 15 Jul 2020 14:39:07 +0000</pubDate><guid>http://example.org/posts/580694660/</guid><description>紧接上一篇博客中的思路，这次我们来说说事件总线(EventBus)，回首向来，关于这个话题，我们可能会联想到发布-订阅模式、观察者模式、IObservable与 IObserver、消息队列等等一系列的概念。所以，当我们尝试着去解释这个概念的时候，它到底是什么呢？是一种设计模式？是一组 API 接口？还是一种新的技术？显而易见，发布-订阅模式和观察者模式都是设计模式，而 IObservable与 IObserver、消息队列则是具体的实现方式，就像你可以用委托或者事件去实现一个观察者模式，而 Redis 里同样内置了发布-订阅模型，换言之，这是抽象与具体的区别，消息队列可以用来实现 EventBus，而 EventBus 主要的用途则是系统间的解耦，说到解耦，你可能会对观察者模式和发布-订阅模式这两种模式感到困惑，因为它们实在是太像了，一个最本质的区别在于发布者(主题)是否与订阅者(观察者)存在强依赖关系，而发布-订阅引入了类似主题/Topic/Channel 的中介者，显然从解耦的角度要更彻底一些，所以，我们今天就来一起实现一个事件总线(EventBus)。
EventBus 整体设计 通过前面的探讨，我们可以知道，EventBus 其实是针对事件的发布-订阅模式的实现，所以，在设计 EventBus 的时候，我们可以结合发布-定阅模式来作为对照，而一个典型的发布-订阅模式至少需要三个角色，即发布者、订阅者和消息，所以，一般在设计 EventBus 的时候，基本都会从这三个方面入手，提供发布消息、订阅消息、退订消息的接口。由于 EventBus 本身并不负责消费消息，所以，还需要借助IEventHandler&amp;lt;T&amp;gt;来编写对应的事件处理器，这是 EventBus 可以实现业务解耦的重要原因。而为了维护事件和事件处理器的关系，通常需要借助 IoC 容器来注册这些 EventHandler，提供类似Castle或者Autofac从程序集中批量注册的机制，下面是博主借鉴 eShopOnContainers 设计的 EventBus，首先是 IEventBus 接口，其定义如下：
public interface IEventBus { void Publish&amp;lt;TEvent&amp;gt; (TEvent @event) where TEvent : EventBase; void Subscribe&amp;lt;T, TH&amp;gt; () where T : EventBase where TH : IEventHandler&amp;lt;T&amp;gt;; void Unsubscribe&amp;lt;T, TH&amp;gt; () where TH : IEventHandler&amp;lt;T&amp;gt; where T : EventBase; } 注意到，这里对事件(EventBase)和事件处理器(EventHandler)均有一定约束，这是为了整个 EventBus 的实现，在某些 EventBus 的实现中，可能会支持非泛型的EventHandler，以及Func这样的委托类型，这里不考虑这种情形，因为从 Binlog 中获取的数据，基本上都是格式固定的 JSON。关于这部分，下面给出对应的定义：</description></item></channel></rss>