<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DelayQueue on 元视角</title><link>https://qinyuanpei.github.io/tags/delayqueue/</link><description>Recent content in DelayQueue on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 07 Mar 2022 09:34:36 +0000</lastBuildDate><atom:link href="https://qinyuanpei.github.io/tags/delayqueue/index.xml" rel="self" type="application/rss+xml"/><item><title>七种武器：延迟队列的原理和实现总结</title><link>https://qinyuanpei.github.io/posts/summary-of-the-principle-and-implementation-of-delay-queue/</link><pubDate>Mon, 07 Mar 2022 09:34:36 +0000</pubDate><guid>https://qinyuanpei.github.io/posts/summary-of-the-principle-and-implementation-of-delay-queue/</guid><description>“这是最好的时代，这是最坏的时代”，英国作家查尔斯·狄更斯在两百多年前写下的这句话，如果从辩证的角度来看，它或许可以适用于任何一个时代。我们生活在一个怎样的时代呢？我想，或许是一个矛盾的时代。因为，有时它让你对未来有无限的期待，有时它又会让你陷入无尽的绝望，特别是当集体和个人的命运形成强烈反差的时候，当实用主义、精致利己主义开始盛行的时候，我们偶尔会感慨罗曼蒂克的消亡、怀念从前慢、追忆芳华，可下一秒就被卷入到同时间赛跑的庸庸碌碌当中。生活节奏越来越快，人们越来越追求实时、速度、效率，选择当下的同时，意味着选择实时满足，譬如，我想吃一块美味的蛋糕，我现在就要吃。与之相对的，则被称之延迟满足，譬如，制定一个长期的写作计划以实现个人知识网络的构建。由此可见，人生本来就有快有慢、有张有弛，此时，便引入了这篇文章的主题——延迟队列。
什么是延迟队列 延迟队列，即 DelayQueue，所以，顾名思义，首先，它是一个队列，对于队列这种数据结构，相信大家都不陌生啦！这是一种先入先出(FIFO)的数据结构，就像现实生活中排队讲究先来后到一样，普通队列中的元素都是有序的。相比普通队列，延迟队列主要多了一个延迟的属性，此时，元素何时出队不再取决于入队顺序，而是入队时指定的延迟时间，它表示该元素希望在经过该指定时间后被处理。从某种意义上来讲，延迟队列更像是一种以时间作为权重的集合。我想，单纯地介绍概念，不一定能真正深入人心，所以，请允许我举几个生活中的例子：当你在网上购物的时候，如果下单后一段时间内没有完成付款，那这个订单就会被自动取消；当你通过 Outlook 预约了会议以后，Outlook 会在会议开始前 15 分钟提醒所有与会人员；当你在网上叫外卖以后，平台会在订单即将超时前 10 分钟通知外卖小哥&amp;hellip;这样看起来，是不是顿时觉得延迟队列的使用场景还是挺广泛的呢？因为工作上的关系，博主接触类似场景的机会还是蛮多的，所以，想系统地研究下相关的技术，最终，就有了今天这篇博客，下面我们来看看具体的实现方式有哪些。
延迟队列的实现方式 延迟队列思维导图我知道，在一个短视频横行的时代，人们的注意力注定要被那些实时满足的事物消耗掉，在我有预感到，不会有多少人愿意在我这篇自以为是的文字前驻留的时候，我唯有识趣地放出这个思维导图，TLDR的这种心理，其实我完全可以感同身受，因为看一部电影永远比看一本书容易，当媒介从文字变成图片再到视频，本质上是我们获取信息的能力下降了，我们变得只能接受低密度的信息。当然，这是一个时代的症结，你可以拥有你的选择，是独善其身还是随波逐流？
数据结构 JDK 中提供了一个延迟队列的实现 DelayQueue，位于 Java.util.concurrent 这个包下面，它是一个 BlockingQueue，本质上封装了一个 PriorityQueue，队列中的元素只有到达了Delay时间，才允许从队列中取出。如下图所示，队列中放入三个订单，分别设置订单在当前时间的第 5、10、15 秒后取消：
延迟队列示意图对于 Java 中的 DelayQueue 而言，其对应的代码实现如下面所示：
Order Order1 = new Order(&amp;#34;Order1&amp;#34;, 5, TimeUnit.SECONDS); Order Order2 = new Order(&amp;#34;Order2&amp;#34;, 10, TimeUnit.SECONDS); Order Order3 = new Order(&amp;#34;Order3&amp;#34;, 15, TimeUnit.SECONDS); DelayQueue&amp;lt;Order&amp;gt; delayQueue = new DelayQueue&amp;lt;&amp;gt;(); delayQueue.put(Order1); delayQueue.put(Order2); delayQueue.put(Order3); System.out.println(&amp;#34;订单延迟队列开始时间:&amp;#34; + LocalDateTime.now().format(DateTimeFormatter.ofPattern(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;))); while (delayQueue.size() != 0) { Order task = delayQueue.</description></item></channel></rss>