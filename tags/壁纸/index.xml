<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>壁纸 on 元视角</title><link>http://example.org/tags/%E5%A3%81%E7%BA%B8/</link><description>Recent content in 壁纸 on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 11 Oct 2019 08:56:27 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E5%A3%81%E7%BA%B8/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Python 开发插件化应用程序</title><link>http://example.org/posts/1960676615/</link><pubDate>Fri, 11 Oct 2019 08:56:27 +0000</pubDate><guid>http://example.org/posts/1960676615/</guid><description>插件化应用是个老话题啦，在我们的日常生活中更是屡见不鲜。无论是多年来臃肿不堪的 Eclipse，亦或者是扩展丰富著称的 Chrome，乃至近年来最优秀的编辑器 VSCode，插件都是这其中重要的组成部分。插件的意义在于扩展应用程序的功能，这其实有点像 iPhone 手机和 AppStore 的关系，没有应用程序的手机无非就是一部手机，而拥有了应用程序的手机则可以是 Everything。显然，安装或卸载应用程序并不会影响手机的基本功能，而应用程序离开了手机同样无法单独运行。所以，所谓“插件”，实际上是一种按照一定规范开发的应用程序，它只能运行在特定的软件平台/应用程序且无法运行。这里，最重要的一点是应用程序可以不依赖插件单独运行，这是这类“插件式”应用的基本要求。
好了，在了解了插件的概念以后，我们来切入今天的正文。博主曾经在《基于 Python 实现 Windows 下壁纸切换功能》这篇文章中编写了一个小程序，它可以配合 Windows 注册表实现从 Unsplash 上抓取壁纸的功能。最近，博主想为这个小程序增加 必应壁纸 和 WallHaven 两个壁纸来源，考虑到大多数的壁纸抓取流程是一样的，博主决定以“插件”的方式完成这次迭代，换句话说，主程序不需要再做任何调整，当我们希望增加新的数据源的时候，只需要写一个.py 脚本即可，这就是今天这篇文章的写作缘由。同样的功能，如果使用 Java 或者 C#这类编译型语言来做，我们可能会想到为插件定义一个 IPlugin 接口，这样每一个插件实际上都是 IPlugin 接口的实现类，自然而然地，我们会想到通过反射来调用接口里的方法，这是编译型语言的做法。而面对 Python 这样的解释型语言，我们同样有解释型语言的做法。
首先，我们从一个最简单的例子入手。我们知道，Python 中的 import 语法可以用来引入一个模块，这个模块可以是 Python 标准库、第三方库和自定义模块。现在，假设我们有两个模块：foo.py 和 bar.py。
#foo.py import sys class Chat: def send(self,uid,msg): print(&amp;#39;给{uid}发送消息：{msg}&amp;#39;.format(uid=uid,msg=msg)) def sendAll(self,msg): print(&amp;#39;群发消息：{msg}&amp;#39;.format(msg=msg)) #bar.py import sys class Echo: def say(self): print(&amp;#34;人生苦短，我用Python&amp;#34;) def cry(): print(&amp;#34;男人哭吧哭吧不是罪&amp;#34;) 通常, 为了在当前模块(main.py)中使用这两个模块，我们可以使用以下语句：
import foo from bar import * 这是一种简单粗暴的做法，因为它会导入模块中的全部内容。一种更好的做法是按需加载，例如下面的语句：</description></item></channel></rss>