<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>EventBus on 元视角</title><link>https://qinyuanpei.github.io/tags/eventbus/</link><description>Recent content in EventBus on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 15 Jul 2020 14:39:07 +0000</lastBuildDate><atom:link href="https://qinyuanpei.github.io/tags/eventbus/index.xml" rel="self" type="application/rss+xml"/><item><title>利用 MySQL 的 Binlog 实现数据同步与订阅(中)：RabbitMQ 篇</title><link>https://qinyuanpei.github.io/posts/580694660/</link><pubDate>Wed, 15 Jul 2020 14:39:07 +0000</pubDate><guid>https://qinyuanpei.github.io/posts/580694660/</guid><description>紧接上一篇博客中的思路，这次我们来说说事件总线(EventBus)，回首向来，关于这个话题，我们可能会联想到发布-订阅模式、观察者模式、IObservable与 IObserver、消息队列等等一系列的概念。所以，当我们尝试着去解释这个概念的时候，它到底是什么呢？是一种设计模式？是一组 API 接口？还是一种新的技术？显而易见，发布-订阅模式和观察者模式都是设计模式，而 IObservable与 IObserver、消息队列则是具体的实现方式，就像你可以用委托或者事件去实现一个观察者模式，而 Redis 里同样内置了发布-订阅模型，换言之，这是抽象与具体的区别，消息队列可以用来实现 EventBus，而 EventBus 主要的用途则是系统间的解耦，说到解耦，你可能会对观察者模式和发布-订阅模式这两种模式感到困惑，因为它们实在是太像了，一个最本质的区别在于发布者(主题)是否与订阅者(观察者)存在强依赖关系，而发布-订阅引入了类似主题/Topic/Channel 的中介者，显然从解耦的角度要更彻底一些，所以，我们今天就来一起实现一个事件总线(EventBus)。
EventBus 整体设计 通过前面的探讨，我们可以知道，EventBus 其实是针对事件的发布-订阅模式的实现，所以，在设计 EventBus 的时候，我们可以结合发布-定阅模式来作为对照，而一个典型的发布-订阅模式至少需要三个角色，即发布者、订阅者和消息，所以，一般在设计 EventBus 的时候，基本都会从这三个方面入手，提供发布消息、订阅消息、退订消息的接口。由于 EventBus 本身并不负责消费消息，所以，还需要借助IEventHandler&amp;lt;T&amp;gt;来编写对应的事件处理器，这是 EventBus 可以实现业务解耦的重要原因。而为了维护事件和事件处理器的关系，通常需要借助 IoC 容器来注册这些 EventHandler，提供类似Castle或者Autofac从程序集中批量注册的机制，下面是博主借鉴 eShopOnContainers 设计的 EventBus，首先是 IEventBus 接口，其定义如下：
public interface IEventBus { void Publish&amp;lt;TEvent&amp;gt; (TEvent @event) where TEvent : EventBase; void Subscribe&amp;lt;T, TH&amp;gt; () where T : EventBase where TH : IEventHandler&amp;lt;T&amp;gt;; void Unsubscribe&amp;lt;T, TH&amp;gt; () where TH : IEventHandler&amp;lt;T&amp;gt; where T : EventBase; } 注意到，这里对事件(EventBase)和事件处理器(EventHandler)均有一定约束，这是为了整个 EventBus 的实现，在某些 EventBus 的实现中，可能会支持非泛型的EventHandler，以及Func这样的委托类型，这里不考虑这种情形，因为从 Binlog 中获取的数据，基本上都是格式固定的 JSON。关于这部分，下面给出对应的定义：</description></item></channel></rss>