<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>上传 on 元视角</title><link>http://example.org/tags/%E4%B8%8A%E4%BC%A0/</link><description>Recent content in 上传 on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 20 Mar 2022 09:34:36 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E4%B8%8A%E4%BC%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>利用 gRPC 实现文件的上传与下载</title><link>http://example.org/posts/use-grpc-to-realize-file-upload-and-download/</link><pubDate>Sun, 20 Mar 2022 09:34:36 +0000</pubDate><guid>http://example.org/posts/use-grpc-to-realize-file-upload-and-download/</guid><description>几天前，某人同我抱怨，说是某接口无法正常工作，坦白地讲，这只是程序员生命里再枯燥不过的日常，因为无论“好”或者“不好”，他们都要努力回应来自灵魂深处的那声“为什么”。所以，善待程序员的方式之一，就是不要总问他“为什么”，因为他已经听了太多的“为什么”。经过一番攀谈交心，我了解到是模型绑定出了问题。原来，他需要实现一个导出/下载功能，因为他不确定能否通过 Envoy 代理来自 gRPC 的文件流，故而，他选择了传统的 Web API，结果不曾想在模型绑定上栽了跟头。听完了他的话，我不禁陷入了沉思，难道 gRPC 真的不能做文件的上传和下载吗？常言道，“实践出真知”，所以，今天这篇博客，我们来聊聊利用 gRPC 实现文件的上传和下载。
定义 Protobuf 首先，我们来看 Protobuf 的定义，此前介绍 gRPC 流式传输相关内容的时候，我一直找不到一个更为贴切的场景，而此时此刻，我只想说，冥冥中自有天意，难道还有比上传和下载更好的例子吗？
service FileService { rpc UploadFile(stream UploadFileRequest) returns (UploadFileResponse); rpc DownloadFile(DownloadFileRequest) returns (stream DownloadFileResponse); } //Upload message UploadFileRequest { string FileName = 1; bytes Content = 2; } message UploadFileResponse { string FilePath = 1; } //Download message DownloadFileRequest { string FilePath = 1; } message DownloadFileResponse { bytes Content = 1; } 其中，UploadFile是一个针对客户端的流式接口，DownloadFile是一个针对服务器端的流式接口，可以注意到，这其实非常符合我们平时对于上传/下载的认知，即，对上传而言，客户端以二进制流的形式作为输入；对下载而言，服务器端以二进制流的形式作为输出。在 Protobuf 的定义中，二进制流可以使用 bytes类型来表示，因此，我们在 UploadFileRequest 和 DownloadFileResponse 这两个类型中，统一使用 Content 这个字段来表示上传或者下载过程中的二进制流。</description></item></channel></rss>