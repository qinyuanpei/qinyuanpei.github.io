<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tracing on 元视角</title><link>http://example.org/tags/tracing/</link><description>Recent content in Tracing on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 07 Apr 2022 09:34:36 +0000</lastBuildDate><atom:link href="http://example.org/tags/tracing/index.xml" rel="self" type="application/rss+xml"/><item><title>利用 ASP.NET Core 中的标头传播实现分布式链路追踪</title><link>http://example.org/posts/asp-net-core-using-headerpropagation-for-distributed-tracking/</link><pubDate>Thu, 07 Apr 2022 09:34:36 +0000</pubDate><guid>http://example.org/posts/asp-net-core-using-headerpropagation-for-distributed-tracking/</guid><description>在此之前，我曾写过一篇博客，《Envoy 集成 Jaeger 实现分布式链路追踪》，主要分享了 ASP.NET Core 应用如何结合 Envoy 和 Jeager 来实现分布式链路追踪，其核心思想是：生成一个全局唯一的 x-request-id ，并在不同的微服务或者子系统中传播该信息。进而，可以使得相关的信息像一条线上的珠子一样串联起来。在此基础上，社区主导并产生了 OpenTracing 规范，在这个 规范 中，一个 Trace，即调用链，是由多个 Span 组成的有向无环图，而每个 Span 则可以含有多个键值对组成的 Tag。不过，当时我们有一个非常尴尬的问题，那就是每个微服务必须显式地传递相关的 HTTP 请求头。那么，是否有一种更优雅的方案呢？而这就是我们今天要分享的内容。首先，我们来回头看看当初的方案，这是一个非常朴实无华的实现：
[HttpPost] public async Task&amp;lt;IActionResult&amp;gt; Post([FromBody] OrderInfo orderInfo) { var paymentInfo = new PaymentInfo() { OrderId = orderInfo.OrderId, PaymentId = Guid.NewGuid().ToString(&amp;#34;N&amp;#34;), Remark = orderInfo.Remark, }; // 设置请求头 _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-request-id&amp;#34;, Request.Headers[&amp;#34;x-request-id&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-traceid&amp;#34;, Request.Headers[&amp;#34;x-b3-traceid&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-spanid&amp;#34;, Request.Headers[&amp;#34;x-b3-spanid&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-parentspanid&amp;#34;, Request.Headers[&amp;#34;x-b3-parentspanid&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-sampled&amp;#34;, Request.Headers[&amp;#34;x-b3-sampled&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-flags&amp;#34;, Request.Headers[&amp;#34;x-b3-flags&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-ot-span-context&amp;#34;, Request.</description></item><item><title>Envoy 集成 Jaeger 实现分布式链路追踪</title><link>http://example.org/posts/768684858/</link><pubDate>Fri, 14 Jan 2022 16:46:23 +0000</pubDate><guid>http://example.org/posts/768684858/</guid><description>当我们的应用架构，从单体系统演变为微服务时，一个永远不可能回避的现实是，业务逻辑会被拆分到不同的服务中。因此，微服务实际就是不同服务间的互相请求和调用。更重要的是，随着容器/虚拟化技术的发展，传统的物理服务器开始淡出我们的视野，软件被大量地部署在云服务器或者虚拟资源上。在这种情况下，分布式环境中的运维和诊断变得越来越复杂。如果按照功能来划分，目前主要有 Logging、Metrics 和 Tracing 三个方向，如下图所示，可以注意到，这三个方向上彼此都有交叉、重叠的部分。在我过去的博客里，我分享过关于 ELK 和 Prometheus 的内容，可以粗略地认为，这是对 Logging 和 Metrics 这两个方向的涉猎。所以，这篇文章我想和大家分享是 Tracing，即分布式追踪，本文会结合 Envoy、Jaeger 以及 .NET Core 来实现一个分布式链路追踪的案例，希望能带给大家一点 Amazing 的东西。
可观测性：Metrics、Tracing &amp;amp;amp; Logging分布式追踪 如果要追溯分布式追踪的起源，我想，Google 的这篇名为 《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》 的论文功不可没，因为后来主流的分布式追踪系统，譬如 Zipkin、Jeager、Skywalking、LightStep……等等，均以这篇论文作为理论基础，它们在功能上或许存在差异，原理上则是一脉相承，一个典型的分布式追踪系统，大体上可以分为代码埋点、数据存储和查询展示三个步骤，如下图所示，Tracing 系统可以展示出服务在时序上的调用层级，这对于我们分析微服务系统中的调用关系会非常有用。
分布式追踪系统基本原理一个非常容易想到的思路是，我们在前端发出的请求的时候，动态生成一个唯一的 x-request-id，并保证它可以传递到与之交互的所有服务中去，那么，此时系统产生的日志中就会携带这一信息，只要以此作为关键字，就可以检索到当前请求的所有日志。这的确是个不错的方案，但它无法告诉你每个调用完成的先后顺序，以及每个调用花费了多少时间。基于这样的想法，人们在这上面传递了更多的信息(Tag)，使得它可以表达层级关系、调用时长等等的特征。如图所示，这是一个由 Jaeger 产生的追踪信息，我们从中甚至可以知道请求由哪台服务器处理，以及上/下游集群信息等等：
通过 Jaeger 收集 gRPC 请求信息目前，为了统一不同 Tracing 系统在 API、数据格式等方面上的差异，社区主导并产生了 OpenTracing 规范，在这个 规范 中，一个 Trace，即调用链，是由多个 Span 组成的有向无环图，而每个 Span 则可以含有多个键值对组成的 Tag。如图所示，下面是 OpenTracing 规范的一个简单示意图，此时，图中一共有 8 个 Span，其中 Span A 是根节点，Span C 是 Span A 的子节点， Span G 和 Span F 之间没有通过任何一个子节点连接，称为 FollowsFrom。</description></item></channel></rss>