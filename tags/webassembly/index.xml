<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WebAssembly on 元视角</title><link>http://example.org/tags/webassembly/</link><description>Recent content in WebAssembly on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 23 Feb 2021 05:37:47 +0000</lastBuildDate><atom:link href="http://example.org/tags/webassembly/index.xml" rel="self" type="application/rss+xml"/><item><title>通过 EmbededFileProvider 实现 Blazor 的静态文件访问</title><link>http://example.org/posts/3789745079/</link><pubDate>Tue, 23 Feb 2021 05:37:47 +0000</pubDate><guid>http://example.org/posts/3789745079/</guid><description>重构我的 独立博客 ，是博主今年的计划之一，这个基于 Hexo 的静态博客，最早搭建于2014年，可以说是比女朋友更亲密的存在，陪伴着博主走过了毕业、求职以及此刻的而立之年。其间虽然尝试过像 Jekyll 和 Hugo 这样的静态博客生成器，可是考虑到模板、插件等周边生态，这个想法一直被搁置下来。直到最近，突然涌现出通过 Blazor 重写博客的想法，尤其是它对于 WebAssembly 的支持，而类似 Vue 和 React的组件化开发模式，在开发体验上有着同样不错的表现。所以，今天这篇博客就来聊聊在重写博客过程中的一点收获，即如何让 Blazor 访问本地的静态文件。
从内嵌资源说起 首先，我们要引入一个概念，即：内嵌资源。我们平时接触的更多的是本地文件系统，或者是 FTP 、对象存储这类运行在远程服务器上的文件系统，这些都是非内嵌资源，所以，内嵌资源主要是指那些没有目录层级的文件资源，因为它会在编译的时候“嵌入”到动态链接库(DLL)中。一个典型的例子是Swagger，它在.NET Core平台下的实现是Swashbuckle.AspNetCore，它允许使用自定义的HTML页面。这里可以注意到，它使用到了GetManifestResourceStream()方法：
app.UseSwaggerUI(c =&amp;gt; { // requires file to be added as an embedded resource c.IndexStream = () =&amp;gt; GetType().Assembly .GetManifestResourceStream(&amp;#34;CustomUIIndex.Swagger.index.html&amp;#34;); }); 其实，这里使用的就是一个内嵌资源。关于内嵌资源，我们有两种方式来定义它：
在 Visual Studio 中选中指定文件，在其属性窗口中选择生成操作为嵌入的资源： 如何定义一个文件资源为内嵌资源在项目文件(.csproj)中修改对应ItemGroup节点，参考示例如下： &amp;lt;Project Sdk=&amp;#34;Microsoft.NET.Sdk.Web&amp;#34;&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;ItemGroup&amp;gt; &amp;lt;EmbeddedResource Include=&amp;#34;_config.yml&amp;#34;&amp;gt; &amp;lt;CopyToOutputDirectory&amp;gt;Always&amp;lt;/CopyToOutputDirectory&amp;gt; &amp;lt;/EmbeddedResource&amp;gt; &amp;lt;/ItemGroup&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;/Project&amp;gt; 这样，我们就完成了内嵌资源的定义。而定义内嵌资源，本质上还是为了在运行时期间去读取和使用，那么，自然而然地，我们不禁要问，该怎么读取这些内嵌资源呢？在Assembly类中，微软为我们提供了下列接口来处理内嵌资源：
public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName); public virtual string[] GetManifestResourceNames(); public virtual Stream GetManifestResourceStream(Type type, string name); public virtual Stream GetManifestResourceStream(string name); 其中，GetManifestResourceNames()方法用来返回所有内嵌资源的名称，GetManifestResourceInfo()方法用来返回指定内嵌资源的描述信息，GetManifestResourceStream()方法用来返回指定内嵌资源的文件流。为了方便大家理解，这里我们准备了一个简单的示例：</description></item></channel></rss>