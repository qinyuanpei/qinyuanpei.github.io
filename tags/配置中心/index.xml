<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>配置中心 on 元视角</title><link>http://example.org/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link><description>Recent content in 配置中心 on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 11 Oct 2020 12:19:02 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/index.xml" rel="self" type="application/rss+xml"/><item><title>基于选项模式实现.NET Core 的配置热更新</title><link>http://example.org/posts/835719605/</link><pubDate>Sun, 11 Oct 2020 12:19:02 +0000</pubDate><guid>http://example.org/posts/835719605/</guid><description>最近在面试的时候，遇到了一个关于 .NET Core 配置热更新的问题，顾名思义，就是在应用程序的配置发生变化时，如何在不重启应用的情况下使用当前配置。从 .NET Framework 一路走来，对于 Web.Config 以及 App.Config 这两个配置文件，我们应该是非常熟悉了，通常情况下， IIS 会检测这两个配置文件的变化，并自动完成配置的加载，可以说它天然支持热更新，可当我们的视野伸向分布式环境的时候，这种配置方式就变得繁琐起来，因为你需要修改一个又一个配置文件，更不用说这些配置文件可能都是放在容器内部。而有经验的朋友，可能会想到，利用 Redis 的发布-订阅来实现配置的下发，这的确是一个非常好的思路。总而言之，我们希望应用可以随时感知配置的变化，所以，在今天这篇博客里，我们来一起聊聊 .NET Core 中配置热更新相关的话题，这里特指全新的选项模式(Options)。
Options 三剑客 在 .NET Core 中，选项模式(Options)使用类来对一组配置信息进行强类型访问，因为按照接口分隔原则(ISP)和关注点分离这两个工程原则，应用的不同部件的配置应该是各自独立的，这意味着每一个用于访问配置信息的类，应该是只依赖它所需要的配置信息的。举一个简单的例子，虽然 Redis 和 MySQL 都属于数据持久化层的设施，但是两者属于不同类型的部件，它们拥有属于各自的配置信息，而这两套配置信息应该是相互独立的，即 MySQL 不会因为 Redis 的配置存在问题而停止工作。此时，选项模式(Options)推荐使用两个不同的类来访问各自的配置。我们从下面这个例子开始：
{ &amp;#34;Learning&amp;#34;: { &amp;#34;Years&amp;#34;: 5, &amp;#34;Topic&amp;#34;: [ &amp;#34;Hotfix&amp;#34;, &amp;#34;.NET Core&amp;#34;, &amp;#34;Options&amp;#34; ], &amp;#34;Skill&amp;#34;: [ { &amp;#34;Lang&amp;#34;: &amp;#34;C#&amp;#34;, &amp;#34;Score&amp;#34;: 3.9 }, { &amp;#34;Lang&amp;#34;: &amp;#34;Python&amp;#34;, &amp;#34;Score&amp;#34;: 2.6 }, { &amp;#34;Lang&amp;#34;: &amp;#34;JavaScript&amp;#34;, &amp;#34;Score&amp;#34;: 2.8 } ] } } 此时，如果希望访问Learning节点下的信息，我们有很多种实现方式：
//方式1 var learningSection = Configuration.</description></item></channel></rss>