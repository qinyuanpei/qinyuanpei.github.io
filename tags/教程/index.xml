<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>教程 on 元视角</title><link>http://example.org/tags/%E6%95%99%E7%A8%8B/</link><description>Recent content in 教程 on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 18 Feb 2022 09:34:36 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC 流式传输极简入门指南</title><link>http://example.org/posts/grpc-streaming-transmission-minimalist-guide/</link><pubDate>Fri, 18 Feb 2022 09:34:36 +0000</pubDate><guid>http://example.org/posts/grpc-streaming-transmission-minimalist-guide/</guid><description>最近一直在研究 gRPC 的 ServerReflection，顾名思义，这是 gRPC 里提供的反射接口，当你需要获取某个接口的描述信息，或者是希望动态调用 gRPC 的时候，这一切就会变得非常有用，如果你经常使用 gRPC UI 这款工具来调试 gRPC 接口，那么，你一定会注意到一件事情，即它要求服务端必须支持 ServerReflection API，而这一点在 ASP.NET Core 中已经得到支持，对此感兴趣的朋友可以参考官方文档。当然，这并不是我想表达的重点(我就知道)。重点是什么呢？在使用 ServerReflection API 的过程中，我发现它采用了 gRPC 双向流的方式来进行交互，在过去的日子里，我研究过诸如 WebSocket、Server-Sent Events 等等服务器推送的技术，我意识到这是一个非常接近的技术，所以，今天这篇文章，我们来一起聊聊 gRPC 中的流式传输。
从 HTTP/2 说起 首先，我想说，流式传输并不是一个新的概念，这一切就好像，即使你从来没有听过流媒体的概念，可这并不妨碍你追剧、刷短视频，隐隐然有种“不识庐山真面目，只缘身在此山中”的感觉。随着网络带宽和硬件水平的不断提升，越来越多的云服务变得像水、电、天然气一样寻常，以此作喻，流式传输，就像你打开水龙头，此时，水就会源源不断地流出来，并且可以做到随用随取。因此，流式传输实际上就是指通过网络传输媒体，例如音频、视频等的技术统称，服务器可以连续地、实时地向客户端发送数据，而客户端不必等所有数据发送完就可以访问这些数据。按照实现方式的不同，流式传输可以分为 实时流式传输 和 顺序流式传输 两种，前者通常指RTP/RTCP，典型的场景是直播；后者通常是指由 Nginx、Apache 等提供支持的顺序下载。
HTTP/1.1 vs HTTP/2如果你对 HTTP/2 有一定了解的话，就会知道它最为人所知的特性是多路复用。在 HTTP/1.1 的时代，同一个时刻只能对一个请求进行处理或者响应，换句话说，下一个请求必须要等当前请求处理完才能继续进行，与此同时，浏览器为了更快地加载页面资源，对同一个域名下的请求并发数进行了限制，所以，你会注意到一个有趣的现象，部分网站会使用多个 CDN 加速的域名，而这正是为了规避浏览器的这一限制，HTTP/1.1 时代，可以称为“半双工模式”。到了 HTTP/2 的时代，多路复用的特性让一次同时处理多个请求成为了现实，并且同一个 TCP 通道中的请求不分先后、不会阻塞，是真正的“全双工通信”。一个和本文更贴近的概念是流，HTTP/2 中引入了流(Stream) 和 帧(Frame) 的概念，当 TCP 通道建立以后，后续的所有操作都是以流的方式发送的，而二进制帧则是组成流的最小单位，属于协议层上的流式传输。
gRPC 中的流式传输 OK，现在我们正式开始 gRPC 流式传输的话题。首先，对于一个 gRPC 接口而言，它的起源是 Protobuf 定义。所以，一个最为直观的认识是从 Protobuf 定义入手：</description></item><item><title>EasyAR 尝鲜系列教程之视频播放功能的实现</title><link>http://example.org/posts/316230277/</link><pubDate>Wed, 09 Dec 2015 08:40:22 +0000</pubDate><guid>http://example.org/posts/316230277/</guid><description>&lt;p>各位朋友大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是&lt;a href="http://qinyuanpei.com">http://qinyuanpei.com&lt;/a>。到现在为止，我们对 EasyAR 中的 ImageTarget 基本上可以说是驾轻就熟了，因此我们这个系列教程可以说是接近尾声了。博主第一次接触 AR 这个概念是在大学时候读到一本讲解计算机图形视觉的书籍里，相对 VR 技术目前华而不实的市场现状，AR 技术从实用性和成熟度都能得到较好的保证。可是大家都清楚这些技术背后都是建立在复杂而高深的图形学算法的基础上的，如果想学习 AR 技术请回归计算机图形学的本源，这就和学习游戏技术要追寻可编程渲染管线是一样的，所以这个系列完全是博主个人的兴趣使然，希望了解这个技术的可以进行更加深入的探索。这次我们来说说 VideoTarget 如何实现吧！&lt;/p></description></item><item><title>EasyAR 尝鲜系列教程之 ImageTarget 千呼万唤始出来</title><link>http://example.org/posts/3736599391/</link><pubDate>Wed, 09 Dec 2015 08:39:54 +0000</pubDate><guid>http://example.org/posts/3736599391/</guid><description>&lt;p>各位朋友大家好，欢迎大家关注我的博客，我是秦元培，我的博客地址是&lt;a href="http://qinyuanpei.com">http://qinyuanpei.com&lt;/a>。最近 EasyAR 终于迎来了一次重大的版本更新：v1.10，真可谓是“千呼万唤始出来”啊，所以在官方文档和示例项目基本完善的情况下，博主决定将 EasyAR 尝鲜系列教程继续下去。本次教程主要以官方新发布的 Unity 示例项目为基础来进行讲解，关注 Androis/iOS 原生应用开发的朋友请自行针对官方示例项目进行研究。好了，今天主要的内容是通过 EasyAR SDK 来自行构建一个 ImageTarget 的实例，采用 Unity3D 4.6.4 版本进行开发。&lt;/p></description></item><item><title>EasyAR 尝鲜系列教程之自定义 Marker 的实现</title><link>http://example.org/posts/1156673678/</link><pubDate>Tue, 03 Nov 2015 10:23:14 +0000</pubDate><guid>http://example.org/posts/1156673678/</guid><description>&lt;p>各位朋友大家好，欢迎大家关注我的博客，我是&lt;strong>秦元培&lt;/strong>，我的博客地址是：&lt;a href="http://blog.yuanpei.me">http://blog.yuanpei.me&lt;/a>。通过本系列第一篇文章，我们初步了解了 EasyAR 这个增强现实引擎，这次我们来尝试自己定义一个 Marker，这样我们就可以用自己喜欢的图片来作为 Marker。因为目前 EasyAR 文档并不完善，所以下面的这些内容可能更多的是我个人的尝试和探索。如果大家对此感兴趣的话继续往下看否则就不要往下看了，因为我担心在官方正式文档出来以后大家可能会骂我啊。好了，对这个话题感兴趣的朋友就请继续往下看吧！&lt;/p></description></item><item><title>EasyAR尝鲜系列教程之Hello EasyAR</title><link>http://example.org/posts/3120185261/</link><pubDate>Fri, 30 Oct 2015 09:44:18 +0000</pubDate><guid>http://example.org/posts/3120185261/</guid><description>&lt;p>各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是&lt;a href="http://qinyuanpei.com">http://qinyuanpei.com&lt;/a>。从今天起博主将为大家带来EasyAR尝鲜系列教程，本教程适用的对象是增强现实应用开发者和Unity3D游戏开发者，在阅读本教程前请确保具备增强现实应用开发及Unity3D游戏开发的相关基础知识。在本节及后续内容中，博主将以国产增强现实引擎EasyAR为主要开发平台来带领大家一起走进增强现实应用开发的世界，希望大家能够喜欢！&lt;/p></description></item><item><title>SDL 游戏开发系列第二话：基本图形的绘制</title><link>http://example.org/posts/3789971938/</link><pubDate>Mon, 27 Jul 2015 08:48:59 +0000</pubDate><guid>http://example.org/posts/3789971938/</guid><description>&lt;p>各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是：&lt;a href="http://qinyuanpei.com">http://qinyuanpei.com&lt;/a>。话题紧接上回，在上回我们讲到了 SDL 的下载、安装和配置并对 SDL 游戏有了初步的了解。我们知道游戏开发中最为基础的内容是图形的绘制，因此在我们学习 SDL 游戏开发的过程中我们同样要从最简单的图形绘制开始学习。在 2D 游戏开发中，精灵（Sprite）是一个基础而核心的内容，具体来讲精灵首先是一张 2D 图片，精灵的绘制从本质上是图片的绘制，所以这是一个基础的内容。因为精灵在 2D 游戏中承担着 GameObject 的重要角色，所以一个图形引擎对精灵的支持好坏会决定游戏设计的最终效果。今天这篇文章主要是通过使用 SDL 中的 SDL_LoadBMP()、SDL_CreateTextureFromSurface()和 SDL_RenderCopy()这三个方法来实现在 SDL 中基本图形的绘制，从整体上尚属较为简单的内容。可是从学习 SDL 游戏开发的角度来看，一切都值得我们深入地去研究。好了，这就开始吧！&lt;/p></description></item><item><title>SDL 游戏开发系列第一话：Hello SDL</title><link>http://example.org/posts/183718218/</link><pubDate>Sat, 25 Jul 2015 15:19:01 +0000</pubDate><guid>http://example.org/posts/183718218/</guid><description>&lt;p>各位读者朋友大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是&lt;a href="http://qinyuanpei.com">http://qinyuanpei.com&lt;/a>。从今天起博主将带领大家一起走进 SDL 游戏开发的世界，如果说此前的 Unity3D 游戏开发系列文章让大家感受到的是游戏引擎工具化开发的方便与快捷，那么这一次就让我们以 SDL 库为基础，通过了解游戏开发中的底层图形渲染、输入事件响应等内容来全面认识游戏引擎，博主为 SDL 游戏开发系列文章建立了专栏，大家可以通过&lt;a href="http://blog.csdn.net/column/details/sdlgame.html">这里&lt;/a>获取所有的系列文章，希望大家能够喜欢！好了，作为&lt;a href="http://blog.csdn.net/column/details/sdlgame.html"> SDL 游戏开发系列&lt;/a>的第一篇文章，按照技术性文章写作的国际惯例这将是一篇介绍 SDL 入门内容的文章，因此这篇文章叫做：Hello SDL。&lt;/p></description></item><item><title>Unity3D 塔防游戏开发项目讲解(下)</title><link>http://example.org/posts/1176959868/</link><pubDate>Wed, 21 Jan 2015 13:50:48 +0000</pubDate><guid>http://example.org/posts/1176959868/</guid><description>&lt;p>各位朋友，大家好，我是秦元培，欢迎大家关注我的博客，我的博客地址是&lt;a href="http://blog.csdn.net/qinyuanpei">http://blog.csdn.net/qinyuanpei&lt;/a>。我们知道一个完整的塔防游戏由地图、敌人、防守单位三个部分组成，在上一篇文章中我们已经对地图这块儿进行了全面的讲解，今天我们来说说敌人和防守单位。&lt;/p></description></item></channel></rss>