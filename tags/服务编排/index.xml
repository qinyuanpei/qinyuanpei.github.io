<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>服务编排 on 元视角</title><link>https://qinyuanpei.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/</link><description>Recent content in 服务编排 on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 14 Aug 2021 22:13:32 +0000</lastBuildDate><atom:link href="https://qinyuanpei.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/index.xml" rel="self" type="application/rss+xml"/><item><title>你不可不知的容器编排进阶技巧</title><link>https://qinyuanpei.github.io/posts/172025911/</link><pubDate>Sat, 14 Aug 2021 22:13:32 +0000</pubDate><guid>https://qinyuanpei.github.io/posts/172025911/</guid><description>在团队内推广Docker Compose有段时间啦，值得庆幸的是，最终落地效果还不错，因为说到底，大家都不大喜欢，那一长串复杂而枯燥的命令行参数。对我而言，最为重要的一点，团队内使用的技术变得更加透明化、标准化，因为每个微服务的配置信息都写在docker-compose.yml文件中，任何人都可以快速地构建出一套可用的服务，而不是每次都要去找具体的某一个人。我想说，这其实是一个信息流如何在团队内流动的问题。也许，我们有文档或者Wiki，可新人能不能快速融入其中，这才是检验信息流是否流动的唯一标准。就这样，团队从刀耕火种的Docker时代，进入到使用服务编排的Docker Compose时代。接下来，能否进入K8S甚至是云原生的时代，我终究不得而知。今天我想聊聊，在使用Docker Compose的过程中，我们遇到的诸如容器的启动顺序、网络模式、健康检查这类问题，我有一点Docker Compose的进阶使用技巧想和大家分享。
容器的启动顺序 使用服务编排以后，大家最关心的问题是，如果服务间存在依赖关系，那么如何保证容器的启动顺序？我承认，这是一个真实存在的问题，譬如，你的应用依赖某个数据库，理论上数据库要先启动，抑或者是像Redis、Kafka、Envoy这样的基础设施，总是要优先于应用服务本身启动。
假如章鱼的这些脚互相影响会怎么样？熟悉Docker Compose的同学，也许会想到depends_on这个选项，可如果大家亲自去尝试过就会知道，这终究只是我们的一厢情愿。为什么呢？因为这个depends_on主要是看目标容器是不是处于running的状态，所以，在大多数情况下，我们会注意到Docker Compose并不是按我们期望的顺序去启动的，因为目标容器在某一瞬间的确已经是running的状态了，那这样简直太尴尬了有木有啊！我们从一个简单的例子开始：
version: &amp;#34;3.8&amp;#34; services: redis_server: image: redis:latest command: &amp;gt; /bin/bash -c &amp;#39; sleep 5; echo &amp;#34;sleep over&amp;#34;;&amp;#39; networks: - backend city_service: build: CityService/ container_name: city_service ports: - &amp;#34;8081:80&amp;#34; networks: - backend depends_on: - redis_server networks: backend: 可以注意到，为了证明city_service服务不会等待redis_server服务，我故意让子弹飞了一会儿，结果如何呢？我们一起来看看：
Docker Compose 启动顺序：一厢情愿果然，我没有骗各位，city_service服务不会等待redis_server服务。我们知道，Redis提供的命令行接口中，有一个PING命令，当Redis可以正常连接的时候，它会返回一个PONG，也许，这就是乒乓球的魅力所在。基于这个想法，我们继续修改docker-compose.yml文件：
version: &amp;#34;3.8&amp;#34; services: redis_server: image: redis:latest networks: - backend city_service: build: CityService/ container_name: city_service ports: - &amp;#34;8081:80&amp;#34; networks: - backend depends_on: - redis_server command: &amp;gt; /bin/bash -c &amp;#39; while !</description></item></channel></rss>