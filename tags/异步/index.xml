<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>异步 on 元视角</title><link>http://example.org/tags/%E5%BC%82%E6%AD%A5/</link><description>Recent content in 异步 on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 15 Apr 2017 21:10:47 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E5%BC%82%E6%AD%A5/index.xml" rel="self" type="application/rss+xml"/><item><title>异步 Lambda 表达式问题的探索</title><link>http://example.org/posts/187480982/</link><pubDate>Sat, 15 Apr 2017 21:10:47 +0000</pubDate><guid>http://example.org/posts/187480982/</guid><description>各位朋友，大家好，欢迎大家关注我的博客，我是 Payne，我的博客地址是:http://qinyuanpei.com。今天博主想和大家探讨的是，.NET 中异步 Lambda 表达式的问题。为什么要讨论这个问题呢，这或许要从公司首席架构推广内部框架这件事情说起。我其实很久以前就有这种在团队内部做技术演进的想法，即通过公共类库、团队 Wiki 和技术交流等形式逐步地推进和完善团队整体架构的统一，因为一个团队在业务方向和技术选型上基本是一致的，因此团队内的技术演进对提高开发效率和交付质量意义重大，所以我能理解首席架构在内部推广公共类库这件事情，因为除了 KPI 这种功利性的目标以外，从长远来看这些东西对一个团队来说是积极而有利的，可是我们都知道工程师是这个世界上最傲慢的人，如果一个东西设计得不好，他们一定会尝试去改进甚至重新设计，所以架构并非是一种虚无缥缈的、凭空想象出来的东西，它的存在必须是为了解决某种问题。
所以我始终认为，架构设计必须由一线开发人员来提炼和抽象，因为只有真正经历过&amp;quot;坑&amp;quot;的人，才会清楚地知道团队里最需要解决的问题是什么，一个良好的架构绝对不是由某些所谓&amp;quot;专家&amp;quot;闭门造车的结果，你只有真正了解了一个问题，懂得如何去定义一个问题，你才会知道目前这个团队中最迫切需要去解决的问题是什么，虽然说团队里技术层次存在差异，一个技术选型必然会和普通社会学问题一样存在众口难调的情形，可是一个东西设计得不好它就是不好，你不能强迫团队成员必须去使用它，因为这实在有悖于&amp;quot;自由&amp;quot;和&amp;quot;分享&amp;quot;的黑客文化。我相信软件开发没有银弹可言，这意味着它没有一种一劳永逸的解决方案，即使它的抽象层次再高、代码鲁棒性再好，所以团队内部技术演进应该采取&amp;quot;自下而上&amp;quot;的方式，对待工程师最好的方式就是给他们充分的自由，&amp;ldquo;自上而下&amp;quot;的行政命令不适合工程师文化，自计算机文明诞生以来，那种来自内心深处的&amp;quot;极客思维&amp;quot;决定了我们的基因，所以啊，&amp;ldquo;请原谅我一生不羁放纵爱自由&amp;rdquo;。
好了，现在回到这个问题本身，问题产生的根源来自 ICommand 接口，而我们都知道该接口主要承担命令绑定作用。通过 ICommand 接口的定义我们可以知道，ICommand 接口的 Execute 方法是一个同步方法，因此常规的做法如 RelayCommand 或者 DelegateCommand，基本上都是传入一个 Action 来指向一个具体方法，最终 ICommand 接口中的 Execute 方法执行的实际上是这个具体方法。截止到目前为止，这个策略在主流的场景下都实施得非常好，可是我们在引入 Task、async/await 这些新的概念以后，我们突然发现 ICommand 接口存在一个亟待解决的问题，即它缺乏一个支持异步机制的 Execute 方法，显然这是一个历史遗留问题。 我开始关注这个问题是当我在同事 John 和 Charles 的项目中看到类似下面的代码，事实上他们都是非常优秀的高级工程师，在对这个问题理解和探讨的过程中，我要特别感谢他们愿意分享他们的想法。我们一起来看看下面的代码：
public RelayCommand RunCommand { get { return new RelayCommand(async ()=&amp;gt;{ /* await awaitable */ }); } } 请相信你的眼睛，因为你没有看错，让我倍感纠结的的正是这样一段简单的代码。这段代码让我迷惑的地方有两处，第一，RelayCommand 实现了 ICommand 接口，而 ICommand 接口的 Execute 方法是一个同步的方法，为什么我们可以在这个里传入一个异步方法，并通过 Action 这种委托类型来对其进行包装；第二，Action 是一个 void 类型，即无返回值的委托类型，我们这里显然使用 async 关键字修饰了一个无返回值的方法，因为我们在这个匿名方法内部使用了 await 语法。可是我们知道微软官方的建议是，使用 async 关键字来修饰一个返回值类型为 Task 或者 Task的方法。在我了解到 async 关键字还可以这样使用以后，对第二处疑惑我稍稍有些许释怀，因为事实上 Charles 就是正式通过这种思路来启发我，可我始终无法理解，为什么我们可以在一个同步的方法里执行一段异步代码，并试图去安慰自己说这段代码是异步的，在执行一个非常耗时的任务时界面不会阻塞。</description></item><item><title>C# 中 Socket 通信编程的异步实现</title><link>http://example.org/posts/2041685704/</link><pubDate>Sun, 22 Mar 2015 09:37:04 +0000</pubDate><guid>http://example.org/posts/2041685704/</guid><description>&lt;p>本文将在 C#中 Socket 同步通信的基础上，分析和研究 Socket 异步编程的实现方法，目的是深入了解 Socket 编程的基本原理，增强对网络游戏开发相关内容的认识。&lt;/p></description></item></channel></rss>