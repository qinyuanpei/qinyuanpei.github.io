<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Retrofit on 元视角</title><link>http://example.org/tags/retrofit/</link><description>Recent content in Retrofit on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 02 Apr 2020 10:26:53 +0000</lastBuildDate><atom:link href="http://example.org/tags/retrofit/index.xml" rel="self" type="application/rss+xml"/><item><title>WebApiClient 中动态路由的实现与使用</title><link>http://example.org/posts/2488769283/</link><pubDate>Thu, 02 Apr 2020 10:26:53 +0000</pubDate><guid>http://example.org/posts/2488769283/</guid><description>博主曾经在「声明式 RESTful 客户端 WebApiClient 在项目中的应用」这篇博客中，介绍过.NET 平台下的“Retrofit”——WebApiClient，它是一种声明式的 RESTful 客户端，通过动态代理来生成 Http 调用过程代码，而调用方只需要定义一个接口，并使用相关“注解”对接口进行修饰即可，类似的实现还有Refit，是一种比 HttpWebRequest、HttpClient 和 RestSharp 更为优雅的接口调用方式。在今天这篇博客中，我想聊聊 WebApiClient 中动态路由的实现与使用。
一个典型的 WebApiClient 使用流程如下，首先定义一个接口，并使用“注解”对接口进行修饰：
public interface ISinoiovApiClient : IHttpApiClient { /// &amp;lt;summary&amp;gt; /// 运单取消接口 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; [HttpPost(&amp;#34;/yl/api/waybill/cancel&amp;#34;)] [AuthorizeFilter] [LoggingFilter] [JsonReturn] ITask&amp;lt;BaseApiResult&amp;lt;object&amp;gt;&amp;gt; CancelShipment([JsonContent]BaseShipmentDto shipment); } 接下来，调用就变得非常简单：
var config = new HttpApiConfig () { HttpHost = new Uri (baseUrl) }; using (var client = HttpApiClient.Create&amp;lt;ISinoiovApiClient&amp;gt; (config)) { var result = await client.CancelShipment (new BaseShipmentDto () { }); //TODO：TODO的意思就是永远都不做 } 有多简单呢？简单到调用的时候我们只需要给一个 baseUrl 就可以了！然而，如果你真这么想的话，就太天真了！虽然现在是一个遍地都是微服务和容器的时代，可是因为 RESTful 风格本身的约束力并不强，实际使用中难免会出现以下情况：</description></item></channel></rss>