<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CTS on 元视角</title><link>http://example.org/tags/cts/</link><description>Recent content in CTS on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 15 Aug 2024 12:52:10 +0000</lastBuildDate><atom:link href="http://example.org/tags/cts/index.xml" rel="self" type="application/rss+xml"/><item><title>浅议 CancellationToken 在前后端协同取消场景中的应用</title><link>http://example.org/posts/cancellation-mechanism-cancellationtoken-cooperative-scene/</link><pubDate>Thu, 15 Aug 2024 12:52:10 +0000</pubDate><guid>http://example.org/posts/cancellation-mechanism-cancellationtoken-cooperative-scene/</guid><description>两个月前，我写过一篇题为为《关于 ChatGPT 的流式传输，你需要知道的一切》的文章。当时，我主要聚焦于 “流式传输” 这个概念。因此，Server-Sent Events、WebSocket 等技术，便顺理成章地成为了我的写作内容。然而，当我们将视野扩展到整个生成式 AI 领域时，我们会发现 “取消” 是一个非常普遍的业务场景。尽管我曾在这篇文章中提到了 AbortController 和 CancellationToken，但我并不认为我完全解决了当时的问题，即：如何让前、后端的取消动作真正地协同起来？言下之意，我希望前端的 AbortController 发起取消请求以后，后端的 CancellationToken 能够及时感知并响应这一变化。这一切就好比，AI 智能体固然可以通过 “观察” 来感知外部的变化，可当用户决定停止生成的时候，一切都应该戛然而止，无论你是不是为了节省那一点点 token。所以，当两个月前的子弹正中眉心时，我决定继续探讨这个话题。由此，便有了今天这篇稍显多余的博客。
前后端协同取消 我必须承认，在推崇前后端分离的当下，我这个想法难免显得不合时宜。可什么是合时宜呢？在刚刚落幕的巴黎奥运会上，35 岁的 “龙队” 马龙，斩获了个人第 6 枚奥运金牌。对此，这个被誉为 “六边形战士” 的男人表示，“只要心怀热爱，永远都是当打之年”。这是否说明，一切的不合时宜都是自我设限，而年龄不过是个数字。在以往的工作中，我接触的主要是 “Fire and Forget” 这类场景。特别是当一个任务相对短暂时，有没有真正地取消从来都不会成为讨论的重点。直到最近做 Agent 的时候，我发觉这一切其实可以做得更好，即便我的原动力是为了省钱。
async Task Main() { Console.WriteLine(&amp;#34;[HeartBeat] 服务运行中，请按 Ctrl + C 键取消...&amp;#34;); var cts = new CancellationTokenSource(); Console.CancelKeyPress += (sender, e) =&amp;gt; { e.Cancel = true; cts.Cancel(); }; try { await HeartBeatAsync(cts.Token); } catch (OperationCanceledException) { Console.</description></item></channel></rss>