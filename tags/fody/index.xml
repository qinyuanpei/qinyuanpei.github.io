<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fody on 元视角</title><link>https://qinyuanpei.github.io/tags/fody/</link><description>Recent content in Fody on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 23 Aug 2022 12:52:10 +0000</lastBuildDate><atom:link href="https://qinyuanpei.github.io/tags/fody/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Fody 实现 .NET 的静态编织</title><link>https://qinyuanpei.github.io/posts/implement-static-weaving-of-dot-net-via-fody/</link><pubDate>Tue, 23 Aug 2022 12:52:10 +0000</pubDate><guid>https://qinyuanpei.github.io/posts/implement-static-weaving-of-dot-net-via-fody/</guid><description>在很长的一段时间里，我们的项目中一直使用 OnMethodBoundaryAspect 这个基类来记录每个方法的日志。诚然，FodyWeavers.xml 这个文件的存在，早已在冥冥之中暗示我，Fody 才是这座冰山下真正的墨西哥湾暖流。可惜，因为某种阴差阳错的巧合，譬如两者都使用了 OnMethodBoundaryAspect 这个命名，这导致我过去一直以为我们使用的是 PostSharp。如果你是用过 ReSharper 或者 Rider 这些由 JetBrains 出品的工具，你大概会听说过 PostSharp。不过，有趣的是，JetBrains 和 PostSharp 其实没有半毛钱的关系，两者唯一相似的地方，或许是它们都不姓微软:joy:。当我们谈论 PostSharp 的时候，我其实想说的是静态编织。由此，我们就引出了今天这篇文章的主题，即: .NET 中的静态编织。而对于静态编织，我们这里只需要知道，它是一种在编译时期间将特定的字节码插入到目标类和方法的技术。
再从 AOP 说起 想不到吧，此去经年，我再一次聊起了 AOP 这个话题。众所周知，AOP 是指面向切面编程 (Aspect Oriented Programming)，而所谓的切面，可以认为是具体拦截的某个业务点。对于面向对象编程的语言来说，一个业务点通常就是一个方法或者函数。因此，我们谈论 AOP 这个话题的时候，更多的是指在某个方法执行前后插入某种处理逻辑。此时，广义的 AOP 就有静态编织和动态代理两种形式，前者发生在编译时期间，后者发生在运行时期间。如下图所示，我们平时使用的 Castle DynamicProxy 、 AspectCore、DispatchProxy 等等都属于动态代理的范畴，这些都是在运行时期间对代码进行“修改”；而我们今天要讨论的 Fody ，则是属于静态编织的范畴，顾名思义，它是在编译时期间对代码进行“修改”。我们知道，按照实现方式上的不同， AOP 又可以分为代理模式和父子类重写两种“修改”方式。至此，我们对于 AOP 的认知范围被进一步扩大，就像我们以前学习数学的时候，我们对于对于“数”的定义，是先从有理数扩充到无理数，后来又从实数扩充到虚数。那么，屏幕前的你，真的搞懂 AOP 了吗？
广义上的面向切面编程Fody 的初体验 作为一个类库，Fody 在使用上并没有任何非同寻常的地方。这意味着，你可以像使用任何一个第三方库一样，直接通过 NuGet 来安装：
dotnet add package Fody --version 6.6.3 可惜，这样或许会令你感到失望。因为对于 Fody 而言，我们通常使用的是它的插件 (Add-In) 而不是 Fody 本身，除非当你需要真正编写一个插件。身处西安这个十三朝古都，你一定听说过鼎鼎大名的三秦套餐，即：凉皮、冰峰、肉夹馍。这里，我们就以 Rougamo.</description></item></channel></rss>