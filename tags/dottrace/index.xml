<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DotTrace on 元视角</title><link>https://qinyuanpei.github.io/tags/dottrace/</link><description>Recent content in DotTrace on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 01 Nov 2020 12:19:02 +0000</lastBuildDate><atom:link href="https://qinyuanpei.github.io/tags/dottrace/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 dotTrace 对 .NET 应用进行性能分析与优化</title><link>https://qinyuanpei.github.io/posts/3672690776/</link><pubDate>Sun, 01 Nov 2020 12:19:02 +0000</pubDate><guid>https://qinyuanpei.github.io/posts/3672690776/</guid><description>前几天，有位朋友问我，你平时都是怎么去排查一个程序的性能问题的啊。不要误会，这位朋友不是我啦，因为我真的有这样一位叫做 Toby 的朋友。说到性能问题，可能大家立马会想到类似并发数、吞吐量、响应时间、QPS、TPS等等这些指标，这些指标的确可以反映出一个系统性能的好坏。可随着我们的系统结构变得越来越复杂，要找到这样一个性能的“损耗点”，同样会变得越来越困难。在不同的人的眼中，对于性能好坏的评判标准是不一样的，譬如在前端眼中，页面打开速度的快慢代表着性能的好坏；而在后端眼中，并发数、吞吐量和响应时间代表着性能的好坏；而在 DBA 眼中，一条 SQL 语句的执行效率代表着性能的好坏。更不用说，现实世界中的程序要在硬件、网络的世界里来回穿梭了，所以，从 80%的功能堆积到 100%，是件非常容易的事情；而从 80%的性能优化到 85%，则不是件非常轻松的事情。想清楚这一点非常简单，因为我们的系统从来都不是简单的1 + 1 = 2。此时，我们需要一个性能分析工具，而今天给大家分享的是 JetBrains 出品的 dotTrace 。
快速开始(Quick Start) 安装软件的过程此处不表，这里建议大家同时安装 dotTrace 和 dotMemery。因为这都是 JetBrains 全家桶中的软件，安装的时候选一下就可以了，可谓是举手之劳。安装好以后的界面是这样的，可以注意到，它可以对进程中的 .NET 应用、本机的 .NET 应用以及远程的 .NET 应用进行检测，因为这里写一个 .NET Core 应用来作为演示，所以，我们选择 Profile Local App：
dotTrace主界面在这里，我们准备了一个简单的控制台程序：
public class Program { static void Main(string[] args) { CPUHack(); MemeryHack(); } public static void MemeryHack() { Console.ReadLine(); var bytes = GC.GetTotalAllocatedBytes(); Console.WriteLine($&amp;#34;AllocatedBytes: { bytes } bytes&amp;#34;); var list = new List&amp;lt;byte[]&amp;gt;(); try { while (true) { list.</description></item></channel></rss>