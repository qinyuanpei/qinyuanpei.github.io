<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Any on 元视角</title><link>https://qinyuanpei.github.io/tags/any/</link><description>Recent content in Any on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 10 Dec 2021 11:53:29 +0000</lastBuildDate><atom:link href="https://qinyuanpei.github.io/tags/any/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC 借助 Any 类型实现接口的泛化调用</title><link>https://qinyuanpei.github.io/posts/2617947988/</link><pubDate>Fri, 10 Dec 2021 11:53:29 +0000</pubDate><guid>https://qinyuanpei.github.io/posts/2617947988/</guid><description>我发现，人们非常喜欢在一件事情上反复横跳。譬如，以编程语言为例，人们喜欢静态的、强类型语言的严谨和安全，可难免会羡慕动态的、弱类型语言的自由和灵活。于是，在过去的这些年里，我们注意到，.NET 的世界里出现了 dynamic 类型，JavaScript 的世界里出现了 TypeScript，甚至连 Python 都开始支持类型标注。这种动与静、强与弱的角逐，隐隐然有种太极圆转、轮回不绝的感觉。果然，“城外的人想冲进去，城里的人想逃出来”，钱钟书先生说的固然是婚姻，可世上的事情，也许都差不多罢！人们反复横跳的样子，像极了「九品芝麻官」里的方唐镜。曾经有段时间，好多人吹捧 Vue3 + TypeScript 的技术栈，有位前辈一针见血地戳破了这种叶公好龙式的喜欢，“你那么喜欢 TypeScript，不还是关掉了 ESLint 的规则，项目里全部都用 Any”。对于这个吐槽，我表示非常真实，因为我们对于动与静、强与弱的心理变化是非常微妙的。常言道，“动态类型一时爽，代码重构火葬场”，你是如何看待编程语言里的动与静静、强与弱的呢？在 gRPC 中我们通过 Protobuf 来描述接口的参数和返回值，由此对服务提供/消费方进行约束。此时，参数和返回值都是静态的、强类型的。如果我们希望提供某种“泛型”的接口，又该如何去做呢？所以，这篇文章我们来聊聊 gPRC 里的 Any 类型。
Protobuf 里的 Any 类型 在讲 Any 类型前，我想，我们应该想明白，为什么需要这样一个类型？现在，假设我们有下面的 Protobuf 定义：
// Vehicle message Vehicle { int32 VehicleId = 1; string FleetNo = 2; } // Officer message Officer { int32 OfficerId = 1; string Department = 2; } 此时，按照Protobuf的规范，我们必须像下面这样定义对应的集合：
// VehicleList message VehicleList { repeated Vehicle List = 1; } // OfficerList message OfficerList { repeated Officer List = 1; } 考虑到，在C# 中我们只需要使用 List&amp;lt;Vehicle&amp;gt; 和 List&amp;lt;Officer&amp;gt; 即可，这样难免就会形成一种割裂感，因为你几乎要为每一种类型建立对应的表示集合的类型，从语义化的角度考虑，我们更希望使用下面的 Protobuf 定义：</description></item></channel></rss>