<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jeager on 元视角</title><link>http://example.org/tags/jeager/</link><description>Recent content in Jeager on 元视角</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 15 Oct 2022 12:30:47 +0000</lastBuildDate><atom:link href="http://example.org/tags/jeager/index.xml" rel="self" type="application/rss+xml"/><item><title>浅议分布式链路追踪与日志的整合</title><link>http://example.org/posts/integration-of-distributed-tracing-system-and-logging-system/</link><pubDate>Sat, 15 Oct 2022 12:30:47 +0000</pubDate><guid>http://example.org/posts/integration-of-distributed-tracing-system-and-logging-system/</guid><description>最近拜读了 Artech 大佬的新文章 《几个Caller-特性的妙用》，可以说是受益匪浅。不过，对我而言，最大的收获当属这篇文章里的第二主角，即 ActivitySource 和 Activity，这组 API 可以认为是微软针对 OpenTelemetry 规范的一种实现，即：每一个 Activity 都对应着一个 Span 。在以前的博客 《Envoy 集成 Jaeger 实现分布式链路追踪》 中，我曾经向大家介绍过 OpenTelemetry 规范，并最终结合 Envoy 和 Jeager 实现了非侵入式的、网关层的分布式链路追踪，正所谓“温故而知新”，在这个过程中我意识到其中还有值得去挖掘的东西。譬如，可观测性的三大支柱分别是 Logging、Tracing 和 Metrics 。可当我们接入了 Jeager 、Zipkin 等等的链路追踪系统，我们会发现它和平用到日志系统如 NLog、Serilog、ELK &amp;hellip;等等都相去甚远，好像这两者间存在着一种天然的割裂感，你不得不在了解了服务间的调用关系以后，再一头扎进各种各样的日志文件里。幸运的是，经过数日的探索，我有了一点小小的收获。因此，今天这篇博客我想和大家分享的是，分布式链路追踪系统如何和日志系统进行整合。
.NET 中的分布式追踪 微软的 官方文档 中，有一个独立的章节来介绍分布式追踪。如果你观察得足够仔细，就会发现官方将其归类为 诊断和检测。我个人认为，这是我们日常开发中经常被忽略的一个东西。早年开发 Windows 桌面程序的时候，每当程序出现异常的时候，经验丰富的前辈总会让你去看一下 Windows 日志。其实，这个 Windows 日志就是 .NET Framework 时代的一种诊断工具。由此我们就可以知道， Diagnostics 就是一种帮助你记录应用程序运行期间的关键性操作及其执行时长的机制，我承认，这听起来和现在流行的 APM 差不多，至少从宏观上来看这个观点是成立的，因为 APM 的核心功能之一就是检测应用程序的关键事件。从 .NET Core 开始，Diagnostics 这个命名空间从 Microsoft 变为了 System 。如下图所示，整个诊断的核心建立在 Activity 这个类，以及 IObservable&amp;lt;T&amp;gt; 和 IObserver&amp;lt;T&amp;gt; 这组观察者模式的 API 上，其基本原理是：通过一系列活动来产生一系列事件，而关心这些事件的订阅者则可以通过这些事件来判断应用程序当前的状态。</description></item><item><title>利用 ASP.NET Core 中的标头传播实现分布式链路追踪</title><link>http://example.org/posts/asp-net-core-using-headerpropagation-for-distributed-tracking/</link><pubDate>Thu, 07 Apr 2022 09:34:36 +0000</pubDate><guid>http://example.org/posts/asp-net-core-using-headerpropagation-for-distributed-tracking/</guid><description>在此之前，我曾写过一篇博客，《Envoy 集成 Jaeger 实现分布式链路追踪》，主要分享了 ASP.NET Core 应用如何结合 Envoy 和 Jeager 来实现分布式链路追踪，其核心思想是：生成一个全局唯一的 x-request-id ，并在不同的微服务或者子系统中传播该信息。进而，可以使得相关的信息像一条线上的珠子一样串联起来。在此基础上，社区主导并产生了 OpenTracing 规范，在这个 规范 中，一个 Trace，即调用链，是由多个 Span 组成的有向无环图，而每个 Span 则可以含有多个键值对组成的 Tag。不过，当时我们有一个非常尴尬的问题，那就是每个微服务必须显式地传递相关的 HTTP 请求头。那么，是否有一种更优雅的方案呢？而这就是我们今天要分享的内容。首先，我们来回头看看当初的方案，这是一个非常朴实无华的实现：
[HttpPost] public async Task&amp;lt;IActionResult&amp;gt; Post([FromBody] OrderInfo orderInfo) { var paymentInfo = new PaymentInfo() { OrderId = orderInfo.OrderId, PaymentId = Guid.NewGuid().ToString(&amp;#34;N&amp;#34;), Remark = orderInfo.Remark, }; // 设置请求头 _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-request-id&amp;#34;, Request.Headers[&amp;#34;x-request-id&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-traceid&amp;#34;, Request.Headers[&amp;#34;x-b3-traceid&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-spanid&amp;#34;, Request.Headers[&amp;#34;x-b3-spanid&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-parentspanid&amp;#34;, Request.Headers[&amp;#34;x-b3-parentspanid&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-sampled&amp;#34;, Request.Headers[&amp;#34;x-b3-sampled&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-b3-flags&amp;#34;, Request.Headers[&amp;#34;x-b3-flags&amp;#34;].ToString()); _httpClient.DefaultRequestHeaders.Add( &amp;#34;x-ot-span-context&amp;#34;, Request.</description></item></channel></rss>