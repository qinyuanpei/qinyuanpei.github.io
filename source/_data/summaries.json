{"2676125676": {"descs": "我好像被施诅咒一样，在和小古分开后，我喜欢过两个有男朋友的女生，有时候我都想告诉自己，我不再是那个十八九岁的少年，长大以后的爱情夹杂着现实，变得更加让人迷惑，可我再找不回那种“赌书泼茶”的感觉，或许求而不得是人生常态，王尔德说“人生有两种悲剧，一种是想得到的得不到，一种是想得到的得到了”，我对小古说，给我留一个梦好吗;西安的面食对我而言是粗犷的，如同这片关中大地上粗犷的民风，所以最初就买了本菜谱学习做饭，我学做饭的动机，其实是非常简单的，最低要求是以后讨不着老婆不会饿死自己，进阶要求是两口子过日子必须要有一个具备这项生活技能，现在我们看到有把吃作为爱好的吃货，可这样的人是不能称之为吃货的，因为吃货如果就是花花钱动动嘴这样简单，就对不起古往今来的吃货们，譬如苏东坡之于红烧肉，季鹰之于鲈鱼，袁枚之于《随园食单》，能做会吃这是真吃货;我想找一个可以托付终生的人，因为父母总有一天会先我们而去，如果需要有人陪伴在我生命的一刻，我希望那个人会是你，可我决不会如此自私，因为我不想你在这个世界里孤单;大概从8月份开始学习做饭，而学习做饭的动机早就模糊不清，我只知道，从那一刻开始，我的生活开始慢慢发生变化，从一个不知道做饭需要买什么调味品的人，变成一个喜欢逛超市、喜欢看商品价格的人，变成一个喜欢周末去超市购物、喜欢钻研美食的人，变成一个懂得如何照顾自己、爱惜自己的人;2017年技术博客的写作，基本延续2016年的策略，不再写面向新手的教程类内容，而是侧重对技术的整合和改进，尽可能地去写一种思路或者想法，与此同时，希望在技术博客以外扩展更多的，譬如写对生活的感悟、对电影的思考等等，计划中打算开通知乎专栏(已开通)、开通个人微信公众号(正在准备)", "tags": [["人", 0.018949468206759103], ["去", 0.010609174761698833], ["会", 0.00924944568163748], ["电影", 0.007889634609034505], ["喜欢", 0.007880130580584618]], "title": "2017，在驻足间回首"}, "2911923212": {"descs": "因此，这些论文的问世直接催生了Hadoop的诞生，可以说今天主流的大数据框架如Hadoop、Spark等，无一不是受到Google这些论文的影响，而这正是MapReduce由来，其得名则是因为函数式编程中的两个内置函数: map()和reduce();我们提到，MapReduce之得名，其灵感来自函数式编程中的两个内置函数：map()和reduce();通过梳理Web检索的一般流程，我们意识到，Web检索可以分为两部分，即获取网页内容并建立索引、根据网页索引来处理查询关键字，从而引出了Mapper和Reducer两个基本的数据处理单元，MapReduce是分治思想在大规模机器集群时代的集中体现，其中，Mapper负责任务的划分，Reducer负责结果的汇总;接下来，我们顺着函数式编程的思路，分析了函数式编程中的map()和reduce()，这两个核心的函数同MapReduce在思想上的一致性，这正是为了印证前文中MapReduce得名的由来;我们提到MapReduce来自两个内置函数：map()和reduce()", "tags": [["mapreduce", 0.01955178402347755], ["中", 0.0166211777713936], ["函数", 0.01476212472205737], ["上", 0.013024745074676963], ["数据", 0.011192817852527908]], "title": "AI时代：聊聊大数据中的MapReduce"}, "3959327595": {"descs": "服务端的主要职责是处理各个客户端发送来的数据，因此在客户端的Socket编程中需要使用两个线程来循环处理客户端的请求，一个线程用于监听客户端的连接情况，一个线程用于监听客户端的消息发送，当服务端接收到客户端的消息后需要将消息处理后再分发给各个客户端;public void SendMessage(string ip,int port,string msg);客户端相对于服务端来说任务要轻许多，因为客户端仅仅需要和服务端通信即可，可是因为在和服务器通信的过程中，需要时刻保持连接通畅，因此同样需要两个线程来分别处理连接情况的监听和消息发送的监听;//创建服务端线程，实现客户端连接请求的循环监听;本文通过分析和总结C#中Socket通信编程的关键技术，按照同步实现的方式实现了一个简单的Socket聊天程序，目的是通过这个程序来掌握Socket编程，为进一步开发Unity3D网络游戏打下一个坚实的基础", "tags": [["客户端", 0.029436120854911135], ["socket", 0.018050829022526787], ["消息", 0.014938525875805438], ["服务端", 0.013162822912559642], ["连接", 0.012626272683136666]], "title": "C#中Socket通信编程的同步实现"}, "2041685704": {"descs": "相信大家还记得我们在《C#中Socket通信编程的同步实现》这篇文章中使用多线程来实现简单聊天的案例吧，在这个案例中我们需要开启两个线程来不断监听客户端的连接和客户端的消息，这样的效率肯定是很低的;if (socket == null || message == string.Empty) return;在Socket的异步编程中，服务端不需要为一个客户端单独创建一个线程来维护其连接，可是这样带来的一个问题就是博主不知道该如何实现一个多客户端的异步编程的实例;Console.WriteLine(string.Format(\"客户端发送消息:{0}\", Encoding.UTF8.GetString(data)));if (client == null || p == string.Empty) return", "tags": [["socket", 0.029065296564638854], ["中", 0.022904208347760194], ["方法", 0.019162009445048866], ["消息", 0.017626811655001656], ["客户端", 0.015912904090355756]], "title": "C#中Socket通信编程的异步实现"}, "305484621": {"descs": "我们使用扩展方法无非是因为它在逻辑层需要这样的功能，所以我们没有必要去改变抽象层的逻辑，因为这样会“污染”整个代码;/// <param name=\"str\">4、第一个参数必须使用this关键字指定要使用扩展方法的类型</param>;为了解决这个问题，我们可以扩展出三个方法SetPositionX、SetPositionY、SetPositionZ来分别为x、y、z三个坐标分量进行赋值，我们继续在SomeClass这个类中添加方法：;更为重要的一点是，它采用扩展方法这种实现方式，使得我们在调用这些API接口的时候难以感觉到我们是在使用一个插件，更像是在使用Unity3D的原生函数，所以当我们使用DOTween + uGUI 这样的组合的时候，内心会感到无比的舒畅，一切都像是水到渠成一般;C#中的扩展方法实现起来是相对来说比较简单的，例如我们做在Unity3D游戏开发的时候，可能会用到DOTween这个插件", "tags": [["方法", 0.032523420908363423], ["中", 0.02434049917786948], ["会", 0.019667450158962634], ["扩展", 0.01820444687667163], ["使用", 0.015997081553703257]], "title": "C#中的扩展方法学习总结"}, "3086300103": {"descs": "另一方面，既然Id在每个数据库的实现都不一样，那么，作为Id本身应该考虑放到 `ISqlAdapter` 接口中由使用者来实现啊，可偏偏 ISqlAdapter 里只定义了一个 Insert() 方法，所以，就算我们实现了 OracleSqlAdapter ，一样无法解决 Insert() 方法以外的其它方法在 Oracle 下面的问题，正因为如此，默认的 @ 符号在 Oracle 环境下下没有被完全替换掉，这就需要修改 Dapper.Contrib 的底层代码，这真的是一个不好的设计，因为使用者完全没有办法通过重写来覆盖某些默认行为，我们一起来看看，需要修改哪些地方：;因为不同的数据库在实现自增ID时的机制不同，Oracle 甚至需要引入序列这个概念，这种差异化，增加了 Dapper 各个扩展库维护的工作量，这是官方一直不愿意实现 OracleSqlAdapter 的原因，其次， Dapper.Contrib 底层设计不合理，除了Insert() 方法以外，其它依赖主键的方法都没有提供扩展接口，导致使用者只能通过修改底层代码的方式解决问题，这严重违反开闭原则;大家会注意到我实现的 OracleSqlAdapter 在实现 Insert() 方法的时候简化了大量代码，这是因为我真的不知道，怎么从 Oracle 中获取一个新生成的ID，尤其是这个ID居然还要依赖一个我听都没有听说过的“序列”，而之所以要在 ISqlAdapter 中实现 Insert() 方法，最根本的原因就是，各个数据库对于自增ID的实现是不一样的，比如 MySQL 中使用的是 `SCOPE_IDENTITY()`，而 MSSQL 中使用的则是 `SCOPE_IDENTITY()` ，就因为这一点点差异，我们就必须要去折腾一遍，可以说， Dapper.Contrib 不支持 Oracle 的一个重要原因，就是在 Oracle 下实现自增ID太麻烦了;本文分析了 Dapper.Contrib 这个扩展库，在搭配 Oracle 数据库使用时遇到 ORA-XXXXX 系列错误的原因及相应地处理方法，这个问题的表象是 Dapper.Contrib 没有实现 OracleSqlAdapter ，而更深层的原因，实际上是 Dapper.Contrib 选择支持自增ID而带来的 SQL 标准差异化问题;众所周知，`Dapper` 的核心其实就是一个 SqlMapper ，它提供的 Query() 和 Execute() 接口本身都是附加在 `IDbConnection` 接口上的扩展方法，所以，最基础的 `Dapper` 用法其实是伴随着 SQL 语句和以匿名对象为主的参数化查询，这可以说是 Dapper 的核心，而 `Dapper.Contrib` 在这个基础上提供了 Get()、Insert()、Delete() 和 Update() 等等常见的 CRUD 方法，这些方法都针对的是单主键的表，让 `Dapper`有了一点 ORM 的感觉，可惜的是 `Dapper.Contrib` 的实现是不完整的，主要是指下面两个方面，即：第一，官方未能提供 Oracle 版本的 `ISqlAdapter`", "tags": [["dapper", 0.020555914050480552], ["id", 0.0155977697172552], ["oracle", 0.013988230410608862], ["问题", 0.013483409633036658], ["实现", 0.012549852108692047]], "title": "Dapper.Contrib在Oracle环境下引发ORA-00928异常问题的解决"}, "3120185261": {"descs": "从今天起博主将为大家带来EasyAR尝鲜系列教程，本教程适用的对象是增强现实应用开发者和Unity3D游戏开发者，在阅读本教程前请确保具备增强现实应用开发及Unity3D游戏开发的相关基础知识;在本节及后续内容中，博主将以国产增强现实引擎EasyAR为主要开发平台来带领大家一起走进增强现实应用开发的世界，希望大家能够喜欢;[增强现实概念图](https://ww1.sinaimg.cn/large/4c36074fly1fziy7k2yssj20m80b4tad.jpg);作为一款国产的增强现实引擎，目前EasyAR的表现我还是比较满意的，虽然在识别的准确度上无法和国外的同类产品相比，但是它的简单易用确实是做得不错;EasyAR提供了诸如手机APP互动营销、户外大屏幕互动活动、网络营销互动等形式在内的增强现实互动营销技术和解决方案", "tags": [["应用", 0.01914983236324762], ["easyar", 0.01690335638964838], ["sdk", 0.013742416211103265], ["大家", 0.013045261409948125], ["技术", 0.011773450907331682]], "title": "EasyAR尝鲜系列教程之Hello EasyAR"}, "3736599391": {"descs": "好了，在了解了EasyAR中常用的标准接口以后，我们下面来着手构建第一个ImageTarget项目，和我们第一次接触EasyAR不同，这次我们会编写些简单地代码，打开场景填入应用程序密钥(Key)然后运行它，这种方式在这里会显得略LOW;EasyAR中的识别图相对来说比较简单，因为我们只需要选择一张图片然后为其创建一个材质，再将这个材质附加到ImageTarget物体上就可以了;我确信这个类简单到彻底，它需要开发者在编辑器中填入KEY然后再Awake方法中完成对EasyAR的初始化，就是这样简单，我们这里将这个脚本附加到EasyAR这个物体上去，这样我们就完成了引擎的初始化工作，下面我们就可以专注于AR内容的产生了;可以注意到在这个类中我们主要做了两件事情：第一，定义了隐藏和显示识别模型的方法HideObjects和ShowObjects，其作用是在没有识别到Target的时候隐藏物体，在识别到Target的时候显示物体;我们将创建好的材质附加到ImageTarget物体上以后，可能在场景中并不会看到对应的识别图，这是因为我们没有为其配置参数", "tags": [["中", 0.03180355445777011], ["easyar", 0.026784929936370744], ["识别", 0.016878022260045127], ["imagetarget", 0.01575923436142753], ["key", 0.013784324004555024]], "title": "EasyAR尝鲜系列教程之ImageTarget千呼万唤始出来"}, "1156673678": {"descs": "如果我们希望把它放在一个自定义的文件夹中，如StreamingAssets/ziying目录下，则需要将ziying的image属性值改为ziying/ziying.jpg，以此类推;[EasyAR基本流程示意图](https://ww1.sinaimg.cn/large/4c36074fly1fzix180mu7j20g0057dft.jpg);我们可以注意到idback这张图片和mousepad这张图片相比增加了两个属性，即uid和size;到目前为止，EasyAR官方还没有给出一个完整的API文档，所以我们目前能做的研究依然十分有限，在本文中涉及到的部分没有解决的问题，博主会在官方给出文档后第一时间给予解决，希望大家继续关注我的博客;\"image\" : \"idback.jpg\",", "tags": [["中", 0.022371103525261032], ["图片", 0.015452507074866739], ["easyar", 0.014729489177998377], ["对应", 0.010299665069812895], ["官方", 0.009822326900835211]], "title": "EasyAR尝鲜系列教程之自定义Marker的实现"}, "316230277": {"descs": "这个增强ImageTarget是指在ImageTarget的基础上融入VideoPlayerBehaviour的功能，因为按照官方的示例来考虑，这两部分功能是独立的，博主希望让大家在制作识别图的时候完全忘记区别ImageTarget和VideoTarget，这样我们可以更为专注地制作识别图，因为视频组件就只是设置参数这一件事情，完全可以一次性搞定，所以我们首先来定义一个VideoTargetBaseBehaviour类，一起来看代码：;博主这里不太理解EasyAR为什么不采用MovieTexture或者Unity3D中针对视频播放提供的相关插件，因为VideoTarget本质上就是把三维模型换成了可以播放的视频而已，所以大家在前面文章的基础上创建一个ImageTarget然后再其下面放置一个附加了VideoPlayerBehaviour的的子物体就可以了;public void ShowObjects(Transform trans);从图中我们可以看到这个组件相关参数的设置，这里选取的视频资源是StreamingAssets目录下的video.mp4这个文件，视频资源的Stroge同样支持App、Assets、Absolute这三种类型，和图片资源的Stroge是一样的，关于这三种类型的资源路径的问题，我这里不想再重复说了，这个看看文档就知道了;void HideObjects(Transform trans)", "tags": [["视频", 0.025414611303162492], ["组件", 0.017401019231713333], ["中", 0.016706357954469175], ["easyar", 0.011760215118160694], ["imagetarget", 0.011667249032977863]], "title": "EasyAR尝鲜系列教程之视频播放功能的实现"}, "2038378679": {"descs": "## JavaScript中的面向对象编程;如果直接使用JavaScript代码;### 在JavaScript中函数(function)就是就是一个类(class);其中image可以是HTML中的<img/>标签或者是JavaScript中的Image对象;接下来我们通过JavaScript来获取这个Canvas并通过相关API实现绘图环境的初始化", "tags": [["canvas", 0.023162134221239025], ["绘制", 0.017097995180521183], ["中", 0.016771949177504925], ["函数", 0.016410140085288488], ["html5", 0.016319363624140677]], "title": "HTML5游戏开发技术基础整理"}, "3687594958": {"descs": "下面，按照惯例，我们将实现一个“**Hello World**”级别的实例，即：通过ELK来收集一个ASP .NET Core应用的日志信息;所以，从今天开始，我将为大家带来 **.NET Core + ELK搭建可视化日志分析平台** 系列文章，希望大家喜欢;博主计划在接下来的篇幅中介绍`Logstash`/`FireBeat`管道配置、Docker容器内的日志收集、以及自定义日志组件开发这些话题，希望大家继续关注我的博客;至此，ELK在ASP.NET Core中的集成已经全部结束，这意味着我们所有的日志都会写入到ELK中;所以，使用ELK可以为我们带来下面这些便利：**分布式日志数据集中式查询和管理", "tags": [["中", 0.021856979803591643], ["日志", 0.021759116199153442], ["elk", 0.020966051523915893], ["大家", 0.011032229746725289], ["elasticsearch", 0.009723423256676552]], "title": ".NET Core + ELK搭建可视化日志分析平台(上)"}, "116795088": {"descs": "POCOController是ASP.NET Core中提供的一个新特性，按照约定大于配置的原则，在ASP.NET Core项目中，所有带有Controller后缀的类，或者是使用了[Controller]标记的类，即使它没有像模板中一样继承Controller类，ASP.NET Core依然会将其识别为Controller，并拥有和普通Controller一样的功能，说到这里，你是不是有点兴奋了呢，因为我们在ASP.NET里花了大力气去做类似的事情，因为ASP.NET里一个普通的类是没有办法成为Controller的，即使通过Castle的Dynamic Proxy黑科技，我们依然需要去Hack整个MVC框架创建、筛选Controller和Action的过程;所以，我们希望在提供默认路由的基础上，使用者可以自由配置路由风格，所以，我们需要通过这个接口来构造路由信息，值得一提的是，我们可以在这个过程中设置ApiExplorer是否可见，为接口参数设置合适的绑定模型等等，所以，我们会使用HttpGet/HttpPost等来标记接口的调用方式，使用Route来标记用户自定义的路由信息，使用FromBody/FromQuery等来标记参数的绑定信息，有了这些配合Swagger简直是无往不胜，并非是开发人员不愿意写文档，而是因为文档的更新速度往往赶不上需求的变化速度，一旦文档落后于实际业务，这样的文档实际是没有意义的，我真的讨厌所有人都来找你问接口的地址、参数这些东西，如果你写完了一个Service，写好对应的方法注释，然后你就有了一个可用的Web API，和一个可用的在线文档，何乐而不为呢;这篇博客延续了上一篇博客中关于动态Controller的设想，而借助于.NET Core框架提供的良好特性，它以一种更为简洁的方式被实现了，核心的内容有两个点，其一是ControllerFeatureProvider，它能决定MVC会不会把一个普通的类当做控制器;如你所见，我们采用了一种简单粗暴的方式，任何非Public、非抽象、非泛型并且实现了IDynamicController接口的类型，都可以被认为是一个Controller，原谅我起了这样一个直白而普通的接口名称，因为一开始做的时候，真的就是想延续动态Web Api这个想法而已，所以，大家明白就好了，不用太过纠结这个接口的名字，甚至你还可以通过Attribute来打上标记，反正都是为了辨别哪些类型可以被当做控制器;通过我们上一篇文章里动态路由的整个过程，大家就知道有多麻烦了啊，可在.NET Core里要实现一个泛型的控制器就非常容易了啊，因为我们只需要告诉ControllerFeatureProvider，这是一个控制器，并且控制器的类型就是这个泛型参数T，所以，综上所述，ControllerFeatureProvider主要做两个事情，第一，判定一个类型能不能算作Controller", "tags": [["接口", 0.016529982745290352], ["controller", 0.016116236586129453], ["会", 0.01299477659512674], ["api", 0.012120519182729026], ["中", 0.011583474117194417]], "title": ".NET Core POCOController在动态Web API中的应用"}, "2414960312": {"descs": "因为此前实现基于RabbitMQ的EventBus的时候，我们是每次创建一个Channel，即官方所谓的“短连接”的方式，因为Channel本质上是Connection在TCP连接上的一个虚拟连接，所以，每次创建Channel都会占用一个TCP连接，当我们系统中的TCP连接被用完的时候，就会出现无法连接、连接过慢的问题，为了解决这个问题，我们最终引入了对象池，实际上这里是实现了一个Channel“池”，关于是否应该实现Connection“池”，这一点我还没有想好，总而言之，游戏世界里可以复用的GameObject、各种数据库里的连接池，都是对象池模式在各自领域中的具体实现，这就是这篇博客的内容啦，欢迎大家在评论中留言，谢谢大家;在这个项目中，它提供了一个持久化连接的类`DefaultRabbitMQPersistentConnection`，主要解决了RabbitMQ在连接断开后自动重连的问题，可实际上我们都知道，RabbitMQ提供的连接数是有一个上限的，如果频繁地使用短连接的方式，即通过`ConnectionFactory`的`CreateConnection()`方法来创建一个连接，从本质上讲，一个`Connection`对象就是一个TCP连接，而`Channel`则是每个`Connection`对象下有限的虚拟连接，注意“有限”这个限定词，这意味着`Channel`和`Connection`一样，都不能毫无节制的创建下去;实现对象池可以考虑`ConcurrentBag<T>`、`Stack<T>`、`Queue<T>`以及`BlockingCollection<T>`等多种数据结构，而微软在.NET Core中已经为我们实现了一个简单的对象池，大多数情况下，我们只需要定义自己的`IPooledObjectPolicy<T>`去决定对象应该怎么样“借”、怎么样“还”;public void Return(T item);return item", "tags": [["对象", 0.02429320092628831], ["实现", 0.015576911877377439], ["objectpool", 0.015135368382233817], ["中", 0.014227924192728393], ["连接", 0.013856714542321695]], "title": ".NET Core中对象池(Object Pool)的使用"}, "1734098504": {"descs": "public INamedServiceProviderBuilder AddNamedService<TImplementation>(string serviceName, ServiceLifetime lifetime) where TImplementation : class;public INamedServiceProviderBuilder TryAddNamedService<TImplementation>(string serviceName, ServiceLifetime lifetime) where TImplementation : class;相信到这里，大家都明白博主的意图了吧，核心其实是在`Build()`方法中，因为我们最终需要的是其实是`NamedServiceProvider`，而在此之前的种种，都属于收集依赖、构建ServiceProvider的过程，所以，它被定义为`NamedServiceProviderBuilder`，我们在这里维护的这个字典，最终会被传入到`NamedServiceProvider`的构造函数中，这样我们就知道根据名称应该返回哪一个服务了;public NamedServiceProvider(IServiceProvider serviceProvider, IDictionary<string, Type> registrations);var sayHelloFactory = _serviceProvider.GetRequiredService<Func<string, ISayHello>>()", "tags": [["实现", 0.01707552585730031], ["isayhello", 0.013196960469638747], ["注入", 0.012654830205105778], ["serviceprovider", 0.012335229430825106], ["timplementation", 0.011416684840045098]], "title": ".NET Core原生DI扩展之基于名称的注入实现"}, "1658310834": {"descs": "装饰器模式，又被称之为“静态代理\"，是面向切面编程(**AOP**)的实现方式之一，我们在这里为默认的ServiceProvider增加了`Autowired()`方法，它会扫描所有含`[Autowired]`标签的字段或属性，并尝试从容器中获取对应类型的实例;其实，在`AutowiredControllerActivator`里同样有这个问题，就是你即使实现`IServiceProviderFactory`接口，依然没有办法替换掉默认的ServiceProvider实现，只能说它能解决一部分问题，同时又引入了新的问题，最直观的例子是，你看到一个接口的时候，你并不能找全所有加了`[Autowired]`标签的依赖项，所以，直接造成了依赖关系模糊、不透明、难以测试等等的一系列问题，我认为，在一个可控的、小范围内使用还是可以的;var instance = _serviceProvider.GetService (serviceType);instance = null;所以，为了在微软自带的DI上实现属性注入，我们就必须实现自己的ServiceProvider——AutowiredServiceProvider，这个ServiceProvider相比默认的ServiceProvider多了一部分功能，即反射属性或者字段的过程", "tags": [["实现", 0.014768937465339064], ["注入", 0.01466828151577116], ["属性", 0.012480299345885825], ["serviceprovider", 0.011716547244296075], ["容器", 0.011711874175833923]], "title": ".NET Core原生DI扩展之属性注入实现"}, "4197961431": {"descs": "好了，现在大家应该理解EVAL这个命令的使用方法啦，那么对EVALSHA命令来说，顾名思义，它就是使用了SHA1验证的EVAL方法，我们注意到现在脚本都是定义在EVAL命令的第一个参数上，假如我们需要复用一个脚本，而该脚本可以为我们提供Sum这样的功能，即它可以返回一组参数的和给我们，显然参数的个数是不同的，那么这个时候我们总不能每次都重复写这个脚本吧，所以Redis会为脚本创建一个指纹，我们使用EVALSHA命令来传入一个指纹，Redis将从缓存的脚本中找到这个脚本，并结合我们的参数来调用它，这样我们就可以获得脚本执行以后的结果，关于指纹的这种说法，大家可以结合Git提交代码时的感受进行理解，除此以外，它和EVAL在使用方法上是完全一致的，所以不再举例子说明啦;尤其当我面试的时候，我发现好多我写在简历上的内容，都会成为某种意义上的呈堂证供，这让我更加确信好多东西需要不断地去巩固，所以尝试在实际项目上使用Moq、考虑怎么写出更好的测试方法以及时刻保持自我的不可替代性，这些都是我最近在考虑的事情，有时候发脾气是因为觉得自己在浪费生命，可越是被这种无力感笼罩的时候，就越是要对自己狠一点儿，所以在这篇博客中，让我们重新拾起对Redis的学习兴趣，今天我们来说说Redis中的Lua脚本;好了，我们下面来解释下这段脚本，我们向Redis中键名为**data**的集合中添加了5个元素，注意这句脚本是在执行**src/redis-cli**后执行的，这部分内容我们在前面讲解Redis中的数据结构的时候提到过，博主表示在写这篇文章的时候依然要去看文档，总之现在我们有一个集合，并且这个集合中有5个元素，与此同时呢，我们编写了一个Lua脚本文件**script01.lua**，这个脚本的作用是对集合中的元素进行求和;所以我们可以想到一种Lua脚本自动管理的思路，即通过命令行读取指定目录下的Lua脚本文件，通过SCRIPT LOAD方法获得其在Redis中的SHA1指纹，然后我们将脚本名称或者ID和这个指纹关联起来并将其存储在Redis中，此时我们只需要传入脚本名称和参数即可返回脚本执行后的结果，这样是不是感觉非常优雅呢;在Lua脚本中调用call()或者pcall()方法来执行Redis命令时，Redis命令执行的结构会被转换为Lua中的数据结构", "tags": [["redis", 0.027915224322828794], ["脚本", 0.02477089195425873], ["lua", 0.02008480957600954], ["中", 0.01866341952814455], ["命令", 0.011134646895889026]], "title": "Redis缓存技术学习系列之Lua脚本"}, "335366821": {"descs": "在这个例子中，我们尝试在事务中对Record_Count做一个自增操作，这段代码在非并发的情况下是没有问题的，可是在并发的情况下，如果在执行EXEC命令前有一个用户修改了Record_Count的值，那么我们此时的结果就会比期望的结果小1，现在我们有了WATCH，Redis就会对Record_Count进行监听，当Redis监听到该值发生变化的时候，这个事务就会被自动取消，进而避免造成冲突;Redis中提供了一种称为check-and-set的机制，该机制主要通过WATCH命令来实现，其原理正是基于乐观锁的策略，Redis会在执行EXEC命令前检查被监视的键对应的值是否发生变化，如果该值发生变化表明有人修改过这个键中存储的值，此时Redis将会自动取消当前事务;特别地，因为在Redis中命令是存储在一个队列中，所以，事务中的所有命令都会按顺序执行，并且在执行事务的过程中不会被客户端发送的其它命令中断;当我们输入EXEC命令时，将触发当前事务，这相当于我们从命令队列中取出命令并执行，所以Redis中一个事务从开始到执行会经历**开始事务**、**命令入队**和**执行事务**三个阶段;我们这里举一个例子，数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条SQL语句在被执行的时候，都会生成一条撤销日志(Undo Log)，而撤销日志中记录的是和当前擦作完全相反的操作，比如删除的相反操作是插入，插入的相反操作是删除等", "tags": [["事务", 0.03118393751994268], ["中", 0.028285542766943256], ["redis", 0.025519302112651247], ["执行", 0.017956647681886838], ["键", 0.01752481388269237]], "title": "Redis缓存技术学习系列之事务处理"}, "1444577573": {"descs": "对具体观察者而言，我们需要做的就是继承Observer类然后重写Update方法，在这里我们需要实现两个不同的类EmailObserver和WechatObserver，它们分别来实现邮件和公众号接收到主题推送消息以后的逻辑，这里以EmailObserver为例，代码实现如下：;在这里，我们订阅的公众号称为\"主题\"，而我们则称为\"观察者\"或者\"订阅者\"，而这正是观察者模式又被称为\"发布-订阅模式\"的原因所在，这种定义了一种一对多的依赖关系，让多个观察者同时监听同一个主题对象，当该主题对象在状态发生变化时，会通知所有观察者对象并使其自动更新自己的设计模式就被称为\"观察者模式\";这个场景可以看出\"推送模式\"让订阅者饱受消息骚扰，而为了解决这个问题，我们就有了\"拉取模式\"，此时主题仅仅是告诉观察者博客内容有更新，而更新的内容需要观察者自己去处理，这种模式大同小异，大家可以参照\"推送模式\"来自己实现;对Observer而言，它在观察者模式中承担着消息接收者的角色，所以我们需要为其定义好接收消息的接口，需要注意的是该接口必须与具体主题保持一致，这便是我在文章中提到的，主题和观察者存在一定程度依赖的问题;虽然我们在这篇文章中花费大量时间来讲观察者模式，事实上Redis中的发布-订阅是非常轻量并且强大的，下面是常见的命令：", "tags": [["观察者", 0.03240580909497286], ["模式", 0.02640401433421854], ["中", 0.02205405472677815], ["消息", 0.020348663156623707], ["订阅", 0.019427464567912712]], "title": "Redis缓存技术学习系列之发布订阅"}, "3032366281": {"descs": "​        好了，这就是这篇博客的内容了，自我感觉Redis中的内容相对分散，这种细小的知识点都隐藏在命令中，最初在介绍不同的数据类型的时候，在文章中均做了详细的介绍并辅以终端脚本，可是最后发现这样写下去还不如去看官方文档，像Redis这种即使学习了都不见得有机会使用的技术，当然我并不是说Redis不好啊，关系型数据库目前依然是主流的技术驱动力量，所以我觉得我们学习的时候最好是“观其大略”、“不求甚解”，首先注重整体知识体系上的理解，微枝末叶上的细节问题可以在使用的时候去查阅文档;我们知道Redis是一个键-值数据库，所以在了解了Redis中支持的数据类型，即“值”以后，现在让我们将关注点回归到“键”上面来，这是因为作为一个键-值数据库，键是我们从数据库中获取值的唯一方式，因此在这里说说Redis中那些和键有关的命令，这些命令基本都遵循下面的命名格式，常见的命令有：;Redis是一个采用键-值存储方案的数据库，因而传统关系型数据库里的SQL在这里将不再适用;在Redis中可以使用HMSET、HMGET、HGET、HGETALL四种命令来存储和读取散列类型的值;这个例子演示了如何在Redis中存储和读取一个简单的字符串类型的值，看起来这一切都非常简单啊，的确Redis就是这样一个简单而高效的键-值数据库", "tags": [["redis", 0.03475168060261791], ["命令", 0.021793310404848207], ["中", 0.021167094190310414], ["使用", 0.01875070867431573], ["数据库", 0.018203313274786755]], "title": "Redis缓存技术学习系列之邂逅Redis"}, "2015300310": {"descs": "既然要使用`Referer`这个错误的拼写，那就一直这样错下去好了，为什么特么又冒出来个`Referrer`，虽然它的拼写的确是对的，可不统一的写法还是会让人抓狂啊;说到这里，大家至少明白了一件事情，这个错误的`Referer`其实是指`Referrer`;有人说，使用JavaScript开发同构应用的体验非常好，恐怕从今天这篇博客以后要打个折扣，因为你刚刚在后端写完`referer`，转眼就要在前端写`referrer`，希望像博主这样的`伪全栈工程师`不会因此而精神分裂;所以一般涉及到读取 HTTP 请求头的场景，我们需要用 Referer 这种错误拼写(后端);故事要追溯到上个世纪90年代，当时HTTP协议中需要有一个用来表示页面或资源来源的请求头部，Philip Hallam-Baker将这个请求头部定义为Referer，并将其写入了[RFC1945](https://datatracker.ietf.org/doc/rfc1945/", "tags": [["referer", 0.023073778084311602], ["referrer", 0.019399880993251985], ["错误", 0.017646678073986403], ["中", 0.014461461109367173], ["http", 0.013612999541353192]], "title": "Referrer还是Referer? 一个迷人的错误"}, "183718218": {"descs": "# 什么是SDL;在以上代码中我们基本遵循了SDL游戏开发的一般流程，即首先对SDL进行初始化，当SDL初始化完成后，我们创建一个标题为\"SDL学习示例1\",窗口对齐方式为居中对齐，窗口大小为640*480的窗口，然后创建了模式为软件渲染的SDL渲染器，并设置渲染器的背景色为黑色;作为第一个项目，它简单到纯粹，当我们运行项目，会发现一个黑色的窗口一闪而过，这是因为我们这里在渲染了一次后就使用SDL_Quit()方法退出了，第一篇文章并不会有太复杂的内容，因为它的意义在于让我们对SDL游戏开发有个基本的认识和了解;下面以一个简单的示例来向大家演示SDL游戏开发的一般流程：;SDL游戏开发的一般流程是：", "tags": [["sdl", 0.06857362694875103], ["开发", 0.016142363004423132], ["大家", 0.015286522658551098], ["http", 0.012161711821438303], ["游戏", 0.011789474617445072]], "title": "SDL游戏开发系列第一话：Hello SDL"}, "3789971938": {"descs": "SDL_RenderCopy(g_pRenderer,m_pTexture,m_pSrcRect,m_pTargetRect);SDL_RenderCopy(renderer,m_pTexture,m_pSrcRect,m_pTargetRect);SDL_RenderCopy(renderer,m_pTexture,m_pSrcRect,m_pTargetRect);//绘制SDL纹理;//绘制SDL纹理", "tags": [["sdl", 0.05775073799656584], ["中", 0.023111140184248168], ["方法", 0.01897185128328652], ["绘制", 0.0186518434230674], ["图片", 0.014351285133890536]], "title": "SDL游戏开发系列第二话：基本图形的绘制"}, "1176959868": {"descs": "//Debug.Log(\"敌人\" + _enemy.transform.name + \"未进入攻击范围,距离为:\" + mDis);//Debug.Log(\"敌人\" + _enemy.transform.name + \"已进入攻击范围,距离为:\" + mDis);好了，现在我们来说说敌人的血条吧，我们知道当怪物沿着寻路路径向我方阵地发起攻击的时候，我方防守单位会自动地对敌人进行防御性攻击，那么此时血条就可以显示敌人的实时血量，从而方便玩家根据战场的情况来调整兵力部署情况;_Enemy.HP= (float)mData.Level*0.25F * 100;go.GetComponent<Enemy>().MoveSpeed=(float)mData.Level * 0.15F", "tags": [["敌人", 0.03559636049751506], ["中", 0.012841976199200442], ["大家", 0.012488340099522897], ["float", 0.010982848946970132], ["enemy", 0.010376525701048233]], "title": "Unity3D塔防游戏开发项目讲解(下)"}, "927393529": {"descs": "1、三个不同的物体使用同一种材质，不做静态批处理，不做动态批处理：**DrawCall为4、面数为584、顶点数为641**;2、三个不同的物体使用同一种材质，只做静态批处理，不做动态批处理：**DrawCall为2、面数为584、顶点数为641**;3、三个不同的物体使用不同的材质，不做静态批处理，不做动态批处理：**DrawCall为4、面数为584、顶点数为641**;4、三个不同的物体使用不同的材质，只做静态批处理，不做动态批处理：**DrawCall为4、面数为584、顶点数为641**;5、三个不同的物体使用不同的材质，不做静态批处理，只做动态批处理：**DrawCall为4、面数为584、顶点数为641**", "tags": [["游戏", 0.022300367386755587], ["批处理", 0.017104369414169755], ["中", 0.01533612772832928], ["材质", 0.01105794653610412], ["unity3d", 0.010918027017272685]], "title": "Unity3D游戏场景优化系列之批处理"}, "2527231326": {"descs": "目前主要有C++ CLR和C++ Native两种实现方法，其中C++ CLR可以理解为运行在.Net CLR即公共语言运行库上的C++代码，这种代码是托管的C++代码，目前并没有被C++标准承认，因为它更像是C++和C#两种语言的混合代码，这种代码的优势是可以像普通的.NET库一样被C#调用，考虑到Unity3D建立在和.Net类似的Mono上，因此这种方式应该是我们的最佳实践方案;Debug.Log(\"调用C++ CLR中的方法Max(5,10):\" + ExampleClass.Max(5,10));C++ Native则是指传统的C++ 动态链接库，通过DllImport在C#中进行包装后在C#中进行调用，相对地这种方式调用的是非托管的C++代码，这种方式相信接触过Windows开发的朋友应该不会感到陌生啦，它是一种更为普遍的方法，例如我们要接入苹果官方SDK的时候，需要对Object C的代码进行封装后交给C#去调用，而这里使用的方法就是DllImport了;return (gcnew System::Random)->Next(min,max);Debug.Log(\"调用C++ Native的方法Max(5,10):\" + Max(5, 10))", "tags": [["c++", 0.0260138326449221], ["中", 0.020830537147532316], ["方法", 0.019118232574174148], ["c#", 0.015810230605783116], ["使用", 0.015633921852152788]], "title": "Unity3D游戏开发之C++插件接入"}, "4088452183": {"descs": "* 1、通过PMD Loader打开加载PMD文件的窗口，建议这里将ShaderType设置为Default，因为如果使用MMD的Shader的话，待会转换出来的模型可能会存在找不到材质的问题;该软件最初希望能够将3D建模软件完成的VOCALOID的初音未来等角色模型制作成可以随着音乐跳舞的动画，因此称为MMD;从这样一个过程我们了解到，制作MMD还是需要一定的技术门槛的，因为并不是每一个人都能够完成模型的绑骨、动画这些任务的;如果选择MMDShader，转换出的模型会找不到对应得材质，比如说我在尝试转换下面这个模型的时候，因为MMD对模型的精细程度的要求，所以模型会被分得很细，因此像这个模型当贴图数目较少的时候，就没有办法自动对应贴图，所以这快目前还是个问题吧;* 2、接下来通过VMD Loader打开加载VMD文件的窗口，选择场景中的模型文件和项目资源中的XMD动作文件，点击Convert，大概有1分钟多一点的样子就好了", "tags": [["mmd", 0.03116687772818318], ["模型", 0.031146218333574192], ["会", 0.020448126452873257], ["https", 0.015199151830838909], ["制作", 0.014943467960232128]], "title": "Unity3D游戏开发之MMD For Unity插件研究"}, "582264328": {"descs": "* 三、在使用InsertValues方法时请参考SQLite中字段类型与C#中数据类型的对应关系，博主目前测试了int类型和string类型都没有什么问题，更多类型的数据请大家自行测试然后告诉博主测试的结果，如果大家有兴趣扩展这个辅助类的话可以自行去扩展哦，嘿嘿;int fieldCount=ReadFullTable(tableName).FieldCount;在Unity3D中使用的SQLite以Mono.Data.Sqlite.dll即动态链接库的形式给出，因此我们需要将这个文件放置在项目目录下的Plugins文件夹中，此外我们需要System.Data.dll或者Mono.Data.dll这两个文件添加到Plugins目录中，因为我们需要的部分数据相关的API或者类都定义在这两个文件当中，这些文件可以从[这里](http://pan.baidu.com/s/1sjLZyrj)直接下载;string queryString = \"DELETE FROM \" + tableName + \" WHERE \" + colNames[0] + operations[0] + colValues[0];string queryString = \"DELETE FROM \" + tableName + \" WHERE \" + colNames[0] + operations[0] + colValues[0]", "tags": [["数据库", 0.03314063954642315], ["string", 0.014183539211103787], ["sqlite", 0.013504608640674397], ["中", 0.012758256688925718], ["大家", 0.011078863881381382]], "title": "Unity3D游戏开发之SQLite让数据库开发更简单"}, "3019914405": {"descs": "注意到DrawRotate()方法与DrawPositin()及DrawScale()方法在实现方式上略有不同，这是因为Transform组件的Rotation属性是一个Quaternion即四元数的结构，四元数是利用x、y、z、w四个数值来表示物体的三维旋转，这不仅和我们平时习惯的欧拉角相违背而且更为关键的是貌似目前我还没有发现可以直接绘制四元数的API接口，如果有的话希望大家可以告诉我，所以这里我们用了变通的一种方法，即通过Transform的eulerAngles来实现，但是这种方式绘制的属性框大小和EditorGUILayout.PropertyField()方法绘制的属性框大小并不一致，同时我们需要自己去完成属性值的更新;此时如果我们给场景中的某个物体附加上该脚本，则我们在Inspector窗口可以看到Example类的实例Example将被序列化到编辑器面板中，同时我们可以注意到私有的editable字段并没有被序列化出来，这是因为**在Unity3D中，公有的字段默认支持序列化，私有的字段除非显式的增加[SerializeField]标记，否则都不会被序列化**，这一点希望大家注意;在第一个示例中，可以注意到我们使用了FindProperty()方法来获取一个可序列化物体的属性(字段)，然后我们在EditorGUILayout.PropertyField()方法来绘制了各种属性框，这种方式可以实现属性的自动更新;这里的PatrolNPC是一个可寻路NPC类，基本和这篇文章的内容无关，大家只要知道那个Paths字段是一个Vector3[]就好啦，这样当我们在场景中编辑这些路径节点的时候，对应NPC的路径节点信息就会同步发生更新，这样我们就可以随心所欲地规划NPC的移动路径啦，哈哈;* OnInspectorGUI():该方法可对Inspector窗口面板进行扩展或者重写，比如我们可以通过DrawDefaultInspector()方法来绘制默认Inspector窗口面板然后在此基础上使用GUILayout或者EditorGUILayout等辅助类进行自定义的绘制", "tags": [["方法", 0.020685781745513224], ["中", 0.020310591103261826], ["属性", 0.014459969936422887], ["paths", 0.013875270052437336], ["序列化", 0.012680007464901843]], "title": "Unity3D游戏开发之Unity3D场景编辑器扩展开发"}, "1320325685": {"descs": "Unity3D的[Asset Server](http://unity3d.com/unity/team/assetserver/)是一个Unity3D内部集成的版本控制软件，它和我们熟知的SVN类似，适合在小团队内进行版本控制，这是一个收费软件，尽管在某些方面它甚至比SVN还要方便，不过在实际的项目中使用这个的还是比较少的，所以如果大家对这个感兴趣，可以从这里了解它的具体情况，这里我们不打算介绍这个软件的使用;因此为了方便版本控制软件对文件进行比对，常常需要项目变动的这些因素转化为文本形式，如果熟悉Github的朋友应该知道，Github中判断两个文件的差异就是根据文本(代码)来比较的，因此在Unity3D中使用版本控制同样需要遵循这个原则，好在Unity3D在管理Unity3D项目时已经考虑到了这一点，通常在对Unity3D项目进行版本控制的时候，我们需要做这样的事情：;使用Github进行版本控制时可以在Git仓库中添加一个.gitignore文件来对项目中需要同步的文件进行过滤，在文章开始我们已经知道Unity3D项目的版本控制主要针对Assets和ProjectSetting这两个文件，因此.gitignore的内容可以这样填写:;在Unity3D中进行版本控制主要针对Assets和ProjectSetting这两个文件夹，因为除此以外的文件和文件夹都是Unity3D在运行过程中产生的临时文件，这些文件会在使用Unity3D打开项目后重新生成，因此无需对这些文件或文件夹进行版本控制;* Unity3D中的资源默认是以二进制的形式进行组织的，这种组织方式对版本控制来说是不合适的，因此需要通过通过Edit->Project Settings->Editor菜单打开编辑器设置选项，将Asset Serialization下的Mode设为Force Text", "tags": [["文件", 0.02281284363521638], ["进行", 0.02203797961545275], ["中", 0.020364817057138457], ["项目", 0.0181859263749517], ["unity3d", 0.01675307852997458]], "title": "Unity3D游戏开发之从Unity3D项目版本控制说起"}, "1467630055": {"descs": "可是因为这种打包方式仅仅是保证了场景中的GameObject与本地资源的引用关系而非是将本地资源打包，因此从减少游戏容量的角度来说并不是十分实用，而且当我们使用WWW下载完AssetBundle后，需要使用Application.Load()方法来加载场景，我们知道在Unity3D中加载一个关卡(场景)是需要在BuildSetting中注册关卡的，因此在使用这种方式动态加载的时候请注意到这一点;这种思路是考虑到需要在一个场景中动态替换GameObject或者是动态生成GameObject的情形，使用这种方法首先要满足一个条件，即：场景内所有的物体都是预制件(Prefab);既然今天的题目已然告诉大家是使用AssetBundle和Xml文件实现场景的动态加载，我相信大家已经明白我要使用那种方式了;* 将场景内的所有物体打包为AssetBundle配合相关配置文件动态生成场景：这种方法的思路是使用一个配置文件来记录下当前场景中所有物体的位置、旋转和缩放信息，然后再根据配置文件使用Instantiate方法逐个生成即可;* 使用BuildStreamedSceneAssetBundle()方法将场景打包为AssetBundle：这种方法将生成一个流式的.unity3d文件，从而实现按需下载和加载，因此这种方式特别适合Web环境下游戏场景的加载，因为在Web环境下我们可以希望的是玩家可以在玩游戏的同时加载游戏", "tags": [["场景", 0.024585678636416346], ["物体", 0.01813337653079022], ["使用", 0.01786901831269918], ["gameobject", 0.01709170417690342], ["中", 0.016760265053416257]], "title": "Unity3D游戏开发之使用AssetBundle和Xml实现场景的动态加载"}, "1082185388": {"descs": "好了，下面我们再来看看怎么提取这个模型文件对应的贴图，在游戏目录/assetbundles/NPC/Texture/下有一个名为s049_1.unity3d_1D2446B9的文件，这就是s049这个模型对应的贴图了;下面我们就来尝试解析这个文件，不过游戏制作方对config文件夹下的内容进行了加密，因为在这个文件夹下面是两个AssetBundle文件，博主尝试用extract和bundle-extract两个命令进行解析，可是得到的只是些文本文件，对我们继续研究没有什么帮助;这个工具呢，博主在[Unity3D游戏开发之反编译AssetBundle提取游戏资源](http://www.qinyuanpei.com/2015/04/02/unity3d-development-with-assetbundle/)这篇文章中其实已经提到过了，不过因为有些朋友对如何使用这个工具依然存在问题，所以博主决定特地写一篇文章来讲解如何使用disunity来提取Unity3D游戏中的素材;这说明《新仙剑OL》的场景和界面资源是通过动态加载的方式加载到游戏当中的，而这些资源则是通过这个Xml文件来配置和管理的，这符合我们平时在Unity3D游戏开发中的观点和方法;因为所有的Unity3D游戏都会有这样的文件，而AssetBundle文件只有在使用了这项技术的游戏项目中才有", "tags": [["文件", 0.03161563870268259], ["unity3d", 0.022526615377043525], ["游戏", 0.02180264739619479], ["中", 0.02161874522796722], ["disunity", 0.018082649818972747]], "title": "Unity3D游戏开发之使用disunity提取Unity3D游戏资源"}, "166983157": {"descs": "经过博客中一位朋友指出，这篇文章中实现BindPage这个方法时可以在代码上再精简些，主要是考虑这个代码中有部分功能是重合的，因此这里对这个方法进行重写，分页从本质上来讲是编写这样一个函数：输入数据集合data、每页显示的元素个数pageSize以及当前页数page，然后返回一个新的数据集合;在这段代码中，m_ItemList表示我们要展示的元素列表，m_ItemsCount表示元素列表中元素的个数，m_PageCount表示这些元素可以分成的总页数，m_PageIndex表示页数的索引**默认从1开始**;return sprite;return output;好了，前面我们说到分页的一个目的是可以解决列表内元素数目不确定的问题，因此我们这里利用一个12生肖的数组来随机生成元素数目不同的列表，代码实现如下：", "tags": [["元素", 0.02060681776408261], ["中", 0.018657515537155427], ["griditem", 0.01667042484509393], ["大家", 0.010622248992999078], ["列表", 0.009614191835961712]], "title": "Unity3D游戏开发之分页效果在uGUI中的实现"}, "2799263488": {"descs": "具体来说呢，AssetBundle在Unity3D中是一种用于资源打包盒资源动态加载的解决方法，比如我们平时玩的单机游戏容量一般都比较大，这是因为制作人员在制作游戏的时候将所有的项目资源都整合到了一起;第五个参数是平台的选择，因为Unity3D是一个跨平台的游戏引擎，而各个平台现在的情况又不尽相同，因此现在Unity3D采取的方案是各个平台只能使用自己平台对应的AssetBundle，这一点希望大家在使用的时候注意啊;这是一个简单的导出AssetBundle资源包的方法，它有两个参数，第一个参数表示是一个枚举类型，定义为ExportType，取Single时表示打包一个特定的激活物体，比如说一个模型、一个场景等等;好了，今天的内容就是这样了，希望大家喜欢，AssetBundle打包是一个值得去深入研究的问题，今天博主提出的这些观点不过是对《新仙剑OL》这个游戏的打包提出de一些看法，如果大家有不同的看法，欢迎一起来交流;今天我们来说说通过反编译Unity3D的AssetBundle来提取游戏资源，博主写这篇文章的目的并非是要教大家如何去破解一款基于Unity3D引擎开发的游戏，而是想通过今天这篇文章来告诉大家如何在开发Unity3D游戏的过程中保护自己的游戏资源", "tags": [["游戏", 0.03547811038646213], ["assetbundle", 0.019133983342150822], ["中", 0.016479451713300786], ["资源", 0.016299080932826802], ["大家", 0.015312162650663784]], "title": "Unity3D游戏开发之反编译AssetBundle提取游戏资源"}, "1190622881": {"descs": "本文通过对网络上两种比较通用的不规则按钮制作方案进行对比和研究，解决了基于多边形碰撞器实现不规则按钮这个过程中存在的问题，剖析了基于精灵像素检测实现不规则按钮 这个过程的内部原理，从易用性角度来讲，后者要优于前者，而这种方法的缺陷主要来自于它对图片类型的限制以及允许像素可读写这两个方面，它必须是Advance类型，所以普通的Texture或者Sprite拥有的特性在这里它都无法享受，比如我们无法为其做颜色渐变这类Tween动画、无法使用精灵特有的图集特性等等，于此同时它必须允许像素可读写，因此在实际使用中它会在内存中复制一份，在执行效率上可能会受到影响;我们必须意识到的一点是，这个方法的空间复杂度为O(n-1)，所以随着多边形顶点数目的增加，这个方法的执行效率会越来越低，如果对不规则精灵的边界没有十分苛刻的要求的话，我的建议是我们使用多边形碰撞器标记出一个相对模糊的边界即可，因为现在我们这个方法主要依靠数学计算，没有涉及到摄像机相关计算，所以宣雨松[博客](http://www.xuanyusong.com/archives/3492)中有朋友指出他的方法仅仅适用于Canvas的模式为Screen-Space Camera这种情况，而我目前这个方法对除了World Space以外都是可以使用的，我最大的疑虑来自对鼠标位置进行转化的时候是否应该使用Screen.width和Screen.height，因为我担心可能会出现屏幕适配这种需求;mod=viewthread&tid=41050&highlight=uGUI%2B%E4%B8%8D%E8%A7%84%E5%88%99&mobile=2)指出可以使用多边形碰撞器的OverlapPoint方法来判断一个点是否在多边形内部，可是经过我测试，这种方式和宣雨松提供的方法有着类似地问题，无论是否对坐标系进行转换，这个方法都返回false，响应区域与上图完全一致;* 2、RolygonCollider2D中的points属性即多边形顶点数组存储的是相对于UI元素的相对坐标，在进行计算的时候应该统一转化为绝对坐标，这个过程在宣雨松的代码中有所涉及，但我认为对UI元素来讲，应该使用transform.GetComponent<RectTransform>().position而非transform.position，因为transform.position最初是给3D物体使用的，而实际上这里是存在误差的;这段代码说实话我理解的不是很透彻，而且令人费解的是实际结论和算法结论完全相反，因为按照我现在这样的设计，当cn为偶数时返回为true，此时应该表示该点再多边形外部啊，可是事实上我测试这段代码的时候，它居然是可以正常工作的，即当该方法返回true的时候我的点击确实是在多边形内部，所以这是一段可以正常工作同时让我感到费解的代码，而且当我屏蔽了cn为0的这种情况以后，现在它已经可以完美的工作了", "tags": [["中", 0.019463561317870772], ["方法", 0.01624724447045292], ["使用", 0.010285835404279822], ["问题", 0.009890514131632402], ["精灵", 0.00808250054946512]], "title": "Unity3D游戏开发之在uGUI中使用不规则精灵制作按钮"}, "1424645834": {"descs": "这里我们首先将关卡配置文件levels.xml放置在Resources目录下，这是因为我们可以使用Resources.Load()这种方式来加载本地资源，这种方式对于Unity3D来说有着得天独厚的优势：;总之呢，我们把握住一点，这个路径是可以在移动平台上使用的一个可以读写的路径，当然在路径这块儿可能同样会碰到和Application.dataPath类似的问题，因为博主写这篇文章的时候并没有对移动平台进行测试，这一点希望大家能够注意啊，这并不是我偷懒，实在是公司最近的事情比较多，没有时间做进一步的测试，不过除了路径的问题以外，我可以向大家保证，这个路径是可以读写的，所以如果我们在开发Unity3D游戏过程中需要在本地存储某些文件的话，这个路径是个不错的选择;从关卡的基本结构Level可以定义出如下的配置文件，这里使用Xml作为配置文件的存储形式：;那么好了，在完成了关卡的结构定义和配置文件定义后，接下来我们开始思考如何来实现一个关卡系统，因为此处并不涉及到Unity3D场景中的具体逻辑，因此我们在关卡系统中主要的工作就是维护好主界面场景和各个游戏场景的跳转关系，我们可以注意到这里要完成两件事情，即第一要将配置文件中的关卡以一定形式加载到主界面中，并告诉玩家哪些关卡是已解锁的、哪些关卡是未解锁的，当玩家点击不同的关卡时可以得到不同的响应，已解锁的关卡可以访问并进入游戏环节，未解锁的关卡则需要获得更多的分数或者是通过付费来解锁关卡;这两点综合起来就是我们需要对关卡的配置文件进行读写，因为我们注意到一个关卡是否解锁仅仅取决于unlock属性，那么好了，明白了这一点后我们来动手编写一个维护关卡的类", "tags": [["关卡", 0.02739893717208323], ["路径", 0.01681895587224525], ["大家", 0.015111988103212197], ["中", 0.014025781233304266], ["游戏", 0.012416994554225562]], "title": "Unity3D游戏开发之快速打造流行的关卡系统"}, "70687890": {"descs": "开发Unity3D编辑器扩展程序的命名空间主要是UnityEditor，在该命名空间下常用的类有EditorGUI、EditorGUILayout、EditorWindow(可能还有其它的类，不过到目前为止博主就用过这些，如果有其它的类，欢迎大家来补充啊);当我们在场景中选择好物体后，只要填好预设物体的名称、tag、Layer就可以直接生成Prefab了，不过这里有个问题，因为生成Prefab必须要传入一个GameObject，因此如果直接选择项目资源文件夹里的内容可能会报错，因为你选择的不是一个GameObject;* 在Unity3D中我们可以通过TextureImporter、ModelImporter、AudioImporter、MovieImporter等来分别向Unity3D中导入贴图、模型、音频、视频等等，经过设置后最终通过AssetDatabase.ImportAsset()来将其添加到项目中热完全，最后需要使用AssetDatabase.Refresh()方法来刷新本地资源，使导入的资源生效;而对于有界面的这种扩展程序，我们需要让定义的这个类继承EditorWindow并实现OnGUI()方法,因为在OnGUI()方法中我们将会对扩展程序的界面进行绘制，不过无需担心啦，因此扩展程序的界面绘制和Unity3D脚本中的OnGUI()方法是相似的，我们要做的就是要熟悉常见的控件;我们知道在没有UGUI以前，我们使用NGUI的时候要做的第一件事情就是把要用到的贴图打成图集，现在在Unity3D里面我们可以通过贴图的Packing Tag来实现图集打包，就是说具有相同Packing Tag的物体会被打到一张大图上，这样做的好处是节省资源", "tags": [["中", 0.022808298135659662], ["unity3d", 0.017106502820996183], ["贴图", 0.015107108251311206], ["大家", 0.013892085803710551], ["物体", 0.01241917461626106]], "title": "Unity3D游戏开发之编辑器扩展程序开发实例"}, "719322223": {"descs": "我不知道公司领导当初是怎么样确定使用Unity3D来做这个项目，因为考虑到虚拟展示的需要，这个项目最终展示给用户的是一个网页，这样就更需要考虑资源组织的问题，就这样在工作的第一周时间内我想到了以前在学校做游戏的时候都没\"舍得\"使用的技术方案，基本的思路是本地的游戏文件最终仅仅保留一个主场景文件(MainMenu.cs)，主场景负责维护从楼盘到户型再到家装的所有逻辑，各个场景中的动态的部分则是通过Resource.Load()和AssetBundle来实现，将这些场景放到服务器上，主场景将决定具体加载哪一个场景;然而现实是残酷的，在这个项目中，因为楼盘、户型、家装等等因素的不可控性，所以在设计UI的时候全部都是以动态加载的形式来处理的，因为你并不能确定这些UI里显示的元素到底有多少个，这样我在设计这个框架的时候是这样考虑的，就是把所有需要人力来调整、控制的部分(如模型摆放、场景设计等等)都手动完成，所以和UI相关的部分(如UI元素的动态加载、模型的加载、本地配置文件等等)都通过动态加载来实现，因为在整个项目中第三部分的家装会涉及到大量的模型，所以这部分考虑的是将模型文件打包成AssetBundle文件从服务器加载;具体使用的时候需要将*号部分分别替换成允许跨域访问的地址和端口，因为我是用WAMP这个软件搭建的本地服务器，所以这里都采用的是默认值，具体怎么去设置这里的内容还需要大家自己去探索，不过这里就是像告诉大家使用Unity3D做网页游戏或者是从服务器上下载文件是一定要考虑这个问题的啊;这个问题主要是因为服务器上缺少一个叫做crossdomain.xml的文件，这是由Adobe提出的以保证Flash能够跨域访问文件的一种策略，当发生这个错误时具体的表现就是你可以通过浏览器从服务器上下载AssetBundle文件，可是当你试图在Unity里使用WWW访问该文件时就会报错，具体的错误信息我已经不记得了，不过错误信息中特别明确的指出了是因为缺少crossdomain.xml这个文件，所以解决的方案就是在服务器根目录里增加这样一个文件，文件的内容如下：;可是在设计整个项目的过程中，因为美术都忙着建模，所以UI设计这块儿基本上都是空白，作为一个刚进公司不久没有什么话语权的新人，在这种情况下我只能自己先大致做出来一个DEMO，然后再听取领导的意见反复进行修改，可是如果这样，到了项目后期如果因为项目需求发生变动，可能UI设计就需要重新制作，我个人是比较讨厌做UI，因为UI有时候会因为参数设置不合理等等的原因造成无法调试的错误，这样你折腾了大半天找了可能出现的各种错误，最终却发现是因为一个参数设置不合理，这该有多蛋疼啊", "tags": [["中", 0.017176071270002757], ["ui", 0.012987088907553377], ["项目", 0.01229979709771599], ["场景", 0.011983234650039264], ["问题", 0.010591395439695861]], "title": "Unity3D游戏开发之路：一周工作总结"}, "1059499448": {"descs": "我进公司这么长时间，基本没有看到过成文的策划或者是方案，更多的时候是大家在一块儿做，然后做的过程中发现有什么问题再返回去改，领导的态度从来没有准，觉得什么东西可以借鉴过来就要求程序和美术去实现，计划朝令夕改内心深处就不知道自己想做什么;我一直强调统一和规范，可是美术总认为程序的要求过于苛刻，可是事实上懂得编程的人都明白计算机程序不过是对某个过程的一种模拟，而且这个过程是有限状态的，因此当美术说需要XXX功能的时候，程序员的内心其实是拒绝的，因为为了这点需求，他可能需要写十几行重复的代码，为了满足用户的懒惰和弱智，领导让我们将户型内的物体尽量全部实现动态化，要给用户最大的自由，结果却是剥夺了程序员的自由写了若干个if或者是重复调用相同的方法，这简直是恶魔啊;好了，那么现在的问题是我们处在一个没有策划的团队里，如果程序按照美术的思路去做，可能程序会在修改了若干次项目以后对美术的要求失去信心，因为相对于程序解决问题而言，作为美术的普通人提出需求的难度显然更低;归根到底一句话，美术不愿意尝试新的东西，美术总认为Max里的模型导出到Unity3D后材质啊、灯光啊会丢，美术总认为Max渲染的效果要比Unity3D好许多，可是既然你选择了这个引擎来做项目，我觉得美术是有责任来了解这个引擎的，你让程序员帮你拼UI我可以接受，可是你让程序员帮你打灯光、修改材质、摆场景，这是程序员该做的事情嘛;这种想法其实是特别可怕的，以公司为例，从我进公司以来，公司从未对即将要做的项目进行过技术上的评估和立项讨论，公司的大部分美术甚至都不知道有这样一个项目存在、更不知道做好的模型要运用到一个怎样的技术上去以及最终会以什么样的方式呈现给用户", "tags": [["项目", 0.021450708988567373], ["美术", 0.017340535009937916], ["做", 0.015095113088046523], ["程序员", 0.010144643223980543], ["代码", 0.009638038128927245]], "title": "Unity3D游戏开发之路：一月工作总结"}, "887585917": {"descs": "因为我们这里要做的是一个游戏存档的方案设计，因为考虑到存档数据的安全性，我们可以考虑采用相关的加密/解密算法来实现对序列化后的明文数据进行加密，这样可以从一定程度上保证游戏存档数据的安全性;public static void SetData(string fileName,object pObject);public static object GetData(string fileName,Type pType);private static object DeserializeObject(string pString,Type pType);private static object DeserializeObject(string pString,Type pType)", "tags": [["数据", 0.018418781678738935], ["string", 0.015077010102877904], ["存档", 0.013790510283280578], ["游戏", 0.013640953677012808], ["信息", 0.01264292217968225]], "title": "Unity3D游戏开发游戏读/存档在Unity3D中的实现"}, "369095810": {"descs": "所以，说白了我们就是想利用它这个“云引擎”来调用Server酱的接口，幸运的是，LeanCloud提供的Hooks目前是支持Nodejs的，所以，到这里思路就非常清晰了，我们给`Comment`这张表加一个`AfterSave`类型的Hooks，在保存完以后调用Server酱接口推送评论信息即可;[Valine](https://valine.js.org/)是一个基于[LeanCloud](https://leancloud.cn)的评论系统，在很长的一段时间里，一直作为多说、[Gitalk](https://gitalk.github.io/)、[Gitment](https://github.com/imsun/gitment)等等的一个替代品，博主所使用的评论系统实际上就是Valine，虽然独立博客的整体活跃度无法媲美专业博客，可还是想在这纷扰的世界里有自己的一方天地啊;Valine本身是利用LeanCloud的数据存储SDK来实现评论的读写的，所以，它相对于“多说”这种第三方的服务，在数据安全性上更有保障一点，虽然“多说”在关闭评论服务以前，提供了导出JSON格式评论信息的功能;LeanCloud提供了一个称作“云引擎”的环境，它可以提供运行比如Nodejs、Python等等的环境，实际上，[Valine-Admin](https://github.com/DesertsP/Valine-Admin)这个项目就是用Nodejs编写的，你可以理解为，只要你的应用符合它的规范，就能在它的环境里运行，这就是所谓的“FAAS”(函数即软件)和“BAAS”(后端即软件);而[Server酱](http://sc.ftqq.com/)则是一个消息推送服务，它提供了一个基于HTTP的请求接口，通过这个接口，我们就能实现向微信推送消息，前提是关注“方糖”公众号", "tags": [["评论", 0.021727767285643455], ["提供", 0.012491452082714693], ["博客", 0.011881250542367857], ["https", 0.010982699289791977], ["hooks", 0.010240403219166905]], "title": "Valine搭配Server酱实现博客评论推送"}, "169430744": {"descs": "通过Vue文档中关于[数据校验](<https://cn.vuejs.org/v2/cookbook/form-validation.html>)这一节的内容，我们了解到官方推荐的两个表单验证插件是[vuelidate](https://github.com/monterail/vuelidate)和[VeeValidate](http://vee-validate.logaretm.com/)，而实际上这篇博客中的第一个例子，就是由文档中的例子演化而来;<div class=\"form-group\" name=\"password\" rules=\"required\">;-- script of LoginForm -->;<div class=\"form-group\">;<div class=\"form-group\">", "tags": [["vue", 0.018072138975850405], ["验证", 0.015541440752500624], ["项目", 0.011670637551847333], ["校验", 0.009753303802587134], ["表单", 0.009404271341548507]], "title": "Vue快速实现通用表单验证"}, "2488769283": {"descs": "博主曾经在「[声明式RESTful客户端WebApiClient在项目中的应用](https://blog.yuanpei.me/posts/380519286/)」这篇博客中，介绍过.NET平台下的“Retrofit”——[WebApiClient](https://github.com/dotnetcore/WebApiClient)，它是一种声明式的RESTful客户端，通过动态代理来生成Http调用过程代码，而调用方只需要定义一个接口，并使用相关“注解”对接口进行修饰即可，类似的实现还有[Refit](https://github.com/reactiveui/refit)，是一种比HttpWebRequest、HttpClient和RestSharp更为优雅的接口调用方式;是的，你猜对了，实际运作过程中，测试环境和正式环境不单单会使用不同的域名，可能还会使用不同的路由，虽然，理论上两个环境的程序应该完全一样，应该使用相同的路由;在今天这篇博客中，我想聊聊WebApiClient中动态路由的实现与使用;这样，我们就在无形中解决了一类问题，对于第二种形式，版本号以查询参数的方式出现，我们选择在过滤器中`AddUrlQuery()`或者使用`[PathQuery]`来解决;这种方式可以解决问题，可我使用WebApiClient的原因之一，就是我不喜欢在客户端(调用方)维护这些地址", "tags": [["webapiclient", 0.02236335383953052], ["使用", 0.021864497397294794], ["中", 0.019818205927298417], ["接口", 0.017479735433781708], ["服务", 0.016333027233721042]], "title": "WebApiClient中动态路由的实现与使用"}, "4159187524": {"descs": "好了，以上就是在使用WSL中的Docker搭建ELK全家桶过程中遇到的问题的梳理，从体验上来讲，我个人会把Linux平台相关的工作渐渐转移到WSL上，因为安装双系统总会分散你的精力去处理维护相关的事情，虽然装系统对程序员来说都不算是个事儿，可我内心依旧排斥自己被贴上“修电脑”的标签;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -;装完WSL以后，对各种编译环境的使用相当满意，最近在研究日志可视化平台ELK，其中需要使用Docker来搭建环境，一顿sudo操作猛如虎，快速安装完Docker环境，结果发现熟悉的命令行居然无法正常工作，是可忍孰不可忍;[WSL中完美运行的Docker](https://ww1.sinaimg.cn/large/4c36074fly1g2ohrctulqj20m80bomy1.jpg);接下来，我们给WSL中的Docker设置宿主机的地址，在终端中输入下列命令即可：", "tags": [["docker", 0.05553279199298532], ["wsl", 0.023393672895344053], ["中", 0.017801240721773415], ["会", 0.016806863822266385], ["linux", 0.012770736309311496]], "title": "WSL下Docker使用踩坑小记"}, "1397717193": {"descs": "var treeNode = zTree[i];= null) {;var parentNode = treeNode.getParentNode();var parentNode = treeNode.getParentNode();var treeNode = treeNodes[i]", "tags": [["ztree", 0.02908996608713206], ["节点", 0.024705087895861583], ["var", 0.01320460265873775], ["null", 0.013032857042200825], ["树形", 0.012521547052446335]], "title": "zTree删除/拖拽子节点保留父节点分组样式"}, "345410188": {"descs": "* Tips38：通过Task实例的ConfigureAwait()方法，可以设置使用await时同步上下文的行为，默认情况下，await操作符会尝试捕捉同步上下文，并在其中执行代码，即调度器会向UI线程投入成千上百个后续操作任务，这会使用它的消息循环来异步地执行这些任务，当我们不需要在UI线程中运行这些代码时，向ConfigureAwait方法传入false将会是一个更高效的方案;* Tips51：ParallelEnumerable类含有PLINQ的全部逻辑，并且作为IEnumerable集合功能的一组扩展方法，默认情况下结果会被合并单个线程中，我们可以通过ForAll方法来指定处理逻辑，此时它们使用的是同一个线程，将跳过合并结果的过程，除了AsParallel()方法，我们同样可以使用AsSequential()方法，来使得PLINQ查询以顺序方式执行(相对于并行);* Tips13：SemaphoreSlim是Semaphore的轻量级版本，用以限制同时访问同一个资源的线程数量，超过该数量的线程需要等待，直到之前的线程中某一个完成工作，并调用Release()方法发出信号，其使用了混合模式，而Semaphore则使用内核模式，可以在跨程序同步的场景下使用;使用Task实例的RunSynchronously方法启动任务，该任务是运行在主线程中，这是一个非常好的优化，可以避免使用线程池来执行非常短暂的操作;要创建一个异步函数，首先需要使用async关键字标注一个方法，其次异步函数必须返回Task或Task类型，可以使用async void的方法，但是更推荐async Task的方法，使用async void的方法的唯一合理的地方就是在程序中使用顶层UI控制器事件处理器的时候，在使用async关键字标注的方法内部，可以使用await操作符，该操作符可与TPL任务一起工作，并获取该任务中异步操作的结果，在async方法外部不能使用await关键字，否则会有编译错误，异步函数代码中至少要拥有一个await关键字", "tags": [["方法", 0.027818557169272454], ["线程", 0.027016144839061812], ["使用", 0.024548139208892285], ["中", 0.017035675331263038], ["调用", 0.013151753109242886]], "title": "《C#多线程编程实战》读书笔记"}, "1670305415": {"descs": "在这里子着色器使用Tags标签来告诉渲染引擎期望何时和如何渲染对象，其语法是：;在通道中可以定义其名称和任意数目的标签，通过使用tags来告诉渲染引擎在什么时候该如何渲染他们所期望的效果，其语法和Tags标签完全相同，即采用键值对来定义标签的名称和其对应的值;Properties是由多条标签组成的Shader属性定义，这些属性能够在Unity3D中的编辑器中显示出来，以此来确定这段Shader代码由哪些输入;设置当顶点光照关闭时所使用的颜色;表示决定渲染次序的队列标签，其取值定义如下：", "tags": [["中", 0.023416872154854447], ["shader", 0.020209320775596683], ["渲染", 0.019011324708251287], ["cg", 0.014787058848604259], ["时", 0.01324989389791871]], "title": "《Cg Programming in Unity》读书笔记"}, "3677280829": {"descs": "- 指使用符合RPC风格的XML或JSON + HTTP接口的系统(不使用SOAP);- 使用HTTP;# 查询参数和路径的使用区别;# 设计优美的Web API：;- 表示唯一资源时，放在路径中", "tags": [["使用", 0.033642704368554946], ["资源", 0.02862493607720499], ["http", 0.025182179988328907], ["api", 0.024673207914363032], ["指定", 0.02044937770774177]], "title": "《Web API 的设计与开发》读书笔记"}, "1118169753": {"descs": "仙剑六中做得最好看的永远都是人物的脸，我不知道北软是不是在有意告诉大家：这是一个看脸、靠脸的时代，所以当我们面对这个游戏的时候我们就发现整个游戏除了脸比较漂亮以外基本没有什么优点，可是事实上不同的人物在不同的场合、年龄他的面部应该都是不一样的啊，北软你把所有人的脸都做的这么漂亮，是想告诉玩家都不用去努力工作、只要拼脸就可以了吗;在仙剑奇侠传六的宣传阶段，我在我的QQ群里、我的博客中不断向大家输送着这样一个概念：仙剑六是仙剑奇侠传系列二十年的突破之作，它一定不会让大家失望的，甚至我不遗余力地和游戏圈子里使用Unity3D引擎开发游戏的朋友们说，看，仙剑六是使用Unity3D引擎开发的，它的画面是历代游戏中最好的，这一次它终于要尝试即时战斗了;目前Unity3D的授权方式是收入超过3万美元即18万人民币左右需要按照一定的比例向Unity3D官方支付费用，我不知道这次的优化问题是否会对仙剑六的销量产生影响，可是我觉得恐怕官方都会认为这款游戏存在影响Unity3D引擎声誉的问题吧;对于此次仙剑六游戏优化的问题，我不想做详细的说明，我更不想为北软洗白，当我们觉得仙剑奇侠传六之泰坦陨落变成一个笑话的时候，我觉得我们可以说说Unity3D这个游戏引擎了;首先我们来说说游戏画面，我不知道有多少玩家可以在这款游戏中保证特效全开，总之在我的电脑上看起来整个画面有一种糊糊的感觉，远景看起来比较唯美壮丽，然而当我将镜头拉近的时候我觉得我还是不要计较仙剑奇侠传这个游戏的画面了吧", "tags": [["游戏", 0.015884228352265238], ["仙剑", 0.015232579864001866], ["觉得", 0.009094155746298476], ["大家", 0.008271625084895122], ["人", 0.0077482521621907025]], "title": "《仙剑奇侠传六》游戏感言"}, "1684318907": {"descs": "可是大护法很快就发现，在花生镇这样一个奇怪的地方，随时随地都会有人杀戮村民和外来者，这些人被称为刑法者，负责帮助老神仙欧阳吉安杀死“该死”地村民，所以在故事一开始大护法在村子里就遭到了袭击，可是说起大护法来，这是一个战斗力爆表的反差萌系设定，而通过故事我们知道，这些刑法者由一个称为罗单的人管理，他不属于花生镇，和欧阳吉安这些人类不一样，他对彩这个神秘女子有种强烈的占有欲，他偷看她洗澡被发现便转身离开，可当他发现下属产生感情的时候，他毫不留情地杀死了他们，所以大概到现在为止，我们所认识的世界存在着严格的等级区分，整个故事从此定性，罗单压抑着自己的情欲，却不允许下属产生情欲，所以当他杀死欧阳吉安的时候，我们不会感到太意外，因为他心里隐藏了太多东西;欧阳吉安，即花生镇村名眼中的老神仙，他说鬼蘑菇是一种可怕的传染病，一旦花生人长了鬼蘑菇就必须被立即处死，花生人不能开口说话，即使他们都贴着假眼睛和假嘴巴，花生人不能拥有意识和思考，一旦说出事实就会被认为染了疯病必须被立即处死，所有的村民都循规蹈矩地听着老神仙的话，可事实上鬼蘑菇根本就不是传染病，它是花生人成熟的标志，老神仙这样一个统治者，从来不会将花生人视为人，它们活着的唯一意义就是等死后，由庖卯从脑袋里取出黑石头;在整个故事设定中，大护法的爷爷的爷爷起就一直是弈卫国的大护法，所以大护法的职责就是要保护太子，在故事安排上这部电影相对枯燥，因为后期基本上一直在找太子，所以太子有这样的机会，去选择做自己想做的事情，其实是因为有大护法在一直保护他，相反普通人可能不会有这样的机会，这一点我们稍后会提到;小姜是唯一一个自我意识觉醒的花生人，他通过隐婆了解到自己是怎么来到这个世界上的，了解到毒蘑菇到底是怎么一回事情，了解到花生人来自蚁猴子却又以蚁猴子为食的真相，这里有一个有趣的设定，花生人是以蚁猴子作为食物的，这就好像喂猪的泔水里会有猪肉一样，想通了这一点，或许人吃猪肉和人吃人并没有本质的区别;可在影片中颇为讽刺的是，一个想成为厨师的人的最大理想，居然是想要一刀取人心脏，我们不能说这种想法不是一份理想，用大护法的话说就是“你的理想，杀气这么重，怕是实现得一天，会是你的终年”", "tags": [["人", 0.025105712929144982], ["会", 0.015463213125976828], ["花生", 0.015014355857413274], ["故事", 0.01323588238739946], ["说", 0.010569193507971269]], "title": "《大护法》—— 花生镇里的成人童话"}, "1122710277": {"descs": "说明：表达是否最好用0和1来表示，我们用Y和N时经常会出现，开发人员忘记给模型赋值，导致进入到数据库里的数据出现错误数据，而领域模型里又不建议给字段默认值，可如果使用unsigned tinyint类型，它本身就自带默认值0，这样就可以避免这种问题的出现;说明：建议全部使用小写，因为主流SQL教程的里关键字都采用大写，但在PLSQL/SQLyog里编写SQL语句时，字段会自动地变成小写，而且不区分大小写，为了避免人格分裂，建议所有字段都用小写;说明：英文不好可以去查，禁止使用纯拼音或者拼音缩写的命名方式，除了不能“望文生义”以外，对导致别人在调用接口的时候，向这种“丧心病狂”的编码风格妥协，这里不点名批评某SAP提供的OA接口，除了超级难用以外，每次都要花大量时间去对字段;说明：冗余字段是个好东西，但主表和扩展表间的一致性保证需要经过良好的设计，那种把相关表都放在一个事务里处理的做法，都声称是为了保证数据的一致性，可实际过程中依然会存在数据不一致的情况;说明：因为finally块一定会在return前执行，所以，无论程序是否发生了异常，我们都可以在finally块中对资源对象、流对象、数据库连接等进行关闭或者释放，using其实是try", "tags": [["使用", 0.022129758167092454], ["接口", 0.01145998400743306], ["说明", 0.011132967240052404], ["进行", 0.01023854719973366], ["会", 0.009811308911321332]], "title": "《阿里巴巴Java开发手册》读书笔记"}, "3247186509": {"descs": "在这里Contract实现了IRankable接口，每个Contract的权重由Level和Priority两个属性来计算，示例中我们一次从集合中随机抽取了10个Contract，而我们的算法能够保证它们都是不重复的，这个程序可以满足各种各样的抽取规则，比如按照Contract的口语、职位等不同的维度进行概率模型的建立即可，只要它实现了IRankable接口就可以使用这篇文章中的方法来随机抽取，这其实是一个业余时间的小项目啦，可我还是想让自己认真地考虑下这个问题，所以我花时间写了这篇文章，我对它的期望并没有太高，我喜欢将这些想法写下来而已;后者在每次抽取完以后需要将抽中的奖品从奖品池中取出，重新计算概率后方能进行下一轮抽取，所以这里我们直接给出这两两种抽取方法的代码实现，这里需要考虑的一个问题是，在抽取指定数目个“奖品”的时候我们通常不希望出现重复的元素，前者需要我们判断已抽取的奖品列表中是否存在指定元素，而后者因为抽取的奖品会被取出，所以不需要考虑这种情况的处理;好了，现在我们就获得了不同权重物品所对应的累积概率，即其概率范围，因此我们可以利用随机生成[0,1)范围内的随机数，然后判断随机数所在哪个概率范围内，我们就可以知道要对哪个权重分组中的奖品进行抽取，而对每个权重分组来说，因为其权重都是一样的，所以这里抽取试验可以认为是符合随机概率的，我们只需要从该分组中随机选取一个奖品返回就可以啦;首先我们可以想到的一点是，因为这里的泛型类型T需要实现IRankable接口，因此我们可以通过IRankable接口中定义的GetRank()方法来获取不同奖品的权重，在此基础上我们对奖品按照权重进行分组，则我们可以计算出每种权重在整个奖品权重中占到的百分比，我们以此作为每种权重奖品的概率，利用累积概率的思想可以非常容易地获得各种权重奖品对应的概率范围;好了，言归正传，现在我们会发现一个问题，这种方案在奖品种类非常多的情况下，调整概率会是一件非常困难的事情，这就像工程师不喜欢产品经理和游戏策划，其真实原因并非是工程师无法实现特定需求，而是在整个建筑完成规划和设计以后，频繁的需求变更让一座伟大的建筑变成了临时的脚手架，你必须认识到这是工程师经过创作以后的某种产出，你可以不在乎这些无人问津的代码，可是我作为工程师我一定要比任何人都要在乎啊", "tags": [["概率", 0.021244960001253522], ["contract", 0.014027276206640842], ["问题", 0.013864114252514298], ["需要", 0.012016376456326285], ["level", 0.011046397155220282]], "title": "一个关于概率的问题的思考"}, "172426938": {"descs": "博主有一个Python[脚本](https://github.com/qinyuanpei/BlogScripts/blob/master/HexoBlog.py)运行在TravisCI的服务器上，而TravisCI来自一家法国的技术公司，因此在不指定时区的情况下，会默认使用TravisCI服务器上的时间，这并不是我想要的结果，所以，我们需要pytz来解决这个问题，至于这里为什么我们使用的是上海而不是北京，这是因为中国横跨5个时区，在国内大家习惯使用北京时间，而在国外这些时区数据没有做及时更新，所以这算是一个关于时区的历史遗留问题吧;* Time类型仅存储时间，不存储日期，需要7个字节的存储空间，默认格式为hh:mm:ss.nnnnnnn，可以注意到默认的秒分量小数部分为7位，建议使用字符串或者SysDateTime()这两种方式赋值，不建议使用GetDate()，因为该方法返回值为DateTime类型，其时间部分的精度没有Time类型的经度高;简单来说，在Python中我们只需要给定时区，即可将本地时间转化为指定时区对应的UTC时间，这里我们使用的是Python中的pytz这个库，如果你打开这个库的安装目录，就会发现其实它有大量时区相关的数据组成，如果我们直接调用pytz.timezone()就可以获得所有的时区信息;* Date类型仅存储日期，不存储时间，需要3个字节的存储空间，默认格式为yyyy-MM-dd(PS:为什么没有一个标准来统一这些占位符的大小写)，取值范围为0001-01-01 ~ 9999-12-31，可以采用字符串、GetDate()、SysDateTime()三种方式赋值;根据该格式的定义，当日期和时间组合使用时，需要在时间面前增加一个大写字母T，而Z表示时区，且默认表示0时区，因此字母Z可以省略，以我国为例，我国是东八区，所以正确的写法是+08:00，由此可以得知，第二种写法实际上就是一个表示东八区时间的表示方法，虽然这个写法是错误的", "tags": [["时间", 0.03334554314384567], ["中", 0.01466973824483784], ["会", 0.01433794785322679], ["时区", 0.014042208553554357], ["问题", 0.010034529314251141]], "title": "一个由服务器时区引发的Bug"}, "1809438689": {"descs": "一个30+的朋友和我说，他想自己干点啥，因为他觉得他再找工作就没人要了，也许生活就是永远这么充满变化吧，就像不变的只有变化本身一样，提前焦虑未来没有什么用，现在的规划将来不一样会按部就班，我只能说，多去想想自己有什么，如果你只是比别人能加班，这实在算不上什么过人的长处，因为随时有年轻人可以替换你下来;坦白说，我并不知道该怎么去说，而更戏剧性的反转，则是后来一家公司联系到我，问我有没有意向去做这些背调公司的外包，你要知道，在西安几乎没有互联网公司，所以，当绕了一大圈后，再回到原点的时候，我不禁哑然失笑;这次面试中兴的经历，让我意识到，虽然进入IT行业的门槛非常低，可同样不幸的是，大厂/国企对相关岗位的门槛在不断加高，研究生起步基本就是标配啦，我甚至怀疑，我没有通过中兴的面试，是否和我非科班的出身以及没有考过的四级有关，这的确是一个现实问题，不管你想走技术路线，还是想走管理路线，一段大厂的经历能为你增加不少闪光点，可如果你拼进全力依然被这些门槛挡住，你是否会对未来感到迷茫呢;今年因为疫情的原因，医疗行业应该赚得盆满钵满，可好多公司还是在疯狂地抢占市场，类似的还有物流行业，可在效益还不错的情况下，我只看到了越来越变本加厉的压榨，我看日剧《下町火箭》的时候就在想，虽然佃制作所这样一家小公司一样会加班，可人家的是火箭级别的阀门和加速器啊，人家愿意花时间去钻研工艺技术，而我们只能通过比别人早交付来赢得客户的青睐，那这是否说明，我们和竞争对手间的服务差异化其实并不大呢;就这样，一直等一直面，陆陆续续地接到像软通动力这种外包性质的Offer，在面试中更是见识了大大小小的各种公司，我发现整个行业都在疯狂的内卷，996在道德上的批判声还没有褪去，人们又开始钻劳动法的空子，搞大小周、周一/三/四强制加班，这样做的不单单有华为、中兴这样的大厂，同样还有这些小公司", "tags": [["去", 0.022893479654204567], ["公司", 0.014948430732738027], ["没有", 0.012579543224993373], ["会", 0.011946204346595823], ["工作", 0.010512957171679854]], "title": "一个西漂打工人的求职心路"}, "2613006280": {"descs": "妓院里男主一个房间一个房间的找小女孩，当找到小女孩的时候，这个电影突然燃了起来，虽然按照角色设定，男主不应该有这样的身手，可事实上这名印度演员萨尔曼·汗，就是以健身达人的称号闻名于世的，据说他参与演出的电影都会安排裸露上身的戏份，这一次我们就当做主角光环好啦，甚至当看到黑中介在电线上荡秋千时，小女孩那纯真的笑脸，我能想到的只有一句话，“愿你被世界温柔对待”，这样一个可爱的小女孩，我愿意她一直都长不大，因为这个世界并没有那么好，幸运的是，她遇到了善良的猴神大叔;电影两条相互交叉的线索构成，男主帕夫是一个虔诚的宗教信徒，他信奉的是印度猴神哈奴曼，并努力将宗教的教义落实到言行中去，甚至在生活中显得憨厚而木讷，导演在刻画这个人物时明显夸大了这一点，印象最深的是男主考高中就考了10次，最终父亲居然因为这个“惊喜”而去世;电影的主线是非常清晰的，不同的是，整个电影被放在一个充斥着宗教矛盾、种姓歧视、印巴冲突的大背景里，所以导演试图去表达的内涵，就不再单纯地是为了讲这样一个故事，一如“三傻”抨击印度教育制度、OMG/偶滴个神/PK探讨宗教和神一样，这部电影里有许多值得去探讨的东西;男主的岳父家是一个典型的印度佛教徒家庭，沙希达因为受到肉食的诱惑而到领居家吃鸡肉，当她遇到清真寺就会像母亲一样裹上头巾上前参拜;事实上两国曾因为流民而引发流血事件，电影中男主岳父仇视巴基斯坦人的原因恰在于此", "tags": [["印度", 0.01524803452520917], ["沙希达", 0.013089000902413803], ["男主", 0.012236999213800875], ["小女孩", 0.012169665388087246], ["人", 0.011544307451658364]], "title": "一念执着，千山无阻"}, "21112647": {"descs": "昨天晚上，不知道为什么突然特别难过，或许是因为被同事说中心事，或许是因为想到我喜欢过的女孩而心存不甘，或许是因为憎恶现在这个状态的自己......总而言之，有那么一瞬间我感到我的心像是被挖去了一块，原来喜欢一个人可以让我如此难过，想到种种过往我以为自己会泣不成声，结果我声音哽咽着眼睛却是干的，或许我们最喜欢使用的那个“破涕为笑”的表情最能形容我当时的心境，我想了很久，一个人跑出去散步，当风轻轻地划过我的脸庞的时候，当秋天的寒意让我猝不及防的时候，我忽然觉得，当这个世界越发地充满“恶意”的时候，你更需要一个坚强地理由去生活，她们都教会我很多，和这个相比，悲伤和痛苦都显得微不足道，我想努力学好英语、我想努力练习写字、我想努力培养兴趣、我想努力克服恐惧，我是一个骄傲的人，在技术上是在生活上更应该是，如果我不能像编程一样掌控世界，我愿意在这纷繁的世界里不忘初心，喜欢和爱这种美好的情感，是不该让悲伤来消化的奢侈品;男人在年轻的时候，最难以接受而不得不接受的一个现实是，你非常喜欢一个人，可你此时此刻完全没有能力给她想要的生活，就像古古说她可能再遇不到我这样对她好的人，可她始终觉得我们两个人是没有未来的，而这一次，我忽然发现这一切是如此的相似，虽然我清楚地知道她们是完全不同的两个人，当她们同时对我说出“你会找到真正适合你的那个人”这句话的时候，我已无心分辨这句话的真假，我只知道我会陷入无休止的纠结，就像一个死循环导致的精神分裂;当一个男生接受女生“成为朋友”这种现实的时候，从某种意义上来讲，他是将对她的喜欢以一种新的方式重新输出，就像她不在公司里的时候，她愿意委托我帮她处理某些事情，这对我而言是非常开心的一个时刻，因为你永远都期待着，她在有事情的时候能够第一个想到你，即使她曾经拒绝过你两次，即使她明确告诉你她不喜欢你，我曾经告诉过自己，喜欢是占有而爱是克制，至少曾经有很多很多的瞬间，我们两个人因为坦露心声而变得非常开心，这是我最让我怀念的瞬间;我确认我依然喜欢她，尤其是当我知道，她年龄比我大1岁以及她拥有硕士学位，这样两个事实以后，我更多的纠结和痛苦是来自来自我的否定，我们常常说爱情一半靠缘分一半靠争取，可当你真正试图走进一个人的生活的时候，你是否认真地考虑过两个人的未来，因为我不想重蹈覆辙;我像是忽然间发现我在感情上的天赋基本为负值似的，从我开始喜欢她开始，在这个过程中我感觉自己非常自卑，甚至当我真正站在她面前的时候，我常常会变得非常笨拙以至于完全不知道要说什么，我和她说我在她面前的时候有点儿“怕”她，她回复给我一个笑脸说：你可是我师父啊", "tags": [["人", 0.019625000355992503], ["说", 0.018104389115883898], ["喜欢", 0.01708072920390638], ["会", 0.016860268654455418], ["想", 0.010592630196193192]], "title": "一见钟情，无疾而终"}, "3411909634": {"descs": "return (Comparer<T>)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(GenericComparer<int>), t);return (Comparer<T>)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(GenericComparer<int>), t);if (other == null) return 1;= null) return -1;= null) return -1", "tags": [["hashset", 0.017072845644377742], ["接口", 0.013743219156977297], ["中", 0.013605125052748124], ["int", 0.011812714048589487], ["方法", 0.010778680704782294]], "title": "一道 HashSet 面试题引发的蝴蝶效应"}, "720539850": {"descs": "我忽然发现我一年中我陪他们的日子屈指可数，从前向往远方觉得在那里能找到我的梦，现在越发地觉得他们一天天老去，想努力长大成熟，让他们能够放心，可更怕因为距离而疏远了他们，古人说『树欲静而风不止，子欲养而亲不待』，这个世界固然不再是古人所认识的世界，这种感情却超越了时间和空间轮回至今;早上看到这样一句话，『你懂得越多，就越觉得自己像这个世界里的孤儿』，人生而孤独，父母总有一天会离开我们，但他们教会我们如何去爱这个世界，我希望我可以用他们教会我的，在他们有生之年做些在他们眼里不再『孩子气』的事情，虽然在他们眼里我们永远都是孩子，我觉得真正的成熟并不是变得冷酷麻木，而是你知道这个世界有黑暗的一面，依然愿意相信那些温暖的事情;如果没有人愿意陪伴我做一件事情，我不会勉强更不会因此而沮丧，因为当你习惯了一个人去面对所有事情，你会发现你从来不缺乏做一件事情的动力;想到父母孤零零地待在家里，想到每年屈指可数的回家次数，曾几何时，我们想去更广阔的世界寻找诗和远方，可父母逐渐蹒跚的步履注定无法，陪伴我们去那些遥远的地方;可当家里人问我国庆要不要回家的时候，我突然心软得像融化了的雪，我意识到是我心底涌出的一股暖流，快速地打开微信买回家的火车票，结果发现15号的时候票就没有了，妈妈发微信给我说，『如果实在买不到火车票，就买机票回来吧，不用太心疼钱，人回来了就好』", "tags": [["去", 0.020240181787613262], ["回家", 0.01545241542669112], ["会", 0.013445032299648923], ["世界", 0.012969381891421083], ["说", 0.012818363221507123]], "title": "不如归去"}, "888549816": {"descs": "人有时候会刻意拉大时空的疏离感，就像我第一次看《叶问》还是在同学的MP4上，我甚至都没有看过《叶问1》里“我要打10个”的名场面，因为第一次看《叶问》的时候，叶师傅已经在大圆桌上同洪师傅切磋武艺了;我说，这个问题根本不需要多想，因为逝者已逝，让更多的人活下来，九泉之下有知的逝者或许会感到欣慰吧;翻过年以后，我就28岁啦，如果回头看我的10年，时间大概一样会变得空泛，因为有的人来来回回地从你生命里来了又去，而有的人甚至从未真正进入过你生命里;你、我，这个世界上的每一个人都会死，这是所有人都无法逃脱的自然规律，即使是同为人类的医生一样会死，难道医生都是神灵或者天使吗;医学的发展自始至终都是建立在死亡上的，我们不能在享受医学带来的好处的同时，仅仅因为那个人是你或我的亲人，就去伤害这些医疗工作者，因为他们和我们一样，都是普普通通的人，他们唯一比我们多的就是医术，可医术甚至于这世界上一切人类发明的东西，都不是万能的啊", "tags": [["人", 0.014322297958606192], ["说", 0.014254685539618742], ["会", 0.01177294725457089], ["人类", 0.009777980367063923], ["师傅", 0.008810402477995494]], "title": "不知老之将至"}, "828223375": {"descs": "这段代码博主在本地使用NodeJS测试了没有不过什么问题，大家可以在截图中清楚地看到[music:29713754]已经被替换称了网易云音乐的Flash组件，这样在网页中就会显示出网易云音乐的播放器，我们就能听到这熟悉而温暖的旋律了;那么，现在我们其实就是在做这样一件事情，我们在文章中插入这样一个[key:value]的结构，然后通过程序将它替换成相应的HTML结构，这样就实现了在Hexo的文章中使用[key:value]结构来编写简单插件的功能，如果经历过使用wordpress建站的朋友一定知道，在wordpress中存在许多这样的类似插件，可以帮助写作者简化某些输入内容;相信经过博主的一番介绍，大家已经对这段代码相当熟悉了吧，这里就是先做判断，判断文章内容中是否有[key:vaule]这样的结构，如果没有就直接输出item.content;item.content=item.content.replace(dicts[i],'<embed src=\"http://music.163.com/style/swf/widget.swf;经过这么长时间对Hexo的学(zhe)习(teng),我们知道文章的内容是定义在layout\\_partial下的article.ejs这个文件中，在这个文件中有一个叫做item的变量,这个item的真实身份其实是Hexo中定义的一个全局变量post", "tags": [["中", 0.02199770938107037], ["hexo", 0.017268699036001776], ["文章", 0.015479764315723734], ["代码", 0.013417744851224454], ["博客", 0.01115772422435046]], "title": "为Hexo开发一个网易云音乐的文章插件"}, "1478979553": {"descs": "IT是科技，解决技术问题，当所有的技术集成到一起并能成功运行的时候就是IT,当所有技术集成到一起而且足够轻的时候就是便携，便携就会产生移动，当人们使用这些便携的IT产品相互发生关系时就是移动互联网;>互联网的本质是关系;因为真正能改变甚至颠覆传统行业的互联网模式，可能并不是建立在一项伟大的技术的基础之上，而是这种新的模式能为人们的生活带来怎样的利用价值，互联网的本质是服务行业，这种属性到了移动互联网时代变得更加地明确了;这样的描述让我们开始重新审视互联网，互联网时代的本质是数据对数据、信息对信息交换，这种经济的特点是，在给了人们更多选择的自由的同时，让更多的东西逐渐从黑暗中走出来，成为公信力引导下的公开博弈，而更加不可思议的是，这种近乎原始时代的信誉体系却是人们主动地、自发地建立并维护的;可以说互联网的本质就是关系，而且是全新的、广泛的关系、跨越时空的关系", "tags": [["互联网", 0.04396202856337672], ["关系", 0.0260326406313919], ["人们", 0.013741141206159421], ["行业", 0.013478033362514703], ["技术", 0.01329058456895248]], "title": "互联网黑洞读书笔记(1)"}, "1930050594": {"descs": "我们不可或缺地依赖着互联网，却从来不对为这个行业努力付出的程序员们表示尊敬，如果有一天这个世界没有了互联网，有多少人的生活会变得混乱不堪;我从来不喜欢政治，因为是政治是一种极其微妙的东西，正直且单纯的人永远不适合政治，可是因为互联网的舆论作用，互联网所代表的全民制衡开始不断地和政治发生着反应，互联网精神的终极目标从来都不是取代和颠覆现有的模式，而是希望在和政治博弈的过程中让这个世界更加美好;在互联网面前，每个人都是平等的，大家可以通过网络获取信息、获取服务，互联网发展到今天，当我们每个人都对身边的一切习以为常的时候，互联网却在不断地改变我们与世界接触的方式，这就是创新，这就是变革;>互联网的人文属性，决定了盈利模式的地域局限和社会差异;当我们感慨移动互联网的时候，大数据时代已经悄然来临，在大数据时代每个人的数据都是一个数据云，如果我们能够将这些数据收集起来加以利用的话，那么这可能就是大数据时代留给我们的机会吧", "tags": [["互联网", 0.04745691594973149], ["人", 0.018536664671118388], ["微信", 0.017648969331089778], ["关系", 0.015162292328442952], ["政治", 0.012961122364551336]], "title": "互联网黑洞读书笔记(2)"}, "3099575458": {"descs": "升级2.2的时候，调整项目文件中的`Microsoft.NET.Sdk.Web`为`Microsoft.NET.Sdk`可以解决，而这个方法在3.x以后失效;- 安装完 `.NET Core 3.x`，使用`dotnet build`编译项目提示找不到`Microsoft.NET.Sdk.Web`;- 升级后提示无法加载类型：`Microsoft.AspNetCore.Mvc.MvcJsonOptions`，解决方案是：;* [升级 ASP.NET Core 3.0 设置 JSON 返回 PascalCase 格式与 SignalR 问题](https://www.cnblogs.com/Irving/p/11587556.html);- 直接从`.NET Core 3.0` 创建的SignalR项目，服务端返回的JSON数据存在大小写的问题，这是由`System.Text.Json`引起的", "tags": [["signalr", 0.018313726962897126], ["项目", 0.018001312527464324], ["调整", 0.014563680565444635], ["路由", 0.012885345546179781], ["json", 0.01272000188157196]], "title": "从 .NET Core 2.2 升级到 3.1 的踩坑之旅"}, "1166840790": {"descs": "实际上在React为前端带来虚拟DOM、单向数据流和不可变对象等一系列函数式编程的概念的同时，Facebook在开源社区中的话语权同样越来越大，Facebook在开源协议中夹藏私货的确让人有种\"挟天子以令诸侯\"的感觉，曾几何时，社区指责微软没有开放全部的OpenXML标准，因为大家都觉得按照这个标准实现的Office文档和微软家的存在差异，可是面对这种和自家产品紧密联系的项目要开源，我觉得这不单是Facebook会有所提防，恐怕所有的商业公司都会有类似的想法吧，所以在这个事件中，隐含的一个点就是，一旦当使用React的公司和Facebook发生业务上的竞争，React将成为Facebook获得诉讼胜利的一个重要筹码，因为根据React的专利协议，Facebook有权在开展诉讼时从被授权方手中收回React的使用权，所以我们不难理解为什么百度和Wordpress都宣称要停止使用React，除了不想受制于人以外，像百度这种未来可能会和Facebook在AI等领域发生竞争的公司，宁可自己造一套轮子而不愿让自家专利被对方使用的做法，我觉得是可以理解的;或许在数日前，你还在为React专利事件而苦恼，或者考虑在Preact的基础上实现一个新的React，或者考虑转向Angular和Vue这两个框架，此时此刻Facebook宣布将React的开源协议修改为MIT，或许这算是开源社区的一次胜利，或许这算是整个专利事件的尘埃落定，或许有人继续担心Facebook搞其他事情，可是这个世界原本就是在每天都发生变化着的，对于未来我们常常是无从得知它的足迹会在哪里;所以这篇文章我想和大家通过React专利事件来聊聊开源软件许可，以及我们如何在商业化和开源社区间找到一个平衡点;国内因为盗版软件盛行的原因，大家在心底里好像都不认同软件许可，但是像外企或者是对信息安全比较重视的企业，通常要么对许可证书比较看重，要么对开源软件不太感冒，所以像最近的WePhone创始人自杀这种事件，都在告诉我们一个道理，程序员不要整天都关注技术层面上的东西，虽然技术世界有很多纯粹而美好的事情，但当它和人类联系在一起、和政治联系在一起的时候，它就完全不在我们的控制之中了，所以我觉得我们有必要了解些法律相关的事情，那么从何处开始呢;第二，React在开源协议中附加专利许可的做法，从商业公司自我保护的角度来看，的确是无可厚非，不过这种做法未免会给开源社区带来不好的风气", "tags": [["开源", 0.019050615620490798], ["中", 0.012866826424284505], ["facebook", 0.012437185892209941], ["上", 0.0123584937928674], ["协议", 0.01234051850268841]], "title": "从React专利事件看开源软件许可"}, "3356910090": {"descs": "本文将从游戏中的\"复活\"和\"暂停/恢复\"这两个应用场景的角度来谈谈在游戏开发中如何对游戏中的数据进行管理和配置;首先我们来从游戏当中的两个常见的应用场景:\"复活\"和\"暂停/恢复\"来看看游戏数据配置和管理的重要性;动态数据是指在游戏中会不断变化的数据，比如玩家的得分、玩家的生命值、玩家的经验值等等;可是如果我们将玩家的属性全部都设为Public，我们可能不得不去面对在编辑器窗口中为每一个属性去赋值，因为一旦我们试图调整游戏双方力量的平衡时，这将是我们不得不去面对的问题，更为致命的玩家的属性并不是永远不变的，比如在RPG游戏中玩家的生命值等属性会随着角色等级的提升而不断增加;首先游戏暂停后，场景内所有的物体都会停止运动，此时游戏中每个物体的状态都发生了变化，不过因为在Unity3D中控制游戏暂停/的恢复主要是通过调整Time.timeScale的值来实现的", "tags": [["游戏", 0.05521211258688845], ["玩家", 0.023491837238972402], ["中", 0.020931654201847637], ["会", 0.01840607342789293], ["数据", 0.011021388996270226]], "title": "从[复活]和[暂停/恢复]谈游戏数据配置管理"}, "3602353334": {"descs": "而对于动态表情包，我们可以考虑使用` imageio`和`MoviePy`，它们都可以从图片或者视频来生成GIF，一起来看下面的例子：;所以，下面我们来通过这些图片生成视频，这里主要用到`opencv-python`和` MoviePy`两个库，前者可以通过`OpenCV`合成视频，而后者则可以对视频进行剪辑，例如加入片头、片尾、背景音乐等等;经常使用Kindle的朋友，一定对它的邮箱传书功能非常熟悉，这意味着我们此基础上，将生成的PDF文件直接推送到Kindle上，而在Python中发送邮件则是非常简单的，这一点我们不再赘述，那到底能不能实现我们这个想法呢;如果使用`MoviePy`来生成GIF，则可以通过`VideoFileClip`或者`ImageSequenceClip`来分别从视频和图片创建GIF;# 从一组图片并生成GIF和视频", "tags": [["视频", 0.00986498702275091], ["import", 0.008238741586421171], ["chapterpath", 0.006813682764020539], ["大家", 0.006710045604864759], ["https", 0.006626097918609795]], "title": "作为技术宅的我，是这样追鬼滅の刃的"}, "2275646954": {"descs": "我们常常表现出，一种试图要要证明比别人过得更好的心态，仿佛在朋友圈或者微博这种社交平台上，我们能找到更多的自豪感，可我同样知道，这个世界上最大的社交网站Facebook，背后却是由一个有社交障碍的人创造出来的，我们都渴望让别人了解自己、认识自己，这不同于社交场合里那种客套的场面话，对此，弗洛姆认为，人与人之间可以通过讲述这种方式来打破人与生俱来的这种孤独感，“讲述自己的生活，叙述自己的希望和恐惧，谈出自己幼稚的或者不成熟的梦想，以及找到面对世界的共同利益——所有这一切都是克服人与人之间隔离的途径，甚至表露自己的愤怒和仇恨，毫无顾忌地交心也都被看作是亲密的表现”，我们对爱的终极理解其实应该是，我们通过爱一个人，进而爱全人类，爱一切生命，我们从自我的生命的本质出发去爱对方，并且去体验对方的本质，爱情是意志的行为，是人作的一项把全部生命交付对方的决定;爱的确是一门艺术，可对我们每个人而言，它像是某种缥缈甚至是难以揣测的情绪，你不能用一种非常理性的眼光来审视和定义它的存在，弗洛姆说：“不是拥有财物的人是富裕的，而是给予他人东西的人才是富裕者”，可现实是并非你不顾一切地对一个人好，就能赢得一份让你感动的爱情，所以在经历过挫折以后，我不再考虑一味地索取或者付出，我喜欢将这个过程叫做分享，人们在分享的过程中认识彼此、丰富彼此、提高彼此的生命感，这是我认为在爱情中我们需要去挖掘的一种潜质，如果一个人没有生命力，就不会有创造爱情的能力，所以当我们试图爱一个人之前，我们首先要学会爱我们自己，而弗洛伊德将这种人的自我欣赏叫做“自恋”，除了爱情自身积极性的因素以外，爱情具有所有爱的形式所共有的因素，如：关心、责任心、尊重和理解;我们来到这个世界上，更本质的意义在于我们希望认识些有趣的人，做些有趣的事情而已，这意味着我们常常试图在这个世界上留下自己的印记，我们习惯了在朋友圈里晒美食、晒旅游、晒自拍等等约定俗成的处事方法，亦如我们生来就渴望被人理解、被人喜欢一样，而这一切更本质的原因，我们现在称为“刷存在感”，恰恰迎合了这个观点，我们想要在这个世界上留下我们的印记，即使这些方式方法看起来并不是我们最初喜欢的样子，弗洛姆将在这个观点理解为“超越自己”的追求，这一追求属于人的最基本要求，即“人对自己的纯生物作用不满，他不能忍受自己仅仅是被扔进这一世界的小卒;弗洛姆这本《爱的艺术》是我自己为自己挑选的一本书，在我买了Kindle以后，我将我的时间安排在看书和学习上，因为我的确很喜欢读书，而我这种理性的性格有时候难免让人讨厌，所以读书特别是选择去读人文类书籍，从某种意义上来说是我在刻意地稀释这种理性思维造成的影响，《黑客与画家》里告诉我们一件事情，聪明人不被周围人喜欢是因为他们比周围人聪明，当谈恋爱越发地被人们改造成一种套路，我们对爱的定义或许会越来越模糊，可是爱作为一种大自然间普遍存在的情感，我坚信它是一种相当原始而简单的事情;或许对弗洛姆本人而言，这本《爱的艺术》更像是 他对自我的一种内省，因为他的爱情基本上在持续地遭遇着失败，他曾经和四个不同的女人结过婚，所以他在这本书里提出的大量观点都来源自他自己的感情经历，他早期研究过弗洛伊德的相关理论，而事实上，因为对爱的无能为力让他真正找到了爱的能力，我们在年轻的时候总会遇到一个非常喜欢，可我们却无法给她想要的生活的女孩子，或许我们都需要用一生去领悟爱的真正含义吧，就像弗洛姆这本书是建立在将理论和实践结合起来的基础上的，我不认为我此刻已经读懂了这本书，可是它对我的确非常重要，我总要学着去爱别人，让自己变得更好", "tags": [["人", 0.033107812549039314], ["爱", 0.03139951199426421], ["去", 0.015666898496825343], ["爱情", 0.01566322162271023], ["生活", 0.010703172099289521]], "title": "你了解爱的艺术吗？"}, "1417719502": {"descs": "> https://cdn.jsdelivr.net/gh/user/repo@version/file;[jsDelivr提供的CDN加速资源](https://i.loli.net/2020/02/05/HtmhUdsSRLW4Q9A.png);https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js;最终，我采用的方案是，通过Travis CI编译部署的时候，首先导出变量`$TRAVIS_BUILD_NUMBER`到一个文本文件中，然后Hexo在生成静态页面的时侯，从这个文本文件中读取该变量的值作为版本号，这样每次编译部署的时候，我们总能获得一个新的tag，而这个tag和Hexo中引用的资源版本一致，这样就彻底解决了这个遗留问题;首先，我们在浏览器里输入下面这个地址：[https://cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/](https://cdn.jsdelivr.net/gh/qinyuanpei/qinyuanpei.github.io@latest/)", "tags": [["hexo", 0.01602392489126526], ["https", 0.015405148572256897], ["cdn", 0.015283631218063937], ["中", 0.013780777015391502], ["版本号", 0.011740573223506448]], "title": "使用 jsDelivr 为 Hexo 博客提供高效免费的CDN加速"}, "1989654282": {"descs": "这里，我们给出的是WebSocketChat中间件中最为关键的部分，详细的代码我已经放在[Github](https://github.com/qinyuanpei/dotnetcore-pritices)上啦，大家可以参考[WebSocketChat](https://github.com/qinyuanpei/dotnetcore-pritices/blob/master/hello-webapi-1/Middlewares/WebSocketChat.cs)类，其基本原理是：使用一个字典来存储每一个聊天室中的会话(Socket)，当用户打开或者关闭一个WebSocket连接时，会向服务器端发送一个事件(Event)，这样客户端中持有的用户列表将被更新，而根据发送的消息，可以决定这条消息是被发给指定联系人还是群发：;<hr/> 发送给：;var webSocket = await context.WebSockets.AcceptWebSocketAsync();本文以一个WebSocket聊天室的案例，来讲解WebSocket在实际项目中的应用，在这里我们使用ASP.NET Core来完成服务端WebSocket的实现，而客户端选用原生WebSocket API和Vue来实现，在此基础上，我们讲解了ASP.NET Core下中间件的概念，并将服务器端WebSocket以中间件的形式实现;需要说明的是，客户端使用了Vue来做界面相关的绑定，作为一个不会写CSS、不会写ES6的伪前端，我做了一个相当简洁(简陋)的前端页面，下面给出主要的页面结构，ViewModel层的代码比较多，大家可以参考[这里](https://github.com/qinyuanpei/dotnetcore-pritices/blob/master/client/websocket/index.html)：", "tags": [["websocket", 0.03273117754113884], ["中", 0.017750187651839337], ["客户端", 0.014849474032062522], ["请求", 0.014149114831653323], ["会", 0.012952843545939672]], "title": "使用.NET Core和Vue搭建WebSocket聊天室"}, "1071063696": {"descs": "而**Recurring jobs**和**Continuations**则是周期性任务，任务在入队后可以按照固定的时间间隔去执行，周期性任务都是支持CRON表达式的，**Continuations**类似于Task中的ContinueWith()方法，可以对多个任务进行组合，我们现在的项目中开发了大量基于Quartz的Job，可当你试图把这些Job相互组合起来的时候，你就会觉得相当尴尬，因为后台任务做所的事情往往都是大同小异的;return new JsonResult (new { Flag = true, Message = $\"Job:#{jobId}-{jobDescriptor.JobName}已加入队列\" });return new JsonResult (new { Flag = true, Message = $\"Job:#{jobId}-{jobDescriptor.JobName}已加入队列\" });因为我们不希望任务调度和具体任务放在一起，我们项目上采用Quartz来开发后台任务，它要求我们实现一个特定接口IbaseJob，最终任务调度时会通过反射来创建Job，就在刚刚过去的这周里，测试同事向我反馈了一个Bug，而罪魁祸首居然是因为某个DLL没有分发，所以，我希望实现一个基于HTTP方式调用的HttpJob，这既是为了将任务调度和具体任务分离，同时为了满足这篇文章开头描述的场景，得益于Hnagfire良好的扩展性，我们提供了一组Web API，代码如下：;简单来说，我们会提供一个接口，调用方提供参数和回调地址，调用后通过Hangfire创建后台任务，等任务处理结束后，再通过回调地址返回结果给调用方，这就是所谓的HTTP异步化", "tags": [["hangfire", 0.018764997124774738], ["中", 0.015185767641668135], ["会", 0.010824749532354188], ["job", 0.010663491830104255], ["任务", 0.009415994066281201]], "title": "使用ASP.NET Core和Hangfire实现HTTP异步化方案"}, "2734896333": {"descs": "这恰恰印证了我们最初的观点，即HTTPS协议依然采用HTTP协议(三次握手)进行通讯，不同的地方在于中间环节增加了加密处理，例如在客户端和服务器端相互验证的环节采用的是非对称加密，在客户端验证通过以后双方采用随机数作为密钥是对称加密，而三次握手以后验证消息是否被篡改则是采用HASH算法;我们可以将其理解为在HTTP协议的基础上增加了安全机制，这里的安全机制是指SSL,简单来讲HTTPS协议依然采用HTTP协议，不过它在HTTP和TCP间增加了加密/身份验证层，因此在保证数据传输安全的同时，为服务器提供了身份校验机制;好了，现在我们对HTTPS协议有了一个基本的认识：HTTPS协议相比HTTP协议增加了身份验证和消息加密的机制，因此HTTPS协议能够保证通讯过程中的数据传输安全;所以我们应该可以注意到，HTTP协议和HTTPS协议的一个显著的区别是，前者采用明文来传输消息，而后者采用密文来传输消息，因此HTTPS协议比HTTP协议在通讯上更为安全;可是当我们了解了HTTPS协议后，我们发现，如果要让最初设计的Web服务器支持HTTPS协议，我们需要关注的是Security，即身份验证和数据加密，我们知道这里的Security指的是SSL，所以需要了解SSL相关的内容", "tags": [["https", 0.03744347947693989], ["http", 0.015038346383666858], ["中", 0.01428125382888536], ["证书", 0.014138432907516606], ["客户端", 0.012657900425771642]], "title": "使用C#开发HTTP服务器之支持HTTPS"}, "3040357134": {"descs": "这里我们设定状态码为200，这是一个正常的请求，其次ContentType等字段可以自行阅读HTTP协议中头部字段的相关资料，最后我们通过ProcessResponse这个方法来处理响应，其内部是一个使用Socket发送消息的基本实现，详细的设计细节大家可以看项目代码;在HTTP协议中，客户端负责发起一个Request，该Request中含有请求方法、URL、协议版本等信息，服务端在接受到该Request后会返回一个Response，该Response中含有状态码、响应内容等信息，这一模型称为请求/响应模型;这里需要说明的是，实际的请求报文和响应报文会因为服务端设计的不同，和这里的报文示例略有不同，报文中头部信息参数种类比较多，我不打算在这里详细解释每个参数的含义，我们只需要对报文格式有一个基本的认识即可，想了解这些内容的朋友可以阅读[这里](http://www.cnblogs.com/xly1208/archive/2011/10/12/2208468.html);MVC中有一个路由的概念，这个概念我们可以和HTTP中请求行来对应起来，我们知道发出一个HTTP请求的时候，我们能够从请求报文中获得请求方法、请求地址、请求参数等一系列信息，服务器正是根据这些信息来处理客户端请求的;* 响应报文：响应报文是指在服务端接收并处理了客户端的请求信息以后，服务端发送给客户端的HTTP报文，服务端开发的重要工作就是处理来自客户端的请求，所以这是我们开发一个HTTP服务器的核心工作", "tags": [["http", 0.017596943246465307], ["中", 0.01759056784317667], ["请求", 0.013856098234680344], ["服务器", 0.012530403480746998], ["客户端", 0.008011150016602677]], "title": "使用C#开发HTTP服务器系列之Hello World"}, "1700650235": {"descs": "\"分割该行数据以后就可以得到“num1=23&num2=12”这样的结果，这里我们使用一个方法GetRequestParms来返回参数字典，这样作做是为了复用方法，因为在处理Post请求的时候我们会继续使用这个方法;例如我们传递的两个参数num1和num2对应的数值分别是12和24，那么在具体的请求报文中我们都能找到类似“num1=12&num2=24”这样的字符结构，所以只要针对这个字符结构进行解析，就可以获得客户端传递给服务器的参数啦;num1=23&num2=12”这样的字样，这就是客户端传递给服务器的参数，我们很容易想到只需要将这个字段串中的“键”和“值”都解析出来，服务器就可以对这些数据进行处理然后返回给客户端了;string content = string.Format(\"这是通过Post方式返回的数据:num1={0},num2={1}\",num1,num2);Post请求相对Get请求比较安全，因为它克服了Get请求参数长度的限制问题，而且由于它的参数是存放在消息体中的，所以在传递参数的时候对用户而言是不可见的，我们平时接触到的网站登录都是这种类型，而复杂点的网站会通过验证码、Cookie等形式来避免爬虫程序模拟登录，在Web开发中Post请求可以由一个表单发起，可以由爬虫程序如HttpWebRequest、WebClient等发起，下面我们重点来分析它的请求报文：", "tags": [["请求", 0.025600207664037603], ["中", 0.019552541279944317], ["参数", 0.018347135449011915], ["post", 0.012088331570975105], ["服务器", 0.012070772166183182]], "title": "使用C#开发HTTP服务器系列之实现Get和Post"}, "3603924376": {"descs": "其次，我们在设计HTTP服务器的时候，每次在向客户端返回响应报文以后，我们就关闭了Socket连接，这意味着每次的请求和响应完全都是独立的，那么这样是不是就和聊天机器人不能理解上下文非常相似了呢;下面我们再来说说基于HttpListener实现请求-响应模型，它和改进Socket不同，它对我们编写一个Web服务器的意义主要体现在它提供了一个非常规范的接口，类似我这里的HttpResponse和HttpRequest以及OnPost、OnGet等接口这些设计;到目前为止我们了解的HTTP服务器开发，实际上由两部分组成，即Socket通信和请求-响应模型;基于这两点考虑，我们这里提供两种快速实现Web服务器的具体思路，这是在我们理解了HTTP协议实质以后，从原理出发想到的解决方案，为什么我不建议在刚开始就学习这些东西呢;关于今天本文中提到的两种方案，我都是作为HTTP服务器开发延伸出来的内容来写出来给大家看,所以这块儿内容我都是点到为止不打算给出完整的实现，如果有兴趣的朋友可以顺着我这个思路区继续改进", "tags": [["http", 0.016899436423756006], ["服务器", 0.01680950905334139], ["请求", 0.012498662109105156], ["socket", 0.011690702925474548], ["使用", 0.01114367735504841]], "title": "使用C#开发HTTP服务器系列之更简单的实现方式"}, "3637847962": {"descs": "在REST中表现形式作为我们对资源请求的一个结果的呈现，通过对HTTP协议的学习我们已经知道，服务器会给客户端返回什么形式的信息，这一点取决于服务器响应报文中相关头部字段，而对REST来讲，它通常会采用XML或者JSON来告诉请求者请求的结果，因为JSON相比XML所含的冗余信息较少，所以目前更加倾向于或者说流行使用JSON作为请求结果的表现形式;除此之外，我们注意到REST基于HTTP协议，所以HTTP协议中的状态码对它来讲同样适用，例如最常用的200表示成功、500表示服务器内部错误、404表示无法找到请求资源等等;首先，REST即REpresentational State Transfer，通常被翻译为“表述性状态传输”或者“表述性状态转移”，它最早出自Roy Fielding的《Archltectural Styles and the Design of Network-based Software Arcltechures》这篇论文，作者曾经参与HTTP协议和Apache Web Server的设计，所以REST实际上是一个和HTTP协议联系非常紧密的一种设计思想;> REST是一种使用URL来定位资源，使用HTTP请求描述操作的Web服务规范;由此我们注意到REST在形式上更加趋向API设计，而我们获取的资源则通过一定的形式进行统一而规范化的表达，因此REST实现了让不同的平台共享一套API这样的愿望，这是一件非常美好的事情，这个世界上的技术阵营举不胜数，而它们为了各自的利益建立一套封闭、臃肿的体系框架，很多时候当我们不需要这样的“全家桶”并且希望“跨平台”的时候，REST将会是一个不错的选择", "tags": [["rest", 0.01884613695555764], ["web", 0.017481344472002603], ["http", 0.014899250935488311], ["webservice", 0.011106973355500248], ["协议", 0.009998593148894612]], "title": "使用C#开发HTTP服务器系列之构建RESTful API"}, "3695777215": {"descs": "可以注意到在这里我们首先根据请求方法和请求地址来判断当前客户端是否在请求主页页面，然后我们判断在服务器目录下是否存在index.html文件，如果该文件存在就读取文件并返回给客户端，否则我们将返回给客户端一个404的状态，熟悉Web开发的朋友应该会知道这个状态码表示的是无法找到请求资源，类似地我们还可以想到的状态码有200、501等等，通常来讲，这些状态码的定义是这样的：;这里我的理解是这样的，对页面来讲服务器在读取它以后会返回给客户端，所以对客户端而言这部分响应是完全可见的，而页面中关联的CSS样式和JavaScript脚本则可能是通过浏览器缓存下载到本地，然后再根据相对路径引用并应用到整个页面中来的，而为了区分这些不同类型的资源，我们需要在响应报文中的Content-Type字段中指明内容的类型，所以现在我们就清楚了，首先在请求页面的时候存在大量关联资源，这些资源必须通过响应报文反馈给客户端，其次这些资源由不同的类型具体体现在响应报文的Content-Type字段中;* 链接形式2:\"http://localhost:4050/assets/styles/\"表示访问指定页面资源，此时读取服务器目录下的/assets/styles/style.index文件;* 链接形式1:\"http://localhost:4050/assets/styles/style.css\"表示访问指定文件资源，此时读取服务器目录下的/assets/styles/style.css文件;首先我们可以认识到的一点是，网站主页是一个网站默认展示给访问者的页面，所以对服务器而言，它需要知道两件事情，第一客户端当前请求的这个页面是不是主页，第二服务端应该返回什么内容给客户端", "tags": [["服务器", 0.022422846686409707], ["中", 0.018127443899049144], ["页面", 0.017907430970233576], ["请求", 0.014719100835933304], ["文件", 0.013600091404753855]], "title": "使用C#开发HTTP服务器系列之静态页面"}, "1150071886": {"descs": "博主是最近了解到，Github除了可以用xxx.github.io这种方式搭建博客外，还可以通过gh-pages分支来实现，换句话说只要我们把静态的网页放到项目的gh-pages下，Github就能帮你把页面显示出来，因此我们就可以将Unity3D导出的网页版本游戏放到Github上，从而实现游戏的在线演示;本文将尝试借助Coding.NET的项目演示功能，通过对Hexo中支持的发布类型进行扩充，实现可以在Hexo中发布网页游戏，从而方便博主展示游戏作品和帮助读者了解游戏效果;博主是一名至今为止都还没有做出一款完整游戏(指已上线)的游戏开发者,可是即使这样，博主依然愿意将自己在游戏开发过程中的感悟和体会分享给大家，因为博主在学习编程的路上摸索了这么久，首先要感谢的就是那些愿意在互联网上分享技术的人们，不管是Github上愿意将项目开源的那些技术大牛，还是在博客圈子里不断探索追逐梦想的人们，如果没有他们不求回报的辛勤付出，我是绝对不可能在环境科学这样一个专业中学好编程技术的;首先我们的目的是要实现在博客中集成游戏的功能，因此我们的游戏是不能作为博客的文章出现的首页，我们知道在Hexo中可以通过hexo new page[PageName]这个命令来生成一个自定义页面，而且生成的自定义页面不会出现在博客首页，只有通过链接才可以访问到这个页面，因此我们可以从这里作为突破口;博主经常在博客上写一些游戏开发的技术文章，每次都会在文章最后给出这篇文章中具体实现了一种怎样的效果", "tags": [["游戏", 0.03103672300593676], ["博客", 0.029533499960768678], ["项目", 0.018721441384278927], ["实现", 0.01590152094633534], ["页面", 0.01461741748178008]], "title": "使用Coding.NET和Hexo实现网页游戏的发布"}, "3672690776": {"descs": "结合一个简单的示例程序，本文简单地介绍了来自 `JetBrains` 的两款软件 [dotTrace](https://www.jetbrains.com/profiler/) 和  [dotMemery](https://www.jetbrains.com/dotmemory/) 的基本使用，以及如何通过内存转储文件(Dump)对生产环境中的内存进行诊断;在以往的关于程序性能优化的经历中，我个人还使用过 [ANTS-Performance-Profiler](https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/)  这个软件，但体验上感觉还是 [dotTrace](https://www.jetbrains.com/profiler/) 和  [dotMemery](https://www.jetbrains.com/dotmemory/) 稍微好用一点，而对于更一般的代码角度的性能分析，我推荐一个轻量级的项目[MiniProfiler](https://miniprofiler.com/)，性能优化不能靠猜，可是从初中就开始学的“控制变量法”未尝不是一个不错的思路;通过这两图，我们可以非常清晰的看到，最耗时的正是我们这里的`CPUHack()`方法，并且这里一共有四个线程，这是因为博主的计算机使用的是一款4核的i3处理器，并且在[dotTrace](https://www.jetbrains.com/profiler/)中可以直接看到相关的代码片段，当然，这一切的前提是你没有对应用程序做过混淆处理，这样，我们就完成了一个简单的性能分析;这两个命令同样可以对内存进行分析，关于更多的.NET Core的诊断教程，请参考：[https://docs.microsoft.com/zh-cn/dotnet/core/diagnostics/event-counter-perf](https://docs.microsoft.com/zh-cn/dotnet/core/diagnostics/event-counter-perf)，这些细节都是针对.NET Core的，可能不具有普适性，感兴趣的朋友可以自行前去了解;其实，拿到Dump文件以后，分析它的工具非常多，比如常见的WinDBG、DebugDiag等等，这里我们可以直接使用 [dotMemery](https://www.jetbrains.com/dotmemory/) ，因为它本身就支持Dump文件的导入，相比前面两种在使用上要更加友好一点", "tags": [["https", 0.01756520905958969], ["程序", 0.014040580855335225], ["性能", 0.011958257737267749], ["会", 0.009778603960207922], ["dottrace", 0.008862859478167237]], "title": "使用 dotTrace 对 .NET 应用进行性能分析与优化"}, "118272597": {"descs": "var propertyParam = Expression.Property (parameter, condition.Field);searchParameters.Query.Add(new Condition() { Field = \"StringValue\", Op = Operation.Contains, Value = \"山\", OrGroup = \"StringValue\" });searchParameters.Query.Add(new Condition<Foo>() { Field = x => x.StringValue, Op = Operation.Contains, Value = \"有朋\", OrGroup = \"StringValue\" });searchParameters.Query.Add(new Condition<Foo>() { Field = x => x.StringValue, Op = Operation.Contains, Value = \"有朋\", OrGroup = \"StringValue\" });searchParameters.Query.Add(new Condition() { Field = \"OrgCode\", Op = Operation.Equals, Value = \"新选组\", OrGroup = \"OrgCode\" })", "tags": [["var", 0.018952070106991348], ["表达式", 0.013625952057141776], ["condition", 0.012584175750225428], ["expression", 0.011106208516968568], ["field", 0.01050351959614202]], "title": "使用Dynamic Linq构建动态Lambda表达式"}, "815861661": {"descs": "所以，在这今天这篇文章里，你将看到：**如何使用Jexus实现ASP.NET在Linux平台下的部署**;综合考虑这些因素，我们决定采用[Jexus](https://www.jexus.org/)来将ASP.NET项目部署到Linux平台;Jexus是由[宇内流云](http://www.cnblogs.com/yunei)开发的一款Linux平台上的高性能Web服务器，它是一个可以免费使用、不开源的项目，最大的特色是可以支持ASP.NET、ASP.NET Core、PHP;本文从一个实际工作的场景切入，分析和阐述了如何使用Jexus实现ASP.NET项目在Linux下的部署;通过查阅相关资料，博主发现ASP.NET Core的部署不需要Jexus，它只需要一个dotnet run命令即可", "tags": [["jexus", 0.0237411947768179], ["使用", 0.014342063011798942], ["docker", 0.013136140565442453], ["网站", 0.012771276608605699], ["中", 0.011449618249658584]], "title": "使用Jexus实现ASP.NET在Linux平台下的部署"}, "3742212493": {"descs": "这里暂且抛开它到底是XML、JSON还是EDI这种细节性的问题，我想我们大概会有一个简单的想法，如果把需要传输给对方的接口报文做成模板，然后通过`Liquid`语法完成数据的绑定，那么数据映射这一层的工作就可以减轻不少，毕竟写`A.XXX=B.XXX`这种赋值语句是没什么前途的啦，而`AutoMapper`则需要提前写好Map并注册，经过一番权衡，我们来验证一下我们的想法吧;因为要对接的接口数量多、字段多，我首先根据字段对应关系制作了一份`Liquid`模板，并根据业务上的需要，用主表(Main) + 明细表(Details)的方式来定义数据，这意味着我接下来只需要根据业务实现不同的数据源即可：;为此，我们介绍了`Liquid`模板引擎，它提供的语法可以让我们完成一系列的绑定，顺着这个思路，博主为大家展示了这种想法的可行性;今天这篇博客，我并不打算故弄玄虚地扯这些概念，我的落脚点是接口级别的数据交换，主要通过Liquid这款模板引擎来实现;实际上，在我写这篇博客的时候，我刚刚了解到一件事情，`Jekyll`就是基于`Liquid`而开发的，想到当初搭建这个博客时被`Ruby`劝退的回忆，我大概想不到有一天会再次接触它吧，不得不说，人生还真是奇妙啊", "tags": [["liquid", 0.014899362069767203], ["需要", 0.013565349167438604], ["数据", 0.01304240380724268], ["譬如", 0.010309703183781329], ["模板", 0.009296527091116372]], "title": "使用Liquid实现简单的数据交换"}, "426338252": {"descs": "local dir=1;这里定义了getNextPoint()的方法，目的是计算在蛇头位置添加的下一个元素，这里我们注意到根据蛇的移动方向(dir)的不同，其中0表示上、1表示下、2表示左、3表示右，计算出下一个元素的位置，因为在这个游戏中网格大小是20，所以这里可以直接根据坐标来计算一个元素的位置;local gameState=1;今天博主将通过[Love2D](http://love2d.org/)这款游戏引擎来为大家实现一个简单的贪吃蛇游戏,在本篇文章当中我们将会涉及到“贪吃蛇”的基本算法、Lua语言编程等基本的内容，希望能够对大家开发类似的游戏提供借鉴和思考，文章中如有不足之处，还希望大家能够谅解，因为博主的游戏开发基本就是这样慢慢摸索着学习，所以难免会有不足的地方;function love.keypressed(key)", "tags": [["蛇", 0.03346140403942937], ["游戏", 0.02029221337366418], ["love2d", 0.017031666327947437], ["local", 0.016618670582991633], ["食物", 0.01654870323762377]], "title": "使用Love2D引擎开发贪吃蛇游戏"}, "2583252123": {"descs": "通过前面的学习，我们知道Unity2D使用的Mecanim动画系统主要是通过改变游戏体的属性来实现某种特定的动画效果的，例如我们这里的动画是通过改变角色精灵附加的SpriteRenderer组件的Sprite属性来实现的，因此从本质上来说Unity2D的动画控制器是一种属性动画;void FlipSrite();<img src=\"http://img.blog.csdn.net/20150301180533660\" alt=\"为Idle动画添加帧\" />;<img src=\"http://img.blog.csdn.net/20150301180634110\" alt=\"Idle动画效果演示\" />;private void SpriteMove()", "tags": [["动画", 0.04449977430511326], ["大家", 0.014251443063406736], ["中", 0.013507632265455684], ["float", 0.01332545370135639], ["实现", 0.010757912099894682]], "title": "使用Mecanim动画系统来控制2D动画"}, "907824546": {"descs": "我们将编译好的程序命名为Launcher.exe，放置我们前面定义的Mono运行时目录结构的根目录下，这个文件将作为启动文件暴露给用户，当用户点击这个程序后就可以打开主文件Main.exe;因为Mono和.NET都可以执行IL代码，所以我用Mono来作为.NET程序的运行时是一个顺理成章的想法;本文通过Mono实现了一个轻量级的.NET程序运行环境，从某种程度上来说，它间接地实现了.NET程序脱离.NET Framework运行;因为我们这里是为了让编写的.NET应用程序运行在Mono运行时中，所以我们这里需要的是Mono运行时(mono.exe)和基础类库;在考虑使用Mono来作为.NET应用程序的运行时前，首先我们来考虑.NET版本的兼容问题", "tags": [["程序", 0.029101849183790218], ["mono", 0.026547555390705302], ["中", 0.022352197744343407], ["运行", 0.0219500956295813], ["使用", 0.018213628475016026]], "title": "使用Mono打造轻量级的.NET程序运行时"}, "1836680899": {"descs": "我们可以看到命令行下输出了我们期望的Hello World，这意味着我们编写的程序现在运行在Mono中了，实际上在Windows下由Mono提供的C#编译器mcs.exe编译的IL文件双击是可以直接运行的，因为我们的计算机上安装了CLR，它作为.NET的一部分内置在我们的计算机中;所以我们可以这样理解.NET程序跨平台，因为IL文件是一个和平台无关、和CPU无关的、跨平台的文件结构，所以我们只需要在不同的平台上实现这样一个公共语言运行时(CLR)就可以实现在不同的平台上运行同一个程序;由此我们会发现一个问题，我们这里的跨平台实际上是编译器、运行时和基础类库这三部分的跨平台，这意味着我们在Linux下运行.NET程序是需要Mono提供支持的;我们知道微软的技术体系在发展过程中因为某些历史遗留问题，.NET程序在不同的Windows版本中的兼容性有时候会出现问题，虽然微软宣布Windows XP停止维护，我们编写Windows应用程序的时候可以忽略对Windows XP版本的支持，可是因为国内用户不喜欢在线更新补丁的这种普遍现状，所以假如让用户在安装程序的时候先去安装.NET框架一定会降低用户体验，其次.NET框架会增加应用程序安装包的大小，所以我们需要一种能够让我们开发的.NET应用程序在脱离微软的这套技术体系时，同时能够安全、稳定的运行，所以我们这里考虑借助Mono让.NET程序脱离.NET框架运行;* 2、这样将生成Main.exe这样一个IL文件，现在我们需要一个运行时来解析它，在.NET下我们使用CLR来完成这个步骤，在Mono下我们使用mono.exe这个文件来完成这个步骤", "tags": [["mono", 0.01921359464596431], ["跨平台", 0.01881645856965355], ["程序", 0.014910664046393757], ["下", 0.013737048118108433], ["运行", 0.013477310049049325]], "title": "使用Mono让.NET程序跨平台运行"}, "1960676615": {"descs": "考虑到Python是一门解释型的语言，我们在编写插件的时候，更希望做到“热插拔”，比如修改了某个插件后，希望它可以立刻生效，这个时候我们就需要重新加载模块，此时importlib的reload就能满足我们的要求，这正是博主一开始就要使用importlib，而不是import语法对应内建方法__import__()的原因;好了，现在我们就完成了这次“插件化”的迭代，截止到目前为止，博主共完成了 [Unsplash]() 、 [Bing壁纸]() 、 [WallHaven]() 和 [国家地理]() 四个“源”的接入，这些插件在实现上基本大同小异，本质上来讲它们是一个又一个的爬虫，只要实现了getImage()这个方法都可以接入进来，这就是我们通常说的“约定大于配置”，关于更多的代码细节，大家可以通过[Github]((https://github.com/qinyuanpei/WallPaper))来了解;mkt=zh-CN) 和 [WallHaven](https://wallhaven.cc) 两个壁纸来源，考虑到大多数的壁纸抓取流程是一样的，博主决定以“插件”的方式完成这次迭代，换句话说，主程序不需要再做任何调整，当我们希望增加新的数据源的时候，只需要写一个.py脚本即可，这就是今天这篇文章的写作缘由;简单回顾下这篇博客，核心其实是importlib模块的使用，它可以让我们在运行时期间动态导入一个模块，这是实现插件化的重要前提;`语句的时候，这个机制就已经在工作了，否则Python应该是找不到foo和bar这两个模块的了", "tags": [["插件", 0.019427046115782064], ["模块", 0.017642766948291394], ["python", 0.0168563674420172], ["壁纸", 0.012449339411616142], ["实现", 0.012431156011006026]], "title": "使用Python开发插件化应用程序"}, "1427872047": {"descs": "考虑到小说人物关系抽取，属于自然语言处理(**NLP**)领域的内容，所以，除了准备好Python环境以外，我们需要提前准备相关的中文语料，在这里主要有：[半泽直树原著小说](https://github.com/qinyuanpei/graph-relation/blob/master/input/半泽直树.txt)、 [半泽直树人名词典](https://github.com/qinyuanpei/graph-relation/blob/master/input/人名词典.txt)、[半泽直树别名词典](https://github.com/qinyuanpei/graph-relation/blob/master/input/别名词典.txt)、[中文分词停用词表](https://github.com/qinyuanpei/graph-relation/blob/master/input/停用词词典.txt);所以，你基本可以想到，我们会使用结巴分词对小说文本进行分词处理，而半泽直树人名列表则作为用户词典供结巴分词使用，经过一系列处理后，我们最终通过`Gephi`和`PyECharts`对结果进行可视化，通过分析人物间的关系，结合我们对电视剧剧情的掌握情况，我们就可以对本文所采用方法的效果进行评估，也许你认为两个人毫无联系，可最终他们以某种特殊的形式建立了联系，这就是我们要做这件事情的意义所在;因为`Gephi`和`PyECharts`以及`NetworkX`都提供了针对`Graph`的可视化功能，因此，我们可以使用这种方法，对《半泽直树》原著小说中的人物关系进行抽取;其中，`extract()`方法用于抽取制定小说文本中的人物关系，`exportGephi()`方法用于输出Gephi格式的节点和边信息， `exportECharts()`方法则可以使用`ECharts`对人物关系进行渲染和输出：;今天，就让我们使用Python来抽取半泽直树原著小说中的人物关系吧", "tags": [["使用", 0.01305752753584955], ["半泽", 0.013003377394130659], ["https", 0.009918093499315356], ["人物", 0.009176688061045322], ["关系", 0.008674757666566451]], "title": "使用Python抽取《半泽直树》原著小说人物关系"}, "1329254441": {"descs": "我意识到我的博客配置了 [hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content) 插件，这个插件最初的目的是为博客提供离线的搜索能力，该插件会在博客的根目录里生成一个**content.json**文件，而这个文件中含有我们想要的一切信息，因此我们的思路转变为解析这个文件，人生苦短啊，我果断选择了我最喜欢的Python，这里我们会提取出所有的文章信息，按照日期由近到远排序后生成列表;现在我们更新博客时的流程将发生变化，首先通过 **hexo generate 或 hexo g**命令生成博客，这样Hexo会为我们生成 ** content.json**，然后我们执行这段Python脚本，就可以生成REAMD.md文件，这里我们将这个文件推送到blog分支;关于博客采用 [TravisCI](https://www.travis-ci.org/)  提供持续集成(CI)服务相关内容，可以参考 [持续集成在Hexo自动化部署上的实践](https://qinyuanpei.github.io/posts/3521618732/) 这篇文章;通过官方文档中关于[事件](https://hexo.io/api/events.html)和[生成器](https://hexo.io/api/events.html)的描述，我们获得了两种新的思路，分别是在生成页面以后通过 child_process 模块调用 python 脚本、通过 Locals 变量获取全部文章信息后生成Markdown;我最初想到的办法是读取每个Markdown文档的文件名，因为我的使用习惯是采用英文命名，这样当博客的**永久链接(permalink)**采用默认的**:year/:month/:day/:title/**形式时，每个Markdown文档的文件名等价于文章链接", "tags": [["博客", 0.018787452387157143], ["中", 0.016075742936565135], ["文件", 0.014817208388011106], ["hexo", 0.013375253761974026], ["生成", 0.012626248770032855]], "title": "使用Python生成博客目录并自动更新README"}, "4891372": {"descs": "经过反复尝试，最终我们实现了：**在TravisCI下使用MSBuild构建项目**、**使用Nuget在线安装NUnit并运行单元测试**、**使用SonarCloud对代码进行静态检查**;通常使用Sonar来构建静态检查工具时，需要我们在本地搭建一套运行环境，而SonarCloud是针对Sonar推出的一个“云”版本;在编写TravisCI脚本的过程中，我们一同验证了MSBuild、Nuget、NUnit等.NET常规工具或者类库在Linux平台下使用的可能性，最终在TravisCI的帮助下完成了从项目构建、单元测试再到代码的分析的整个流程;接下来，为了验证SonarCloud和TravisCI进行集成的可行性，我们尝试通过travisCI脚本的方式来调用SonarCloud，其原理是通过配置文件获得相关信息由TravisCI完成所有的分析工作，这里需要注意的是要对token进行加密;可偏偏我注意到了SonarCloud生成命令中有MSBuild的身影，于是我开始尝试在TravisCI脚本中编写.NET相关的命令，因为我从未在TravisCI中对.NET项目进行持续集成，所以我很好奇它如果跑起来会是什么样子的", "tags": [["sonarcloud", 0.018526673907259063], ["中", 0.016601046640980152], ["travisci", 0.015444593356245581], ["sonar", 0.01446403720774358], ["token", 0.011652639167114806]], "title": "使用SonarCloud为.NET/.NET Core项目集成静态检查"}, "3449402269": {"descs": "首先这种转盘游戏概率设计的前提是转盘固定不动，转盘指针绕中心位置旋转，与这篇文章中的恰好相反;[转盘游戏概率设计效果演示](https://ww1.sinaimg.cn/large/4c36074fly1fz01zwac2hj20e407gq32.jpg);//为转盘指针随机生成旋转角度;这种情况可以根据转盘上圆心角的大小为每一个奖项设定一个范围，然后在这个范围内随机生成一个角度来计算指针的角度，好了，下面给出代码实现：;这里我们随机给出一个速度mInitSpeed，然后让它按照mDelta的速率缓慢的减少，当mInitSpeed的数值为0时表示转盘停止转动", "tags": [["转盘", 0.027995753289959718], ["抽奖", 0.017886161145408228], ["概率", 0.015259768430893621], ["中", 0.015247373607806688], ["游戏", 0.01487935249952644]], "title": "使用Unity3D创建一个幸运转盘"}, "3291578070": {"descs": "今天这篇文章，我们从一个实际项目的背景出发，引出使用Unity框架来简化异常处理和日志记录流程这一想法，在正式实践这一想法前，我们首先了解了Unity框架中提供的三种拦截器及其各自优劣，在此基础上我们实现了LogHandler和ExceptionHandler两个组件，并展示了如何使用这两个组件，探讨使用整个AOP机制对现有项目的影响有多大，以及为什么我们需要Unity框架等问题，框架固然重要，了解为什么使用框架则更重要;那么在今天的故事中，我们遇到了的一个场景是在指定方法执行前、后插入代码片段，这是面向切面编程(AOP)的基本思想，为此，我们考虑使用Unity框架来简化应用程序中异常处理及日志记录流程;这是一个具备完整前端和后端流程的项目，在学习这个项目的过程中，我逐渐发现某些非常有趣的东西，比如在Web API的设计中采用严谨而完善的错误码、使用OAuth和JWT对API资源进行访问控制，在JavaScript中使用修饰器特性来实现日志记录等等，这些东西我会在后续的博客逐步去整理，今天想说的是如何通过Unity框架来简化应用程序异常处理和日志记录流程，而之所以关注这个问题，是因为我发现项目中接近滥用的异常处理，以及我不能忍受的大量重复代码;由于业务场景上的需要，我们在产品中集成了大量第三方硬件厂商的SDK，这些SDK主要都是由C/C++编写的动态链接库，因此在使用这些SDK的过程中，通常频繁地使用返回值来判断一个方法是否成功被调用，虽然项目上制定了严格的错误码规范，可当我看到大量的Log()方法和业务逻辑混合在一起时，我内心依然是表示拒绝的，甚至我看到在捕获异常以后记录日志然后继续throw异常，这都是些什么鬼操作啊，考虑到我的语言描述得可能不太准确，大家可以从下面两段代码来感受下整体画风：;这种代码看起来不再关注异常，可和第一段一样，从头出现到尾的BeginLog()/EndLog()简直不能忍，而且这里的try...finally结构难免让人想起using的语法糖，那么这样是不是可以考虑让这个Log拥有类似的结构，换言之，我们总不能一直都在每一个方法里，重复写BeginLog()/EndLog()这两个方法吧，既然EndLog()方法总是在finally块里被执行，那为什么不考虑把它放到Dispose()方法里(前提是有一个结构实现IDispose接口)", "tags": [["代码", 0.014602057530353778], ["中", 0.014377857661280264], ["方法", 0.013165092776217477], ["使用", 0.013040655352078004], ["实现", 0.011832047010824728]], "title": "使用Unity框架简化应用程序异常处理及日志记录流程"}, "3222622531": {"descs": "既然，作为Git可视化工具的SourceTree可以使用VSCode作为Diff和Merge的工具，那么，我们干脆一鼓作气，将VSCode作为Git默认的Diff和Merge的工具吧;现在，使用SourceTree的时候，周围同事大部分都习惯GUI操作，所以，就想能不能把SourceTree和VSCode结合着来用，因为我发现SourceTree可以支持外部的Diff和Merge工具;然后，我们在SourceTree里做如下配置，这里我们直接让VSCode作为我们的Diff和Merge工具，具体参数如图所示：;git config --global al merge.tool cod code;git config --global al difftool.code.cmd '\"C '\"C:\\Program Files\\Microsoft VS Code\\de\\Code.exe\" \"-\" \"--wait --diff\" \"$LOCAL\" \"$REMOTE\"'", "tags": [["git", 0.034250786240170625], ["vscode", 0.019444758280425772], ["diff", 0.017954203632697403], ["命令行", 0.01710101079488798], ["使用", 0.0170040174918972]], "title": "使用VSCode作为SourceTree的Diff和Merge工具"}, "786195243": {"descs": "我是一名程序员，可是我从来没有觉得我的工作低人一等，我每天的付出和老师给学生授课、销售员给顾客售货、银行柜员给消费者办理业务、公务员为人民服务......并没有什么不同，我靠自己掌握的技能去解决工作中的问题，我靠自己掌握的知识去帮助更多的人，我并没有觉得我选择了一条错误的道路，难道在安逸中渐渐迷失了自我会让你从此与众不同;曾经和老师一起做艾依河的毕业设计，当时觉得对整个艾依河了如指掌，然而每天上下班从宝湖经过的时候却突然发现自己的渺小，我是一个普通人，我想做的事情就是努力让自己变得强大去拥有一个温暖的家，能够让因衰老而疲惫的心有个归宿，不至于在满是迷雾的现实中丢失本心，我就想一直这样简单地生活下去，做正直、正确的事情，做一个温暖、善良的人，做最初的自己;我一直认为互联网行业是政治干预较为稀疏的一个行业，所以在这个行业当中我不会遭遇那些让我厌恶的政治因素，虽然有人聚集的地方就会有政治产生，但是作为互联网基础要素之一的技术是一个相对纯粹的领域，它依靠最为简单的0和1构成了今天丰富多彩的世界，它讲道理、守规矩让我觉得这个领域简单而纯粹;我不知道梦想对一个二十三岁的人是不是一种奢侈品，我只知道当我住在狭小、拥挤的出租房里的时候，我想努力去拥有一个温暖的家，我不想靠着一张嘴去哗众取宠，我不想刻意地迎合和奉承这个世界，我只想靠我平凡而微薄的努力让我的生活一天天地温暖起来;虽然我知道当今中国的社会是一个人情社会、关系社会，可我就是不愿意把时间浪费在交际应酬这样的事情上，因为我知道人的这一生的时间是非常宝贵的，从小我就看到身边熟悉的人因为各种各样的原因突然离开这个世界，我们每一个人都会面临死亡，所以当我懒得理会这些无聊的事情的时候，我更希望在我喜欢或者关注的事情上投入精力", "tags": [["去", 0.02527515179317801], ["人", 0.013139121110749802], ["互联网", 0.012764934074608705], ["做", 0.0124454053189058], ["政治", 0.011903128264552799]], "title": "做最初的自己"}, "3653716295": {"descs": "可是人生其实本来是没有意义的，你从出生到走向死亡早已安排好，你需要做的就是“重写”这个过程，所以我们来到这个世界上，无非是想要认识些有趣的人、经历些有趣的事情，所以如果你对一件事情的成与败、一件东西得与失，都能做到坦然处之，或许你就不会再畏惧失败，当我们不再愿意为一件事情投入热情的时候，其实我们已经习惯了为自己的懒惰找到一个借口，你必须要相信你做的事情是最正确的事情，你必须要有一种敢于突破自我的激情，否则你注定只能做出平庸而普通的产品;一位同事给我推荐了《模仿游戏》这个电影，在此之前我对图灵这个人物的了解，无外乎他对整个计算机行业做出的革命性的贡献，以及他像谜一样的人生经历，可是通过这部电影，我看到的是一种天才般的疯狂和执著，图灵在被通知去接受破解德国加密装置“恩尼格玛”的任务时，军方对其进行了一个简单的面试，在面试中我们发现图灵或许不懂得什么是幽默，这种被我们称为“书呆子”的性格，在实际生活中是不讨喜的，在《黑客与画家》中作者明确地指出，“书呆子”不受欢迎是因为他们比普通人聪明，可是图灵很快就能发现，团队中有哪些人是不合格的解密者，而在这个过程中他因为不太懂得如何和别人相处，而被团队里的成员指责和谩骂，可他从来没有放弃过制造他的机器，而最终的结果的确是依靠他的机器计算出来的，天才的孤独在于常常不被常人理解，可是当图灵被强迫关闭他的机器的时候，团队中的成员愿意站在这一边，这一幕是让我感受到温情存在的，而这一切来自一个走进他生命中的女孩子：琼;这意味着我们需要去做些疯狂的事情，我们追求极致和完美，是因为我们想在这个世界上，留下属于我们自己的印记，没有人会明白，为什么乔布斯天生就有一种想要和IBM抗衡的想法，这种想法促成了让人们印象深刻的\"1984\"广告，其创意来自乔治·奥威尔的小说《一九八四》，并借助小说中的“大佬”映射当时的蓝色巨人IBM，这个举动让苹果公司、让Mac成为人们心中理想主义的化身，这个举动相当地疯狂，不是吗;我不知道大家如何定义程序员这个工作，在我看来，在某种意义上，程序员和艺术家们具有相同之处，我们都是创作者，和诗人、画家、作家等等这些职业相近，我们都在试图创作出优秀的作品，我们借助编程语言来重构我们对这个世界的认识、借助抽象的概念来创造这个世界上不存在的东西，所以我们对自由和创造的渴望，来源自我们在这个世界上写下的第一行代码，或许这像是一个充满理想主义的臆想，可这并不重要，重要的是你如何看待这个世界、如何看待你自己，我更喜欢将程序员视为造梦者，就像每一个孩子在搭积木的时候，都有一个建筑师的梦一样，你可以选择让代码简洁、优雅，你同样选择让代码肮脏、丑陋，你相信什么，你执着什么，它就会是什么，所以为什么不给我们自己更多创造的机会;天才与普通人的区别在于，他们会做出在我们普通人眼中显得“疯狂”的事情，在电影《乔布斯》的结尾，乔布斯说：“只有疯狂到相信自己能改变世界的人，才能真正改变世界”，而这里对天才的定义是什么呢", "tags": [["世界", 0.01735514991660055], ["人", 0.013439993613947744], ["去", 0.009783344165030643], ["人类", 0.008503176873291371], ["天才", 0.008337931354650819]], "title": "像诗人一样睿智，像天才一样疯狂"}, "2318173297": {"descs": "我今天想说的是，一个业务中遇到的单位转换的问题，我们平时在存储货物的重量时，默认都是以千克作为单位来存储的，直到我们对接了一家以大宗商品交易作为主要业务的客户，对方要求我们在界面上统一用吨来展示数据，因为这样更符合客户方的使用习惯;我最终还是通过反射解决了这个问题，即在使用AutoMapper前，从数据库查出数据后，首先要做的第一件事情就是对数值进行转换：;这样看起来是没有问题的，可当你结合今天这篇博客的背景来看是，就会发现一个问题，所有的数值在展示的时候都必须要知道，数据库里存储的数值的原始单位是什么，而使用者希望在界面上看到的数值的单位又是什么;我们项目中采用的第一种方案，我印象非常深刻，在计算件数、重量和体积的时候，必须要等所有明细行都计算完以后，再通过调用Sum()方法给表头赋值，实际上这个表头字段，完全可以通过只读属性的方式取值啊，更何况我们还使用了外键，表头实体本身就引用了明细表实体，因为有外键的存在，序列化表头实体的时候会出现循环引用，对此，我想说，干得漂亮;//当默认重量单位为KG时不做任何处理", "tags": [["中", 0.018527907234439894], ["单位", 0.01363391171109118], ["问题", 0.012738656015366747], ["数据库", 0.011815864696889052], ["使用", 0.010873035982264773]], "title": "关于单位转换相关问题的常见思路"}, "2462008667": {"descs": "战争带给我们的是永远的伤痛，今天我们对于日本这个国家，可能有时候还会充满抵触情绪，但我想说的是，这场战争并没有结束，金九认为日本人已经投降，不再需要可依靠捐助维持，以光明正大地回到国内搞建设，可事实上像廉锡镇这样投日派，并没有完全得到清算，所以，金九在回国后不久就被韩国激进分子刺杀，廉锡镇所说的独立运动派系之争，在历史上是真实存在着的，金九就是被卷入到这场政治斗争中的牺牲品，所以，金元凤最终选择了朝鲜，而这种派系之争，更是加剧了整个朝鲜半岛的分裂，在这片土地上，曾经一起战斗过的兄弟、朋友，最终变成兵戎相向的敌人;自然，故事的结尾，所谓善恶有报，16年前的暗杀任务，终于在韩国光复以后，有安沃允和明宇重新执行，结尾处被乱枪打死的廉锡镇，在被问到为什么要出卖同志时，说了一句“我没想到会解放啊”，一句听起来像开玩笑的话，其实说出了战争年代人们的无奈，如果没有战争，或许这些事情就真的不会发生，可当战争机器被发动时，又有谁会想到这些呢;故事发生在京城(即韩国首尔)和上海，时任韩国临时政府局务局局长的廉锡镇(**李政宰**饰)，在早年刺杀日军大将失败以后，暗地里早已投靠日本人，此时更将暗杀三人组的消息泄露给日方;与此同时，间接导致了女主安沃允的母亲被亲日派父亲康寅国派人杀死，安沃允与双胞胎姐姐美津子分离，直至多年后，来自东北抗日武装的安沃允，和自幼在日占区长大的美津子，终于在一个屋檐下相认，可转眼间，姐姐就被卖国贼康寅国给杀死了，电影中全女神亲眼目睹姐姐死亡的那一幕真的是令人心碎;电影讲述了19世纪30年代，以安沃允(**全智贤**饰)为首的暗杀三人组，奉命刺杀日军驻朝鲜司令官及本国卖国贼的故事", "tags": [["人", 0.014152405278893518], ["没有", 0.010556288468811983], ["电影", 0.009653436309561524], ["廉锡镇", 0.008613506502577422], ["会", 0.008374327107124718]], "title": "关于电影《暗杀》背后的故事和想法"}, "2752169106": {"descs": "我特别喜欢和技术圈子里的这些朋友聊天，因为我觉得在这些人中间可以找到共同的话题，或许大家的经济状况都不宽裕，可是听着每一个人的故事都是一部奋斗史，没有人能随随便便成功，可是每一个人都在用一种近乎纯粹的信仰去努力实现，而不是随波逐流;说实话，这些村民生活在山区生活困顿不堪，可是每次到村里都很热心地招待我们，这让我在感受到他们的质朴时更加自责，我们所做的工作从本质上来讲根本没有什么意义，每次和这些队长交流，他们最关心的问题就是他们的土地会不会被收回去，可是他们视如生命的土地却往往只是国土局任意划定的一个范围;而明天毕业后的我同样会有这一天，我真的不想小河变成大楼，我真的不想单纯变成冷漠，许嵩的这首《秋千坠》很多人都没有用心地听，因此这首歌轻快的节奏只会让人记得那段重复的飘啊飘...以单纯的心去面对这个世界，可能会受到伤害;我今天早上看《我是演说家》这个节目，我觉得这是一个比较有品位的节目，如乐嘉所说，这个节目的收视率可能不会像其它的娱乐节目那样高，可它能让你的内心真正有所触动，因为讲故事的人可能是一个你素不相识的人，可是它讲的故事可能会是你身上正在发生的事情;我每隔一段时间就会去我的博客看看，每次碰到问我问题的朋友我都很热心的回答，因为我觉得人与人之间真的存在某种特殊的联系", "tags": [["人", 0.020502653540376576], ["工作", 0.015458240327659686], ["喜欢", 0.01285302924903615], ["会", 0.011194087020455221], ["去", 0.009166876704839507]], "title": "写给永远单纯的自己"}, "3111375079": {"descs": "其实回头想想今年面试的表现，前端、数据库等相关经验的匮乏，一度让我在面试中非常被动，而外冷内热的性格常常给人一种不自信的表现，特别是去葡萄城面试的这次体验，让我意识到在面试中我无法展示出和职位匹配的能力，我们说面试是双向选择的一个过程，这看起来有点像是找男女朋友一样，有时候我们太在乎对方而导致表现不佳;有时候人的命运像极了历史的兴衰，记得三年前和同学第一次来西安，那个时候我们说，总有一天我们会再来这里的，那时的我或许完全不知道现在会面临这种处境，看着那些年龄比自己大依然碌碌无为的人，看着那些面临中年危机而不得不向生活妥协的人.....我告诉自己，我永远都害怕自己变成这样的人，所以让我内心无法平静下来的，永远是我近乎自责的自我反省式人格;我花了时间去听知乎上有关面试技巧的Live，甚至找朋友帮我分析如何给出面试官满意的答案，有时候别人会觉得我对严厉到苛刻的程度，是因为我对某些东西太在乎的缘故，可是不在乎这些问题就能解决了吗;我是一个不大主动同家里的人，在那一刻我忽然觉得，这个冬天没有那么冷了，即使我身处没有暖气的出租屋里，即使早晨带着体温的被子早已凉透，我想对自己说一句，冬天来了，春天还会远吗;人类总是肤浅地相信眼睛看到的，固执地认为自己的想法就是正确的，可人这种复杂的动物怎么会一眼就望穿呢，所以试图通过面试完全了解一个人，原本就是不切实际的想法", "tags": [["人", 0.025575011158073827], ["面试", 0.02116194250931283], ["妈妈", 0.013619088745342296], ["会", 0.013613114098215454], ["去", 0.013350076350087914]], "title": "冬天来了，春天还会远吗？"}, "2171683728": {"descs": "本文对函数式编程中的常见术语如高阶函数、局部套用/柯里化、惰性求值等结合C#语言进行了简单分析;举一个基本的例子，.NET中IEnumerable<T>接口提供了大量的如Select、Where等扩展方法，而这些扩展方法同样会返回IEnumerable<T>类型，并且这些扩展方法不会改变原来的集合，所有的修改都是作用在一个新的集合上，这就是函数式编程的不可变性;常用的函数式编程术语有高阶函数、柯里化/局部调用、惰性求值，递归等;首先，函数式编程中强调无状态、不可变性，认为函数是一等公民，并且在函数式编程中每一个函数都是一个纯函数，它是数学概念咋计算机领域的一种延伸，和冯.诺依曼计算机体系不同，函数式编程的核心思想是以lambda演算为基础的表达式求值，并且函数式编程强调无副作用;自然是同样的道理啦，因为我们都知道，在C#中委托是一种类似函数指针的概念，因为当我们需要传入和返回一个函数的时候，选择委托这种特殊的类型可谓是恰如其分啦，这样并不会影响我们去理解高阶函数", "tags": [["函数", 0.03758906826580059], ["编程", 0.017653280071463752], ["中", 0.016618929961686377], ["lambda", 0.009217749017734995], ["参数", 0.009067157093489289]], "title": "函数式编程常用术语"}, "2436573863": {"descs": "这篇文章主要分享了三种实现列表拖拽排序的方案，在技术选型阶段，主要选择Nestable和Sortable这两种方案，前者对层级节点提供的序列化支持非常好，但经过一番折腾后，发现要想像作者一样用好这个插件，着实是件困难的事情，而且貌似作者已经不再维护这个项目了，最近的代码提交历史大概是6年前，**毕竟属于jQuery的辉煌时代已经过去，何况是一个基于jQuery的插件呢;[Sortable](https://sortablejs.github.io/Sortable/)相比Nestable好的一点就是，它对自己的定位是“一个用于可重新排序的拖放列表的JavaScript库”;最终的结果是我们打算为用户提供自定义的功能，考虑到操作的便利性问题，我们放弃了那种通过上下箭头按钮进行排序的方案，这样就回到了本文的主题，如何在前端中对一组列表进行拖拽排序，最终我们选定了两组方案，它们分别是[Nestable](https://github.com/dbushell/Nestable)和[Sortable](http://sortablejs.github.io/Sortable/);<li class=\"dd-item\" data-id=\"1\">;<li class=\"dd-item\" data-id=\"2\">", "tags": [["列表", 0.01259076637133677], ["中", 0.012196109612896352], ["sortable", 0.012036520040786598], ["用户", 0.01153490702889505], ["使用", 0.01148122783600699]], "title": "分享两种实现前端拖拽排序的方案"}, "1333693167": {"descs": "Binlog是实现主从复制的重要机制，而基于这一机制，业界普遍的做法是利用MySQL的交换协议，让客户端\"伪装\"成一个从库，在比较了Canal 、Maxwell 以及Python-Mysql-Replication后，博主选择了. NET Core  + RabbitMQ + Python的方案，目标是让Binlog可以发布到消息总线(EventBus)中供消费者订阅和消费;首先，每次读取Binlog，必须要知道对应的日志文件和位置，而如果在新的Binlog 产生前，没有处理完原来的Binlog，就必须要记录对应的日志文件和位置，而且经过博主本人测试，Binlog无法直接给查询语句追加过滤条件，来达到筛选某些数据库、表以及事件的目的，而且日志文件的格式会因为模式的不同而不同，最主要的一点是，直接在主库上读取Binlog会给数据库带来访问压力，所以，主流的方案，是让客户端伪装成“从库”，关于一点，我们可以配合下面的图片来理解;其次，利用Python-Mysql-Replication实现一个读取Binlog的后台程序，这些Binlog最终会以JSON的形式发布到RabbitMQ上;以博主最近处理的业务为例，A系统中的司机、设备、用户在新建/更新更新时，需要把新数据推送到B系统，因为这类纯数据类的\"变化\"没有实际业务意义，所以，人们不舍得为这些变化去分发事件，而要想分发事件，又不得不去面对强耦合带来的阵痛，所以，Binlog的第二个用途是可以作为事件源来实现事件驱动;# 什么是Binlog", "tags": [["binlog", 0.030803147634996208], ["mysql", 0.011787066314992739], ["中", 0.010567803371742861], ["数据", 0.010352755520293888], ["数据库", 0.010206854206661302]], "title": "利用MySQL的Binlog实现数据同步与订阅(上)"}, "3424138425": {"descs": "在这个过程中，我们了解了Binlog的相关概念，参考微软的 [eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) 项目实现了一个基于RabbitMQ的EventBus，而这一切都在这篇博客中完成了最终的“拼合”，通过 [Python-Mysql-Replication](https://github.com/noplay/python-mysql-replication) 实现了Binlog解析，而EventBus则作为整个事件系统的“上帝”对所有事件处理器(**EventHandler**)进行统一调度，最终我们不需要关心这些事件是如何被发布到EventBus中的，只需要知道它对应哪一个Event并为它编写对应的EventHandler即可，除了这篇博客中提到的Binlog以外，实际上它还可以作为系统内的“领域事件”来实现业务上的事件驱动，譬如`OrderInfoCreateEvent`这个事件可以表示一个订单被创建，而关心订单状态的人则可以通过EventHandler来实现订阅，实现类似发短信、发邮件、发微信等等的功能，或者可以让第三方的Web API来消费事件中携带的信息;_logger.LogInformation ($\"日志编号：{@event.TRANSACTION_ID}，日志级别：{@event.LOG_LEVEL}，主机：{@event.HOST_NAME}，IP：{@event.HOST_IP}，内容：{@event.CONTENT}\");终于到这个系列的最后一篇，在前两篇博客中，我们分别了介绍了**Binlog**的概念和事件总线(**EventBus**)的实现，在完成前面这将近好几千字的铺垫以后，我们终于可以进入正题，即通过EventBus发布Binlog，再通过编写对应的EventHandler来订阅这些Binlog，这样就实现了我们“最初的梦想”;在读取到Binlog以后，我们需要将其发布到EventBus里，为此，在.NET Core这边提供一个Web API接口，只需要注入` IEventBus`然后调用` Publish()`即可：;public Task Handle (WriteLogEvent @event) {", "tags": [["binlog", 0.01850579141038683], ["实现", 0.017600741492251736], ["event", 0.017209036833373985], ["eventbus", 0.015114667374701936], ["事件", 0.01259643560233975]], "title": "利用MySQL的Binlog实现数据同步与订阅(下)"}, "580694660": {"descs": "而实现EventBus最关键的三个方法，即Publish()、Subscribe()和Unsubscribe()，这其中需要了解一部分RabbitMQ的知识，所以，在这篇博客中，你可以了解到RabbitMQ的四种交换器、死信机制、重试超时机制等等，在此基础上，我们将在下一篇博客中，通过 [Python-Mysql-Replication](https://github.com/noplay/python-mysql-replication) 实现Binlog的发布，而一旦我们将Binlog发布到消息队列中，本文实现的EventBus就可以作为消息的中介者而登场啦，欢迎大家继续关注我的博客，我们下一篇见;在这里，我们对消息进行序列化以后，按照事件的类型信息生成`routingKey`，并指定交换器的类型为` direct`，这是一个RabbitMQ中自带的`发布-订阅`实现，因为交换器会根据` routingKey`投递消息到对应的队列中，关于RabbitMQ中四种交换器的说明，可以在下一节找到答案;显而易见，发布-订阅模式和观察者模式都是设计模式，而IObservable<T>与IObserver<T>、消息队列则是具体的实现方式，就像你可以用委托或者事件去实现一个观察者模式，而Redis里同样内置了发布-订阅模型，换言之，这是抽象与具体的区别，消息队列可以用来实现EventBus，而EventBus主要的用途则是系统间的解耦，说到解耦，你可能会对观察者模式和发布-订阅模式这两种模式感到困惑，因为它们实在是太像了，一个最本质的区别在于发布者(主题)是否与订阅者(观察者)存在强依赖关系，而发布-订阅引入了类似主题/Topic/Channel的中介者，显然从解耦的角度要更彻底一些，所以，我们今天就来一起实现一个事件总线(EventBus);如果已注册，则获取当前事件对应的EventHandler集合，然后通过IoC容器逐个地取得对应实例，因为在定义EventHandler的时候，我们让`Handle()`方法返回了一个Task，所以，我们可以顺利成章地使用`Task.WhenAll()`，而当所有的EventHandler都处理完成的时候，我们就可以认为这条消息被处理完了，此时，我们可以手动进行ACK，这样这条消息就会从队列中移除，至此，我们已经实现了一个完整的EventBus;本文参考微软的 [eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) 项目，实现一个基于RabbitMQ的事件总线，事件总线是发布-订阅模式的一种延伸，可以在分布式的环境中令消息的发布者、订阅者完美地解耦，是领域驱动设计(DDD)中重要的基础设施之一，对于实现业务上的“事件驱动”非常有帮助", "tags": [["消息", 0.022652767446041226], ["rabbitmq", 0.019031399279230053], ["中", 0.013779402128438764], ["实现", 0.012116158909362709], ["eventbus", 0.010896885517412587]], "title": "利用MySQL的Binlog实现数据同步与订阅(中)"}, "123663202": {"descs": "如果是同一个，则不进行赋值运算，直接返回，如果事先不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题，当*this和传入的参数是同一个实例时，一旦释放了自身的内存，传入的参数的内存将同时被释放，因此将再也找不到需要赋值的内容了;*  因为链表中的内存不是一次性分配的，所以我们不能确定链表的内存和数组一样是连续的，因此如果想在链表中找到第i个结点，我们只能从头结点开始，沿着指向下一个结点的指针遍历链表，其效率是O(n);get{ return instance;return result[n];*  当我们需要在函数或者方法中返回一个String实例时，我们需要在传入的参数前加上ref或者out标记", "tags": [["中", 0.029803178190864213], ["结点", 0.014240442938674321], ["内存", 0.013429681384751304], ["时", 0.013270381458590344], ["链表", 0.012229322003852183]], "title": "剑指Offer读书笔记(1)"}, "3444626340": {"descs": "其实，你仔细观察七牛图片外链的格式就会发现，除了域名部分以外，剩下的就是该文件在bucket里对应的key啦，所以，博主的想法开始从Markdown文件入手，最终我们的思路是，解析博客对应的Markdown文件，通过正则匹配所有的图片链接，截取出图片的文件名并通过qshell下载到本地;七牛的测试域名被官方回收了以后，我们有两种思路去导出这些图片，其一，是临时像官方提工单申请一个测试域名，这样在测试域名被回收前，我们可以直接使用官方提供的[qrsctl](https://developer.qiniu.com/kodo/tools/qrsctl)或者[qshell](https://developer.qiniu.com/kodo/tools/qshell)工具进行批量导出，因为此时我们可以直接在配置文件里配置测试域名，具体可以参考这篇文章：[跑路之后七牛图片如何导出备份至本地](https://www.jianshu.com/p/309709f7bfe4)，甚至你可以直接到七牛的管理控制台手动下载，可这样就一点都不极客了对吗;如果你现在访问我的博客，大概就会发现，之前那些无法显示的图片，现在基本上都可以显示啦，而我所做的事情，就是执行这些Python脚本，让它帮我完成从图片下载、上传再到替换链接的所有事情;去年国庆的时候，七牛官方开始回收测试域名，这直接导致博客中大量图片出现无法访问的情况，虽然博主第一时间启用了新的域名：[https://blog.yuanpei.me](https://blog.yuanpei.me)，可是因为七牛官方要求域名必须备案，所以，这件事情一直耽搁着没有往下进行;os.system('qshell get {0} {1} -o {2}'.format(bucket,fileKey,outfile))", "tags": [["图片", 0.02011701046663833], ["https", 0.013523464051384363], ["博客", 0.011365726908179543], ["文件", 0.010290034613897634], ["qshell", 0.010038342606681346]], "title": "博客图片迁移折腾记"}, "2147036181": {"descs": "本文主要抓取了Boss直聘、智联招聘、前程无忧三个招聘网站的职位信息和公司信息，并在此基础上对西安市的求职招聘进行了数据分析，主要从行业结构、学历结构、薪资待遇、学历与薪资关系、经验与薪资关系、招聘热词等方面入手，经分析，针对西安市的求职招聘的求职招聘，我们可以得出下面的结论：(1)西安市排名相对靠前的行业主要有：**房地产、建筑/建材/工程、计算机软件、电子技术/半导体/集成电路、教育/培训/院校**等;counter = dict(records);title_opts=opts.TitleOpts(title=\"西安市求职招聘工作经验与薪资关系分析\", pos_left=325),;title_opts=opts.TitleOpts(title=\"西安市求职招聘学历与薪资关系分析\", pos_left=325),;[西安市求职招聘工作经验与薪资关系分析](https://i.loli.net/2020/12/05/XOUBgy2AJqHRQWs.png)", "tags": [["https", 0.009800640649116586], ["去", 0.008826085843848376], ["会", 0.008473083046958797], ["分析", 0.008062375205395173], ["行业", 0.00776642387577047]], "title": "厉害了！打工人用Python分析西安市职位信息"}, "478946932": {"descs": "之前曾经尝试过像 [hexo-recommended-posts](https://github.com/huiwang/hexo-recommended-posts) 这样的插件，坦白说效果不是特别好，因为有时候加载这些站外的内容，导致博客页面打开的时候异常卡顿，所以，我们今天将采用原生的JavaScript来为Hexo实现博客推理功能，希望对大家有所启发;<% var post_list = recommended_posts(page, site, config.recommended_posts.limit) %>;function recommended_posts(page, site, limit = 5) {;<% if(post_list.length > 0 && config.recommended_posts.enable) { %>;if (page.tags.length == 0) return []", "tags": [["博客", 0.025106870191882354], ["不", 0.010248324235900927], ["屏", 0.009275551928486076], ["时间", 0.00881538393593984], ["推荐", 0.008175697893710707]], "title": "原生JavaScript实现Hexo博客推荐功能"}, "2954591764": {"descs": "顺着这样的思路，如果我们可以把ChannelFactory注入到RealProxy中，就可以在接口调用过程中记录相关信息，这样我们就可以关注调用本身，因为所有的我们不想写的代码，现在全部都由代理类接管了，更重要的是，所有通过这种方式调用的WCF服务，都可以以一种统一而简洁的方式去处理，永远不用担心因为某个人忘记写代理方法而出现问题，下面给出整个实现的关键代码：;现在，我们来考虑WCF，WCF需要通过ChannelFactory来创建和释放，而这恰恰是代理类所做的事情，就像下面的代码一样，我们通常会把所有的WCF集中配置在一个地方，并通过构造Binding和终结点地址来创建一个WCF服务，在调用服务的过程中，会对调用时间、异常信息等进行记录，这其实和我举的第一个例子完全一致，那么我们能不能用RealProxy来实现这些功能呢;首先，我们定义一个简单的接口ICalculator，它含有加、减、乘、除四种基本运算，我们希望记录每个方法调用的参数、结果和执行时间，因此通过RealProxy对现有类型CalculatorService进行代理，并动态地创建代理对象来供调用方使用，下面给出关键代码：;通过RealProxy，我们已经实现了WCF服务的动态代理，这里介绍第二种方式，即Castle.DynamicProxy，Castle和AspectCore、Unity等项目一样，提供了AOP相关的能力，可以让我们对接口、虚方法、类等进行拦截;我们实现了WCF服务创建细节的隐藏，调用者不再需要去关心ChannelFactory相关的底层细节，可以像使用普通接口一样调用WCF服务，并且可以用一种统一的方式去记录调用相关的细节、对异常进行处理等等", "tags": [["代理", 0.018564880748883475], ["中", 0.015471773026860697], ["方法", 0.01405305659256676], ["调用", 0.013719772946772148], ["使用", 0.011292264625366678]], "title": "又见AOP之基于RealProxy实现WCF动态代理"}, "2950334112": {"descs": "大家可以看到这里就是一段HTML代码，因为我们要引入的这个模板和article.ejs在同一个页面中，所以我们可以直接在这里调用item这个变量，而item这个变量里是封装了当前文章的标题和链接的，因此我们可以顺利成章的构造这样一段HTML代码，因为博主不会写CSS样式，所以使用了一个默认的代码样式来完成这个工作，如果大家懂CSS，请自行发挥你的创意将它做得更好;<div class=\"article-content\">;<div class=\"article-content\">;我们可以注意到文章的内容是在<%- item.content %>这个标签里，因此我们如果要在文章中增加内容，只需要在<%- item.content %>的后面引入一个ejs模板文件即可，所以我们接下在article.ejs的同级目录下创建一个declare.ejs文件：;好了，废话少说，放码过来，我们下面来看看怎么在Hexo中的文章中增加一个展示版权信息的模块，这里以[Jacman](https://github.com/wuchong/jacman)主题为例，我们首先定位到该主题文件夹下的\\layout\\_partial\\post\\article.ejs文件：", "tags": [["博客", 0.02637791705561044], ["文章", 0.018113059167374206], ["版权", 0.013915883648755428], ["知识", 0.013770727568133438], ["item", 0.00941865368144682]], "title": "在Hexo中为文章自动添加版权信息声明模块"}, "1152813120": {"descs": "好了，这些就是基本的Markdown语法所定义的元素啦，我觉得这是一种非常优雅的标记语言，如果你觉得纯文本的内容太单调，如果你觉得Word使用起来太复杂，那么Markdown就在这两者间找到一个平衡点，我没有劝大家放弃Word然后转而投身Markdown写作，可是作为一个经常码字的博客作者，我可以负责任的说，Markdown是一种可以让你专注写作的工具，而且作为一名工程师，你会发现StackOverflow、Segmentfault、Github等知名技术社区，无一例外地都在支持Markdown语法，所以Markdown其实是开源社区里除了英语以外的第二大通用语言，所以如果你喜欢写作或者是喜欢开源，Markdown都会是你不错的选择，而它的语法相信你此时已然学会了;我不太喜欢这个编辑器的一个重要原因是，我喜欢在离线环境下写文章，然后将其发布在我的个人博客上面，而这款编辑器和社区耦合过紧，虽然提供了离线版本的Markdown编辑器，但是对我而言功能上略显臃肿，我在这里推荐这个Markdown编辑器的原因是，它提供了HTML/PDF的导出功能，当我们在线编辑Markdown文档时即可通过浏览器导出HTML/PDF，如果你不需要经常导出Markdown为其它的文档格式，我会推荐你使用Sublime、VSCode、马克飞象、为知笔记、小书匠等编辑器，虽然Markdown语法对使用者的要求并不高，但我相信有一个体验良好的Markdown编辑器，会让我们的写作过程更为开心，从而达到事半功倍的效果;所以，当我们尝试对自我进行知识管理的时候，我们就需要一种良好的方式来管理这些零散的知识，在这里Markdown和Kindle会成为我们的强力工具，来帮助我们收集和整理各种各样的信息，正如我在写这篇博客的时候，我需要Markdown文档撰写和Kindle电子书格式的相关内容，我可以快速地从我的为知笔记中找到参考内容;没有什么比看到一段支持代码高亮的代码片段更让人开心的了，所以你至此就会明白，为什么Markdown会如此深受工程师们的喜爱，尤其当我们需要撰写一篇技术文章并且需要在文章中展示代码的时候，如你所见，这个博客中所有的代码片段都支持代码高亮，这样可以给阅读者更好的阅读的体验，我想吐槽的一件事情是公司内部的Jira居然不支持Markdown语法，虽然公司的第一架构经常会在这里Share技术文章，可是糟糕的代码片段完全让人没有继续看下去的冲动;好了，下面我们介绍一个使用Github/Git和Markdown来构建电子书的网站GitBook，请不要误会，这个网站和全球最大的同性交友网站Github没有任何直接的关系，两者的关系可以理解为，GitBook是一个基于Github/Git的静态页面生成器，其本身是一个由NodeJS编写而成的命令行工具，而通过这个工具和Markdown语法，我们就可以创建出足以媲美专业电子书籍的电子书，和Hexo类似，我们可以将这些生成的静态页面部署到Github Pages来供其它人浏览和阅读，除此以外GitBook本身就是一个相当优秀的内容发布平台，截止到今天GitBook上已经有18036本电子书", "tags": [["markdown", 0.029410797301089767], ["中", 0.014552557908169528], ["kindle", 0.01129850425288307], ["笔记", 0.010372770844469024], ["信息", 0.010091747188974336]], "title": "在Kindle上阅读Markdown文档"}, "570137885": {"descs": "open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/';open( os.path.join( ipp, pf), 'wb' ).write( urllib2.urlopen( 'http://sublime.wbond.net/';ipp = sublime.installed_packages_path();ipp = sublime.installed_packages_path();pf='Package Control.sublime-package'", "tags": [["sublime", 0.059075423484974805], ["package", 0.035135028699333756], ["packages", 0.02595429980717905], ["ipp", 0.02391735917895399], ["opener", 0.019309940057469745]], "title": "在Sublime Text3下安装Package Control"}, "1150143610": {"descs": "好了，接下来我们会遇到一个新的问题，这些精灵的层级应该是从中间位置向两边依次递减的，所以为了解决这个问题，我们还需要对每个精灵的层级进行计算，这部分代码的实现细节如下：;其实这篇文章我还想继续再往下写的，可是因为我比较懒一直拖着不写，以及接下来相当多的内容都是和界面相关的东西，所以我决定这篇文章就暂时写到这里，目前这个方案可以实现一个简单的“3D”滚动的效果，按照这个思路，接下来我们要做的事情是让滚动更加平滑以及支持鼠标或者触屏操作，毕竟这个需求的出发点是来自一个游戏，所以我们可以考虑在“滚动”的时候增加插值特性，与此同时，为了让它更加具有“3D”的感觉，可以在设置精灵层级的时候为不同的精灵设置不同的缩放比例，这样会更加符合美术中的透视关系，效果应该会更好吧;所以在这里除了确定每个精灵的放置位置以外，我们还有一个问题，如何对这些精灵进行排序，所幸的是在uGUI中我们可以通过SetSiblingIndex方法来设置一个精灵的深度，当每次通过按钮切换精灵的时候，我们都需要对所有精灵重新计算坐标和深度，而为了更好的视觉表现力，我们可以在切换的时候做一个简单的位移动画，至此我们就可以开始动手实现功能啦;本文介绍了一种基于曲线方程来构建伪3D效果的思路，主要借助椭圆的参数方程来计算精灵位置，使其实现按照椭圆曲线进行排布的效果，在此基础上配合层级调整、插值、缩放等技巧，在一定程度上可以实现2D平面内的伪3D旋转效果;可以注意到，在这里我们根据精灵索引index和两侧精灵数目halfSize的关系，按照DeltaAngle这个增量来计算每个精灵实际的角度，在此基础上结合椭圆的参数方程，我们可以非常容易地计算出每个精灵实际的位置，这样就可以保证精灵中心都在椭圆曲线上", "tags": [["实现", 0.02225541776428777], ["中", 0.018491060660764894], ["精灵", 0.013374304237929607], ["会", 0.013089476363119685], ["效果", 0.009529222396166121]], "title": "在Unity3D中使用uGUI实现3D旋转特效"}, "821259985": {"descs": "现在我们运行程序可以发现两种方式均可以让图片加载进来，为了对比两种方式在执行效率上的高低，我们在脚本中加入了相关代码，通过对比可以发现使用IO方式加载一张227k的图片需要的时间为0s，而使用WWW方式加载需要0.0185s，因此传统的IO方式具有更高的效率，建议大家在遇到这类问题时尽可能地使用这种方式;经过博主的研究发现，这种方式加载外部图片相对于使用WWW加载外部图片效率更高，所以如果大家遇到类似的需求，博主个人推荐大家使用这种方式进行加载;/// 以WWW方式进行加载;针对有朋友指出WWW加载和传统IO加载方式在效率上的差异，我们这里重新做一个效率测试;可以看到在使用这种方式读取图片文件的时候主要是将图片文件转化为byte[]数组，再利用Texture2D的LoadImage方法转化为Unity3D中的Texture2D", "tags": [["中", 0.028453717714881463], ["www", 0.027049381699793245], ["加载", 0.018830949284904357], ["大家", 0.01846433368284164], ["游戏", 0.017284974042710018]], "title": "在Unity3D中加载外部图片的两种方法"}, "632291273": {"descs": "注意到在这个“通知中心”中，我们首先实现了单例模式，这样我们可以通过Get方法来获取该“通知中心”的唯一实例，其次这里利用一个字典来存储对所有事件的引用，这样保证外部可以通过AddEventListener和RemoveEventListener这两个方法来进行事件的添加和移除，对于添加的事件引用我们可以通过DispatchEvent方法来分发一个事件，事件的回调函数采用委托来实现，注意到这个委托需要一个Notification类型，对该类型简单定义如下：;public void DispatchEvent(string eventKey, GameObject sender, object param);public void DispatchEvent(string eventKey,object param);这里以一个简单的示例来验证事件机制的可行性，我们在场景中有一个球体，默认这个球体的颜色为白色，通过调整界面中的RGB数值，可以改变球体的颜色，在这个示例中UI是事件发送者，负责UI中Slider控件的数值发生变化时向球体发送消息，传递的数据类型是Color类型;eventListeners[eventKey](new Notification(sender,param))", "tags": [["事件", 0.027314219823749663], ["中", 0.018155299740459173], ["进行", 0.015607017266334434], ["问题", 0.01557424690522984], ["模式", 0.014557881422178755]], "title": "在Unity3D中基于订阅者模式实现事件机制"}, "3642630198": {"descs": "```Lua;* 编译项目会得到一个Luac.exe文件，这就是我们编译得到的Lua解释器;* 在同一个解决方案下继续创建VC++项目，项目命名为Lua，项目类型为控制台应用程序、需设置预编译头;* 在同一个解决方案下继续创建VC++项目，项目命名为Lua，项目类型为控制台应用程序、需设置预编译头;* 编译项目会得到一个Lua53.lib的文件，这就是我们编译得到的Lua链接库", "tags": [["lua", 0.08053166430032839], ["编译", 0.037454175237359104], ["项目", 0.029175099316347198], ["文件", 0.02356364821729693], ["程序", 0.015964422029685302]], "title": "在Windows下使用Visual Studio编译Lua5.3"}, "3972610476": {"descs": "Linux Deepin安装是非常顺畅的，但即便安装完这个桌面环境，博主还是不知道怎么启动这个环境，因为你常规使用Ubuntu的话，安装完切换桌面管理器就可以了，可当你用WSL这种方式使用Ubuntu的时候，可能你就会感到非常困惑;虽然目前应用商店里已经提供了Ubuntu、Debian、Kail Linux、OpenSUSE这些常见的发行版，可当你熟悉了Linux的世界以后，就会明白这个世界对多元化的追求是永无止境的，我不想去Judge这些多元化间优劣，我只想自由地使用我喜欢的技术，比如Linux Deepin、Elementary OS;在对比了Gnome、KDE、Unity、Mint、xfce等等的桌面环境以后，我觉得Linux在桌面市场输给Windows是理所当然的，因为实在太混乱了，WSL下需要的应该是一个轻量级的桌面，因为越是华而不实东西，越会消耗大量资源;OK，既然Ubuntu可以装桌面，那么，衍生自Ubuntu的Elementary OS和Linux Deepin应该同样可以吧，虽然目前应用商店里还有这两个发行版;总而言之，博主试图在WSL上体验Elementary OS的想法彻底失败，既然这个最美的Linux发行版已失败告终，并不打算就此罢手的博主，决定继续在命令行终端里折腾Linux Deepin", "tags": [["linux", 0.020744907732207163], ["ubuntu", 0.015480248022725001], ["桌面环境", 0.01543215312243927], ["wsl", 0.012300486507474204], ["使用", 0.012052671321067663]], "title": "在WSL中使用Linux桌面环境的尝试与总结"}, "124807650": {"descs": "在实习过程中，我利用空闲时间研究了塔防游戏和静态博客系统Hexo，我的感觉就是编程环境还是Linux操作系统比较给力，像Ruby这样的环境在Windows下安装简直就是在找虐;在实习期间，我研究了动作类游戏中的三连击效果，这是我在实习中做过的唯一一件与专业无关的事情;9月份到了学校，为了给我的仙剑同人游戏项目寻找素材，我研究了《仙剑奇侠传》、《古剑奇谭》等游戏的解包，并从中提取了大量的游戏模型;回首2014，从年初开始学习Unity3D游戏开发到现在，我的博客共积累了230335次访问量和700名粉丝的关注;6月份我萌生了利用Unity来开发仙剑同人游戏的想法", "tags": [["游戏", 0.020465304522219306], ["人", 0.014311503012997516], ["博客", 0.013850354163028458], ["linux", 0.01134417798997166], ["关注", 0.009231582499590128]], "title": "在平凡中蜕变，我的2014"}, "1254783039": {"descs": "而这种情况常常是因为用户在设计需求的时候忽略了某些细节，所以对我而言我生气、我愤怒，并非是我觉得这个需求无法实现，而是它在某种程度上是冗余的，即它可能破坏了一致性原则，灵活的人类是比呆板的计算机有趣，可和人相处得久了，你难免会觉得人显得不靠谱，这就是我厌恶的理由，在这个世界上所有一切计算机可以处理的问题，在某种程度上都可以转化为数学问题，一旦我们将设定突破这个规则，就会让代码因为妥协而变得丑陋不堪，我显然不允许这样的事情发生;public override void WriteLine(object obj, string category);public override void WriteLine(string message);public override void WriteLine(string message, string category);Trace.WriteLine(\"This is a Debug message", "tags": [["中", 0.019035810049371858], ["会", 0.015917309318425207], ["输出", 0.00904391294357273], ["方法", 0.008788331150198211], ["计算机", 0.007663610246377122]], "title": "基于C#中的Trace实现一个简单的日志系统"}, "3995512051": {"descs": "RUN sudo mono ./sonar-scanner/SonarQube.Scanner.MSBuild.exe begin /k:\"Sonar-HttpServer\" /d:sonar.organization=\"qinyuanpei-github\" /d:sonar.host.url=\"https://sonarcloud.io\" /d:sonar.login=\"db795a28468dc7c12805b330afed53d362fdd2d9\";对于单元测试，微软提供的MSTest功能相对薄弱，关键是严重依赖Visual Studio，一旦我们想要移植到Linux平台下，就会发现阻力重重，所以在平时开发中，我更建议大家去使用NUnit或者XUnit，它们比MSTest功能强大，可以直接通过Nuget安装，同时自带TestRunner，这是一个控制台程序，我们直接通过Mono调用它，并把单元测试项目生成的动态链接库作为参数传递给它即可;RUN sudo mono ./sonar-scanner/SonarQube.Scanner.MSBuild.exe end /d:sonar.login=\"db795a28468dc7c12805b330afed53d362fdd2d9\";RUN sudo apt install apt-transport-https -y;RUN sudo apt-get install wget -y", "tags": [["mono", 0.015681855000001528], ["msbuild", 0.015126117337343188], ["https", 0.014547113979109782], ["docker", 0.011624512551707926], ["项目", 0.009182121417048519]], "title": "基于Docker构建.NET持续集成环境"}, "2418566449": {"descs": "通常来讲，不同的数据库都在数据库层面上实现了主从复制，各自的实现细节上可能会存在差异，譬如SQLServer中可以通过“发布订阅”来配置主从复制的策略，而Oracle中可以通过DataGurd来实现主从复制，甚至你可以直接把主库Dump出来再导入到从库;public static void SwitchToSlave(DbCommand command, string serverName = \"\");public static void SwitchToMaster(DbCommand command, string serverName = \"\");至此，我们就实现了基于EF的数据库主从复制、读写分离;因为通过DbCommandInterceptor我们能拦截到SQL命令，所以，只要是Select命令全部走从库，Insert/Update/Delete全部走主库，这样就实现了读写分离", "tags": [["数据库", 0.027413535327388862], ["中", 0.020985387089467112], ["库", 0.01832231850123226], ["主从复制", 0.016144558802594574], ["command", 0.013546879603082167]], "title": "基于EF的数据库主从复制、读写分离实现"}, "3568552646": {"descs": "我们现在按F5进行调试，和编译时一样，如果用户没有为当前项目配置“任务调试程序”，VSCode会提示我们去创建一个配置文件launch.json，我们这里选择mono，该选项在安装Mono-Debug插件以前是没有的，该配置文件如下，我们注意到这里需要修改program属性为MainClass.exe:;现在，我们应该会得到一个MainClass.exe的文件，最初博主尝试直接去配置launch.json，发现直接填写type为mono在VSCode中是无法识别的，最后决定去安装mono-debug的插件，安装插件在VSCode中是非常简单的，按下Ctrl+Shift+X打开插件界面，可以在这里查看最流行的插件列表、官方推荐的插件列表等等，我们直接搜索mono-debug然后安装插件即可;因为博主的计算机上安装了Mono，所以在一开始使用VSCode的时候，就先入为主地认为在不安装插件的情况下，应该就可以直接在VSCode中编译和调试代码了;好了，下面我们直接按下Ctrl+Shift+B来编译代码，此时VSCode将提示我们“配置任务运行程序”，这里需要说明的是，在VSCode中你可以感受到微软对命令行和配置文件的偏执，这让适应了Visual Studio这样功能强大的我们相当不习惯，按照VSCode的提示或者是通过Ctrl+Shift+P打开命令面板，VSCode将在当前工作目录下为我们创建.vscode目录和tasks.json文件，在VSCode中任何和项目相关的配置信息都会存储在这里啦;Mono提供的C#编译器可以将C#代码编译为.exe或者是.dll，可是在VSCode中好像默认都是编译为.exe，所以如果有知道如何在这里配置编译输出项的朋友，希望可以告诉我怎么去实现", "tags": [["mono", 0.027130375085838813], ["vscode", 0.026224950993348664], ["中", 0.014850663444190405], ["插件", 0.013398118848032759], ["会", 0.01175187669291949]], "title": "基于Mono和VSCode打造轻量级跨平台IDE"}, "835719605": {"descs": "回想起这个面试中“邂逅”的问题，针对对这块内容，其实当时并没有和面试官进行太深的交流，提到了分布式配置、配置中心以及像缓存的雪崩、击穿等等常见的问题，我隐约记得配置文件`appsettings.json`配置的部分有热更新的配置项，但我并没有对选项模式(**Options**)里的三剑客做过深入的挖掘，所以，这篇博客，一方面是系统地了解了一下选项模式(**Options**)的使用，而另一方面是由配置热更新这个话题引申出来的一系列细节，在没有理解`IChangeToken`的时候，实现一个自定义的配置源是有一点困难的，在这篇博客的最后，我们基于Redis的发布-订阅实现了一个简单的配置中心，不得不说，Redis里用`:`来分割Key的方式，实在是太棒了，因为它可以完美地和 .NET Core 里的配置系统整合起来，这一点只能用赏心悦目来形容，好了，国庆节以后的第一篇博客就是这样了，谢谢大家;实际上，.NET Core 可以从配置文件、环境变量、Azure Key Vault、Azure 应用程序配置、命令行参数、已安装或已创建的自定义提供程序、目录文件、内存中的 .NET 对象等各种各样的来源中加载配置，这里的`appsettings.json`使用的是`JsonConfigurationProvider`类，位于`Microsoft.Extensions.Configuration.Json`这个命名空间，可以注意到，它继承自`FileConfigurationProvider`类，并重写了`Load()`方法，通过这些关系，我们最终可以找到这样一段代码：;在 .NET Core 中，选项模式(**Options**)使用类来对一组配置信息进行强类型访问，因为按照`接口分隔原则(ISP)`和`关注点分离`这两个工程原则，应用的不同部件的配置应该是各自独立的，这意味着每一个用于访问配置信息的类，应该是只依赖它所需要的配置信息的;从 .NET Framework 一路走来，对于 Web.Config 以及 App.Config 这两个配置文件，我们应该是非常熟悉了，通常情况下， IIS 会检测这两个配置文件的变化，并自动完成配置的加载，可以说它天然支持热更新，可当我们的视野伸向分布式环境的时候，这种配置方式就变得繁琐起来，因为你需要修改一个又一个配置文件，更不用说这些配置文件可能都是放在容器内部;总而言之，我们希望应用可以随时感知配置的变化，所以，在今天这篇博客里，我们来一起聊聊 .NET Core 中配置热更新相关的话题，这里特指全新的选项模式(**Options**)", "tags": [["配置", 0.024277196413778138], ["实现", 0.010667889471661135], ["使用", 0.008789010867714095], ["string", 0.008552830139835705], ["options", 0.008471103656596946]], "title": "基于选项模式实现.NET Core的配置热更新"}, "2822230423": {"descs": "本文使用Python实现了Windows下切换壁纸的功能，通过requests模块从网络上抓取图片，通过PIL模块实现JPEG格式到BMP格式的转换，通过win32api和win32gui模块实现壁纸设置，并通过修改注册表的方式，将这一功能整合到系统菜单中，可以非常便捷地更换桌面壁纸;Python脚本会通过pyinstaller模块打包成可执行文件，我们通过修改注册表的方式，在右键菜单内加入切换壁纸的选项，这样我们可以直接通过右键菜单实现壁纸切换功能;如你所见，在这篇文章里，我们将通过Python和Windows注册表实现壁纸切换功能，主要涉及到的Python中的requests、pyinstaller这两个模块的使用，希望大家喜欢;好了，现在我们考虑如何来实现这个功能，我们的思路是从[Unsplash](https://unsplash.com/)这个网站抓取图片，并将其存储在指定路径，然后通过Windows API完成壁纸的设置;接下来我们需要通过pyinstaller模块将脚本打包成可执行文件，实际上这个步骤完全可以省略，因为现在我们通过命令行就可以实现壁纸切换，为什么要做这样额外的工作呢", "tags": [["壁纸", 0.013152815479597634], ["图片", 0.012623122677868978], ["模块", 0.011578752645642176], ["https", 0.009660605896628352], ["实现", 0.009103977276876224]], "title": "基于Python实现Windows下壁纸切换功能"}, "2805694118": {"descs": "今天这篇文章会基于 Python 对微信好友进行数据分析，这里选择的维度主要有：性别、头像、签名、位置，主要采用图表和词云两种形式来呈现结果，其中，对文本类信息会采用词频分析和情感分析两种方法;这里我们会在当前目录新建一个HeadImages目录，用以存储所有好友的头像，然后我们这里会用到一个名为FaceApi类，这个类由腾讯优图的SDK封装而来，这里分别调用了[人脸检测](http://youtu.qq.com/#/develop/api-face-analysis-detect)和[图像标签识别](http://youtu.qq.com/#/develop/api-image-tag)两个API接口，前者会统计\"使用人脸头像\"和\"不使用人脸头像\"的好友各自的数目，后者会累加每个头像中提取出来的标签;plt.title(u'%s的微信好友签名信息情感分析' % friends[0]['NickName']);分析好友性别，我们首先要获得所有好友的性别信息，这里我们将每一个好友信息的Sex字段提取出来，然后分别统计出Male、Female和Unkonw的数目，我们将这三个数值组装到一个列表中，即可使用matplotlib模块绘制出饼图来，其代码实现如下：;plt.title(u'%s的微信好友使用人脸头像情况' % friends[0]['NickName'])", "tags": [["中", 0.014509914273123072], ["使用", 0.009987869182503242], ["人", 0.00992259268473839], ["微信", 0.009414278081074071], ["好友", 0.008934115101617048]], "title": "基于Python实现的微信好友数据分析"}, "3175881014": {"descs": "所谓**万变不离其宗\"**，下面我们以.NET为例来快速集成Server-Sent Events，这里需要说明的是，博主下面的例子采用ASP.NET Core 2.0版本编写，首先，我们建一个名为SSEController的控制器，在默认的Index()方法中，按照SSE规范，我们首先组织HTTP响应头，然后发送了一个名为SSE_Start的自定义事件，接下来，我们每隔10秒钟给客户端发送一条消息，请原谅我如此敷衍的Sleep()：;对于SSE而言，它是一个单工通道，客户端不能主动向服务端发送信息，所以，一旦建立了SSE通道，客户端唯一需要关注的地方就是**onmessage**这个回调函数，因为客户端只需要负责处理消息即可，甚至我们可以连**onerror**都不用关注，因为SSE自带断线重连机制，当然你可以选择在发生错误的时候关掉连接，此时你需要**close()**方法;可以看到，完全按照SSE规范来定义的，这里每次生成一个新的GUID来作为消息的ID，客户端断线后重连的间隔为30秒，默认发送的是**\"消息\"**，当指定eventName参数时，它就表示一个自定义事件，这里我们使用JSON格式来传递信息;**event**字段表示自定义事件，默认为message，在浏览器中我们可以用**addEventListener()**来监听响应的事件，这正是为什么SSE被称为服务器推送事件，因为我们在这里既可以发送消息，同样可以发送事件;正如本文一开始所写，博主使用SSE是因为业务上的需要，在经历了轮询带来的性能问题以后，博主需要一款类似WebSocket的东西，来实现服务端主动向客户端推送消息，究其原因，是因为浏览器永远都不知道，App到底什么时候会扫描二维码，所以，从一开始我们试图让网页去轮询的做法，本身就是不太合理的", "tags": [["sse", 0.02338716992812062], ["客户端", 0.014701788745408926], ["http", 0.011585764170188388], ["事件", 0.01007445064447164], ["中", 0.009718910082244039]], "title": "基于Server-Sent Events实现服务端消息推送"}, "1113828794": {"descs": "我的想法是以 [Github](https://github.com/qinyuanpei/qinyuanpei.github.io) 作为代码的主仓库，其上面的 **blog** 分支存放博客的源代码， **master** 分支存放博客的静态页面，在此基础上，我们同时推送静态页面到 Github 和 Coding 的代码仓库，这样就可以实现两个平台的同步部署，这里的部署自然是指由 Travis 完成的自动化部署;其原理是Github为 [Travis CI](https://www.travis-ci.org/) 分配一个token，当我们向 Github 推送新的代码以后，Travis 就会从代码仓库中拉取代码，并通过 [npm](https://www.npmjs.com/) 安装依赖生成静态页面，我们将这些静态页面推送到 master 分支，即可完成对Hexo的部署操作;各位朋友，大家好，我是Payne，欢迎大家关注我的博客，我的博客地址是 [https://qinyuanpei.github.io](https://qinyuanpei.github.io) .在曾经的一篇博客：[《持续集成在Hexo自动化部署上的实践》](https://qinyuanpei.github.io/posts/3521618732/)中，我为大家分享了在线持续集成服务  [Travis CI](https://www.travis-ci.org/) 的相关内容，在这篇文章中我们通过  [Travis CI](https://www.travis-ci.org/) 为 Hexo 提供了自动部署的支持;我们知道 [Github Pages](https://pages.github.com/) 是 Github 提供的静态页面托管服务，其初衷是为个人项目或者组织项目创建演示或者文档站点，而 [Coding Pages](https://coding.net/pages/) 则是国内的代码托管平台 [Coding](https://coding.net/git) 提供的类似服务，国内类似的代码托管平台还有[码云](https://gitee.com/login)、[Gitlab](https://about.gitlab.com/) 等;第二种思路是使用 Hexo 提供的 deploy 插件，例如 [hexo-deploy-git](https://github.com/hexojs/hexo-deployer-git) 这个插件支持通过 git 部署，而 Coding 和 Github 都支持 Git 相关的协议，所以可以考虑使用这个插件来完成这个操作，目前网络上可以检索到的资料，都是使用这个插件来完成同步部署", "tags": [["travis", 0.02181822608491178], ["https", 0.02103865156136644], ["coding", 0.02084799019226492], ["git", 0.016669483924631894], ["github", 0.016236014010114753]], "title": "基于Travis CI实现 Hexo 在 Github 和 Coding 的同步部署"}, "3269605707": {"descs": "OK，现在我们来一起看看最终的效果，如你所见，在视频播放过程中，我们可以通过视频下方的输入框发送弹幕，弹幕会首先经由Redis缓存起来，当到达一定的时间间隔以后，我们就会将消息推送到客户端，这样所有的客户端都会看到这条弹幕，而对于客户端来说，它在和服务端建立WebSocket连接以后，唯一要做的事情就是在onmessage回调中取得弹幕数据，并将其追加到弹幕数组中，关于弹幕绘制的细节，我们在本文的第三节已经做了相关说明，在此不再赘述;当客户端接收到服务端推送的消息后，我们通过Canvas API完成对弹幕的绘制，这样就可以实现一个基本的弹幕系统啦;当WebSocket完成握手以后，我们定时从消息队列中取出弹幕，并推送到所有客户端;好了，下面我们来简单说明下这个Demo整体的设计思路，即我们通过Redis来“模拟”一个简单的消息队列，客户端发送的弹幕会被推送到消息队列中;OK，在编写“消息推送”中间件的时候，我们会注意到，我们使用了一个名为SimpleMessageQueue的类来取得消息，而服务端会负责将该消息群发到所有的客户端", "tags": [["弹幕", 0.021118039206291506], ["中", 0.02075545243186333], ["消息", 0.013216866978272866], ["redis", 0.01201368124796801], ["websocket", 0.009082500695667238]], "title": "基于WebSocket和Redis实现Bilibili弹幕效果"}, "1386017461": {"descs": "在这里我们主要将男嘉宾/女嘉宾分别筛选出来，然后将分词结果用逗号串联起来，这样即可得到male_tags和female_tags，我们会将其传递给WordCloud模块，可以注意到我们为男性/女性词云分别设置了不同的背景图片，最终会生成两张不同的图片，这里主要参考了[Image-colored](https://amueller.github.io/word_cloud/auto_examples/colored.html)这个示例，代码片段展示如下：;接下来，我们有了针对男、女择偶要求期望的Wish字段，可这些信息对我们而言，依然显得繁重而冗余，所以接下来我们考虑对Wish字段进行分词，最初的设想是通过词性和语法来分析，可当我分完词以后我就不得不佩服中文的博大精深，这里我选择了两个中文处理相关的库，即[结巴分词](https://github.com/fxsjy/jieba)和[SnowNLP](https://github.com/fxsjy/jieba)，它们都是开源项目并且有大量的文档作为参考，这里想说的是，SnowNLP中支持中文文本的情感分析，这是我最初想要使用这个库的一个重要原因，因为我想从这些微博中找出评价一个人的形容词或者名词，而这些词的情感分析，可以作为我们是否将其作为一个评价指标的重要依据;解决登录的问题以后，回到这个问题本身，我们需要抓取[@西安月老牵线](https://weibo.com/u/5566882921)发布的所有微博，移动版对微博做了分页处理，所以我们只需要知道总共有多少页，然后循环去提取每一页里的信息即可，因为我们注意到每一页的地址都符合[https://weibo.cn/u/3232168977;可以注意到，这里我们使用结巴分词获得了每个词的词性，不过到我写这篇文章的时候，对于词性的处理我依然没有什么好的想法，这里仅将其作为结果以JSON的形式存储到数据库中，现在我们基本上完成了所有数据处理的流程，在这个过程中会有些特殊的中文字符，我们采取暴力替换的方式进行去除即可，对此不在这里展开说啦;所以，我写这篇文章，通过Python抓取新浪微博数据并对其进行分析，并不是想告诉你，你因为不具备哪些因素而不被人喜欢，而是想告诉你，我们每一个人都是这个世界上独一无二的存在，我们的优点同我们的缺点组合起来，这才是完整的我们", "tags": [["会", 0.012332340804414636], ["中", 0.00753980019345497], ["喜欢", 0.007078597929546018], ["人", 0.0069257154440069005], ["https", 0.00654753558754182]], "title": "基于新浪微博的男女性择偶观数据分析(上)"}, "3083474169": {"descs": "在数据分析这部分，我们对特征、年龄、性别、身高、地区和星座等进行了分析，并借助Python中的图表模块完成了数据的可视化工作;我们通过词云对微博进行可视化分析，更多是针对词频的一种分析方法，这种方法虽然可以帮助我们找出关键字，可是因为最初写作这篇文章时，对数据分析领域相关知识知之甚少，而且在分析的过程中没有考虑停用词，所以我认为在文本分类或者是主题提取层面上，我们都需要一种更好的方法;按照传统主题提取模型，文本分类问题被拆分为**特征工程**和**分类器**两个部分，其中，**特征工程的作用是将文本转化为计算机可以理解的格式，并提供强特征表达能力，即特征信息可以用以分类，而分类器基本上是统计学相关的内容，其作用是根据特征对数据进行分类**;[男女性择偶观数据分析:女性身高分布](https://ww1.sinaimg.cn/large/4c36074fly1fz05o1va6mj20hs0dc3yt.jpg);[男女性择偶观数据分析:男性身高分布](https://ww1.sinaimg.cn/large/4c36074fly1fzixyyw9tyj20hs0dct90.jpg)", "tags": [["中", 0.011940304265768531], ["会", 0.010683264099003022], ["分类", 0.008078078854246483], ["特征", 0.007879566839857098], ["文本", 0.007215881891484588]], "title": "基于新浪微博的男女性择偶观数据分析(下)"}, "3873710624": {"descs": "在这个例子中，bookstore节点由两个book节点组成，而每个book节点则由title、author、year和price四个节点组成，显然这些节点描述的是一种结构化的数据，而这些数据同时附加了相关描述性的信息，例如book节点有category信息，title节点有lang信息;显然，一个实体结构中将包含若干个不同的属性，所以在对一个实体结构进行验证的时候，会通过反射遍历每一个属性上的ValidationAttribute并调用其Validate()方法，所以最终返回给调用者的应该是由一组ValidationResult组成的集合，为此我们设计了ValidationResultCollection这个类，该类实现了ICollection接口，在此基础上我们增加了一个Success属性，当集合中所有ValidationResult的Success属性为true时，该属性为true反之为false;所有校验相关的Attribute都派生自ValidationAttribute这个父类，其核心方法是Validate()方法，该方法被声明为一个虚方法，因此所有的子类都必须对这个方法进行重写，它将返回一个叫做ValidationResult的结构，这是一个非常简单的数据结构，它仅仅包含Success和Message两个属性，前者表示当前校验是否成功，后者表示验证失败时的错误信息;所以，这种在语言层面上进行描述而与实际抽象出的对象无关的概念就称为\"特性”，人们认知和描述一个事物的方式会有所不同，所以在XML中会有这样一个历史遗留问题，我们应该使用Element还是Attribute，而产生这个问题的根源在于我们认识这个世界，是通过语言描述还是通过概念抽象;接下来，我们针对.NET中的Attribute的表象和具象进行了讨论，Attribute从表象上看是和Java中的注解类似，可以像使用标签一样附加在类、方法、属性或者字段等元素上，而从具象上看Attribute提供了一种在运行时期间通过元数据访问附加信息的能力，Attribute是附加在类、方法、属性或者字段等元素上的一个类，需要继承自Attribute，它的实例化必须依赖这些附加对象的实例化，并且Attribute在运行时期间是Readonly的，Attribute通常需要配合反射来使用", "tags": [["中", 0.02105781453683065], ["attribute", 0.021041348787522066], ["上", 0.013353653191982034], ["会", 0.011830965021646685], ["验证", 0.010543402335305251]], "title": "基于特性(Attribute)的实体属性验证方案设计"}, "570888918": {"descs": "垠神这篇文章其实在说一个问题，Checked Exception鼓励开发者主动告知调用者来捕获特定异常，这种思路完全是没有问题的，问题是调用者如何能够知道它需要捕获哪些异常，我们不可能每次都通过\"转到定义”功能去看一个方法会引发哪些异常，垠神从PL的角度出发，想到了通过代码静态分析的方法来处理异常，垠神吐槽的其实是不分青红皂白滥用try-catch的做法，实际上Java标准库里对异常处理相当混乱，虽然官方鼓励使用Checked Exception，但是标准库实现和工程实践上不乏将异常包装为RuntimeException来规避Check的做法，我认为Checked Exception在工程学意义上最大贡献是，在开发阶段该抛出什么异常就应该抛出异常，因为这样可以方便我们快读定位问题，而到了发布阶段则应该将这些异常都catch住即可，这样用户就不会看到这些奇葩的异常;我们可以注意到Java强制让Foo()方法实现了throws声明，原因是在该方法内部可能会引发FileNotFoundException，如果我们不遵从这一\"霸王条款\"，那么我们的代码将无法通过编译，而在调用者层面上，Java的霸道则体现在要求调用者使用try-catch结构处理这种异常，或者继续使用throws声明来使异常继续向上传递，我更喜欢将这种设计称之为一种理想状态下的异常处理机制，比如我们读写一个文件的时候，除了FileNotFoundException以外，可能还会遇到FileLoadException、PathTooLongException、EndOfStreamException等等的异常，如果这些异常在业务层面上是无差别的，那么我认为将异常细分到如此精细的程度是没有意义的，因为对用户而言这个时候它关心的是否成功读写了这个文件，具体的异常原因用户并不想真的知道，可是Java的Checked Exception在面对这种处境的时候，整体而言是显得力不从心的，因为我们不得不在方法从声明该方法会引出哪些异常，这对方法的编写者和方法的调用者来说都很痛苦;可以注意到C#采用的是一种相对温和的策略，即文档会明确告诉你，某个方法是否会引发异常以及引发哪些异常，但是是否要捕获这些异常则完全由调用者决定，我认为这是C#之父Hejlsberg在权衡后在工程实践上选择的一种妥协，因为Java的Checked Exception理想主义色彩稍重，并不是在所有场景下我们都需要去处理所有的异常，所以Checked Exception带来的问题是，即使在只需要捕获基类异常的情况下，我们依然不得不去捕获各种子类异常，这难道不有点矫枉过正的感觉吗;在上一个项目中，我对于异常处理其实实践得并不好，因为我一直不知道哪里是捕获异常的入口，我个人并不认同直接捕获到异常直接throw这种做法，因为你在自定义异常的时候就应该想清楚，哪些异常是需要捕获并处理的，哪些异常时可以直接让它Crash的，如果每个人都仅仅是抛出异常而不去拦截异常，那么异常机制设计得再好又有什么用呢，关于Java的异常有一个梗，是说Java的异常给出了详细的堆栈信息，可就是不直接告诉你到底是哪里异常了，事实证明我设计的这个方案运行的很好，其实我很想吐槽操作日志真的有存在的必要吗;事实上这两者在程序的表达能力上等价的，它们都可以向调用者传达\"异常发生“这个事件，譬如我们在集合中查找一个元素，如果元素不存在则返回-1，这其实就是一个使用错误码来表示\"错误“的经典案例，显然这种从C/C++时代遗留下来的传统解释了Win32 API为什么会选择这样的设计方式，换言之，选择哪种方式，本质上是一种从API风格、代码风格和性能指标等方面综合考虑后的结果，错误码这种方式的缺陷主要在于，错误码不能明确地告诉调用者到底发生了什么错误，除非我们定义更多的错误代码，而且在没有引入可空类型以前，我们没有办法避免错误码污染返回值的值域，比如在这个例子，如果集合中恰好有一个元素-1，那么通过-1这个返回值我们是没有办法判断出，这个-1到底是不是因为方法内部发生了错误而返回-1.", "tags": [["中", 0.018453226004329963], ["代码", 0.01801848522497726], ["exception", 0.012647888219683753], ["会", 0.012618591065437728], ["处理", 0.012613107679011127]], "title": "基于过滤器实现异常处理的探索"}, "380519286": {"descs": "在这里，上传我使用了ASP.NET Core中的IFormFile接口，并且在Postman测试通过，可是在网页上用type为file的input标签进行测试时，发现页面一直无法正常响应，不知道具体是什么原因(**后来发现它完全和Postman中的请求体一样，好吧😬**)，我一直不太理解ajax上传和表单上传的区别，曾经项目上用HttpWebRequest去做文件的上传，里面需要大量的字符串拼接动作去构造MulitpartFormData，只要后端上传的API发生变更，这段代码几乎就会变成不可维护的代码，幸运的是，在经过几次迭代以后，他们终于意识到了这个问题，在我的建议下，他们使用HttpClient重构了代码;大家会注意到，在我的示例代码中，有一个东西一直没有去说，这就是OAuth2Filter，这其实是博主自己扩展的一个特性，这意味着在请求该API前，需要通过OAuth2授权以获得身份令牌;简单来说，所有你想要调用Web API都是接口中的一个方法，你通过注解来告诉Retrofit，该方法会请求哪一个Web API，参数会以什么样的形式传递过去，结果会以什么样的形式返回回来，你完全不必去写那些底层HTTP通信相关的东西，因为Retrofit会帮你在运行时实现这个接口;接下来，我们继承ApiActionFilterAttribute来编写OAuth2FilterAttribute，显然，它会在请求前调用IAuthApiCaller接口实例，这里我们将client_id和client_secret硬编码到代码里，单单是为了演示如何去印证这个想法，实际项目中大家可以考虑通过配置或者是传参来实现：;我了解到的一点信息是，Spring Cloud中的Feign，一个和Retrofit极其相似的HTTP客户端，其本身并没有实现文件上传的功能，需要借助插件来实现相关功能，所以，这是否说明HTTP协议中的上传实现本身就是一个错误，因为它和form-data搅和在一起，试图用键值对的形式去描述一个文件，我们的业务中需要给文件增加备注关联相关信息，坦白讲，这种数据结构令人非常痛苦，所以，上传这块会有三个不同的版本，我一直希望上传可以和具体的业务解耦，即使需要给文件增加备注或者是关联相关信息，应该交给新的Service去做这件事情啊，这简直教人头疼啊", "tags": [["接口", 0.0160863682812305], ["中", 0.01166796726272854], ["客户端", 0.01097852902748071], ["去", 0.010390678612202333], ["webapiclient", 0.010006988284763782]], "title": "声明式RESTful客户端WebApiClient在项目中的应用"}, "187480982": {"descs": "async void方法引发异常时，因为它没有Task对象来放置异常，因此它的异常SynchronizationContext上引发，而且因为[AsyncVoidMethodBuilder](http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.asyncvoidmethodbuilder.aspx)内部并没有使用TaskScheduler，因此对于async void方法来说，线程池中未捕获的异常将会一直向上抛并最终导致程序异常终止，虽然我们可以在AppDomain.UnhandledException这个事件中捕捉到这些\"未处理的异常\"，但这并不能阻止程序异常终止，通过我们可以通过注册这个事件来记录异常日志，以帮助我们快速定位问题;好了，现在我们回到这篇文章开始的问题，我们现在知道async Task和async Task<T>引发的异常，都不会是程序立即终止，除非我们显式地去await一个Task对象会引发异常，可是对async void来讲，一旦它引发异常，常规的try-catch时无法捕捉到异常的，这种\"未处理的异常\"会一直向上抛并最终导致程序异常终止;我们注意到这里声明了两个Action，即两个没有返回值的委托类型，它们的不同点在于前者使用了async/await这两个关键字，而后者则是一个普通的同步方法，那么这两者生成的IL代码是否有区别呢;在这里我更感兴趣的一个问题是，.NET框架中的委托、匿名方法、Lambda表达式和Task是不同时期.NET的产物，那么我们在这里使用一个async关键字来修饰一个匿名方法，编译器在处理它的时候到底会怎么做呢;第二，同匿名方法和扩展方法一样，async/await并未引入新的IL指令，async/await内部应该是在维护一个状态机，这一点和yield关键字应该是相似的，并且对于异步的匿名方法(指voild类型)，通过IL代码可知它是由[AsyncVoidMethodBuilder](http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.asyncvoidmethodbuilder.aspx)类来生成的，而对于异步的方法(指Task和Task<T>类型)，则是由[AsyncTaskMethodBuilder](http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.asynctaskmethodbuilder.aspx)类来生成，需要说明的是这两者在功能上相差无几，唯一的区别就在于异常处理", "tags": [["中", 0.020406460977813103], ["问题", 0.01754173422193743], ["上", 0.01696677089445844], ["会", 0.014360912734154792], ["async", 0.014306366525123144]], "title": "异步Lambda表达式问题的探索"}, "906436376": {"descs": "尽管我们可以使用Xml、Json、ini、数据库等存储形式来存储这些数据，可是毫无疑问的是，Excel是Window平台上最好的数据处理软件，因此数值策划更倾向于使用Excel来设计游戏中的数据，面对如此重要的数值策划工作，我们自然希望在解析Excel文件时不会出现错误，可是我们总不能指望着策划把Excel数据转换成我们能处理的数据类型吧，因此就有了博主今天的这篇文章，所以在今天的文章中我们主要的内容就是如何通过程序来解析Excel文件;既然今天的主题是Unity3D游戏开发，所以无论我们在前面提出了什么样的解决方案，最后我们都要落实到游戏开发上，所以最后和大家分享的是一个Unity3D配合ExcelReader实现Excel解析的简单案例;因为平时经常与技术圈子里的朋友聊天，所以在博主印象里Excel的解析在游戏开发中还是较为常见的，而且博主知道对于微软的Office办公软件是可以通过VBA编程来实现某些功能的，可是因为博主一直在用国产的WPS，所以对于Excel的解析基本上是停留在一个概念性的认识上，可是朋友的忙不能不帮不是，所以博主决定借着这个机会好好研究下Excel文件的解析;尤其像Unity3D这样的跨平台解决方案下，选择一个跨平台的类库或者组件能够保证我们的游戏在各种平台下稳定地运行，所以ExcelRead是博主向大家推荐的一个跨平台的Excel解析方案;第二种解决方案得益于OpenOffice标准,OpenOffice标准可以让我们使用一种标准来解析和处理Excel文件而无需关注Excel文件是来自微软的Misrosoft Office、金山的WPS还是其它的办公软件", "tags": [["excel", 0.024055170143449454], ["数据", 0.01828432897636779], ["游戏", 0.01759170247443961], ["使用", 0.014316337563750989], ["博主", 0.01410541850301779]], "title": "当Unity3D游戏开发遇上Excel"}, "1085014581": {"descs": "可后来我发现我错了，只要有人的地方就会存在政治，无论是公司还是社区，每天都有人宣扬这样或者那样的“文化”，这个时候，我希望我们每一个人都去用心甄别这些概念，因为作为人的自觉，他只会说对自己有利的话，正如择偶标准是最毫无标准可言的标准一样，王垠说编程世界里充满宗派，就是最好的证明;，该有的一切都有，唯独没有对错，希望一个组织有一致的步伐、一致的声音，可偏偏人是一根会思考的芦苇，我知道，当一个人在某一种身份下，他必须要去推动一种文化形成，可如果这些声音连他自己都不信，这种文化的底蕴应该不会特别丰富，很容易成为政治博弈的牺牲品;如果思维存在奇点，将会坍陷于何处，苏格拉有没有底不重要，马老师们谁说得对同样不重要，甚至你看我这满纸荒唐言依然不重要，它仅仅表明我此时此刻在思考，我是一个活生生的人，所谓“我思故我在”，无非给枯燥的人生多一点无用的点缀罢了，你说朱一旦都不枯燥了，我们却还停留在这里，你说，还有比这个更枯燥的事情吗;有人说，一个人开始成熟，就是从学习这几千年来的厚黑学、阴谋论开始，的确啊，连封神都开始变成一场阴谋，不同的是，这次的因果都落在原始天尊身上，每一个人都渴望像姜子牙一样，断天梯、破枷锁，似乎一定要执著于什么东西，这样的人生会显得更真实一点;所以，在“救一个人还是救苍生”这个问题上，其实谁都没有错，我特别喜欢李诞在『奇葩说』中表达的一个观点，**“以自私却不伤害别人的方式活着，才能维持世界的运转", "tags": [["人", 0.015214641188949801], ["会", 0.012533024749213402], ["去", 0.010641733288033847], ["没有", 0.010488521800001836], ["说", 0.010249672935358042]], "title": "当姜子牙遇见朱一旦"}, "3321992673": {"descs": "我一直觉得这样的想法会成为我一生都去奋斗的信仰，可是当我回顾四周的时候看到有的人早已找到工作，我真的不明白，到底是我想要的太多不肯放下身段去做些没有技术含量的工作，还是这个世界的价值存在某种扭曲：一个人要花费四年的时光去做些一辈子里只能做一次的事情，可是当付出了那么多以后突然发现生命里早已有了定数，你想要试图改变的可能仅仅因为环境科学这四个字就变成空想，你最终踏上的注定是和大部分一样平凡的生命;第一次推开一家公司的门，我以为只要我的技术达到了应聘的要求我就可以胜任这份工作，可是我错了，环境科学这个专业会牢牢地拴住我一辈子;如果说以前想去外面是因为觉得外面的工作找起来容易的话，那么此时此刻当我在宿舍里写下这篇文章的时候，这无疑是一种赤裸裸的讽刺了，因此我发现我在银川都找不到合适的工作;我去那家公司应聘的时候，公司里有个人建议我到外面去报个培训班，因为他觉得我在大学里学的和企业需求完全是两回事，可是我作为一个应届毕业生，我原本就是希望到公司里去学习实际的项目经验的，你为什么就要要求我有两到三年的经验呢，我想就算是研究生都不可能天天待在公司里慢慢积累经验吧;我没有抱怨的意思，我只是想让自己快些找到合适的工作，我实在不想继续在这样纠结下去了，希望明天到招聘会上会有所收获吧", "tags": [["工作", 0.02028259845837647], ["去", 0.017851913706472336], ["会", 0.013862783780790339], ["想要", 0.012707036775613313], ["想", 0.010896282287033446]], "title": "当梦想照进现实"}, "4205536912": {"descs": "普通人认为“黑客”就是入侵计算机的“计算机罪犯”，其实“黑客”的本意是指出于兴趣而解决某个难题，不管它有没有用的这类人(出自自由软件基金会创始人理查德·斯托尔曼)，所以黑客从一开始就是有精神追求的，它代表着求解问题过程中产生的精神愉悦或享受，黑客们只是比我们普通人更崇尚分享、开放和民主，他们对任何被禁止的东西都怀有特别强烈的好奇心，他们喜欢去思考那些似乎不应该被思考的问题，他们相信计算机会深刻地改变人们的生活，由此我们可以认识到“黑客伦理”的一个推论：黑客不服从管教，具有叛逆精神;图灵在这个世界上尚未出现计算机的时候，就能够想到有一天机器会比人更聪明，可我们普通人居然狂妄而无知地认为，所有的一切在工程师眼中都是非常简单的事情，工程师们懂得敬畏自然、敬畏真理，可普通人反而不愿意去理解这些原理和事实，更讽刺的事情是，一个软件工程的话语权是掌握在这样的人手中;我们从来不畏惧去挑战艰难的任务，仅仅是因为在这个世界上，有值得我们永远去敬畏和尊重的东西，那就是真理，那是像伽利略、布鲁诺、图灵等等对人类进步做出卓越贡献的人们，愿意用生命去捍卫的东西，现代计算机的理论基础是数学，所以你必须承认计算机是一门科学，其次它是一门艺术;我并非果粉，甚至在某种意义上我一直是软粉，可这并不妨碍我对科技和美的一种热爱，技术本身并不能在商业化策略中起到决定性作用，可是一个优秀的产品一定是将技术和艺术完美地融合在一起，所谓“一张一弛，文武之道”，从这个意义上来说，黑客和画家志同道合，理性与感性相辅相成，即使我们不能这个世界改变什么呢;本书作者是美国互联网界举足轻重、有“创业教父”之称的哈佛大学计算机博士保罗·格雷厄姆 (Paul Graham )，而这本书是由他的思考整理而成的一本文集，虽然这本书的名字叫做《黑客与画家》，可实际上作者在这本书中观点，并非局限于黑客与画家本身，相反地它涉及编程、软件、创业、财富、设计、研究等等多个领域", "tags": [["计算机", 0.018872004255118813], ["黑客", 0.018063951592062047], ["去", 0.010685049258416327], ["时代", 0.01046570189366476], ["人类", 0.009984581244999537]], "title": "当黑客遇见画家"}, "1933583281": {"descs": "我们说，这是一部乌托邦式的电影，因为现实中像李红兵这样的人，绝对不会陡然间良心发现，把饭店归还王大卫，甚至王大卫拉开窗帘阳光照射进来，阳光下苏茉莉牵着女儿的手对他微笑，大卫的蛋炒饭得到溥仪认可，入选国际非遗名录;[大卫做蛋炒饭](https://ww1.sinaimg.cn/large/4c36074fly1fziy5c2n8jj21960u0kjl.jpg);可我还是想说，无条件的善良是懦弱，我们选择善良，是因为我们不想伤害别人，可在今天这样一个时代，善良常常被当做是懦弱的表现，一个人努力让心变狠变硬，或许会达到通常意义上的成功，可成功的定义从来都是被人绑架着的，电影中“好兄弟”登上了“胡弄排行榜”，我不知道这是不是导演的一种讽刺，一个人靠着骗取好兄弟的产业而发家，即使收获了声名和利益，当他一个人在高速公路上疾驶，打算远走他乡的时候，内心是不是会有一点羞愧和遗憾呢;[你饿不饿，我做蛋炒饭给你吃呀](https://ww1.sinaimg.cn/large/4c36074fly1fzix8wx3obj21hc0u041m.jpg);电影中反复出现的台词，来自大卫父亲的那句：做蛋炒饭要慢要慢，一如《阿甘正传》里的经典台词：人生就像一盒巧克力，你永远不知道下一块会是哪种", "tags": [["电影", 0.015989128889370877], ["蛋炒饭", 0.014498962830789568], ["茉莉", 0.011879230322499008], ["人", 0.011537259792205637], ["阿甘", 0.010372710244656337]], "title": "愿你和我一样喜欢蛋炒饭"}, "2314414875": {"descs": "虽然前期在微博上经常看到韩寒在为这部电影做宣传，但我一直想知道它会一种什么样的方式来讲述这个故事，我隐隐约约觉得徐太浪(邓超饰)、徐正太(彭于晏饰)、小花(赵丽颖饰)三个人之间的关系非同寻常，我甚至臆想这是一部俗套的三角恋的故事;顶风作案的罗力，承诺要给松子一方天地，然而等他从狱中出来，见到的却是坐在黄志强车上神色复杂的那个人，你说这个世界是会变的，可它会变成什么样我们永远无从得知，小马希望的是那个拨号上网频频掉线的时代诞生一款OICQ的软件，徐正太希望的是像杜月笙那样收“物业费”......我们期望着什么，我们等待着什么，其实都不重要，世界一直都在变化，而我们如浮萍，或随风漂泊，或乘风破浪，一切都在我们的选择;整个故事其实是一个解惑的过程，所有的线索都是为了让徐太浪明白，自己的父亲为什么会变成这个样子，而围绕这些线索，整理的冲突发生在以徐正太、六一、阿浪、小马为代表的“正太帮”和黄志强、罗力为代表的“黑社会”，双方的利益冲突交织在一间歌舞厅;值得一提的是电影里佳怡和松子这个女性角色，虽然六一喜欢佳怡，可依琳说她有喜欢的人的时候，他默默地选择放手，即使他心里依然有她，而最终六一躺在太平间里，此时陪伴在他身边的，不过是哭成泪人地佳怡和那条巡回犬，大概我们都习惯了忽视身边人的爱吧，从父母到伴侣，影片中正太和小花从四岁结识从始自终，这大概就足以令人唏嘘了吧;影片中一个细节是，最后徐正太和阿浪杀死黄志强以后，怀有身孕的小花匆匆赶来，将满身血污的徐正太紧紧抱在怀里，小花说徐正太有时候像个孩子，其实男人都会有像孩子的一面，所以小花其实代表的是一种母性的关怀吧", "tags": [["人", 0.015194359834987852], ["徐太浪", 0.013852256147480762], ["父亲", 0.011392730127388982], ["会", 0.011128411319010182], ["电影", 0.0109493867169525]], "title": "愿浮萍乘风破浪"}, "1127467740": {"descs": "就像人们觉得大街上耍猴有意思，人们看着被驯化的猴子，遵从人们的指令做出各种动作，人们瞬间有了种睥睨众生的感觉，可明明人类就是由猿猴进化而来，想到这一点，你忽然觉得人类世界的奇妙之处，即人类以自身有限的认知，所勾勒和描绘出的这个世界，其实永远都是冰山一角，在某种情况下，这种体系的崩塌，我让我们不得不重新审视自我的合理性，所谓“你站在桥上看风景，看风景的人在楼上看你;上周国庆节放假，在家里看了黄渤的导演处女座《一出好戏》，虽然网上对它的评价还不错，可当我真正看完了这部电影，我反而觉得它更适合一个人的时候去看，因为在“演而优则导”的大趋势下，越来越多的人都在尝试“触电”，前有角逐奥斯卡的《逐梦演艺圈》，后有倒卖情怀的《爱情公寓》大电影，在这样一个充斥着“浮躁”的娱乐时代，有这样一类充满哲学意味的电影，可以说这是中国电影里的“净土”;电影快结束的时候，马进一直在重复“真的”还是“假的”，当一个人认识到这个社会的复杂性，当一个人在真真假假中来回穿梭的时候，或许他就会和马进一样，真的就分不出“真假”，可让马进走上神坛的电灯，和让小王变成“精神病”的电，难道不是一样的吗;虽然在电影中马小兴修坏了小王的水陆两用车，但其实电影想说的是，马小兴是所有人里唯一一个懂得现代科技的人，所以，马小兴的黑化，其实是马进人性中的阴暗面而已，当你真的拥有了摆布他人的能力，你是否又能守住道德的底线;有没有觉得马进一手持书的样子像极了耶稣，如果说耶稣通过圣经来向世人传道，那么马进对着黑暗中众人的一番演讲，是否具有类似的教化的作用，马进再一次“刷新”了活着的定义，引导人们去重见光明、寻找新大陆和重建家园，至此，我们仿佛过渡到了追求精神文明的阶段", "tags": [["人们", 0.015604357624439824], ["人", 0.015103053128947117], ["人类", 0.011475874582974659], ["马小兴", 0.011299116766122308], ["马进", 0.008823562084378457]], "title": "戏里戏外的一出好戏"}, "352037321": {"descs": "小说中苦沙弥、迷亭、寒月、东风和独仙时常在一起聊天，话题涉及哲学、艺术，爱情、生活等多个方面，这只“毒舌”的猫，就在无意识地引导和放大这些观点，“我认为这个世界上，没有比爱和美更受人尊重的了”，所以这本书里的观点，其实并不是完全的消极的，就像这只猫平静地看着这个世界，它对人类有过嘲讽，有过同情，它甚至没有自己的名字，当它失足淹死在水缸里的时候，对这个世界更多的是种悲天悯人吧;人总在试图驯化猫这种动物，可猫无非是人类的一种折射而已，它就像那些独立潇洒的人一样，不藉由粘人和撒娇来获取安全感，在这个世上没有谁会离不开谁;在猫的眼睛这里，这些人整天聚在一起讨论没有意义的事情，对现实世界心怀不满，不思进取就会怨天尤人，甚至金田及其夫人的”拜金主义“，为金钱而陷害苦沙弥的邻居，唯利是图、虚伪圆滑的铃木，这些人在猫的眼睛里都是丑陋而黑暗的;猫自然对人是有感情的，不过在人类驯养动物的历程中，狗更聪明、更懂得如何向人类索取，我们所认定的感情，在狗的世界里或许并不是;有时候，难免会觉得人类自作聪明，喜欢给世间的事物贴上不同的标签，譬如二哈、喵星人、汪星人、猫主子", "tags": [["猫", 0.03117719347291144], ["人类", 0.022747787795091873], ["日本", 0.013726490434675578], ["人", 0.012359301441409096], ["世界", 0.010042849638409478]], "title": "我是猫，一只特立独行的猫"}, "3653662258": {"descs": "现在解决了创建资源的问题，我们接下来只要调用ProjectWindowUtil的StartNameEditingIfProjectWindowExists方法即可，该方法需要传入一个继承自EndNameEditAction的类的实例、目标文件路径和模板文件的路径;好了，第二个参数作为一个验证的标志，如果该标志为true，意味着我们定义的静态方法是一个验证方法在执行静态方法前会首先对方法进行验证，这个我们暂且不管，因为今天我们这个来自星星的黑科技主要和第三个参数有关，第三个参数表示一个优先级，它表示菜单项在菜单栏中的展示顺序，优先级大的菜单项会展示在优先级小的菜单项下面，由此我们就明白了了模板文件名中的类似81、83这样的数字的真实含义，注意到模板文件的排列顺序和编辑器中的菜单项顺序是一样的，我们做一个尝试，编写下面的代码：;Unity3D默认的脚本模版位于/Editor/Data/Resources/ScriptTemplates/目录下，注意该目录相对Unity3D的安装目录而言，在这个目录中我们可以找到Unity3D中脚本模板的某些蛛丝马迹，首先，脚本模板是一个简单的文本文件，这个文本文件中预先填充了内容，我们在编辑器中创建模脚本或者Shader的时候实际上是读取这些文件然后在写入项目中的指定路径的;因为Shader文件是一个文本文件，所以我们可以非常容易地创建这样一个模板，在这个模板中我们可以进一步完善相关的参数注释，这样就不用每次写Shader的时候都需要查文档了，从这个角度出发，就进入了这篇文章的正题：扩展Unity3D编辑器的脚本模板;现在有了这个黑科技以后，我们可以创建更多的模板来扩展编辑器的功能，比如对Shader而言，我们可以创建些基础性的Shader模板，然后每次需要写Shader的时候直接从模板库中选择一个功能类似的Shader然后在此基础上进行修改，这样比从头开始写一个新的Shader应该会轻松不少，这段时间学习Shader，感觉进程缓慢离图形学高手遥遥无期，行了，这篇博客就是这样了", "tags": [["中", 0.025179832190840457], ["文件", 0.019589627804143934], ["模板", 0.017763560326590724], ["shader", 0.016035656073339226], ["string", 0.013888183733734386]], "title": "扩展Unity3D编辑器的脚本模板"}, "2158696176": {"descs": "防火墙设置非常简单，因为关闭防火墙就好啦，这样可以保证其它设备能够正常访问本地服务器，在测试完页面后应该立即开启防火墙，这个世界可谓是充满了诱惑，有诱惑的地方就有危险，所以当我们通过互联网获取知识的同时，更为重要的一点是学会如何去甄别信息的真伪，魏则西事件让我们每一个人都感到痛心，可我们必须认识到，即使百度在你我的口诛笔伐中宣告破产，对这个世界的影响永远都是杯水车薪，所以无论是杀毒软件还是防火墙，任何形式的东西都不能代替你保护自我的意识，就像在地震、火灾这类破坏性灾难中，学会自救互救比等待公共救援更为有效;现在前端技术如火如荼，而前端技术作为最有可能实现跨平台技术的技术形态，相对原生技术有着更为灵活的适应性和扩展性，因此以响应式设计为代表的Web技术，能够让Web页面在不同尺寸屏幕上都有着相近的体验，因为目前软件开发基本都是在计算机设备上来完成的，这样我们在制作Web页面的时候就需要在不同的设备上进行调试，如果每次都将Web页面部署到远程服务器上，这样将浪费大量的时间而且容易将测试阶段的问题暴露给用户，因此本文将采用一种扫描二维码的方式来实现在移动设备上浏览响应式页面;在这种情况下，理论上我们可以直接使用运行本地服务器的计算机的IP来访问本地服务器，可是因为不同的服务器软件配置不同以及不同的计算机设置不同等等外部性的因素，在实际操作的过程中依然存在各种问题，下面我们就来针对实际操作中需要注意和解决的问题，来说说具体的实现过程;# AllowOverride controls what directives may be placed in .htaccess files.;这样让我感觉显得不够优雅，我一直在思考有没有一种方法可以通过扫描二维码，直接建立移动设备到本地服务器的连接，可是二维码保存的是普通的文本信息，除非我能够通过二维码去调用Android系统中的Intent，否则这个过程是没有办法实现自动化的，一个更好的想法是在PC端生成二维码图片，在手机端通过编写二维码应用来实现两者间的Socket通信，而通信的细节如IP地址、端口号等则可以通过二维码来进行加密和解密", "tags": [["问题", 0.014770239944981322], ["二维码", 0.013519511953761462], ["进行", 0.012586592386556964], ["服务器", 0.011241341859168821], ["技术", 0.011038737808905618]], "title": "扫描二维码在移动设备上浏览响应式页面"}, "3521618732": {"descs": "TravisCI提供了主流编程语言如C#、Java、JavaScript、Ruby、PHP、Node.js等的支持，相比Jenkins而言，它是一个轻量级的持续集成平台，它会在每次提交代码后，根据配置文件来创建一个虚拟机，并执行用户定义的Build任务，这个虚拟机提供版本控制(**Git**)、项目构建(**Node.js**)等，在此前提下，我们下面着手Hexo的自动化部署;现在我们在本地提交代码到blog分支，就会触发TravisCI执行Build任务，在这里Build任务是从blog分支拉取博客内容及主题，通过npm安装依赖的nodejs模块，最终Hexo生成的静态页面会被推送到master分支，这样就完成了整个自动化构建的流程;其次，持续集成可以将开发和部署分离，所以我在任何一台计算机上撰写博客，都可以通过TravisCI实现编译和部署，对Hexo这种静态博客而言，部署其实就是推送页面到Github而已，整体难度并没有太高;首先，我们期望的是开发者在提交代码以后，可以触发编译、构建、测试和部署等一系列操作，我们会通过Git从远程仓库拉取最新代码，然后通过MSBuild来编译整个代码，由于MSBuild提供了定制化的脚本，可以对编译、测试和部署等环节进行精准控制，所以我们在Jenkins上触发的实际上是一系列动作，而这些都是可以在Jenkins上进行配置的，我们通常会将Jenkins上的日志以邮件形式发送给开发者，所以在很长一段时间里，每天到公司第一件事情，就是查看邮箱里的邮件，一旦发现有测试用例没有通过测试，我们就需要重复“修改代码“->“提交代码“这个过程，直至所有用例都完全通过测试，理论上通过测试的代码就可以直接部署上线，因为MSBuild可以帮助我们生成最终文件，我们只需要将其打包然后上传到服务器即可，可是实际上这是我们假想的一种场景而已，因为现实场景中我们考虑得通常会更多;那么当整个环境准备就绪以后，我们就可以着手博客的构建啦，和平时一样，我们会执行hexo clean和hexo generate命令，这样Hexo会帮助我们生成所有的静态页面，现在我们通过Git将其推送到master分支，通常基于Github Pages托管的页面都是存放在gh-pages分支的，可是对Hexo而言，我们放在master分支是没有问题的，这就是TravisCI构建整个博客的具体过程", "tags": [["上", 0.014036600427434752], ["中", 0.011890202109742256], ["持续", 0.011653526513787727], ["devops", 0.011638873369844264], ["travisci", 0.01087919465977449]], "title": "持续集成在Hexo自动化部署上的实践"}, "331752533": {"descs": "接下来，我们在场景中添加一个角色模型来测试我们编写的虚拟摇杆，因为在JoyStick中我们已经定义了事件委托，所以在这里就是简单的调用啦;关于使用第三方插件来实现虚拟摇杆，请大家参照我以前写的文章[Unity3D游戏开发之使用EasyTouch虚拟摇杆控制人物移动](http://blog.csdn.net/qinyuanpei/article/details/26204177)，在这里就不再赘述了;在这段脚本中，我们实现了OnPointerDown、OnPointerUp和OnDrag三个uGUI事件接口，然后注册了相关的事件委托，这里借鉴了EasyTouch的设计，可以使得虚拟摇杆的逻辑和角色控制逻辑相互分离;public Vector2 TouchedAxis;/// 虚拟摇杆的移动方向", "tags": [["摇杆", 0.02570804062046621], ["虚拟", 0.01883356003126595], ["大家", 0.018594424654759047], ["中", 0.01856825302207428], ["移动", 0.01471384833403833]], "title": "教你一步步实现一个虚拟摇杆"}, "1983298072": {"descs": "1962年，北京，清华毕业生陈鹏，在面对国家的大爱与恋人的小爱的选择时，饱含着对恋人王敏佳的爱远赴沙漠投身科研，他质问为支边而蒙蔽内心的李想什么是真实，他用爱托着恋人鼓励她努力活下去，为爱而奉献一生;2010年，北京，广告总监张果果，在明争暗斗的职场上遭人排挤，在面对职场中的名利诱惑时，在面对四胞胎永无止境的救助要求时，李想用生命拯救了张果果的父母，完成自我救赎，而张果果则在迷茫中找会初心，让爱传承下去;[聆听泰戈尔演讲的吴岭澜](https://ww1.sinaimg.cn/large/4c36074fly1fzix9228b7j20k008jglz.jpg);1938年，昆明，世家子弟沈光耀面对山河破碎的现实，在忠与孝的两难抉择中深感困惑，直到听到吴岭澜说“不要放弃对生活的思索，对自己的真实”，毅然选择投笔从戎，成为飞虎队队员，在国家危亡之际战死沙场;[捐躯赴国的沈光耀](https://ww1.sinaimg.cn/large/4c36074fly1fzix90krfyj20k008j752.jpg)", "tags": [["电影", 0.010811852214400697], ["面对", 0.006997576739654772], ["时", 0.006876192358567804], ["人", 0.006080430895153339], ["恋人", 0.00581439178086472]], "title": "无问东西：你曾是少年"}, "1357715684": {"descs": "或许Kent说得是对的，这个世界上并没有那么多，真正看重技术的公司，这个世界上普通如你我的人，无一不在做着普通的事情;天地间万事万物更迭交替，本来是自然界中最普通的规则，可是如果每年的这个时候，你都是一个人去看这山山水水，相比时空上的孤寂感，人的孤寂感会更为强烈，“良辰美景奈何天，赏心乐事谁家院”，外面的世界再纷繁多变，对你而言不过是活着的时间;Kent是坐周五晚上的火车离开，晚上两个人一块儿吃饭，聊到了家里的琐事，聊到了工作的想法，唯独没有提到离别，大概是我不愿意说起;可当时的心性却不再回复，取而代之的是无限的回想，人生总是如此匆忙的别离，你每天都会认识不同的人，你每天都会错过不同的人，光影恍惚间，一切都仿佛是时间的灰烬爬上了镜子，这像什么呢;可她永远不会再出现了，看到路人成双入对的时候，或许爱对我而言是件太困难的事情，佛门有“贪嗔痴”三戒，求而不得是为执，一个人孤零零地在这个城市里，从明天开始，我会经历更多的一个人，一个人吃饭，一个人工作，一个人游曳", "tags": [["人", 0.03546697324633583], ["事情", 0.012549786545301546], ["看", 0.010312210779425249], ["会", 0.010243549895053126], ["没有", 0.00989701984262635]], "title": "时间如灰烬般遥远"}, "3461518355": {"descs": "大家或许觉得我对这个班没有什么感情，可是人和人相处不能单纯地看重对方目前、以后可能会对你有什么样的帮助，因为这不叫朋友叫做关系，我眼中的朋友是那种即使自身没有什么强大的社会资源，可当你需要帮助的时候，他仍然会真心实意地为你付出，我对于朋友和关系的界定实在是困难，因此当我面对这场不知是送别还是交友的毕业聚会的时候，我会突然陷入某种迷茫，即使麦克风音量开到最大、嗓子喊到声嘶力竭，当一切都结束了的时候能够留下什么呢;或许大家都认为我这个人比较冷淡，可是对我而言，我只是想做一个简简单单的人而已，我不会因为即将毕业就表现出某种殷切的神情，在我的心里我当做朋友的会一直当作朋友，即使以后大家都鲜有机会再聚在一起，我讨厌酒桌上的朋友，所以我不会用喝酒这件事情来作为我们彼此情感的见证;朋友对我而言，一直是我所珍视的人，我觉得君子之交淡如水这样的关系就很好，我不是一个善于表演的人，不管是和大家一起拍VCR还是和大家在一起的时候，我想我喜欢的是大家在一起的时光，而不是在一起喝酒的时候;终有一天大家都会奔向各自的前程，去做自己想做的事情，就像慕容紫英一样，百年蹉跎岁月不过转瞬，当朋友们都不再需要他照顾的时候，他会义无反顾地踏上自己的路，他心里记得那句“承君此诺，必守一生”，可是千百年后当昆仑山上下起雪的时候，这世上留给他又有什么呢;昨天我和班里大部分的人喝了酒，目的单纯而简单，就是想感谢大家在这四年里对我的帮助，就是想记住和大家在一起的这段时光，我是一个随和的人，所以我不会强迫别人喝多少酒，因为喝酒就是一种助兴的形式而已，真正让我们铭记于心的不是这顿酒，而是我们彼此在各自的生命里出现过", "tags": [["人", 0.04958306323764116], ["会", 0.03334096950469845], ["朋友", 0.021243257805359347], ["大家", 0.01375255732089644], ["毕业", 0.0117354303931823]], "title": "毕业就像指尖流沙"}, "569337285": {"descs": "在这篇文章里我们讨论了MVC、MVP、MVVM各自架构变迁的前因后果，由此我们知道了软件设计中，一个典型的设计目标是让视图和模型分离，可我们同样发现，带着这个目标去设计软件的时候，我们基本鲜有更换视图的时候，虽然从理论上来讲，所有的业务逻辑都是在ViewModel中，视图和模型应该是可以进行更换的，可是你告诉我，有谁会为同一个软件制作不同的界面呢;所以，在这里我们纠结的地方，其实是选择让控制器更“重”还是让模型更“重”，我曾经接触过1年左右的Android开发，我认为Android工程是一个相对符合MVC架构的设计，可是我们难免会发现，作为控制器的Activity中的代码非常臃肿，因为我们在这里需要和视图、模型关联起来，所以综合现有的这些软件架构思想，我们发现模型和视图相对来讲都是可以复用的，可是作为连接这两者的Controller/Presenter/ViewModel是非常臃肿而且难以复用的，所以我怀疑我们是否是在真正的使用MVVM;这里需要说明的是CanExecuteChanged这个事件，这个和INotifyPropertyChanged接口中的PropertyChanged成员类似，是在当CanExecute发生变化的时候通知视图的，我对这里的理解是CanExecute本身就具备对某一个过程是否应该被执行的支持，可是遗憾的是在，在我参与的项目中，人们更喜欢声明大量的布尔类型变量来处理这里的相关逻辑，因此无论是对Property还是Command而言，在ViewModel里都是看起来非常丑陋的代码实现;我不太喜欢声明式编程，这里是指WPF中XAML这种继承自XML的标记语言，因为Visual Studio对XAML没有提供调试的支持，所以当你发现视图显示出现问题的时候，你很难分清楚是前台视图绑定出现错误还是后台ViewModel出现错误，只要你输入符合XML规范的内容程序都会编译通过而非引发异常，因为它是用反射所以性能问题广为人所诟病，其次ViewModel中通知前台属性发生变化时需要使用OnPropertyChanged，该方法需要传入一个字符串类型的值，通常是指属性的名称，可是如果你定义了一个字符串类型的属性，当你在这里传入这个属性的时候，因为它是字符串类型所以不会引发编译错误，可是我觉得这个东西还是比较坑;以我目前公司项目的情况而已，我认为它更像是使用了双向绑定的MVC，因为你经常可以在ViewModel中看到，某个属性的Get访问器中各种被if-else折磨的“脏”代码，而在ViewModel中我基本上看不到Model的身影，并且因为使用了Binding的概念严重弱化了ViewModel作为类的基本属性，因此它没有构造函数、没有初始化，我们可以在Get访问器中看到各种硬编码，因为视图上的需求经常变动，所以当整个项目结束的时候，我本人是非常不愿意去看ViewModel这部分的代码的，因为项目上要求避免写Code-Behind代码，所以大量的事件被Command和UIEventToCommand代替，这样让ViewModel变得更“重”了", "tags": [["中", 0.016142043074661938], ["控制器", 0.00962483052268161], ["视图", 0.009621053853595428], ["viewmodel", 0.009048448141362611], ["发现", 0.008944745013709114]], "title": "浅析WPF中MVVM模式下命令与委托的关系"}, "3494408209": {"descs": "至此，我们就达到了基于Nginx访问日志实现PV/UV统计的目的;考虑到“不蒜子”里因为更换域名而导致的访问统计重置的问题，我增加了一个初始化站点UV/PV的功能，满足了像博主这样虚荣心爆棚的人的需要;实际上这里整个站点的UV统计是不严谨的，因为严格地来讲，同一个IP访问了同一个站点下的N篇文章，它的UV严格地来说应该算1次，可我们这个方案本身就是向LeanCloud妥协的一种做法，就像我这里直接使用了`location.href`和`document.title`，它带来的问题就是，一个网站的域名或者链接发生变化的时候，访问统计就会被重置从0开始;而PV/UV则是分析用户的浏览行为的最基础指标，所以，通过Nginx的访问日志来统计UV和PV是再合适不过的啦;所以，最终的方案是插入访客记录(**VisitorRecord**)时更新文章的对应的访问次数(**VisitorCounter**)，而单篇文章的更新则会触发站点UV/PV的更新", "tags": [["统计", 0.014745708827206477], ["会", 0.010055294454168865], ["使用", 0.009632683398981974], ["访问", 0.009519782361359018], ["uv", 0.008806097387235241]], "title": "浅析网站PV/UV统计系统的原理及其设计"}, "2829333122": {"descs": "Java是典型的面向对象编程的语言，所以不存在任何游离于Class以外的函数，代理模式对类型的要求更为强烈些，因为我必须限制或者说要求Proxy实现里面的方法，而装饰器模式相对更为宽松些，遇到Python这样的动态类型语言，自然会显得事半功倍;在这个示例中，我们定义了一个decorator_print的装饰器函数，它负责对一个函数func进行修饰，在调用函数func以前执行print语句，进而可以帮助我们调试函数中的参数，通过@语法可以让我们使用一个名称去绑定一个函数对象;然后我们讨论了两种和装饰器有关的设计模式，即代理模式和装饰器模式，选择这两种模式来讨论，是因为我们在Java/C#和Python中看到了两种截然不同的实现AOP的思路，这部分需要花功夫去精心雕琢;我们注意到装饰器可以使用def来定义，装饰器接收一个函数对象作为参数，并返回一个新的函数对象;装饰器天然地和函数式编程、设计模式、AOP等概念产生联系，这更加让我对Python中的这个特性产生兴趣", "tags": [["中", 0.023262560244869838], ["函数", 0.019677113094257022], ["装饰", 0.015491608246550744], ["对象", 0.013427741092211993], ["python", 0.011477118121954278]], "title": "深入浅出理解Python装饰器"}, "2463121881": {"descs": "而从功能性角度来讲，把整个文件的内容全部放在请求体中，则会造成文件信息的不完整，因为此时文件名等信息是没有办法传输到服务器端的，所以，这样综合下来再看的话，HTTP协议本身留给我们的选择的空间并不大，我们能够选择的就只有multipart/form-data和x-www-form-urlencode这两种啦，下面着重来分析下这种数据加密方式;通过这个例子，我们很容易发现的一点是，当我们采用type为file的Input控件上传一个文件时，它会采用multipart/form-data来传递数据，报文中使用了和第二个示例类似的结构，即第一部分负责描述文件信息，譬如文件的名称、扩展名类型等等;当我们回顾Form表单中关于HTTP的部分，我们就会发现，HTTP中具备上传文件可能性的方式只有两种，即multipart/form-data和x-www-form-urlencode;本文从Form表单说起，首先探讨了Form表单和HTTP之间的关系，即Form表单在提交数据的时候，背后的本质其实是一条HTTP请求，相对应地，Form表单默认的请求方式是GET，在第一个示例中，我们分别展示了使用x-www-form-urlencode和multipart/form-data时请求报文实际的内容;更一般的结论是，只要我们的Form表单里有一个type为file的Input控件，对应POST请求的Content-Type就会变为multipart/form-data", "tags": [["文件", 0.019953846093772563], ["中", 0.01843194765150647], ["form", 0.017181464152169614], ["会", 0.014233154337810996], ["http", 0.01352161450726757]], "title": "漫谈前端进化史之从Form表单到文件上传"}, "115524443": {"descs": "考虑到第一种策略无法解决重试无效的问题，我们在此基础上增加对重试次数以及重试间隔的控制，这就是Try-Catch-Redo-Retry策略，其基本实现如下：;AOP是一种可以在运行时期间动态修改代码的技术，我们自然可以想到给所有的函数都加上异常处理和重试的特性，幸运的是Python中的有这样一个第三方库：[Tenacity](http://tenacity.readthedocs.io/en/latest/)，它可以帮助我们优雅地实现重试：;通过@retry这个装饰器函数，我们就可以知道，这里设计的重试策略是：当引发JSONDecodeError这个异常时，每隔5秒中重试一次，最大重试次数为3次;这里的Policy承担了RetryBuilder的角色，它定义了这样一种策略：当程序引发DivideByZeroException时进行重试，重试次数为3次，并且以匿名函数的方式指定了重试时的回调函数;这应该是我们最容易想到的一种重试策略了，其思路是对函数的返回值和异常进行处理，其缺点是无法解决重试无效的问题", "tags": [["中", 0.020000919270379388], ["重试", 0.016933054129510478], ["问题", 0.012454027324081511], ["去", 0.012284582675613158], ["策略", 0.011461048895017829]], "title": "漫谈应用程序重试策略及其实现"}, "3782208845": {"descs": "诚然，我们都希望对方忠诚的对待自己，可人归根到底是一种对自我忠诚的动物，你说你不能接受对方变心，可人、时间和空间无时无刻不在发生着变化，喜欢或者不喜欢，不过是某一瞬间的状态，你必须相信，爱情本来就不完美、充满瑕疵，可这就是真实的爱情的样子啊，人们会记得你婚礼上的海誓山盟，唯独不会记得你每天柴米油盐的平平淡淡;两个人如果真心相爱，即便是满头白发的蹒跚老者，我认为结婚都是没有问题的，可当两个70多岁的老人坦诚相见时，当阿里萨看到费尔米纳干瘪下垂的胸部时，当各自看到对方充满皱纹和赘肉的身体时，我真的想知道，这50多年的等待真的值吗;电影中费尔米纳甚至给阿里萨回了信，可就如同费尔米纳所言，“他们两个人之间只有虚幻，爱情蒙蔽了彼此的双眼”，大概所有一见钟情的人都没能考虑一个问题，那就是你真的了解对方这个人吗;我更愿意相信，这是一种原始的欲望冲动，可你说这两个人间没有爱情，估计所有人都会反对，谁让我们都喜欢用海枯石烂表示爱情的忠贞，这两个人在一起生活50年，甚至作者都表示：一对恩爱的夫妻最重要的不是幸福，而是稳定的关系;或许是值的的，就像这两个人喜欢的都是有点幻想成分的对方一样，我向往永远靠精神慰藉彼此的帕拉图之恋，也不排斥男欢女爱的肉体之欢，可无论哪一种都必须建立在真实的现实中，一个虚幻的爱慕者，一个你并不真正了解的人，当幻想被打破的一瞬间，或许就是爱情破碎的时候，所以，我希望我们对待感情更慎重些，即使没有人爱你，学会自爱未尝不可", "tags": [["人", 0.02158499587150664], ["会", 0.018002629425852706], ["爱情", 0.01788013886660265], ["去", 0.010910557537673808], ["费尔", 0.009621817763948274]], "title": "爱情像一场霍乱"}, "3657008967": {"descs": "一个让我更加感兴趣的地方是，当哈罗德因为独自远行这件事情而声名远播的时候，在那一瞬间形形色色的朝圣者都表示要加入这个旅程，可是很快我们就发现，这些朝圣者或多或少的都各怀心机，有的人是为了追求名利而加入队伍，有的人是为了出一本传奇书籍而加入队伍，有的人是为了挽救一段失败的婚姻而加入队伍，有的人是为了写一篇成为头条的新闻报道而加入队伍......这就像我们这个世界，当所有人都开始尝试按照自己的理解来揣度哈罗德的用意的时候，朝圣这件事情本身地意义就会被无限的忽略，没有一个人尝试去理解哈罗德的本意，当所有人都对此趋之若鹜的时候，或许并不代表这件事情本身为人们所理解所推崇，人们喜欢的仅仅是这种被关注的感觉而已，所以请放下那颗浮躁的心，努力去聆听自己内心的声音，我们生来并不是因为我们需要这样一场添油加醋的作秀，就像我始终相信爱情是两个人彼此吸引自然而然地走到一起，我不擅长刻意的事情，或许是因为我天生就喜欢本色出演;哈罗德最初开始旅程的时候，基本上是一无所有的，他腿脚不便同时患有老年痴呆，正是这样的状态让妻子莫琳对他的所作所在困惑而愤怒，可是随着旅途的深入，那些在旅途中遇到的路人们，常常会馈赠给哈罗德如地图、指南针、药物等等这些东西，所以对哈罗德而言，这个过程是一个装备逐渐增加的过程，可是当他离目标越来越近的时候，他不得不将这些东西转赠给其他人或者是不慎在旅途中丢失，我印象比较深的一点是，他在旅途中收留了一条流浪狗，在相处的过程中逐渐培养出了感情，此时的哈罗德想起自己的儿子曾经想要养一条小狗，可是因为他的固执和懦弱，这个愿望最终成为永远的遗憾，正当他为此而费心伤神时，这条流浪狗忽然不知所踪，等哈罗德找到它时，发现它跟上一个年轻女孩儿上了一辆公交车，或许这告诉我们，我们的人生其实就是一个由简至繁再由繁至简的过程，我们曾经年少轻狂、我们曾经迷失方向，可当我们洗净铅华、丢掉一切附庸的时候，我们或许会不由得感谢，那些生命里教会我们某些东西的人;当我们以今天这样一个世俗的眼光来审视哈罗德的时候，或许沉默寡言的哈罗德完全就是一个失败者，可当他徒步走完627英里的这段旅程以后，我们或许会明白，我们每一个人都是不完美的，而哈罗德所做的，无非是希望通过一个原始而质朴的方式，找回埋藏在内心多年的善良和温情，他曾经不是一个合格的丈夫、更不是一个合格的父亲，可是在经历过这段旅程以后，他终于找回了一个愈加真实的自己，这是一场关于生命地修行;我们都还年轻，所以为什么不趁着现在，去做些真正疯狂的事情，如果当我们垂垂老矣的时候，发现生命是如此的苍白，大概我们会更加因为年轻时的碌碌无为而悔恨终生吧;最初莫琳对丈夫的困惑不解、担忧愤怒，随着故事的推进逐渐演变为探寻改变、尝试了解，甚至到故事的最后两个人终于重新走到一起，我最喜欢的情节是两个人尽释前嫌，手牵着手走向海边，一边走一边回忆第一次两个人在舞会上认识的情景，这个旅程是一个人的远行，可是它却是两个人的灵魂回归，当哈罗德逐渐接受自己懦弱的一面，开始学会承担责任", "tags": [["去", 0.018733228281748456], ["人", 0.01856641266494767], ["会", 0.01808602277683231], ["故事", 0.008996063741065227], ["旅程", 0.007162187394137466]], "title": "生命的朝圣者"}, "337943766": {"descs": "也许这些东西写多了就可以记住，就像我现在可以分清SYSDATE、NOW()和GETDATE()，可它带来的问题是什么呢，大多数的触发器、存储过程、函数都是没有移植性可言的，很多年前，我们讲设计模式，最喜欢觉的例子就是，如果项目发生变动，需要更换数据库，我们要怎么设计能不改动代码，现在看起来，当时还是太天真了，真要换了数据库，估计就是重新做了，敢把全部业务写到数据库里，Web就做一个展示层的项目，有生之年应该是不会换数据库啦;可最近在写Oracle环境的触发器(**存储过程和触发器都是万恶之源**)时，我发现DBeaver和PL/SQL在面对同一段SQL脚本时，居然因为一点点语法上的差异而不兼容，这让我内心深处不由得想对Oracle吐槽一番;你甚至连分页、排序、分组这种事情，都无法在不同的数据库上获得一致的书写体验，读取指定数目的数据库记录，居然要纠结用到底用Limit还是Top，像Select Into这样把指定列存储到指定变量中的操作，居然要求使用者来限制结果集的数目，从函数的角度来看，返回的必然是结果集中的一个元素，只有这样才可以赋值给指定的变量，可问题是存在多条记录的时候，你必须用游标去循环读取，而不能像大多数编程语言一样，直接Map()到一个类型上然后ToList()，可能是我对SQL的要求太高了吧，毕竟它就是个面向过程的语言，OO不OO的没那么重要，可明明你可以抛出异常啊，可以对字符串做截取啊正则啊，可以在控制台里输出日志啊，可以调用各种有的没的的内部函数啊，elsif可能是因为e不发音，就像usr绝对不是拼写错误;可我们同样能意识到，SQL的表达能力有限，它无法表达顺序、条件、循环这种基本的程序结构，所以，数据库厂商几乎都对SQL标准进行了扩展，像PL/SQL和T-SQL中都提供了这些语法，进而催生出函数、触发器、存储过程一系列“万恶之源”，可从编程语言的角度来看，SQL算是个好DSL吗;除了这三种经典的关系型数据库，我们还会用Memcache和Redis这样的内存数据库，Mongodb这样的非关系型数据库，所以，我希望有一个统一的入口来管理这些连接，毕竟我身边的同事会使用三种以上的工具，譬如**Sqlyog**、**PL/SQL**、**SQLServer**等来处理这些工作，恰好DBeaver可以满足我80%的工作需要", "tags": [["sql", 0.01729014652989371], ["数据库", 0.014962188940749537], ["oracle", 0.01140437413937639], ["中", 0.011374292329671718], ["使用", 0.011261148144328282]], "title": "由DBeaver与PL/SQL引发的数据库吐槽"}, "3131944018": {"descs": "可在城市配载这里就相当尴尬啦，因为据说客户会把地图放大到市区街道这种程度来对订单进行配载，所以，这种标注物聚合方案的效果简直是微乎其微，而且更尴尬的问题在于，官方的 [MarkerClusterer](http://api.map.baidu.com/library/MarkerClusterer/1.2/src/MarkerClusterer.js) 插件支持的是标准的覆盖物，即Marker类;百度地图API v3中提供了基于Canvas API的接口，我们可以把这些“好看”的覆盖物绘制到一个层上面去，显然这种方式会比DOM更高效，因为博主亲自做了实验，一次性绘制10万个点放到地图上，真的是一点都不卡诶，要说缺点的话嘛，嗯，你想嘛，这都是不是DOM了，产品经理那些吊炸天的脑洞还怎么搞;所以，一个简洁的Marker类和复杂的DOM结构，会在性能上存在巨大差异，这恰恰是我们加载了800多个点就产生性能问题的原因，因为一个“好看”的标注物，居然由4个DOM节点组成，而这个“好看”的标注物还不知道要怎么样实现Marker类里的右键菜单;看了看同类产品的相关设计，我预感这个功能会变成一个以地图为核心的可视化运输系统，这符合国内用户一贯的“大而全”的使用习惯，地图上的交互会更加复杂，需要展示的信息会越来越多，所以，这篇文章里提到的优化，在未来到底有没有用犹未可知;var len = this._markers.length", "tags": [["地图", 0.016994023382314986], ["会", 0.01294278655231146], ["覆盖物", 0.012609676155553121], ["marker", 0.012113376421970946], ["中", 0.011913436691719976]], "title": "百度地图加载海量标注性能优化策略"}, "2617501472": {"descs": "二十五岁的我，喜欢一个人还是和从前一样无所顾忌，我还是学不会那些复杂的套路，不喜欢单方面付出，不喜欢卑微地爱一个人，每一次都会因为喜欢某个女孩子而尝试改变，想和她站在一起的时候不会被她的光芒完全覆盖，想和她待在一块的时候不让她觉得我这个人枯燥，想和她抱在一起的时候给她讲我从书里看到的某个故事......我一直在想，如果我们的感情不是以异地恋这种方式会不会有不一样的结局，我喜欢《星月神话》这首歌，是因为我们的确呼吸着同一片天空的气息而注定无法再相遇，就像两条相交的直线一样从陌生到熟悉再到陌生;我喜欢穿裙子的女孩子，这一点完全是因为受到她的影响，虽然她一再告诉我，是我喜欢这样的女孩子，而她恰好喜欢穿裙子而已，可这些淹没在风声里的话语，谁会去盘问孰是孰非呢，如果她此刻愿意同我争论这个问题，我直接认输就好啦，我对输赢看得并不重要，这就像在工作中，没有人在意做的产品是不是好用，大家关注的是始终是它能节省多少个FTE，所以为了达到这些光鲜亮丽的指标，没有人会在意工程师的代码被改成什么样子，我们所追求的东西是否显得舍本逐末，我们所在意的东西到底是否真正发自你我的本心;你一定觉得我幼稚或者是不成熟啦，我问过人家要怎么样变得成熟，人家说你去找一个女朋友就好啦，然后就会在喜欢的人面前紧张甚至自卑，我曾一度很讨厌下雨天，因为我怕两个人遇到一起，我既没有伞亦没有外套;一个人少不经事的时候，大概会喜欢对女孩子说甜言蜜语，可当他经历过失去以后，他变得不再轻易许诺，这就好像我小时候是一个特别喜欢说话的人，在经历过因为紧张而变得口吃以后，我终于变成了今天这副沉默寡言的样子;有时候会陡然间觉得自己并没有怎么变，或许是因为她说过她喜欢我这个样子，所以我就固执地不肯改变，因为我怕有一天她回来的时候认不出我来，即使这是我脑补的一个剧情", "tags": [["人", 0.025522012976844713], ["想", 0.015071089861955276], ["喜欢", 0.01409663143443418], ["没有", 0.013854042175202717], ["觉得", 0.013823915054219111]], "title": "秋风劲似去年时"}, "2941880815": {"descs": "影片中喃杭的小伙伴喃湘露，是因为错过最佳治疗时机而死，而第一个送孩子去医院的人，恰恰是她们不大喜欢的老师，大人们说要等机场修好，就可以坐飞机去外面治病，接近尾声时，人们看到头顶呼啸而过的飞机，不知道会不会想起喃湘露这个孩子;“神婆”说米花米酒都变味了不好吃，大概是因为我们缺少了那种简单和纯粹，母女俩一起炸米花的时候，中间女主被叫去一段时间，喃杭炸的米花在翻动的时候，从中间破碎成两半，或许人的心原本如此，当有了隔阂的时候，即便是再简单的事情，都会做不好;心中去敬畏一样东西，不是永远被表象迷惑而且不敢有所怀疑，而是相信科学的解释，同样敬畏一切超越人力的力量，我怀疑云南的女孩子都会跳舞，比如曾经表演过千手观音的杨丽萍老师就来自云南，张大胡子甚至为了找一双好看的手，而让她出演了史上最美的梅超风，于是佛像前的一段舞蹈，成为了不亚于何小萍操场独舞的惊鸿一瞥，假如真的有来生，就祈祷喃湘露出生在一个富足的家庭里吧;喃湘露平时都见不到父母，甚至开玩笑地说，等到生一场大病看他们怎么办，可她依然相信，没有母亲会不爱自己的孩子;这些非常真实的人物，像一张巨大的网将母女俩裹在其中，看起来两个人的矛盾，是留守儿童这样一个社会问题，可在我的理解中，这是现实与传统的一种碰撞，留守儿童不再是印象中内向闭塞的孩子，而或许是跟我们一样，知道什么是“吃鸡”，知道什么是“王者农药”，小镇村民不再是印象中善良淳朴的人们，而或许是知道生病了应该去医院，但“喊魂”这种事情同样需要，而对于募捐来的钱，无论是个人还是集体，都希望能分一点儿", "tags": [["说", 0.017416027449106548], ["会", 0.016247239908543022], ["去", 0.014210536671447711], ["喃", 0.008676687751417094], ["电影", 0.00827019066668264]], "title": "米花之味：永远相信美好的事情"}, "4158690468": {"descs": "因为根据罗马数字最多重复三次的规则，我们应该用5000-1000来表示4000，可问题是这7个基本数字中并没有5000的定义，这和计算机中的数据溢出是非常相似的，因为我们都无法通过现有的构造去描述一个新的东西;回到罗马数字这个问题，我们发现一个残酷的事实是，古罗马人并没有定义1000以上的数字表示，这或许和古罗马人发明数字的过程有关;在罗马数字中，共有7个基本数字，即I、V、X、L、C、D、M，它们分别表示1、5、10、50、100、500、1000;一个最为直观的例子是，数字可能会用一个字母、两个字母或者三个字母来表示，如果两个数字要进行加减法，我们会发现它的数字是无法”对齐“的，你必须非常小心地分清楚不同的数位，而罗马数字恰好是没有数位的概念的;既然罗马数字是一种计数规则，那么我们就不得不说一说它的组合规则，因为4000以内的数字，都可以用这7个基本数字组合表示", "tags": [["罗马数字", 0.03234452082081873], ["数字", 0.0232360841568094], ["表示", 0.01718767443294044], ["问题", 0.014663269786204648], ["会", 0.010876533428223817]], "title": "罗马数字与阿拉伯数字的相互转换"}, "3846545990": {"descs": "现在，我们可以注意到，在控制台中输出了我们期望的结果，这说明页面中定义的showUser()方法确实被执行了，所以，到这里我们可以对JSONP做一个简单总结：**JSONP是一种利用script标签实现跨域的方案，它需要对后端接口进行适当改造以返回可以执行的JavaScript，客户端需要事先定义好接收数据的方法，两者通过callback参数建立起联系，返回类似callback({\"name\":\"tom\",“gender”:\"male\"})结构的数据，因此JSONP请求必然且只能是一个GET请求**;其中，JSONP本质上是返回可以执行的JS，其基本套路是callback({\"foo\":\"bar\"})，利用了HTML中含src的属性天生具备跨域能力的“漏洞”，是一种相对\"hack\"的方案，要求预先定义好callback，需要改造后端接口，仅支持最简单的GET请求;JSONP实际上返回的是可以执行的JavaScript，即text/javascript，它和我们所使用的大多数JavaScript并无区别，所以，你可以想到，当我们把一个远程地址赋值给script标签的src属性时，它和我们引用CDN上的医院文件并无区别，这正是JSONP的秘密所在，显然它只支持Get方式，当我们想要支持更多方式的时候，我们需要的是CORS，一起来看下面这段代码，我们首先来写一个简单的API接口：;接下来，浏览器发起的正式请求会带上这些字段，并返回我们所需要的JSON数据，这就是CORS跨域的实际过程;对于简单请求，浏览器会对请求的头部进行“魔改”，即增加一个Origin字段，这样只要后端接口支持CORS跨域，就可以接收这些跨域请求，并做出回应，即在响应的头部信息中返回Access-Control-Allow-Origin等字段", "tags": [["中", 0.019469146261883844], ["跨域", 0.01640397443999237], ["请求", 0.016182389844168758], ["jsonp", 0.013899485887010595], ["cors", 0.011975346358343446]], "title": "聊聊前端跨域的爱恨情仇"}, "1940333895": {"descs": "*  数据类型：在Lua中支持6种数据类型，即数字(number)、字符串(string)、函数(function)、表(table)、用户数据(userdata)、空值(nil);#include \"lua.h\";print(\"This is a function declared in Lua\");//输出Lua脚本中的两个变量;lua_getglobal(L,\"table\")", "tags": [["lua", 0.05909184139993126], ["中", 0.026038143030314344], ["脚本", 0.02024537813545793], ["luaopen", 0.013091714104286833], ["类型", 0.011534384132649662]], "title": "脚本语言编程：Lua脚本编程入门"}, "1358971951": {"descs": "可或许是我们想多了，有时候两个人分开以后，难过的只有自己，对对方而言或许是种解脱，于是我们在电影里看到了一幕幕单身男女嗨翻天的景象，我们常常听到这样一句话，两个人不合适就分手呗，讽刺的是，我们一边渴望着美好的爱情，一边对待感情弃若敝履，我们谈恋爱的时间越来越短，对彼此越来越没有耐心，有人说，这是因为我们长大了，知道20多岁的年龄，不能再像10多岁一样挥霍，像孟云和林佳这样的情侣，现实中举不胜举，为了彼此一点可怜的自尊，谁都不肯先放下身段同对方和解，等到矛盾积累得越来越多，任何一件事情都有可能成为，压死骆驼的最后一根稻草;这一切都是需要去不断磨合的，我们看待感情的角度是功利的，如果两个人走到一起甚至结婚，我们觉得这就是合适的，那么像孟云和林佳这种相爱五年的情侣，我觉得我们很难用一句合适或者不合适来说说清楚，两个人在一起一定要多沟通，有问题不要想着第二天再解决;这个时候，还要试图用扮演至尊宝说“我爱你”和疯狂吃芒果吃到过敏，这样幼稚可笑的事情来满足各自的虚荣心，好像我们每个人都实现了对彼此的承诺，真正爱你的人，怎么会舍得离开你呢，明明是自私得只懂得爱自己，非要坚持说是对方不够爱自己，真正爱你的人，爱一直都在心里;电影里的两对情侣，孟云和林佳，余飞和丁点，同时因为生活中的矛盾分手，好兄弟和好闺蜜再度走到一起，这个时候，我们觉得失恋应该是痛苦的一件事情，没有喝醉到不省人事，没有悲伤到歇斯底里，这都不算做失恋吧;或许前任与现任永远都是一道无解的题目，就如同网上流传着的一个问题，“我和你妈同时掉水里你会先救哪一个”，我们发现对这个问题而言，即使代入现任和前任这样的设定，它看起来依然是说得通的", "tags": [["前任", 0.018760177132352094], ["人", 0.018522401658825193], ["去", 0.014175362512519482], ["会", 0.013933049992657067], ["没有", 0.012441999784922464]], "title": "致前任：愿余生各自安好"}, "94443781": {"descs": "从此刻开始，我希望你打破这种认知，谁说矮个子男生不能穿长款的衣服，男主这就是活生生的例子啊，我知道女生都喜欢175+的男生，可我希望你能找到我除了不能举高高以外的优点，女主到菜场就买了棵葱回来，男主赶紧接过来拎在手里，真是适合过日子的人啊;12、这里分别是针织衫和毛背心搭配格子衬衫的正确示例，简而言之，衣服的搭配上需要体现出层次感，切忌选择色调过于接近的颜色，衬衣一定要修身，否则搭配毛衣会让你显得臃肿不堪;4、这一次，男女主在众人“陪伴”下开展了一次小旅行，男主所穿的这件短袖衬衣真的是最普通的衣服，目测在某澜之家就可以找到同款，搭配这斜挎的帆布包简直是减龄神器，我真心羡慕那些三十多岁还会被认成学生的“大叔”们，在下高中刚毕业就被叫叔叔到现在，人家明明想被叫做“哥哥”😓;一套贴合肩线的西装，搭配一件白色衬衫，视觉上给人成熟稳重的感觉，男主虽然在剧中表现得很“怂”，可这并不影响他的“帅”啊，这套衣服最多算彩排，真正的新郎礼服请关注第11集;3、你看，这件衣服再次发挥了格子衬衫的伟大魅力，而在这件蓝色的针织衫的衬托下，可以明显地感觉到男主变“白”了，当90后们开始步入中年职场，不妨尝试穿一点靓丽的颜色，因为我们还可以再年轻一下", "tags": [["男主", 0.017339895440811853], ["穿", 0.015236984297978148], ["衬衣", 0.013801652808680887], ["搭配", 0.010356129007089678], ["人", 0.007957079185638287]], "title": "草食系程序员的穿搭指南"}, "2809571715": {"descs": "我突然间想到，高中的第一堂语文课上，老师安排大家写一篇作文，题目好像叫做《回首向来》亦或者是《行走在消逝中》，那时我的作文没有写完，反而被老师叫起来当众朗读，我说“回首向来萧瑟处，也无风雨也无晴”，记忆明明是有的，可我突然叫不出来有些人的名字，甚至在某一个清晨惊醒，梦到过往的某一天考试迟到，或者是快要交卷发现作文没有写;大家都不关注这件事情吧，立马有人跳出说，“将军坟前无人问，戏子家事天下知”，根本没有人关心科技工作者;我承认，别人的世界和你毫无关联，可你终究不愿意让自己成为孤岛，所以你会感到痛苦和挣扎，会想要找一个能永远陪伴你的人;据说知乎上一天内产生了700多个霍金相关的问题，一个曾经活在我们作文里的人物，在他离开这个世界以后，再次成为我们热议的话题，好像他从来没有在这个世界上存在过一样，这是一件可怕的事情;可我想说的是，不要总是等到离开的时候，才会想起一个人的存在", "tags": [["人", 0.018584176499558402], ["会", 0.01487994300621988], ["霍金", 0.010109025991122718], ["时间", 0.009960082109739476], ["世界", 0.009243944075744014]], "title": "行走在消逝中"}, "1124152964": {"descs": "最后，全部的三角面会被读取到faceVertexNormalUV列表中，它表示的是每个三角面的顶点、法线和UV的索引向量，是一个List<Vector3>类型的变量;这里可以注意到我们在开始对文本化的.obj文件的内容有1次替换操作，这是因为在3dsMax中导出的.obj文件关键字**v**这一行中v后面的第一处空格位置是有2个空格，而我们在处理的时候是按照空格来分割每一行的内容的，这样chars[1]就会变成一个空字符串，显然这不符合我们的初衷，所以这里就需要对字符串进行这样一个操作，希望大家在解析的过程中注意，好吧，我承认我想吐槽3dsMax了，我不明白同一家公司的3dsMax和Maya为什么不能互相转换，我不明白3dsMax导出.obj文件的时候要做这样奇葩的设定，我更不明白为什么有开源、免费、轻巧的Blender都不去用非要每次都去安装容量动辄上G的盗版软件和不知道会不会变成下一个GhostXXXX的注册机，我更加不能容忍的是封闭的FBX格式和用起来就如同自虐的FBX SDK;三角面的读取定义在GetTriangleList()方法中，因此三角面的读取实际上首先需要将每一行文本按照空格进行分割，然后再将每一个元素按照/分割，这样就可以依次得到顶点索引、法线索引和UV索引;**newmtl**关键字表示从当前行到下一个newmtl关键字所在行间都表示该关键字所对应的材质，这里的Material即表示材质的名称，它和.obj文件中的**usemtl**关键字相对应，因此我们给模型添加材质的过程本质上是从.obj文件中读取网格，然后找到其对应的材质名称，然后在.mtl文件中找到对应的材质定义，并根据定义来生成材质;好了，我们把所有的索引向量读取完后，按照0、1、2这样的方式组成三角面，这里可能是.obj文件本身定义的一种方式，我们暂且按照这样的方式来处理", "tags": [["中", 0.01920447433958534], ["材质", 0.01356746389964076], ["模型", 0.012722110618653033], ["大家", 0.012003377018307688], ["文件", 0.012000829876756804]], "title": "解析OBJ模型并将其加载到Unity3D场景中"}, "686567367": {"descs": "重启后Visual Studio提示恢复了未保存的代码，此时，我并未注意到Git仓库损坏的情况，就这样，我在一个“游离态”的版本上编写代码，直到我打开SourceTree的时候(作者注：**我就是那个命令行和GUI混合使用的奇葩**)，发现左侧本地分支全部消失，在命令行里`git status`，发现根本没有这个分支，而`.git/refs/`对应分支指向了一个错误的Hash，我意识到我的Git仓库文件可能损坏了，这意味着我写的新feature可能丢失了，此时，Git中提示的类似的错误信息：;所以，使用Git的准则之一，只要仓库没有坏，通过`git reflog`找到对应的Hash ，`git checkout`就可以找回代码，哪怕你刚刚手滑删除了一个未提交的分支，这种情况下都可以找回来;在此之前，其实博主已经经历过类似的事情，在没有未提交的代码的情况下，其实可以暴力删除`. git `目录，然后在` git init `即可，这相当于重新初始化仓库啦，在这种情况下，本地的分支会被删掉，你需要重新建新分支;error: 6f34f2bbde304619622f77f9ca159ed97b6ddafd: object corrupt or missing: .git/objects/6f/34f2bbde304619622f77f9ca159ed97b6ddafd;error: unable to unpack header of .git/objects/67/781ba4991aee01c0bc0d640ae9ee8b674b2f47", "tags": [["git", 0.03993661494817493], ["提交", 0.012117146411519722], ["object", 0.010770259554782387], ["可能", 0.010238012452500472], ["分支", 0.009436226796843892]], "title": "记一次从已损坏的Git仓库中找回代码的经历"}, "795474045": {"descs": "好了，顺着这个思路，我们就会想到在ORM中添加拦截器或者是日志的方式，来获得由ORM生成的SQL语句，这里我们以Entity Framework(以下简称EF)为例，这是.NET中最常见的ORM，因为目前官方的Web开发框架有ASP.NET和ASP.NET Core两个版本，所以这里我们分别以ASP.NET和ASP.NET Core为例来说明具体的实现过程，相应地，我们分别使用了EF6和EF Core 作为各自的ORM;我们说过，ILoggerProvider接口决定在什么情况下应该提供什么样的Logger，我们注意到它提供了一个CreateLogger()的方法，它会根据categoryName来返回不同的Logger，而参数categoryName实际上等价与nameof(FooController)，所以，到这里我们就会明白，为什么这里要判断categoryName了，它实际上起一个过滤的作用，因为我们只需要SQL相关的日志，它和SQLGenLogger中的state相对应，我们已经说过，这是博主试出来的;这篇文章主要介绍如何利用EF来生成不同数据库的SQL脚本，对EF6来说，需要继承DbCommandInterecptor类编写拦截器;现在，我们需要将这个拦截器注册到EF中，注册过程非常简单，一旦拦截器注册完成，当我们在EF中执行相应操作的时候，就可以在日志中看到相对应的SQ语句了，这样我们就达到了用EF生成SQL语句的目的，虽然说这样可能还没手写来快，可它至少让你知道了，这个世界上有一种不需要手写SQL的可能性啊，你说对吗;这里有一点要说明，平时我们在控制器中使用ILogger的时候，通常会在控制器的构造函数中注入ILogger<FooController>，一旦我们使用泛型的ILogger接口，Log()方法中的参数state实际上就是当前类型，这里和SQL语句相关的类型DbCommandData，实际上是博主试出来的，因为如果不限定ILogger<T>中的参数T，我们将得到所有的执行日志，显然，这不是我们想要的结果", "tags": [["中", 0.020512500425676504], ["sql", 0.020010430004776914], ["数据库", 0.012825601669645338], ["orm", 0.01159146963570961], ["ef", 0.011035034041720581]], "title": "记通过EF生成不同数据库SQL脚本的一次尝试"}, "2186770732": {"descs": "在《CG Programming in Unity》一书中提到了贝塞尔曲线，实现了一个基础版本的贝塞尔曲线绘制，即在给定P0和P2的前提下，由用户通过滑杆对P1进行控制，可以实时预览当前曲线的样式，感兴趣的朋友可以阅读该书的第9章部分;二次贝塞尔曲线的路径由给定点P0、P1、P2的函数B(t)给出:;P0、P1、P2、P3四个点在平面或在三维空间中定义了三次方贝塞尔曲线;* 由P0至P1的连续点Q0，描述一条线性贝塞尔曲线;* 由P1至P2的连续点Q1，描述一条线性贝塞尔曲线", "tags": [["曲线", 0.04720806749439638], ["贝塞尔", 0.016711553243202087], ["p1", 0.015055030988417059], ["参数", 0.013247182806585303], ["绘制", 0.012738700111610955]], "title": "贝塞尔曲线学习笔记"}, "450254281": {"descs": "现在，我们基本了解了PWA的概念以及实现PWA的关键技术，我们现在考虑将Hexo博客改造成一个PWA应用，我们这里不打算考虑消息推送的相关问题，所以对Hexo这样一个静态博客生成器而言，我们可以做的实际上只有两件事情，即通过Web App Manifest让它更像一个Native应用，通过ServiceWorker为它提供离线缓存的特性;我们知道传统Web应用有两个关键问题无法解决，即**需要从网络实时加载内容而带来的网络延迟**和**依赖浏览器入口而带来的用户体验**，从某种意义上而言，渐进式应用的出现有望让这些问题得到解决，首先，渐进式应用可以显著加快应用加载速度，其提供的离线缓存机制可以让应用在离线环境下继续使用，关键技术为Service Worker和Cache Storage;按照[官方文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)中的定义，ServiceWorker同WebWorker一样，是一段JavaScript脚本，作为一个后台独立线程运行，其运行环境与普通的JavaScript不同，因此不直接参与Web交互行为，从某种意义上来说，ServiceWorker的出现，正是为了弥补Web应用天生所不具备的离线使用、消息推送、后台自动更新等特性，我们这里来看一个使用ServiceWorker缓存文件已达到离线使用的目的的例子：;说完了ServiceWorker，我们再来说说Web App Manifest，我尝试从豌豆荚下载了移动版Chrome，可我自始至终无法将应用添加到主屏幕，貌似这需要Android系统底层的支持，我测试了两部手机，一部OPPO手机和一部小米手机，发现都没有明显的PWA支持，当我访问页面的时候，浏览器更加不会主动提示我\"将应用添加到主屏\"，像UC浏览器是将网站以应用的形式添加到浏览器首页，这的确没有什么值得令人惊喜的地方，因为在PC端的时候，我们就可以做到类似地实现，这篇文章耗费时间蛮长的啦，大概是因为我不知道，该如何描述这个失败的尝试;我们知道，传统的Web应用需要在网络环境下使用，当处在离线环境下时，因为HTTP请求无法被发送到服务器上，所以浏览器通常会显示一个空白页，并告知用户页面无法加载，因此会影响用户在离线环境下的使用体验，与此同时，因为Web页面在打开的过程中需要加载大量资源，因此在页面刚刚打开的一段时间内，用户看到的页面通常都是一个空白页面，考虑到缓存或者是预加载的Web应用，通常都会以预设资源作为占位符来填充页面，因此带来访问者的印象往往会更好", "tags": [["应用", 0.015332334027528611], ["web", 0.012705127625449487], ["serviceworker", 0.01174298864977541], ["中", 0.01160095816009285], ["缓存", 0.010936896737874586]], "title": "迁移Hexo博客到Google渐进式Web应用(PWA)"}, "4116164325": {"descs": "这个接口位于`System.Web.Http.Description`命名空间下，而显然这是WebApi相关的命名空间，所以，对于一般的WebApi项目，因为微软已经帮我们实现了默认的ApiExplorer，所以，Swagger可以识别出项目中的Controller及其Action，并通过XML注释文档进一步填充接口相关的描述信息;我们的想法是通过反射取出所有的MVC控制器及其Action，然后组织出这些接口的描述信息，再将它们添加到默认的IApiExplorer实现中去，这样MVC和WebApi都可以被Swagger识别，为此，我们继承默认的ApiExplorer，并实现我们自定义的`MvcApiExplorer`：;一旦想到这一层，我们就会明白，为什么Swagger不支持MVC项目，因为MVC里压根就没有实现IApiExplorer接口啊;本文实现了一个针对MVC项目的Swagger扩展，它可以让你编写在MVC控制器里的API接口，像普通WebApi项目一样展示在Swagger里;不错，我们有部分WebApi是写在MVC的控制器里的，我希望使用者可以通过Swagger看到这部分接口的文档，这样我就有时间在这里写博客了", "tags": [["swagger", 0.01799219785857875], ["mvc", 0.014792322715534916], ["实现", 0.013635544979762854], ["文档", 0.013603473726485503], ["项目", 0.013407250087004646]], "title": "通过ApiExplorer为Swagger提供MVC扩展"}, "1289244227": {"descs": "整体来看，后者对代码的侵入性要更小一点，理论上我们可以实现`EF`或`EF Core`的仓储模式，这样两者在实现上会更接近一点，当然，更直接的方案是去拦截`SaveChanges()`方法，这和我们使用继承的目的是一样的，由于Dapper本身没有`ChangeTracker`，所以，在处理`Update()`相关的仓储接口时，都需要先查询一次数据库，这一点是这个方案里最大的短板;在此基础上，我们可以编写我们实际的DbContext，这里以CustomerContext为例，当我们向其中添加、修改和删除Customer的时候，就会触发审计相关的逻辑，默认情况下，审计产生的数据AuditLog和Customer在同一个数据库上下文中，当然，我们可以通过注入IAuditStore来实现更精细的控制，例如，可以将审计日志输入到文本文件，甚至是Mongodb这样的非关系型数据库里，因为有依赖注入的存在，这些实现起来会非常的简单;而对于像Dapper这种轻量级的ORM，它本身没有类似EF/EF Core的ChangeTracker的设计，如果我们在项目中使用Dapper，并且希望实现审计的相关功能，直观上看就会有一点困难;对于前者，主要是通过重写DbContext的`SaveChanges()`方法来实现，而`EF`及`EF Core`中的`ChangeTracker`则提供了一种获取数据库表记录变化前后值的能力;public void SaveAuditLogs(params AuditLog[] auditLogs)", "tags": [["事件", 0.01609225141877031], ["实现", 0.015903019975335237], ["tentity", 0.015079486147285482], ["去", 0.013740430094647874], ["会", 0.01039090061682698]], "title": "通过EF/Dapper扩展实现数据库审计功能"}, "4236649": {"descs": "DynamicControllerActivator 实现了IHttpControllerActivator接口，这里我们通过单例模式获得了DynamicHttpControllerManager对象的一个实例，其内部封装了Castle的容器接口IWindsorContainer，所以，在这里我们直接通过controllerType从容器中Resolve对应的Controller即可，而默认情况下，所有的Controller都实现了IHttpController接口，所以，这一步我们需要做一个显示的类型转换，后面我们会通过它替换微软默认的实现，这样，当一个请求被发送过来的时候，我们实际上是从这个自定义容器中获取对应Controller的实例;老实说，通过自定义IHttpControllerActivator的方式实现依赖注入的方式并不常见，因为更一般的情况是，大家在Global.asax里初始化像Unity、Autofac等等类似的容器，然后在Controller里通过容器去Resolve一个服务出来，对于IHttpControllerActivator接口而言，它只有一个Create()方法，在这篇文章中，我们是通过Castle这个容器来实现依赖注入的，所以，你大概可以想象出它的过程，首先把所有动态生成的Controller全部注入到Ioc容器中，然后再根据传入的类型获取对应Controller的实例;在这个过程中，我们回顾了ASP.NET MVC的基本原理，了解了MVC是如何根据路由筛选Controller、激活Controller和筛选Action，在此基础上，我们对微软的MVC进行了一次Hack，使用我们自定义的组件替换了微软的默认实现，从而可以让原来托管在ServiceHost上的接口，通过Web API来访问和调用;同理，我们还需要告诉MvcHandler，它应该调用哪个方法，这时候我们需要IHttpActionSelector，因为从路由信息中我们可以提取到ActionName参数，因此，通过通过typeof(Controller).GetMethod(ActionName)，就可以获得对应ActionName对应的方法，熟悉反射的朋友应该都知道，它会返回MethodInfo这个类型，实际上IHttpActionSelector所做的事情，就是把MethodInfo传给MvcHandler，因为此时只要通过反射调用这个方法即可，Controller的实例在上一步就创建好了，而调用方法所需要的参数，则被存储在当前请求的上下文HttpContext里面，至此万事具备;我们都知道在ASP.NET下，要写一个Web API必须继承ApiController，就是说这个类必须实现了IHttpController接口，就是因为有这个限制，所以，我们不得不通过Castle来动态生成一个Controller，既然现在ASP.NET Core里可以打破这一限制，那么实现起来自然会非常简单", "tags": [["中", 0.019660628208329235], ["接口", 0.01795241280406901], ["controller", 0.013740193883186603], ["实现", 0.012997990964154656], ["会", 0.011639774419008146]], "title": "通过动态Controller实现从WCF到Web API的迁移."}, "3668933172": {"descs": "再比如，我们的业务中要求：用户在访问相关资源或者是执行相关操作时，需要确保用户的状态是登录着的，因此，我们不可避免地在代码中，使用if语句去判断用户是否登录，试想如果所有的业务代码都这样写，两个模块间就存在了直接耦合，当然我们可以说这是最简单的做法，因为它照顾了大部分人的思维和情绪，可你看Angular/Redux/TypeScript等项目中无一不遍布着修饰器的身影，当一种框架逐渐流行并成为一种趋势的时候，好像大家立刻就忘记了一件事情：原本我们都是非常排斥这些奇技淫巧的，可因为框架的流行你就默认接受了这种设定;在这个例子中，我们通过修饰器函数readonly()对getName()方法进行修饰，使其变成一个readonly的方法;此种差别，大家可以非常明显地看出来，我们在使用修饰器函数setProp()的时候，现在允许传入一个参数20，此时的结果是非常地显而易见的，这段代码将如你所愿地输出20;JavaScript中的修饰器同Python中的修饰器类似，可以修饰类及其方法;显然，现在我们可以避免模块间的直接耦合，无需在每个业务方法中重复去写if语句，更重要的是通过JavaScript中的模块化规范，我们可以把checkLogin这个方法，扩展到更多的业务类及其方法中去，而唯一的代价就是在方法上增加@checkLogin修饰，你说，有这样优雅的策略，你为什么就不愿意去使用呢", "tags": [["中", 0.025277191022523324], ["修饰", 0.016641744141890798], ["大家", 0.014463225486503502], ["方法", 0.013719393341078034], ["器", 0.013710071680226175]], "title": "邂逅AOP：说说JavaScript中的修饰器"}, "1099762326": {"descs": "而杀了李天然，日本人可以随时除掉朱潜龙;唐凤仪，一个愿意陪着朱潜龙做皇帝梦的女人，习惯了被男人驱使和奴役，可被李天然恶作剧般在屁股上以后，她终于明白，自己在朱潜龙心中不过是一个玩物，尤其是六国饭店里的那场戏，看似不露痕迹地打朱潜龙耳光，实则这个敢爱敢恨的女人形象立了起来，回敬李天然的“凤仪之宝”，通过关巧红给李天然通风报信，日军进城时城墙上的一跃，都是这个角色留给人的深刻印象;这一次姜文饰演的蓝青峰，这个角色在我看来相当复杂：想要除掉朱潜龙和根本一郎，但私底下跟这两个人都有来往;蓝青峰的计划是让朱潜龙和根本一郎产生矛盾，朱潜龙杀死根本一郎后，再用李天然做交换;当周围人都是在利用你，杀了朱潜龙，李天然将失去存在感", "tags": [["日本", 0.014066391493327139], ["李", 0.011188911383260065], ["人", 0.010278188298263553], ["朱", 0.00954330116717125], ["师父", 0.009515939083511515]], "title": "邪不压正：本我的发现之旅"}, "3417652955": {"descs": "我曾经开玩笑地和朋友说，我现在喜欢观察路上行人们的穿搭，仿佛这样能让我喜欢的女孩子愿意看我一眼，朋友不无嘲讽地说，“你这是在东施效颦啊”，就连我喜欢的女孩子都说，“每个人都会有自己喜欢的风格啊”;对于我的人生，我不知道今后会是什么样子，我唯一能做的，就是接受我已经失去的一切，长安并不足以安，你会有一个可以令你心安的人出现吗;不要以为只有女孩子，会在面对琳琅满目的商品时选择困难，在这个选择多样化的时代，明确知道自己想要什么，对每一个人而言，反倒是一种相当稀缺的品质;我不得不承认，没有人天生会是一个无忧无虑的漂泊者，无论是洛阳还是长安，对我而言都不是故乡;朋友们都希望我可以“自信”点，可终于有这样一天，你做到了曾经想做而不敢做的事情，这一切又是否真的会如你所愿", "tags": [["会", 0.0208903903145739], ["人", 0.018129606576061642], ["喜欢", 0.012878025668104833], ["长安", 0.011937007932124762], ["标准", 0.011850175533821663]], "title": "长安不见使人愁"}, "1540537013": {"descs": "我们更无从得知，那一年的白居易到底怀着什么样的抱负来到长安，当他从已为陈迹的花萼相辉楼里捡起李白用过的笔的时候，是否真的如他想说想要开创一个新的时代，谱写一曲荡气回肠的长恨歌;据说马亲王这本书的灵感来自“刺客信条”，我本人同样是这部游戏的忠实粉丝，可当你真正想在长安寻找鸟瞰点并进行同步的时候，你会发现小雁塔顶端早已残损，攀爬这样的建筑物简直就是在碰瓷儿，而大雁塔的高度早已被周遭的大悦城超越，按照书中的设定，只要在大悦城的天台上增设武侯，不要说同步鸟瞰点，分分钟就会被弓弩手射中失去同步，因为据说大雁塔下面只有音乐喷泉，并没有安置干草堆;《妖猫传》里绮丽璀璨的幻术表演，极力展现长安奢华的一面，虽然这一切都是活在两位主角的想象中，因为它想表达的是一种美的消逝和幻灭，此时的长安，其伟大和无与伦比体现在这三个符号上——空海代表的真理密法、李白代表的艺术创作、杨贵妃代表的绝对的美;可当历史脉络逐渐清晰起来的时候，我们突然发现，原本我们以为最为意气风发的李白，那一年(开元18年，即公元730年)李白已经30岁了，就在那一年李白谒见宰相张说及一干长安名流，均无结果，直到他结识贺知章并被对方称之为“谪仙”， 引出一段“金龟换酒”的传奇佳话;年少时未见长安，难以想象万国来朝的盛唐气象，心中最为仰慕的人物，是那个“好剑术、喜任侠“、二十五岁“仗剑去国、辞亲远游”的李白", "tags": [["长安", 0.02346610659206892], ["李白", 0.01358201829991586], ["说", 0.009852946516233101], ["人", 0.008165348878336755], ["历史", 0.006897795741161255]], "title": "长安十二时辰随想"}, "1394521917": {"descs": "我每天都坚持早起，因为我不想被这种安逸到近似麻木的生活拔去梦想的翅膀，虽然我在乎的事情没有人懂、更没有人在乎，可我就是不愿做一只温水中的青蛙，因为当危险临近的时候更加不会有人来救我;我固然不愿意离开年迈的父母，我固然不愿意离开生养我的土地，可是对我来说这一切都没有可以选择的余地，每次看到回家看到父母不停地辛劳，我意识到他们渐渐地老了，他们的身体不再像以前那般硬朗，他们的头发一天比一天白，我不愿意他们再为我辛劳下去，留在这座小城市里除了可以经常看到他们以外，对我而言并不会有更好的理由;时光一过不再有，这过去的大半年时间就让它过去吧，在接下来的2016年里，我希望我可以更加勇敢、更加努力，我要更好地把握我的人生，我要变得更加成熟，我要做最初的、最好的自己;我自问每天都在认真的做事情，可是因为领导层和整个公司的问题现在这个项目变成这个样子，我真的感到失望而寒心;从毕业那天起，我就决定这辈子不会再靠我的本科专业生活，因为它从来没有和我的内心发生过强烈的共鸣，所以当我毕业以后就意味着我再没有回头的路可以走", "tags": [["生活", 0.025655211677163222], ["没有", 0.021667912076548383], ["人", 0.01664028443671714], ["时间", 0.01587188463125536], ["人生", 0.014882809341006626]], "title": "青黄未接的2015"}}