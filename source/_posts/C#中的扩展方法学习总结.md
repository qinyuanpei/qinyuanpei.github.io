---
abbrlink: 305484621
categories:
- 编程语言
date: 2015-12-05 12:01:02
description: 我们使用扩展方法无非是因为它在逻辑层需要这样的功能，所以我们没有必要去改变抽象层的逻辑，因为这样会“污染”整个代码;/// <param
  name="str">4、第一个参数必须使用 this 关键字指定要使用扩展方法的类型</param>;为了解决这个问题，我们可以扩展出三个方法 SetPositionX、SetPositionY、SetPositionZ 来分别为 x、y、z 三个坐标分量进行赋值，我们继续在 SomeClass 这个类中添加方法：
tags:
- CSharp
- 扩展方法
- Unity3D
- 技巧
title: C#中的扩展方法学习总结
---

各位朋友大家好，我是秦元培，欢迎大家关注我的博客。最近偶然接触到了 C#中的扩展方法，觉得这个语法特性是一个不错的特性，因此决定在这里系统地对 C#中的扩展方法相关内容进行下总结和整理，因为博主觉得学习这件事情本身就是一个积累的过程，所以博主有时候会对现在的线上培训和视频教程这种“在线教育”感到反感。试想《射雕英雄传》中江南七怪远赴大漠传授郭靖武艺苦历十八载，何以难及全真教丹阳子马钰传授内功两年的积累？这里固然有郭靖愚笨木讷的天性和江南七怪武功低微的因素，可是在博主看来更重要的是强调了一个积累。想郭靖一生受益自全真教的玄门内功终成一代“为国为民”的侠之大者，则我辈需更加努力方可在这世间行走奔波。

<!--more-->

# 什么是扩展方法
扩展方法从字面上理解是指扩展的方法，而对应到面向对象编程这个格局中则是指为一个类提供的扩展方法。按照我们通常的理解，我们首先需要获得某个类的源代码，然后在这个类代码中增加成员方法，这样就可以达到为一个类提供扩展方法的目的。可是不幸地是，这种方法在没有源代码的情况下就无法奏效了，而且我们人为地去改变源代码有可能会破坏整个代码的稳定性。那么有没有一种方法能在不改变源代码的前提下为某个类提供扩展方法呢？这就是我们今天要说的扩展方法，所以我们可以将扩展方法理解为在不改变源代码的前提下向外部提供扩展方法的一种方式。C#中的扩展方法实现起来是相对来说比较简单的，例如我们做在 Unity3D 游戏开发的时候，可能会用到 DOTween 这个插件。这个插件是 iTween 的作者重新编写一个动画插件，效率上比 iTween 有较大的提升。更为重要的一点是，它采用扩展方法这种实现方式，使得我们在调用这些 API 接口的时候难以感觉到我们是在使用一个插件，更像是在使用 Unity3D 的原生函数，所以当我们使用 DOTween + uGUI 这样的组合的时候，内心会感到无比的舒畅，一切都像是水到渠成一般。

# 扩展方法有哪些特点
扩展方法在实现上和普通的面向对象编程是一样的，换句话说，我们只需要定义一个类，然后在里面添加并实现相应的方法即可。但是这里需要注意的地方有三点，第一，实现扩展方法的类必须是静态类且类的名称和实现扩展方法的类无关；第二、实现扩展方法的类方法必须是静态方法；第三、实现扩展方法的类方法的第一个参数必须是使用 this 关键字指明要实现扩展方法的类。例如，我们知道将一个合法字符串类型转换为整型，可以使用 int.parse()方法，假如我们希望为 string 类型扩展一个 ToInt 方法应该怎么办呢？我们一起来看下面的这段代码：

```csharp
/// <summary>
/// 1、定义一个静态类
/// 2、静态类的名称和要实现扩展方法的具体类无关
/// </summary>
public static class SomeClass
{
    /// <summary>
    /// 3、实现一个具体的静态方法
    /// </summary>
    /// <param name="str">4、第一个参数必须使用this关键字指定要使用扩展方法的类型</param>
    /// <returns></returns>
    public static int ToInt(this string str)
    {
        return int.Parse(str);
    }
}
```
需要注意的是 C#支持扩展方法是从.NET3.5 版本开始，所以在编写扩展方法的时候请确保你的.NET 版本是否满足这一要求。提到版本问题，有很多朋友尤其是从 Unity5.0 以后开始学习 Unity3D 的朋友，常常会在我的博客中留言提到我的代码无法在新环境下运行等等类似地问题，我觉得这个世界上更新速度最快的当属 IT 技术了，大家使用新版本没有问题，可是有时候因为技术发展中的历史遗留问题例如 Python2.7 和 Python3、Unity4.X 和 Unity5.X，这个时候可能出现版本不兼容的问题，这个时候如果网络上的资源没有及时更新，建议大家还是及时查看官方的最新文档，因为在博主看来网络上的书籍或者相关文章都是用来参考的，古话说：尽信书不如无书，只有客观、冷静地判断知识的正确与否，我们方能学到真正有用的知识。

好了，现在我们编写完这个扩展方法以后，就可以像下面这样使用扩展方法了：

```csharp
string str = "1234";
int val = str.ToInt();
```
这个示例向大家展示了如何编写一个无参数的扩展方法，那么当我们需要在扩展方法中传入参数的时候该怎么做呢？我们只需要在第一个参数后继续加入参数的声明就好了。例如我们在 Unity3D 中常常需要给一个 3D 物体设置坐标，通常我们可以通过下面的代码来实现：
```csharp
transform.position = new Vector3(1,1,1);
```
这个代码到目前为止是比较简洁的，可是我们知道在 Unity3D 中除了 position 属性以外还有 localPosition 属性，如果我们的代码中再涉及坐标计算的话，我相信这个代码一定会变得非常的长。更有甚者，有时候我们只想改变三维坐标中的一个维度，可是我们必须给 transform.position 一个三维坐标，毫无意外地此时的代码会变得更长。为了解决这个问题，我们可以扩展出三个方法 SetPositionX、SetPositionY、SetPositionZ 来分别为 x、y、z 三个坐标分量进行赋值，我们继续在 SomeClass 这个类中添加方法：
```csharp
/// <summary>
/// 设置Tranform的X坐标
/// </summary>
/// <param name="tran">当前Transform</param>
/// <param name="x">X坐标</param>
public static void SetPositionX(this Transform tran, float x)
{
    tran.position = new Vector3(x, tran.position.y, tran.position.z);
}

/// <summary>
/// 设置Tranform的Y坐标
/// </summary>
/// <param name="tran">当前Transform</param>
/// <param name="x">Y坐标</param>
public static void SetPositionY(this Transform tran, float y)
{
    tran.position = new Vector3(tran.position.x, y, tran.position.z);
}

/// <summary>
/// 设置Tranform的Z坐标
/// </summary>
/// <param name="tran">当前Transform</param>
/// <param name="x">Z坐标</param>
public static void SetPositionZ(this Transform tran, float z)
{
    tran.position = new Vector3(tran.position.x, tran.position.y, z);
}
```
同样的，我们现在可以直接为一个三维物体的坐标进行赋值：
```csharp
transform.SetPositionX(1.0f);
transform.SetPositionY(1.0f);
transform.SetPositionZ(1.0f);
```
# 使用扩展方法的利弊
扩展方法使用起来得心应手，所以我们这里来讨论下使用扩展方法的利弊。好处当然是自由而任性地使用扩展方法对类进行扩展，而且扩展方法在 Visual Studio 中的智能提示会以蓝色向下箭头进行标识。扩展方法的坏处则是要看设计扩展方法的人能否较好的驾驭这个特性啦，其实所有的技术都是一样的，我常常在游戏群里听到人鄙视 Unity3D 引擎，以 UnReal Engine4 为游戏引擎世界里的泰山北斗，我承认 UE4 的画面效果好，可是能真正用好这个引擎的人有多少呢？扩展方法在使用的时候应该遵守就近原则，即是在最小的范围内使用扩展方法，对具体类而非抽象类实现扩展方法。我们使用扩展方法无非是因为它在逻辑层需要这样的功能，所以我们没有必要去改变抽象层的逻辑，因为这样会“污染”整个代码。举一个简单的例子，我们知道.NET 中的基类是 object，如果我们对这个类进行扩展，毫无疑问它会影响所有继承自 object 的类，这样就会造成“污染”，显然是不可取的。

# 小结
* 在 C#中实现扩展方法的类必须是静态类且类的名称和实现扩展方法的类无关
* 实现扩展方法的类方法必须是静态方法
* 实现扩展方法的类方法的第一个参数必须是使用 this 关键字指明要实现扩展方法的类
* 实现扩展方法应遵守就近原则，在最小的范围内使用扩展方法以避免造成“污染”