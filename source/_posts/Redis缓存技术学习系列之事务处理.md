---
abbrlink: 335366821
categories:
- 数据存储
date: 2017-04-08 21:46:40
description: 在这个例子中，我们尝试在事务中对 Record_Count 做一个自增操作，这段代码在非并发的情况下是没有问题的，可是在并发的情况下，如果在执行 EXEC 命令前有一个用户修改了 Record_Count 的值，那么我们此时的结果就会比期望的结果小 1，现在我们有了 WATCH，Redis 就会对 Record_Count 进行监听，当 Redis 监听到该值发生变化的时候，这个事务就会被自动取消，进而避免造成冲突;Redis 中提供了一种称为 check-and-set 的机制，该机制主要通过 WATCH 命令来实现，其原理正是基于乐观锁的策略，Redis 会在执行 EXEC 命令前检查被监视的键对应的值是否发生变化，如果该值发生变化表明有人修改过这个键中存储的值，此时 Redis 将会自动取消当前事务;特别地，因为在 Redis 中命令是存储在一个队列中，所以，事务中的所有命令都会按顺序执行，并且在执行事务的过程中不会被客户端发送的其它命令中断
tags:
- Redis
- 缓存
- 数据库
- 笔记
title: Redis 缓存技术学习系列之事务处理
---

&emsp;&emsp;在本系列的第一篇文章中，我们主要针对 Redis 中的“键”和“值”进行了学习。我们可以注意到，Redis 是一个 C/S 架构的数据库，在我们目前的认知中，它是通过终端中的一条条命令来存储和读取的，即它是一个非常典型的“请求-响应”模型。可是我们知道在实际的应用中，我们要面对的或许是更为复杂的业务逻辑，因为 Redis 中不存在传统关系型数据库中表的概念，因此在使用 Redis 的过程中，我们要面对两个实际的问题，即如何更好的维护数据库中的”键“、如何在高效执行命令的同时保证命令执行成功。对于前者，我认为这是一个设计上的问题，而对于后者，我认为这是一个技术上的问题。所以，这篇文章的核心内容就是找到这两个问题的答案。带着这样的问题出发，我们就可以正式进入这篇文章的主题：Redis 中的事务处理。

<!--more-->

## 从数据库事务说起

​&emsp;&emsp;通常我们提及数据库都不可避免的要提到事务，那么什么是事务呢？事务是指作为单个逻辑工作单元执行的一系列操作。所以，首先事务是一系列操作，这一系列操作具有二态性，即完全地执行或者完全地不执行。因此事务处理可以确保除非事务单元内的所有操作的成功完成，否则不会永久更新面向数据的资源。我们这里举一个例子，数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条 SQL 语句在被执行的时候，都会生成一条撤销日志(Undo Log)，而撤销日志中记录的是和当前擦作完全相反的操作，比如删除的相反操作是插入，插入的相反操作是删除等。我们通常所说的事务回滚其实就是去执行这些插销日志里的相反操作，这同样告诉我们一个道理，只有事务中的一系列操作完全执行的情况下可以回滚，如果是在意外情况下导致事务中的一系列操作没有完全执行，这个时候我们是不能保证数据一定可以回滚的。

​&emsp;&emsp;在数据库相关理论中，一个逻辑工作单元想要成为事务，就必须满足 ACID，即原子性、一致性、隔离性和持久性。(1)：原子性这个概念其实就是指，一个事务内的所有 SQL 操作都是一个整体，因此只有所有的 SQL 操作都完全执行成功，该事务方可以认为提交成功。如果在提交事务过程中某一条 SQL 语句执行失败，则整个事务必须回滚到事务提交前的状态。(2)：而一致性这个概念则是指，事务在完成的时候，必须要保证所有的数据都保持一致的状态，而落实到数据库的各个组成部分上，则要求开发人员能够保证数据、索引、约束、日志等在事务前后具备一致性。(3)：隔离性这个概念主要针对并发，其核心思想就是不同的并发事务对数据产生的修改必须是相互隔离的，假设有两个不同的事务 A 和 B 并发执行，那么对 A 来讲，它在执行前的状态只有两种，即 B 执行前和 B 执行后。同理，对 B 来讲同样是如此，这样的特性我们就称为隔离性。(4)：持久性相对简单，是指事务完成以后它对数据的影响是永久性的。

## Redis 中的事务处理

​&emsp;&emsp;好了，截止到目前为止，我们对数据库中事务处理的相关理论有了一个基本的认识，或许这个世界上的数据库系统千差万别，但我相信在事务处理这个问题上它们最终会殊途同归，就像我们解决并发过程中的冲突问题，常规的做法依然是加锁一样，这是我之所以要花费精力去理解和解释这些理论知识的原因，技术可谓是日新月异，如果我们总是一味地为新技术而疲于奔命，那么或许我们会渐渐地失去对这个行业的热爱，我相信原理永远比框架更为重要，没有系统学习过计算机专业的课程，这件事情让我至今都颇为遗憾。Redis 中的事务是可以视为一个队列，即我们可以通过 MULTI 开始一个事务，这相当于我们声明了一个命令队列。接下来，我们向 Redis 中提交的每条命令，都会被排入这个命令队列。当我们输入 EXEC 命令时，将触发当前事务，这相当于我们从命令队列中取出命令并执行，所以 Redis 中一个事务从开始到执行会经历**开始事务**、**命令入队**和**执行事务**三个阶段。下面是一个在 Redis 中使用事务的简单示例：

```plain
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET Book_Name "GIt Pro"
QUEUED
127.0.0.1:6379> SADD Program_Language "C++" "C#" "Jave" "Python" 
QUEUED
127.0.0.1:6379> GET Book_Name
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) (integer) 4
3) "GIt Pro"
```

我们可以注意到 Redis 中的事务和通常意义上的事务基本上是一致的，即

* 事务是由一系列操作组成的单个逻辑工作执行单元。特别地，因为在 Redis 中命令是存储在一个队列中，所以，事务中的所有命令都会按顺序执行，并且在执行事务的过程中不会被客户端发送的其它命令中断。
* 事务是一个原子操作，事物中的命令只有两种执行结果，即全部执行或者全部不执行。如果客户端在使用 MULTI 命令开启事务后因为意外而没有执行 EXEC 命令，则事务中的所有命令都不会执行。同理，如果客户端在使用 MULTI 命令开启事务后执行 EXEC 命令，则事务中的所有命令都会执行。
* Redis 中的事务可以使用 DISCARD 命令来清空一个命令队列，并放弃对事务的执行。如果命令在入队时发生错误，Redis 将在客户端调用 EXEC 命令时拒绝执行并取消事务，但是在 EXEC 命令执行后发生的错误，Redis 将选择自动忽略。

&emsp;&emsp;我们知道，常见的并发控制方案主要有悲观锁和乐观锁两种方案，这里首先来解释下这两种概念。所谓悲观锁，顾名思义是一种悲观的策略，悲观锁认为：在对任何记录做修改前都应该加锁，如果加锁失败则表明该机录正在被修改，此时应该抛出异常；如果加锁成功则修改记录并在事务完成后解锁；如果有其它人修改则应该等待当前修改解锁或者是抛出异常。而所谓乐观锁，顾名思义是一种乐观的策略，乐观锁认为：每次从记录中查找数据别人都不会修改，因此这个过程中不需要加锁，但是在更新记录的时候，会通过版本号来判断别人是否修改过当前记录。

&emsp;&emsp;通常来讲，乐观锁适合在写冲突相对较少的场合下，悲观锁适合在写冲突相对较多的场合下。Redis 中提供了一种称为 check-and-set 的机制，该机制主要通过 WATCH 命令来实现，其原理正是基于乐观锁的策略，Redis 会在执行 EXEC 命令前检查被监视的键对应的值是否发生变化，如果该值发生变化表明有人修改过这个键中存储的值，此时 Redis 将会自动取消当前事务。我们来看这个简单的例子：

```plain
WATCH Record_Count
val = GET Record_Count
val = val + 1
MULTI
SET Record_Count $val
EXEC
```

&emsp;&emsp;在这个例子中，我们尝试在事务中对 Record_Count 做一个自增操作，这段代码在非并发的情况下是没有问题的，可是在并发的情况下，如果在执行 EXEC 命令前有一个用户修改了 Record_Count 的值，那么我们此时的结果就会比期望的结果小 1，现在我们有了 WATCH，Redis 就会对 Record_Count 进行监听，当 Redis 监听到该值发生变化的时候，这个事务就会被自动取消，进而避免造成冲突。



## 如何管理 Redis 的键

​&emsp;&emsp;其实从切题的角度来讲，这篇博客基本上说清楚了事务处理问题，因此这篇博客虽然没有给大家带来多少惊喜，却依然可以非常恰到好处的结题，可是因为之前有朋友在博客中留言并问到 Redis 的键管理的问题，所以博主决定在这里简单的讨论下这个问题，鉴于博主和大家一样都是感刚接触 Redis，所以下面的观点仅仅是一家之言，如果有疑问可以在博客中留言，欢迎大家批评指正。我认为 Redis 中的键的管理，基本上有两种策略，即惰性删除和定期删除，而实际上这正是 Redis 默认的键删除策略：

> redis 使用`惰性删除`和`定期删除`两种策略来删除过期的键：惰性删除策略在碰到过期键时方进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。

所以，基于这两种键删除策略，我们可以想到的做法有：

* 对于临时变量可以采用临时键来存储，在数据库全局设定一个过期时间，由 Redis 在键过期后自动删除。
* 对于持久化数据可以采用普通键来存储，通过服务器和客户端间定义协议来由客户端主动删除键。
* 对于不同模块中的键采取统一规范的命名规则来命名键，从而解决 Redis 中键管理混乱的问题。
* 设计合理的键回收机制，避免 Redis 使用超过 95%以上的内存，或者通过设置 Redis 中的最大内存容量及其内存策略来主动触发 Redis 对键的淘汰。具体可以参考：[Sunnyxd - Redis 学习笔记-事务、键空间的维护与性能](https://segmentfault.com/a/1190000004171731)

&emsp;&emsp;好了，这篇文章就是这样了，希望大家喜欢，下篇见！